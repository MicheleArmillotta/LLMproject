[
  {
    "function_name": "bpf_core_apply",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6786-6846",
    "snippet": "int bpf_core_apply(struct bpf_core_ctx *ctx, const struct bpf_core_relo *relo,\n\t\t   int relo_idx, void *insn)\n{\n\tbool need_cands = relo->kind != BPF_CORE_TYPE_ID_LOCAL;\n\tstruct bpf_core_cand_list cands = {};\n\tstruct bpf_core_spec *specs;\n\tint err;\n\n\t/* ~4k of temp memory necessary to convert LLVM spec like \"0:1:0:5\"\n\t * into arrays of btf_ids of struct fields and array indices.\n\t */\n\tspecs = kcalloc(3, sizeof(*specs), GFP_KERNEL);\n\tif (!specs)\n\t\treturn -ENOMEM;\n\n\tif (need_cands) {\n\t\tstruct bpf_cand_cache *cc;\n\t\tint i;\n\n\t\tmutex_lock(&cand_cache_mutex);\n\t\tcc = bpf_core_find_cands(ctx, relo->type_id);\n\t\tif (IS_ERR(cc)) {\n\t\t\tbpf_log(ctx->log, \"target candidate search failed for %d\\n\",\n\t\t\t\trelo->type_id);\n\t\t\terr = PTR_ERR(cc);\n\t\t\tgoto out;\n\t\t}\n\t\tif (cc->cnt) {\n\t\t\tcands.cands = kcalloc(cc->cnt, sizeof(*cands.cands), GFP_KERNEL);\n\t\t\tif (!cands.cands) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < cc->cnt; i++) {\n\t\t\tbpf_log(ctx->log,\n\t\t\t\t\"CO-RE relocating %s %s: found target candidate [%d]\\n\",\n\t\t\t\tbtf_kind_str[cc->kind], cc->name, cc->cands[i].id);\n\t\t\tcands.cands[i].btf = cc->cands[i].btf;\n\t\t\tcands.cands[i].id = cc->cands[i].id;\n\t\t}\n\t\tcands.len = cc->cnt;\n\t\t/* cand_cache_mutex needs to span the cache lookup and\n\t\t * copy of btf pointer into bpf_core_cand_list,\n\t\t * since module can be unloaded while bpf_core_apply_relo_insn\n\t\t * is working with module's btf.\n\t\t */\n\t}\n\n\terr = bpf_core_apply_relo_insn((void *)ctx->log, insn, relo->insn_off / 8,\n\t\t\t\t       relo, relo_idx, ctx->btf, &cands, specs);\nout:\n\tkfree(specs);\n\tif (need_cands) {\n\t\tkfree(cands.cands);\n\t\tmutex_unlock(&cand_cache_mutex);\n\t\tif (ctx->log->level & BPF_LOG_LEVEL2)\n\t\t\tprint_cand_cache(ctx->log);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};",
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);",
      "static DEFINE_MUTEX(cand_cache_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_cand_cache",
          "args": [
            "ctx->log"
          ],
          "line": 6843
        },
        "resolved": true,
        "details": {
          "function_name": "print_cand_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6547-6556",
          "snippet": "static void print_cand_cache(struct bpf_verifier_log *log)\n{\n\tmutex_lock(&cand_cache_mutex);\n\tbpf_log(log, \"vmlinux_cand_cache:\");\n\t__print_cand_cache(log, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\tbpf_log(log, \"\\nmodule_cand_cache:\");\n\t__print_cand_cache(log, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tbpf_log(log, \"\\n\");\n\tmutex_unlock(&cand_cache_mutex);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MODULE_CAND_CACHE_SIZE 31",
            "#define VMLINUX_CAND_CACHE_SIZE 31"
          ],
          "globals_used": [
            "static struct bpf_cand_cache *vmlinux_cand_cache[VMLINUX_CAND_CACHE_SIZE];",
            "static struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];",
            "static DEFINE_MUTEX(cand_cache_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MODULE_CAND_CACHE_SIZE 31\n#define VMLINUX_CAND_CACHE_SIZE 31\n\nstatic struct bpf_cand_cache *vmlinux_cand_cache[VMLINUX_CAND_CACHE_SIZE];\nstatic struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];\nstatic DEFINE_MUTEX(cand_cache_mutex);\n\nstatic void print_cand_cache(struct bpf_verifier_log *log)\n{\n\tmutex_lock(&cand_cache_mutex);\n\tbpf_log(log, \"vmlinux_cand_cache:\");\n\t__print_cand_cache(log, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\tbpf_log(log, \"\\nmodule_cand_cache:\");\n\t__print_cand_cache(log, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tbpf_log(log, \"\\n\");\n\tmutex_unlock(&cand_cache_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cand_cache_mutex"
          ],
          "line": 6841
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cands.cands"
          ],
          "line": 6840
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_core_apply_relo_insn",
          "args": [
            "(void *)ctx->log",
            "insn",
            "relo->insn_off / 8",
            "relo",
            "relo_idx",
            "ctx->btf",
            "&cands",
            "specs"
          ],
          "line": 6835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "ctx->log",
            "\"CO-RE relocating %s %s: found target candidate [%d]\\n\"",
            "btf_kind_str[cc->kind]",
            "cc->name",
            "cc->cands[i].id"
          ],
          "line": 6821
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "cc->cnt",
            "sizeof(*cands.cands)",
            "GFP_KERNEL"
          ],
          "line": 6814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cc"
          ],
          "line": 6810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cc"
          ],
          "line": 6807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_core_find_cands",
          "args": [
            "ctx",
            "relo->type_id"
          ],
          "line": 6806
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_core_find_cands",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6698-6784",
          "snippet": "static struct bpf_cand_cache *\nbpf_core_find_cands(struct bpf_core_ctx *ctx, u32 local_type_id)\n{\n\tstruct bpf_cand_cache *cands, *cc, local_cand = {};\n\tconst struct btf *local_btf = ctx->btf;\n\tconst struct btf_type *local_type;\n\tconst struct btf *main_btf;\n\tsize_t local_essent_len;\n\tstruct btf *mod_btf;\n\tconst char *name;\n\tint id;\n\n\tmain_btf = bpf_get_btf_vmlinux();\n\tif (IS_ERR(main_btf))\n\t\treturn ERR_CAST(main_btf);\n\n\tlocal_type = btf_type_by_id(local_btf, local_type_id);\n\tif (!local_type)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tname = btf_name_by_offset(local_btf, local_type->name_off);\n\tif (str_is_empty(name))\n\t\treturn ERR_PTR(-EINVAL);\n\tlocal_essent_len = bpf_core_essential_name_len(name);\n\n\tcands = &local_cand;\n\tcands->name = name;\n\tcands->kind = btf_kind(local_type);\n\tcands->name_len = local_essent_len;\n\n\tcc = check_cand_cache(cands, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\t/* cands is a pointer to stack here */\n\tif (cc) {\n\t\tif (cc->cnt)\n\t\t\treturn cc;\n\t\tgoto check_modules;\n\t}\n\n\t/* Attempt to find target candidates in vmlinux BTF first */\n\tcands = bpf_core_add_cands(cands, main_btf, 1);\n\tif (IS_ERR(cands))\n\t\treturn ERR_CAST(cands);\n\n\t/* cands is a pointer to kmalloced memory here if cands->cnt > 0 */\n\n\t/* populate cache even when cands->cnt == 0 */\n\tcc = populate_cand_cache(cands, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\tif (IS_ERR(cc))\n\t\treturn ERR_CAST(cc);\n\n\t/* if vmlinux BTF has any candidate, don't go for module BTFs */\n\tif (cc->cnt)\n\t\treturn cc;\n\ncheck_modules:\n\t/* cands is a pointer to stack here and cands->cnt == 0 */\n\tcc = check_cand_cache(cands, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tif (cc)\n\t\t/* if cache has it return it even if cc->cnt == 0 */\n\t\treturn cc;\n\n\t/* If candidate is not found in vmlinux's BTF then search in module's BTFs */\n\tspin_lock_bh(&btf_idr_lock);\n\tidr_for_each_entry(&btf_idr, mod_btf, id) {\n\t\tif (!btf_is_module(mod_btf))\n\t\t\tcontinue;\n\t\t/* linear search could be slow hence unlock/lock\n\t\t * the IDR to avoiding holding it for too long\n\t\t */\n\t\tbtf_get(mod_btf);\n\t\tspin_unlock_bh(&btf_idr_lock);\n\t\tcands = bpf_core_add_cands(cands, mod_btf, btf_nr_types(main_btf));\n\t\tif (IS_ERR(cands)) {\n\t\t\tbtf_put(mod_btf);\n\t\t\treturn ERR_CAST(cands);\n\t\t}\n\t\tspin_lock_bh(&btf_idr_lock);\n\t\tbtf_put(mod_btf);\n\t}\n\tspin_unlock_bh(&btf_idr_lock);\n\t/* cands is a pointer to kmalloced memory here if cands->cnt > 0\n\t * or pointer to stack if cands->cnd == 0.\n\t * Copy it into the cache even when cands->cnt == 0 and\n\t * return the result.\n\t */\n\treturn populate_cand_cache(cands, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MODULE_CAND_CACHE_SIZE 31",
            "#define VMLINUX_CAND_CACHE_SIZE 31"
          ],
          "globals_used": [
            "static struct bpf_cand_cache *vmlinux_cand_cache[VMLINUX_CAND_CACHE_SIZE];",
            "static struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MODULE_CAND_CACHE_SIZE 31\n#define VMLINUX_CAND_CACHE_SIZE 31\n\nstatic struct bpf_cand_cache *vmlinux_cand_cache[VMLINUX_CAND_CACHE_SIZE];\nstatic struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];\n\nstatic struct bpf_cand_cache *\nbpf_core_find_cands(struct bpf_core_ctx *ctx, u32 local_type_id)\n{\n\tstruct bpf_cand_cache *cands, *cc, local_cand = {};\n\tconst struct btf *local_btf = ctx->btf;\n\tconst struct btf_type *local_type;\n\tconst struct btf *main_btf;\n\tsize_t local_essent_len;\n\tstruct btf *mod_btf;\n\tconst char *name;\n\tint id;\n\n\tmain_btf = bpf_get_btf_vmlinux();\n\tif (IS_ERR(main_btf))\n\t\treturn ERR_CAST(main_btf);\n\n\tlocal_type = btf_type_by_id(local_btf, local_type_id);\n\tif (!local_type)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tname = btf_name_by_offset(local_btf, local_type->name_off);\n\tif (str_is_empty(name))\n\t\treturn ERR_PTR(-EINVAL);\n\tlocal_essent_len = bpf_core_essential_name_len(name);\n\n\tcands = &local_cand;\n\tcands->name = name;\n\tcands->kind = btf_kind(local_type);\n\tcands->name_len = local_essent_len;\n\n\tcc = check_cand_cache(cands, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\t/* cands is a pointer to stack here */\n\tif (cc) {\n\t\tif (cc->cnt)\n\t\t\treturn cc;\n\t\tgoto check_modules;\n\t}\n\n\t/* Attempt to find target candidates in vmlinux BTF first */\n\tcands = bpf_core_add_cands(cands, main_btf, 1);\n\tif (IS_ERR(cands))\n\t\treturn ERR_CAST(cands);\n\n\t/* cands is a pointer to kmalloced memory here if cands->cnt > 0 */\n\n\t/* populate cache even when cands->cnt == 0 */\n\tcc = populate_cand_cache(cands, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\tif (IS_ERR(cc))\n\t\treturn ERR_CAST(cc);\n\n\t/* if vmlinux BTF has any candidate, don't go for module BTFs */\n\tif (cc->cnt)\n\t\treturn cc;\n\ncheck_modules:\n\t/* cands is a pointer to stack here and cands->cnt == 0 */\n\tcc = check_cand_cache(cands, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tif (cc)\n\t\t/* if cache has it return it even if cc->cnt == 0 */\n\t\treturn cc;\n\n\t/* If candidate is not found in vmlinux's BTF then search in module's BTFs */\n\tspin_lock_bh(&btf_idr_lock);\n\tidr_for_each_entry(&btf_idr, mod_btf, id) {\n\t\tif (!btf_is_module(mod_btf))\n\t\t\tcontinue;\n\t\t/* linear search could be slow hence unlock/lock\n\t\t * the IDR to avoiding holding it for too long\n\t\t */\n\t\tbtf_get(mod_btf);\n\t\tspin_unlock_bh(&btf_idr_lock);\n\t\tcands = bpf_core_add_cands(cands, mod_btf, btf_nr_types(main_btf));\n\t\tif (IS_ERR(cands)) {\n\t\t\tbtf_put(mod_btf);\n\t\t\treturn ERR_CAST(cands);\n\t\t}\n\t\tspin_lock_bh(&btf_idr_lock);\n\t\tbtf_put(mod_btf);\n\t}\n\tspin_unlock_bh(&btf_idr_lock);\n\t/* cands is a pointer to kmalloced memory here if cands->cnt > 0\n\t * or pointer to stack if cands->cnd == 0.\n\t * Copy it into the cache even when cands->cnt == 0 and\n\t * return the result.\n\t */\n\treturn populate_cand_cache(cands, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cand_cache_mutex"
          ],
          "line": 6805
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "3",
            "sizeof(*specs)",
            "GFP_KERNEL"
          ],
          "line": 6797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\nstatic DEFINE_MUTEX(cand_cache_mutex);\n\nint bpf_core_apply(struct bpf_core_ctx *ctx, const struct bpf_core_relo *relo,\n\t\t   int relo_idx, void *insn)\n{\n\tbool need_cands = relo->kind != BPF_CORE_TYPE_ID_LOCAL;\n\tstruct bpf_core_cand_list cands = {};\n\tstruct bpf_core_spec *specs;\n\tint err;\n\n\t/* ~4k of temp memory necessary to convert LLVM spec like \"0:1:0:5\"\n\t * into arrays of btf_ids of struct fields and array indices.\n\t */\n\tspecs = kcalloc(3, sizeof(*specs), GFP_KERNEL);\n\tif (!specs)\n\t\treturn -ENOMEM;\n\n\tif (need_cands) {\n\t\tstruct bpf_cand_cache *cc;\n\t\tint i;\n\n\t\tmutex_lock(&cand_cache_mutex);\n\t\tcc = bpf_core_find_cands(ctx, relo->type_id);\n\t\tif (IS_ERR(cc)) {\n\t\t\tbpf_log(ctx->log, \"target candidate search failed for %d\\n\",\n\t\t\t\trelo->type_id);\n\t\t\terr = PTR_ERR(cc);\n\t\t\tgoto out;\n\t\t}\n\t\tif (cc->cnt) {\n\t\t\tcands.cands = kcalloc(cc->cnt, sizeof(*cands.cands), GFP_KERNEL);\n\t\t\tif (!cands.cands) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < cc->cnt; i++) {\n\t\t\tbpf_log(ctx->log,\n\t\t\t\t\"CO-RE relocating %s %s: found target candidate [%d]\\n\",\n\t\t\t\tbtf_kind_str[cc->kind], cc->name, cc->cands[i].id);\n\t\t\tcands.cands[i].btf = cc->cands[i].btf;\n\t\t\tcands.cands[i].id = cc->cands[i].id;\n\t\t}\n\t\tcands.len = cc->cnt;\n\t\t/* cand_cache_mutex needs to span the cache lookup and\n\t\t * copy of btf pointer into bpf_core_cand_list,\n\t\t * since module can be unloaded while bpf_core_apply_relo_insn\n\t\t * is working with module's btf.\n\t\t */\n\t}\n\n\terr = bpf_core_apply_relo_insn((void *)ctx->log, insn, relo->insn_off / 8,\n\t\t\t\t       relo, relo_idx, ctx->btf, &cands, specs);\nout:\n\tkfree(specs);\n\tif (need_cands) {\n\t\tkfree(cands.cands);\n\t\tmutex_unlock(&cand_cache_mutex);\n\t\tif (ctx->log->level & BPF_LOG_LEVEL2)\n\t\t\tprint_cand_cache(ctx->log);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_core_find_cands",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6698-6784",
    "snippet": "static struct bpf_cand_cache *\nbpf_core_find_cands(struct bpf_core_ctx *ctx, u32 local_type_id)\n{\n\tstruct bpf_cand_cache *cands, *cc, local_cand = {};\n\tconst struct btf *local_btf = ctx->btf;\n\tconst struct btf_type *local_type;\n\tconst struct btf *main_btf;\n\tsize_t local_essent_len;\n\tstruct btf *mod_btf;\n\tconst char *name;\n\tint id;\n\n\tmain_btf = bpf_get_btf_vmlinux();\n\tif (IS_ERR(main_btf))\n\t\treturn ERR_CAST(main_btf);\n\n\tlocal_type = btf_type_by_id(local_btf, local_type_id);\n\tif (!local_type)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tname = btf_name_by_offset(local_btf, local_type->name_off);\n\tif (str_is_empty(name))\n\t\treturn ERR_PTR(-EINVAL);\n\tlocal_essent_len = bpf_core_essential_name_len(name);\n\n\tcands = &local_cand;\n\tcands->name = name;\n\tcands->kind = btf_kind(local_type);\n\tcands->name_len = local_essent_len;\n\n\tcc = check_cand_cache(cands, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\t/* cands is a pointer to stack here */\n\tif (cc) {\n\t\tif (cc->cnt)\n\t\t\treturn cc;\n\t\tgoto check_modules;\n\t}\n\n\t/* Attempt to find target candidates in vmlinux BTF first */\n\tcands = bpf_core_add_cands(cands, main_btf, 1);\n\tif (IS_ERR(cands))\n\t\treturn ERR_CAST(cands);\n\n\t/* cands is a pointer to kmalloced memory here if cands->cnt > 0 */\n\n\t/* populate cache even when cands->cnt == 0 */\n\tcc = populate_cand_cache(cands, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\tif (IS_ERR(cc))\n\t\treturn ERR_CAST(cc);\n\n\t/* if vmlinux BTF has any candidate, don't go for module BTFs */\n\tif (cc->cnt)\n\t\treturn cc;\n\ncheck_modules:\n\t/* cands is a pointer to stack here and cands->cnt == 0 */\n\tcc = check_cand_cache(cands, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tif (cc)\n\t\t/* if cache has it return it even if cc->cnt == 0 */\n\t\treturn cc;\n\n\t/* If candidate is not found in vmlinux's BTF then search in module's BTFs */\n\tspin_lock_bh(&btf_idr_lock);\n\tidr_for_each_entry(&btf_idr, mod_btf, id) {\n\t\tif (!btf_is_module(mod_btf))\n\t\t\tcontinue;\n\t\t/* linear search could be slow hence unlock/lock\n\t\t * the IDR to avoiding holding it for too long\n\t\t */\n\t\tbtf_get(mod_btf);\n\t\tspin_unlock_bh(&btf_idr_lock);\n\t\tcands = bpf_core_add_cands(cands, mod_btf, btf_nr_types(main_btf));\n\t\tif (IS_ERR(cands)) {\n\t\t\tbtf_put(mod_btf);\n\t\t\treturn ERR_CAST(cands);\n\t\t}\n\t\tspin_lock_bh(&btf_idr_lock);\n\t\tbtf_put(mod_btf);\n\t}\n\tspin_unlock_bh(&btf_idr_lock);\n\t/* cands is a pointer to kmalloced memory here if cands->cnt > 0\n\t * or pointer to stack if cands->cnd == 0.\n\t * Copy it into the cache even when cands->cnt == 0 and\n\t * return the result.\n\t */\n\treturn populate_cand_cache(cands, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define MODULE_CAND_CACHE_SIZE 31",
      "#define VMLINUX_CAND_CACHE_SIZE 31"
    ],
    "globals_used": [
      "static struct bpf_cand_cache *vmlinux_cand_cache[VMLINUX_CAND_CACHE_SIZE];",
      "static struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_cand_cache",
          "args": [
            "cands",
            "module_cand_cache",
            "MODULE_CAND_CACHE_SIZE"
          ],
          "line": 6783
        },
        "resolved": true,
        "details": {
          "function_name": "populate_cand_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6580-6606",
          "snippet": "static struct bpf_cand_cache *populate_cand_cache(struct bpf_cand_cache *cands,\n\t\t\t\t\t\t  struct bpf_cand_cache **cache,\n\t\t\t\t\t\t  int cache_size)\n{\n\tstruct bpf_cand_cache **cc = &cache[hash_cands(cands) % cache_size], *new_cands;\n\n\tif (*cc) {\n\t\tbpf_free_cands_from_cache(*cc);\n\t\t*cc = NULL;\n\t}\n\tnew_cands = kmemdup(cands, sizeof_cands(cands->cnt), GFP_KERNEL);\n\tif (!new_cands) {\n\t\tbpf_free_cands(cands);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t/* strdup the name, since it will stay in cache.\n\t * the cands->name points to strings in prog's BTF and the prog can be unloaded.\n\t */\n\tnew_cands->name = kmemdup_nul(cands->name, cands->name_len, GFP_KERNEL);\n\tbpf_free_cands(cands);\n\tif (!new_cands->name) {\n\t\tkfree(new_cands);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t*cc = new_cands;\n\treturn new_cands;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_cand_cache *populate_cand_cache(struct bpf_cand_cache *cands,\n\t\t\t\t\t\t  struct bpf_cand_cache **cache,\n\t\t\t\t\t\t  int cache_size)\n{\n\tstruct bpf_cand_cache **cc = &cache[hash_cands(cands) % cache_size], *new_cands;\n\n\tif (*cc) {\n\t\tbpf_free_cands_from_cache(*cc);\n\t\t*cc = NULL;\n\t}\n\tnew_cands = kmemdup(cands, sizeof_cands(cands->cnt), GFP_KERNEL);\n\tif (!new_cands) {\n\t\tbpf_free_cands(cands);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t/* strdup the name, since it will stay in cache.\n\t * the cands->name points to strings in prog's BTF and the prog can be unloaded.\n\t */\n\tnew_cands->name = kmemdup_nul(cands->name, cands->name_len, GFP_KERNEL);\n\tbpf_free_cands(cands);\n\tif (!new_cands->name) {\n\t\tkfree(new_cands);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t*cc = new_cands;\n\treturn new_cands;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&btf_idr_lock"
          ],
          "line": 6777
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "mod_btf"
          ],
          "line": 6775
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1555-1561",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&btf_idr_lock"
          ],
          "line": 6774
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "cands"
          ],
          "line": 6772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cands"
          ],
          "line": 6770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_core_add_cands",
          "args": [
            "cands",
            "mod_btf",
            "btf_nr_types(main_btf)"
          ],
          "line": 6769
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_core_add_cands",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6649-6696",
          "snippet": "static struct bpf_cand_cache *\nbpf_core_add_cands(struct bpf_cand_cache *cands, const struct btf *targ_btf,\n\t\t   int targ_start_id)\n{\n\tstruct bpf_cand_cache *new_cands;\n\tconst struct btf_type *t;\n\tconst char *targ_name;\n\tsize_t targ_essent_len;\n\tint n, i;\n\n\tn = btf_nr_types(targ_btf);\n\tfor (i = targ_start_id; i < n; i++) {\n\t\tt = btf_type_by_id(targ_btf, i);\n\t\tif (btf_kind(t) != cands->kind)\n\t\t\tcontinue;\n\n\t\ttarg_name = btf_name_by_offset(targ_btf, t->name_off);\n\t\tif (!targ_name)\n\t\t\tcontinue;\n\n\t\t/* the resched point is before strncmp to make sure that search\n\t\t * for non-existing name will have a chance to schedule().\n\t\t */\n\t\tcond_resched();\n\n\t\tif (strncmp(cands->name, targ_name, cands->name_len) != 0)\n\t\t\tcontinue;\n\n\t\ttarg_essent_len = bpf_core_essential_name_len(targ_name);\n\t\tif (targ_essent_len != cands->name_len)\n\t\t\tcontinue;\n\n\t\t/* most of the time there is only one candidate for a given kind+name pair */\n\t\tnew_cands = kmalloc(sizeof_cands(cands->cnt + 1), GFP_KERNEL);\n\t\tif (!new_cands) {\n\t\t\tbpf_free_cands(cands);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tmemcpy(new_cands, cands, sizeof_cands(cands->cnt));\n\t\tbpf_free_cands(cands);\n\t\tcands = new_cands;\n\t\tcands->cands[cands->cnt].btf = targ_btf;\n\t\tcands->cands[cands->cnt].id = i;\n\t\tcands->cnt++;\n\t}\n\treturn cands;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_cand_cache *\nbpf_core_add_cands(struct bpf_cand_cache *cands, const struct btf *targ_btf,\n\t\t   int targ_start_id)\n{\n\tstruct bpf_cand_cache *new_cands;\n\tconst struct btf_type *t;\n\tconst char *targ_name;\n\tsize_t targ_essent_len;\n\tint n, i;\n\n\tn = btf_nr_types(targ_btf);\n\tfor (i = targ_start_id; i < n; i++) {\n\t\tt = btf_type_by_id(targ_btf, i);\n\t\tif (btf_kind(t) != cands->kind)\n\t\t\tcontinue;\n\n\t\ttarg_name = btf_name_by_offset(targ_btf, t->name_off);\n\t\tif (!targ_name)\n\t\t\tcontinue;\n\n\t\t/* the resched point is before strncmp to make sure that search\n\t\t * for non-existing name will have a chance to schedule().\n\t\t */\n\t\tcond_resched();\n\n\t\tif (strncmp(cands->name, targ_name, cands->name_len) != 0)\n\t\t\tcontinue;\n\n\t\ttarg_essent_len = bpf_core_essential_name_len(targ_name);\n\t\tif (targ_essent_len != cands->name_len)\n\t\t\tcontinue;\n\n\t\t/* most of the time there is only one candidate for a given kind+name pair */\n\t\tnew_cands = kmalloc(sizeof_cands(cands->cnt + 1), GFP_KERNEL);\n\t\tif (!new_cands) {\n\t\t\tbpf_free_cands(cands);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tmemcpy(new_cands, cands, sizeof_cands(cands->cnt));\n\t\tbpf_free_cands(cands);\n\t\tcands = new_cands;\n\t\tcands->cands[cands->cnt].btf = targ_btf;\n\t\tcands->cands[cands->cnt].id = i;\n\t\tcands->cnt++;\n\t}\n\treturn cands;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_nr_types",
          "args": [
            "main_btf"
          ],
          "line": 6769
        },
        "resolved": true,
        "details": {
          "function_name": "btf_nr_types",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "477-487",
          "snippet": "u32 btf_nr_types(const struct btf *btf)\n{\n\tu32 total = 0;\n\n\twhile (btf) {\n\t\ttotal += btf->nr_types;\n\t\tbtf = btf->base_btf;\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nu32 btf_nr_types(const struct btf *btf)\n{\n\tu32 total = 0;\n\n\twhile (btf) {\n\t\ttotal += btf->nr_types;\n\t\tbtf = btf->base_btf;\n\t}\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_get",
          "args": [
            "mod_btf"
          ],
          "line": 6767
        },
        "resolved": true,
        "details": {
          "function_name": "btf_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6155-6174",
          "snippet": "int btf_get_fd_by_id(u32 id)\n{\n\tstruct btf *btf;\n\tint fd;\n\n\trcu_read_lock();\n\tbtf = idr_find(&btf_idr, id);\n\tif (!btf || !refcount_inc_not_zero(&btf->refcnt))\n\t\tbtf = ERR_PTR(-ENOENT);\n\trcu_read_unlock();\n\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tfd = __btf_new_fd(btf);\n\tif (fd < 0)\n\t\tbtf_put(btf);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_get_fd_by_id(u32 id)\n{\n\tstruct btf *btf;\n\tint fd;\n\n\trcu_read_lock();\n\tbtf = idr_find(&btf_idr, id);\n\tif (!btf || !refcount_inc_not_zero(&btf->refcnt))\n\t\tbtf = ERR_PTR(-ENOENT);\n\trcu_read_unlock();\n\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tfd = __btf_new_fd(btf);\n\tif (fd < 0)\n\t\tbtf_put(btf);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_is_module",
          "args": [
            "mod_btf"
          ],
          "line": 6762
        },
        "resolved": true,
        "details": {
          "function_name": "btf_is_module",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6186-6189",
          "snippet": "bool btf_is_module(const struct btf *btf)\n{\n\treturn btf->kernel_btf && strcmp(btf->name, \"vmlinux\") != 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_is_module(const struct btf *btf)\n{\n\treturn btf->kernel_btf && strcmp(btf->name, \"vmlinux\") != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_for_each_entry",
          "args": [
            "&btf_idr",
            "mod_btf",
            "id"
          ],
          "line": 6761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_cand_cache",
          "args": [
            "cands",
            "module_cand_cache",
            "MODULE_CAND_CACHE_SIZE"
          ],
          "line": 6754
        },
        "resolved": true,
        "details": {
          "function_name": "check_cand_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6563-6573",
          "snippet": "static struct bpf_cand_cache *check_cand_cache(struct bpf_cand_cache *cands,\n\t\t\t\t\t       struct bpf_cand_cache **cache,\n\t\t\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc = cache[hash_cands(cands) % cache_size];\n\n\tif (cc && cc->name_len == cands->name_len &&\n\t    !strncmp(cc->name, cands->name, cands->name_len))\n\t\treturn cc;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_cand_cache *check_cand_cache(struct bpf_cand_cache *cands,\n\t\t\t\t\t       struct bpf_cand_cache **cache,\n\t\t\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc = cache[hash_cands(cands) % cache_size];\n\n\tif (cc && cc->name_len == cands->name_len &&\n\t    !strncmp(cc->name, cands->name, cands->name_len))\n\t\treturn cc;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "cc"
          ],
          "line": 6746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cc"
          ],
          "line": 6745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "cands"
          ],
          "line": 6739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cands"
          ],
          "line": 6738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_kind",
          "args": [
            "local_type"
          ],
          "line": 6725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_core_essential_name_len",
          "args": [
            "name"
          ],
          "line": 6721
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_core_essential_name_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6481-6491",
          "snippet": "size_t bpf_core_essential_name_len(const char *name)\n{\n\tsize_t n = strlen(name);\n\tint i;\n\n\tfor (i = n - 5; i >= 0; i--) {\n\t\tif (bpf_core_is_flavor_sep(name + i))\n\t\t\treturn i + 1;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nsize_t bpf_core_essential_name_len(const char *name)\n{\n\tsize_t n = strlen(name);\n\tint i;\n\n\tfor (i = n - 5; i >= 0; i--) {\n\t\tif (bpf_core_is_flavor_sep(name + i))\n\t\t\treturn i + 1;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 6720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_is_empty",
          "args": [
            "name"
          ],
          "line": 6719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "local_btf",
            "local_type->name_off"
          ],
          "line": 6718
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "726-729",
          "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 6716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "local_btf",
            "local_type_id"
          ],
          "line": 6714
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "main_btf"
          ],
          "line": 6712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "main_btf"
          ],
          "line": 6711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_get_btf_vmlinux",
          "args": [],
          "line": 6710
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_btf_vmlinux",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "14201-14210",
          "snippet": "struct btf *bpf_get_btf_vmlinux(void)\n{\n\tif (!btf_vmlinux && IS_ENABLED(CONFIG_DEBUG_INFO_BTF)) {\n\t\tmutex_lock(&bpf_verifier_lock);\n\t\tif (!btf_vmlinux)\n\t\t\tbtf_vmlinux = btf_parse_vmlinux();\n\t\tmutex_unlock(&bpf_verifier_lock);\n\t}\n\treturn btf_vmlinux;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct btf *btf_vmlinux;",
            "static DEFINE_MUTEX(bpf_verifier_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstruct btf *btf_vmlinux;\nstatic DEFINE_MUTEX(bpf_verifier_lock);\n\nstruct btf *bpf_get_btf_vmlinux(void)\n{\n\tif (!btf_vmlinux && IS_ENABLED(CONFIG_DEBUG_INFO_BTF)) {\n\t\tmutex_lock(&bpf_verifier_lock);\n\t\tif (!btf_vmlinux)\n\t\t\tbtf_vmlinux = btf_parse_vmlinux();\n\t\tmutex_unlock(&bpf_verifier_lock);\n\t}\n\treturn btf_vmlinux;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MODULE_CAND_CACHE_SIZE 31\n#define VMLINUX_CAND_CACHE_SIZE 31\n\nstatic struct bpf_cand_cache *vmlinux_cand_cache[VMLINUX_CAND_CACHE_SIZE];\nstatic struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];\n\nstatic struct bpf_cand_cache *\nbpf_core_find_cands(struct bpf_core_ctx *ctx, u32 local_type_id)\n{\n\tstruct bpf_cand_cache *cands, *cc, local_cand = {};\n\tconst struct btf *local_btf = ctx->btf;\n\tconst struct btf_type *local_type;\n\tconst struct btf *main_btf;\n\tsize_t local_essent_len;\n\tstruct btf *mod_btf;\n\tconst char *name;\n\tint id;\n\n\tmain_btf = bpf_get_btf_vmlinux();\n\tif (IS_ERR(main_btf))\n\t\treturn ERR_CAST(main_btf);\n\n\tlocal_type = btf_type_by_id(local_btf, local_type_id);\n\tif (!local_type)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tname = btf_name_by_offset(local_btf, local_type->name_off);\n\tif (str_is_empty(name))\n\t\treturn ERR_PTR(-EINVAL);\n\tlocal_essent_len = bpf_core_essential_name_len(name);\n\n\tcands = &local_cand;\n\tcands->name = name;\n\tcands->kind = btf_kind(local_type);\n\tcands->name_len = local_essent_len;\n\n\tcc = check_cand_cache(cands, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\t/* cands is a pointer to stack here */\n\tif (cc) {\n\t\tif (cc->cnt)\n\t\t\treturn cc;\n\t\tgoto check_modules;\n\t}\n\n\t/* Attempt to find target candidates in vmlinux BTF first */\n\tcands = bpf_core_add_cands(cands, main_btf, 1);\n\tif (IS_ERR(cands))\n\t\treturn ERR_CAST(cands);\n\n\t/* cands is a pointer to kmalloced memory here if cands->cnt > 0 */\n\n\t/* populate cache even when cands->cnt == 0 */\n\tcc = populate_cand_cache(cands, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\tif (IS_ERR(cc))\n\t\treturn ERR_CAST(cc);\n\n\t/* if vmlinux BTF has any candidate, don't go for module BTFs */\n\tif (cc->cnt)\n\t\treturn cc;\n\ncheck_modules:\n\t/* cands is a pointer to stack here and cands->cnt == 0 */\n\tcc = check_cand_cache(cands, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tif (cc)\n\t\t/* if cache has it return it even if cc->cnt == 0 */\n\t\treturn cc;\n\n\t/* If candidate is not found in vmlinux's BTF then search in module's BTFs */\n\tspin_lock_bh(&btf_idr_lock);\n\tidr_for_each_entry(&btf_idr, mod_btf, id) {\n\t\tif (!btf_is_module(mod_btf))\n\t\t\tcontinue;\n\t\t/* linear search could be slow hence unlock/lock\n\t\t * the IDR to avoiding holding it for too long\n\t\t */\n\t\tbtf_get(mod_btf);\n\t\tspin_unlock_bh(&btf_idr_lock);\n\t\tcands = bpf_core_add_cands(cands, mod_btf, btf_nr_types(main_btf));\n\t\tif (IS_ERR(cands)) {\n\t\t\tbtf_put(mod_btf);\n\t\t\treturn ERR_CAST(cands);\n\t\t}\n\t\tspin_lock_bh(&btf_idr_lock);\n\t\tbtf_put(mod_btf);\n\t}\n\tspin_unlock_bh(&btf_idr_lock);\n\t/* cands is a pointer to kmalloced memory here if cands->cnt > 0\n\t * or pointer to stack if cands->cnd == 0.\n\t * Copy it into the cache even when cands->cnt == 0 and\n\t * return the result.\n\t */\n\treturn populate_cand_cache(cands, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n}"
  },
  {
    "function_name": "bpf_core_add_cands",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6649-6696",
    "snippet": "static struct bpf_cand_cache *\nbpf_core_add_cands(struct bpf_cand_cache *cands, const struct btf *targ_btf,\n\t\t   int targ_start_id)\n{\n\tstruct bpf_cand_cache *new_cands;\n\tconst struct btf_type *t;\n\tconst char *targ_name;\n\tsize_t targ_essent_len;\n\tint n, i;\n\n\tn = btf_nr_types(targ_btf);\n\tfor (i = targ_start_id; i < n; i++) {\n\t\tt = btf_type_by_id(targ_btf, i);\n\t\tif (btf_kind(t) != cands->kind)\n\t\t\tcontinue;\n\n\t\ttarg_name = btf_name_by_offset(targ_btf, t->name_off);\n\t\tif (!targ_name)\n\t\t\tcontinue;\n\n\t\t/* the resched point is before strncmp to make sure that search\n\t\t * for non-existing name will have a chance to schedule().\n\t\t */\n\t\tcond_resched();\n\n\t\tif (strncmp(cands->name, targ_name, cands->name_len) != 0)\n\t\t\tcontinue;\n\n\t\ttarg_essent_len = bpf_core_essential_name_len(targ_name);\n\t\tif (targ_essent_len != cands->name_len)\n\t\t\tcontinue;\n\n\t\t/* most of the time there is only one candidate for a given kind+name pair */\n\t\tnew_cands = kmalloc(sizeof_cands(cands->cnt + 1), GFP_KERNEL);\n\t\tif (!new_cands) {\n\t\t\tbpf_free_cands(cands);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tmemcpy(new_cands, cands, sizeof_cands(cands->cnt));\n\t\tbpf_free_cands(cands);\n\t\tcands = new_cands;\n\t\tcands->cands[cands->cnt].btf = targ_btf;\n\t\tcands->cands[cands->cnt].id = i;\n\t\tcands->cnt++;\n\t}\n\treturn cands;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_free_cands",
          "args": [
            "cands"
          ],
          "line": 6689
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_free_cands_from_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6512-6516",
          "snippet": "static void bpf_free_cands_from_cache(struct bpf_cand_cache *cands)\n{\n\tkfree(cands->name);\n\tkfree(cands);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void bpf_free_cands_from_cache(struct bpf_cand_cache *cands)\n{\n\tkfree(cands->name);\n\tkfree(cands);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_cands",
            "cands",
            "sizeof_cands(cands->cnt)"
          ],
          "line": 6688
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sizeof_cands",
          "args": [
            "cands->cnt"
          ],
          "line": 6688
        },
        "resolved": true,
        "details": {
          "function_name": "sizeof_cands",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6575-6578",
          "snippet": "static size_t sizeof_cands(int cnt)\n{\n\treturn offsetof(struct bpf_cand_cache, cands[cnt]);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic size_t sizeof_cands(int cnt)\n{\n\treturn offsetof(struct bpf_cand_cache, cands[cnt]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 6685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof_cands(cands->cnt + 1)",
            "GFP_KERNEL"
          ],
          "line": 6682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_core_essential_name_len",
          "args": [
            "targ_name"
          ],
          "line": 6677
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_core_essential_name_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6481-6491",
          "snippet": "size_t bpf_core_essential_name_len(const char *name)\n{\n\tsize_t n = strlen(name);\n\tint i;\n\n\tfor (i = n - 5; i >= 0; i--) {\n\t\tif (bpf_core_is_flavor_sep(name + i))\n\t\t\treturn i + 1;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nsize_t bpf_core_essential_name_len(const char *name)\n{\n\tsize_t n = strlen(name);\n\tint i;\n\n\tfor (i = n - 5; i >= 0; i--) {\n\t\tif (bpf_core_is_flavor_sep(name + i))\n\t\t\treturn i + 1;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cands->name",
            "targ_name",
            "cands->name_len"
          ],
          "line": 6674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 6672
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "targ_btf",
            "t->name_off"
          ],
          "line": 6665
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "726-729",
          "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_kind",
          "args": [
            "t"
          ],
          "line": 6662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "targ_btf",
            "i"
          ],
          "line": 6661
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_nr_types",
          "args": [
            "targ_btf"
          ],
          "line": 6659
        },
        "resolved": true,
        "details": {
          "function_name": "btf_nr_types",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "477-487",
          "snippet": "u32 btf_nr_types(const struct btf *btf)\n{\n\tu32 total = 0;\n\n\twhile (btf) {\n\t\ttotal += btf->nr_types;\n\t\tbtf = btf->base_btf;\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nu32 btf_nr_types(const struct btf *btf)\n{\n\tu32 total = 0;\n\n\twhile (btf) {\n\t\ttotal += btf->nr_types;\n\t\tbtf = btf->base_btf;\n\t}\n\n\treturn total;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_cand_cache *\nbpf_core_add_cands(struct bpf_cand_cache *cands, const struct btf *targ_btf,\n\t\t   int targ_start_id)\n{\n\tstruct bpf_cand_cache *new_cands;\n\tconst struct btf_type *t;\n\tconst char *targ_name;\n\tsize_t targ_essent_len;\n\tint n, i;\n\n\tn = btf_nr_types(targ_btf);\n\tfor (i = targ_start_id; i < n; i++) {\n\t\tt = btf_type_by_id(targ_btf, i);\n\t\tif (btf_kind(t) != cands->kind)\n\t\t\tcontinue;\n\n\t\ttarg_name = btf_name_by_offset(targ_btf, t->name_off);\n\t\tif (!targ_name)\n\t\t\tcontinue;\n\n\t\t/* the resched point is before strncmp to make sure that search\n\t\t * for non-existing name will have a chance to schedule().\n\t\t */\n\t\tcond_resched();\n\n\t\tif (strncmp(cands->name, targ_name, cands->name_len) != 0)\n\t\t\tcontinue;\n\n\t\ttarg_essent_len = bpf_core_essential_name_len(targ_name);\n\t\tif (targ_essent_len != cands->name_len)\n\t\t\tcontinue;\n\n\t\t/* most of the time there is only one candidate for a given kind+name pair */\n\t\tnew_cands = kmalloc(sizeof_cands(cands->cnt + 1), GFP_KERNEL);\n\t\tif (!new_cands) {\n\t\t\tbpf_free_cands(cands);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tmemcpy(new_cands, cands, sizeof_cands(cands->cnt));\n\t\tbpf_free_cands(cands);\n\t\tcands = new_cands;\n\t\tcands->cands[cands->cnt].btf = targ_btf;\n\t\tcands->cands[cands->cnt].id = i;\n\t\tcands->cnt++;\n\t}\n\treturn cands;\n}"
  },
  {
    "function_name": "purge_cand_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6641-6646",
    "snippet": "static void purge_cand_cache(struct btf *btf)\n{\n\tmutex_lock(&cand_cache_mutex);\n\t__purge_cand_cache(btf, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tmutex_unlock(&cand_cache_mutex);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define MODULE_CAND_CACHE_SIZE 31"
    ],
    "globals_used": [
      "static struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];",
      "static DEFINE_MUTEX(cand_cache_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cand_cache_mutex"
          ],
          "line": 6645
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__purge_cand_cache",
          "args": [
            "btf",
            "module_cand_cache",
            "MODULE_CAND_CACHE_SIZE"
          ],
          "line": 6644
        },
        "resolved": true,
        "details": {
          "function_name": "__purge_cand_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6609-6639",
          "snippet": "static void __purge_cand_cache(struct btf *btf, struct bpf_cand_cache **cache,\n\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc;\n\tint i, j;\n\n\tfor (i = 0; i < cache_size; i++) {\n\t\tcc = cache[i];\n\t\tif (!cc)\n\t\t\tcontinue;\n\t\tif (!btf) {\n\t\t\t/* when new module is loaded purge all of module_cand_cache,\n\t\t\t * since new module might have candidates with the name\n\t\t\t * that matches cached cands.\n\t\t\t */\n\t\t\tbpf_free_cands_from_cache(cc);\n\t\t\tcache[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t/* when module is unloaded purge cache entries\n\t\t * that match module's btf\n\t\t */\n\t\tfor (j = 0; j < cc->cnt; j++)\n\t\t\tif (cc->cands[j].btf == btf) {\n\t\t\t\tbpf_free_cands_from_cache(cc);\n\t\t\t\tcache[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];\n\nstatic void __purge_cand_cache(struct btf *btf, struct bpf_cand_cache **cache,\n\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc;\n\tint i, j;\n\n\tfor (i = 0; i < cache_size; i++) {\n\t\tcc = cache[i];\n\t\tif (!cc)\n\t\t\tcontinue;\n\t\tif (!btf) {\n\t\t\t/* when new module is loaded purge all of module_cand_cache,\n\t\t\t * since new module might have candidates with the name\n\t\t\t * that matches cached cands.\n\t\t\t */\n\t\t\tbpf_free_cands_from_cache(cc);\n\t\t\tcache[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t/* when module is unloaded purge cache entries\n\t\t * that match module's btf\n\t\t */\n\t\tfor (j = 0; j < cc->cnt; j++)\n\t\t\tif (cc->cands[j].btf == btf) {\n\t\t\t\tbpf_free_cands_from_cache(cc);\n\t\t\t\tcache[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cand_cache_mutex"
          ],
          "line": 6643
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MODULE_CAND_CACHE_SIZE 31\n\nstatic struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];\nstatic DEFINE_MUTEX(cand_cache_mutex);\n\nstatic void purge_cand_cache(struct btf *btf)\n{\n\tmutex_lock(&cand_cache_mutex);\n\t__purge_cand_cache(btf, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tmutex_unlock(&cand_cache_mutex);\n}"
  },
  {
    "function_name": "__purge_cand_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6609-6639",
    "snippet": "static void __purge_cand_cache(struct btf *btf, struct bpf_cand_cache **cache,\n\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc;\n\tint i, j;\n\n\tfor (i = 0; i < cache_size; i++) {\n\t\tcc = cache[i];\n\t\tif (!cc)\n\t\t\tcontinue;\n\t\tif (!btf) {\n\t\t\t/* when new module is loaded purge all of module_cand_cache,\n\t\t\t * since new module might have candidates with the name\n\t\t\t * that matches cached cands.\n\t\t\t */\n\t\t\tbpf_free_cands_from_cache(cc);\n\t\t\tcache[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t/* when module is unloaded purge cache entries\n\t\t * that match module's btf\n\t\t */\n\t\tfor (j = 0; j < cc->cnt; j++)\n\t\t\tif (cc->cands[j].btf == btf) {\n\t\t\t\tbpf_free_cands_from_cache(cc);\n\t\t\t\tcache[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_free_cands_from_cache",
          "args": [
            "cc"
          ],
          "line": 6633
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_free_cands_from_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6512-6516",
          "snippet": "static void bpf_free_cands_from_cache(struct bpf_cand_cache *cands)\n{\n\tkfree(cands->name);\n\tkfree(cands);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void bpf_free_cands_from_cache(struct bpf_cand_cache *cands)\n{\n\tkfree(cands->name);\n\tkfree(cands);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];\n\nstatic void __purge_cand_cache(struct btf *btf, struct bpf_cand_cache **cache,\n\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc;\n\tint i, j;\n\n\tfor (i = 0; i < cache_size; i++) {\n\t\tcc = cache[i];\n\t\tif (!cc)\n\t\t\tcontinue;\n\t\tif (!btf) {\n\t\t\t/* when new module is loaded purge all of module_cand_cache,\n\t\t\t * since new module might have candidates with the name\n\t\t\t * that matches cached cands.\n\t\t\t */\n\t\t\tbpf_free_cands_from_cache(cc);\n\t\t\tcache[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t/* when module is unloaded purge cache entries\n\t\t * that match module's btf\n\t\t */\n\t\tfor (j = 0; j < cc->cnt; j++)\n\t\t\tif (cc->cands[j].btf == btf) {\n\t\t\t\tbpf_free_cands_from_cache(cc);\n\t\t\t\tcache[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n}"
  },
  {
    "function_name": "populate_cand_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6580-6606",
    "snippet": "static struct bpf_cand_cache *populate_cand_cache(struct bpf_cand_cache *cands,\n\t\t\t\t\t\t  struct bpf_cand_cache **cache,\n\t\t\t\t\t\t  int cache_size)\n{\n\tstruct bpf_cand_cache **cc = &cache[hash_cands(cands) % cache_size], *new_cands;\n\n\tif (*cc) {\n\t\tbpf_free_cands_from_cache(*cc);\n\t\t*cc = NULL;\n\t}\n\tnew_cands = kmemdup(cands, sizeof_cands(cands->cnt), GFP_KERNEL);\n\tif (!new_cands) {\n\t\tbpf_free_cands(cands);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t/* strdup the name, since it will stay in cache.\n\t * the cands->name points to strings in prog's BTF and the prog can be unloaded.\n\t */\n\tnew_cands->name = kmemdup_nul(cands->name, cands->name_len, GFP_KERNEL);\n\tbpf_free_cands(cands);\n\tif (!new_cands->name) {\n\t\tkfree(new_cands);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t*cc = new_cands;\n\treturn new_cands;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 6602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_cands"
          ],
          "line": 6601
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_free_cands",
          "args": [
            "cands"
          ],
          "line": 6599
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_free_cands_from_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6512-6516",
          "snippet": "static void bpf_free_cands_from_cache(struct bpf_cand_cache *cands)\n{\n\tkfree(cands->name);\n\tkfree(cands);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void bpf_free_cands_from_cache(struct bpf_cand_cache *cands)\n{\n\tkfree(cands->name);\n\tkfree(cands);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup_nul",
          "args": [
            "cands->name",
            "cands->name_len",
            "GFP_KERNEL"
          ],
          "line": 6598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 6593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "cands",
            "sizeof_cands(cands->cnt)",
            "GFP_KERNEL"
          ],
          "line": 6590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeof_cands",
          "args": [
            "cands->cnt"
          ],
          "line": 6590
        },
        "resolved": true,
        "details": {
          "function_name": "sizeof_cands",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6575-6578",
          "snippet": "static size_t sizeof_cands(int cnt)\n{\n\treturn offsetof(struct bpf_cand_cache, cands[cnt]);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic size_t sizeof_cands(int cnt)\n{\n\treturn offsetof(struct bpf_cand_cache, cands[cnt]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_cands",
          "args": [
            "cands"
          ],
          "line": 6584
        },
        "resolved": true,
        "details": {
          "function_name": "hash_cands",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6558-6561",
          "snippet": "static u32 hash_cands(struct bpf_cand_cache *cands)\n{\n\treturn jhash(cands->name, cands->name_len, 0);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic u32 hash_cands(struct bpf_cand_cache *cands)\n{\n\treturn jhash(cands->name, cands->name_len, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_cand_cache *populate_cand_cache(struct bpf_cand_cache *cands,\n\t\t\t\t\t\t  struct bpf_cand_cache **cache,\n\t\t\t\t\t\t  int cache_size)\n{\n\tstruct bpf_cand_cache **cc = &cache[hash_cands(cands) % cache_size], *new_cands;\n\n\tif (*cc) {\n\t\tbpf_free_cands_from_cache(*cc);\n\t\t*cc = NULL;\n\t}\n\tnew_cands = kmemdup(cands, sizeof_cands(cands->cnt), GFP_KERNEL);\n\tif (!new_cands) {\n\t\tbpf_free_cands(cands);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t/* strdup the name, since it will stay in cache.\n\t * the cands->name points to strings in prog's BTF and the prog can be unloaded.\n\t */\n\tnew_cands->name = kmemdup_nul(cands->name, cands->name_len, GFP_KERNEL);\n\tbpf_free_cands(cands);\n\tif (!new_cands->name) {\n\t\tkfree(new_cands);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t*cc = new_cands;\n\treturn new_cands;\n}"
  },
  {
    "function_name": "sizeof_cands",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6575-6578",
    "snippet": "static size_t sizeof_cands(int cnt)\n{\n\treturn offsetof(struct bpf_cand_cache, cands[cnt]);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic size_t sizeof_cands(int cnt)\n{\n\treturn offsetof(struct bpf_cand_cache, cands[cnt]);\n}"
  },
  {
    "function_name": "check_cand_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6563-6573",
    "snippet": "static struct bpf_cand_cache *check_cand_cache(struct bpf_cand_cache *cands,\n\t\t\t\t\t       struct bpf_cand_cache **cache,\n\t\t\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc = cache[hash_cands(cands) % cache_size];\n\n\tif (cc && cc->name_len == cands->name_len &&\n\t    !strncmp(cc->name, cands->name, cands->name_len))\n\t\treturn cc;\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cc->name",
            "cands->name",
            "cands->name_len"
          ],
          "line": 6570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_cands",
          "args": [
            "cands"
          ],
          "line": 6567
        },
        "resolved": true,
        "details": {
          "function_name": "hash_cands",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6558-6561",
          "snippet": "static u32 hash_cands(struct bpf_cand_cache *cands)\n{\n\treturn jhash(cands->name, cands->name_len, 0);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic u32 hash_cands(struct bpf_cand_cache *cands)\n{\n\treturn jhash(cands->name, cands->name_len, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_cand_cache *check_cand_cache(struct bpf_cand_cache *cands,\n\t\t\t\t\t       struct bpf_cand_cache **cache,\n\t\t\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc = cache[hash_cands(cands) % cache_size];\n\n\tif (cc && cc->name_len == cands->name_len &&\n\t    !strncmp(cc->name, cands->name, cands->name_len))\n\t\treturn cc;\n\treturn NULL;\n}"
  },
  {
    "function_name": "hash_cands",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6558-6561",
    "snippet": "static u32 hash_cands(struct bpf_cand_cache *cands)\n{\n\treturn jhash(cands->name, cands->name_len, 0);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "cands->name",
            "cands->name_len",
            "0"
          ],
          "line": 6560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic u32 hash_cands(struct bpf_cand_cache *cands)\n{\n\treturn jhash(cands->name, cands->name_len, 0);\n}"
  },
  {
    "function_name": "print_cand_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6547-6556",
    "snippet": "static void print_cand_cache(struct bpf_verifier_log *log)\n{\n\tmutex_lock(&cand_cache_mutex);\n\tbpf_log(log, \"vmlinux_cand_cache:\");\n\t__print_cand_cache(log, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\tbpf_log(log, \"\\nmodule_cand_cache:\");\n\t__print_cand_cache(log, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tbpf_log(log, \"\\n\");\n\tmutex_unlock(&cand_cache_mutex);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define MODULE_CAND_CACHE_SIZE 31",
      "#define VMLINUX_CAND_CACHE_SIZE 31"
    ],
    "globals_used": [
      "static struct bpf_cand_cache *vmlinux_cand_cache[VMLINUX_CAND_CACHE_SIZE];",
      "static struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];",
      "static DEFINE_MUTEX(cand_cache_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cand_cache_mutex"
          ],
          "line": 6555
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"\\n\""
          ],
          "line": 6554
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__print_cand_cache",
          "args": [
            "log",
            "module_cand_cache",
            "MODULE_CAND_CACHE_SIZE"
          ],
          "line": 6553
        },
        "resolved": true,
        "details": {
          "function_name": "__print_cand_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6526-6545",
          "snippet": "static void __print_cand_cache(struct bpf_verifier_log *log,\n\t\t\t       struct bpf_cand_cache **cache,\n\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc;\n\tint i, j;\n\n\tfor (i = 0; i < cache_size; i++) {\n\t\tcc = cache[i];\n\t\tif (!cc)\n\t\t\tcontinue;\n\t\tbpf_log(log, \"[%d]%s(\", i, cc->name);\n\t\tfor (j = 0; j < cc->cnt; j++) {\n\t\t\tbpf_log(log, \"%d\", cc->cands[j].id);\n\t\t\tif (j < cc->cnt - 1)\n\t\t\t\tbpf_log(log, \" \");\n\t\t}\n\t\tbpf_log(log, \"), \");\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void __print_cand_cache(struct bpf_verifier_log *log,\n\t\t\t       struct bpf_cand_cache **cache,\n\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc;\n\tint i, j;\n\n\tfor (i = 0; i < cache_size; i++) {\n\t\tcc = cache[i];\n\t\tif (!cc)\n\t\t\tcontinue;\n\t\tbpf_log(log, \"[%d]%s(\", i, cc->name);\n\t\tfor (j = 0; j < cc->cnt; j++) {\n\t\t\tbpf_log(log, \"%d\", cc->cands[j].id);\n\t\t\tif (j < cc->cnt - 1)\n\t\t\t\tbpf_log(log, \" \");\n\t\t}\n\t\tbpf_log(log, \"), \");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cand_cache_mutex"
          ],
          "line": 6549
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MODULE_CAND_CACHE_SIZE 31\n#define VMLINUX_CAND_CACHE_SIZE 31\n\nstatic struct bpf_cand_cache *vmlinux_cand_cache[VMLINUX_CAND_CACHE_SIZE];\nstatic struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];\nstatic DEFINE_MUTEX(cand_cache_mutex);\n\nstatic void print_cand_cache(struct bpf_verifier_log *log)\n{\n\tmutex_lock(&cand_cache_mutex);\n\tbpf_log(log, \"vmlinux_cand_cache:\");\n\t__print_cand_cache(log, vmlinux_cand_cache, VMLINUX_CAND_CACHE_SIZE);\n\tbpf_log(log, \"\\nmodule_cand_cache:\");\n\t__print_cand_cache(log, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tbpf_log(log, \"\\n\");\n\tmutex_unlock(&cand_cache_mutex);\n}"
  },
  {
    "function_name": "__print_cand_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6526-6545",
    "snippet": "static void __print_cand_cache(struct bpf_verifier_log *log,\n\t\t\t       struct bpf_cand_cache **cache,\n\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc;\n\tint i, j;\n\n\tfor (i = 0; i < cache_size; i++) {\n\t\tcc = cache[i];\n\t\tif (!cc)\n\t\t\tcontinue;\n\t\tbpf_log(log, \"[%d]%s(\", i, cc->name);\n\t\tfor (j = 0; j < cc->cnt; j++) {\n\t\t\tbpf_log(log, \"%d\", cc->cands[j].id);\n\t\t\tif (j < cc->cnt - 1)\n\t\t\t\tbpf_log(log, \" \");\n\t\t}\n\t\tbpf_log(log, \"), \");\n\t}\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"), \""
          ],
          "line": 6543
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void __print_cand_cache(struct bpf_verifier_log *log,\n\t\t\t       struct bpf_cand_cache **cache,\n\t\t\t       int cache_size)\n{\n\tstruct bpf_cand_cache *cc;\n\tint i, j;\n\n\tfor (i = 0; i < cache_size; i++) {\n\t\tcc = cache[i];\n\t\tif (!cc)\n\t\t\tcontinue;\n\t\tbpf_log(log, \"[%d]%s(\", i, cc->name);\n\t\tfor (j = 0; j < cc->cnt; j++) {\n\t\t\tbpf_log(log, \"%d\", cc->cands[j].id);\n\t\t\tif (j < cc->cnt - 1)\n\t\t\t\tbpf_log(log, \" \");\n\t\t}\n\t\tbpf_log(log, \"), \");\n\t}\n}"
  },
  {
    "function_name": "bpf_free_cands_from_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6512-6516",
    "snippet": "static void bpf_free_cands_from_cache(struct bpf_cand_cache *cands)\n{\n\tkfree(cands->name);\n\tkfree(cands);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cands"
          ],
          "line": 6515
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void bpf_free_cands_from_cache(struct bpf_cand_cache *cands)\n{\n\tkfree(cands->name);\n\tkfree(cands);\n}"
  },
  {
    "function_name": "bpf_free_cands",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6504-6510",
    "snippet": "static void bpf_free_cands(struct bpf_cand_cache *cands)\n{\n\tif (!cands->cnt)\n\t\t/* empty candidate array was allocated on stack */\n\t\treturn;\n\tkfree(cands);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cands"
          ],
          "line": 6509
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void bpf_free_cands(struct bpf_cand_cache *cands)\n{\n\tif (!cands->cnt)\n\t\t/* empty candidate array was allocated on stack */\n\t\treturn;\n\tkfree(cands);\n}"
  },
  {
    "function_name": "bpf_core_essential_name_len",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6481-6491",
    "snippet": "size_t bpf_core_essential_name_len(const char *name)\n{\n\tsize_t n = strlen(name);\n\tint i;\n\n\tfor (i = n - 5; i >= 0; i--) {\n\t\tif (bpf_core_is_flavor_sep(name + i))\n\t\t\treturn i + 1;\n\t}\n\treturn n;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_core_is_flavor_sep",
          "args": [
            "name + i"
          ],
          "line": 6487
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_core_is_flavor_sep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6473-6479",
          "snippet": "static bool bpf_core_is_flavor_sep(const char *s)\n{\n\t/* check X___Y name pattern, where X and Y are not underscores */\n\treturn s[0] != '_' &&\t\t\t\t      /* X */\n\t       s[1] == '_' && s[2] == '_' && s[3] == '_' &&   /* ___ */\n\t       s[4] != '_';\t\t\t\t      /* Y */\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool bpf_core_is_flavor_sep(const char *s)\n{\n\t/* check X___Y name pattern, where X and Y are not underscores */\n\treturn s[0] != '_' &&\t\t\t\t      /* X */\n\t       s[1] == '_' && s[2] == '_' && s[3] == '_' &&   /* ___ */\n\t       s[4] != '_';\t\t\t\t      /* Y */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 6483
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nsize_t bpf_core_essential_name_len(const char *name)\n{\n\tsize_t n = strlen(name);\n\tint i;\n\n\tfor (i = n - 5; i >= 0; i--) {\n\t\tif (bpf_core_is_flavor_sep(name + i))\n\t\t\treturn i + 1;\n\t}\n\treturn n;\n}"
  },
  {
    "function_name": "bpf_core_is_flavor_sep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6473-6479",
    "snippet": "static bool bpf_core_is_flavor_sep(const char *s)\n{\n\t/* check X___Y name pattern, where X and Y are not underscores */\n\treturn s[0] != '_' &&\t\t\t\t      /* X */\n\t       s[1] == '_' && s[2] == '_' && s[3] == '_' &&   /* ___ */\n\t       s[4] != '_';\t\t\t\t      /* Y */\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool bpf_core_is_flavor_sep(const char *s)\n{\n\t/* check X___Y name pattern, where X and Y are not underscores */\n\treturn s[0] != '_' &&\t\t\t\t      /* X */\n\t       s[1] == '_' && s[2] == '_' && s[3] == '_' &&   /* ___ */\n\t       s[4] != '_';\t\t\t\t      /* Y */\n}"
  },
  {
    "function_name": "bpf_core_types_are_compat",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6467-6471",
    "snippet": "int bpf_core_types_are_compat(const struct btf *local_btf, __u32 local_id,\n\t\t\t      const struct btf *targ_btf, __u32 targ_id)\n{\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint bpf_core_types_are_compat(const struct btf *local_btf, __u32 local_id,\n\t\t\t      const struct btf *targ_btf, __u32 targ_id)\n{\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "bpf_check_mod_kfunc_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6441-6455",
    "snippet": "bool bpf_check_mod_kfunc_call(struct kfunc_btf_id_list *klist, u32 kfunc_id,\n\t\t\t      struct module *owner)\n{\n\tstruct kfunc_btf_id_set *s;\n\n\tmutex_lock(&klist->mutex);\n\tlist_for_each_entry(s, &klist->list, list) {\n\t\tif (s->owner == owner && btf_id_set_contains(s->set, kfunc_id)) {\n\t\t\tmutex_unlock(&klist->mutex);\n\t\t\treturn true;\n\t\t}\n\t}\n\tmutex_unlock(&klist->mutex);\n\treturn false;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klist->mutex"
          ],
          "line": 6453
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_id_set_contains",
          "args": [
            "s->set",
            "kfunc_id"
          ],
          "line": 6448
        },
        "resolved": true,
        "details": {
          "function_name": "btf_id_set_contains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6198-6201",
          "snippet": "bool btf_id_set_contains(const struct btf_id_set *set, u32 id)\n{\n\treturn bsearch(&id, set->ids, set->cnt, sizeof(u32), btf_id_cmp_func) != NULL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_id_set_contains(const struct btf_id_set *set, u32 id)\n{\n\treturn bsearch(&id, set->ids, set->cnt, sizeof(u32), btf_id_cmp_func) != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&klist->list",
            "list"
          ],
          "line": 6447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klist->mutex"
          ],
          "line": 6446
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool bpf_check_mod_kfunc_call(struct kfunc_btf_id_list *klist, u32 kfunc_id,\n\t\t\t      struct module *owner)\n{\n\tstruct kfunc_btf_id_set *s;\n\n\tmutex_lock(&klist->mutex);\n\tlist_for_each_entry(s, &klist->list, list) {\n\t\tif (s->owner == owner && btf_id_set_contains(s->set, kfunc_id)) {\n\t\t\tmutex_unlock(&klist->mutex);\n\t\t\treturn true;\n\t\t}\n\t}\n\tmutex_unlock(&klist->mutex);\n\treturn false;\n}"
  },
  {
    "function_name": "unregister_kfunc_btf_id_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6432-6438",
    "snippet": "void unregister_kfunc_btf_id_set(struct kfunc_btf_id_list *l,\n\t\t\t\t struct kfunc_btf_id_set *s)\n{\n\tmutex_lock(&l->mutex);\n\tlist_del_init(&s->list);\n\tmutex_unlock(&l->mutex);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&l->mutex"
          ],
          "line": 6437
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&s->list"
          ],
          "line": 6436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&l->mutex"
          ],
          "line": 6435
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid unregister_kfunc_btf_id_set(struct kfunc_btf_id_list *l,\n\t\t\t\t struct kfunc_btf_id_set *s)\n{\n\tmutex_lock(&l->mutex);\n\tlist_del_init(&s->list);\n\tmutex_unlock(&l->mutex);\n}"
  },
  {
    "function_name": "register_kfunc_btf_id_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6423-6429",
    "snippet": "void register_kfunc_btf_id_set(struct kfunc_btf_id_list *l,\n\t\t\t       struct kfunc_btf_id_set *s)\n{\n\tmutex_lock(&l->mutex);\n\tlist_add(&s->list, &l->list);\n\tmutex_unlock(&l->mutex);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&l->mutex"
          ],
          "line": 6428
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&s->list",
            "&l->list"
          ],
          "line": 6427
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&l->mutex"
          ],
          "line": 6426
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid register_kfunc_btf_id_set(struct kfunc_btf_id_list *l,\n\t\t\t       struct kfunc_btf_id_set *s)\n{\n\tmutex_lock(&l->mutex);\n\tlist_add(&s->list, &l->list);\n\tmutex_unlock(&l->mutex);\n}"
  },
  {
    "function_name": "btf_try_get_module",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6330-6350",
    "snippet": "struct module *btf_try_get_module(const struct btf *btf)\n{\n\tstruct module *res = NULL;\n#ifdef CONFIG_DEBUG_INFO_BTF_MODULES\n\tstruct btf_module *btf_mod, *tmp;\n\n\tmutex_lock(&btf_module_mutex);\n\tlist_for_each_entry_safe(btf_mod, tmp, &btf_modules, list) {\n\t\tif (btf_mod->btf != btf)\n\t\t\tcontinue;\n\n\t\tif (try_module_get(btf_mod->module))\n\t\t\tres = btf_mod->module;\n\n\t\tbreak;\n\t}\n\tmutex_unlock(&btf_module_mutex);\n#endif\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btf_module_mutex"
          ],
          "line": 6346
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "btf_mod->module"
          ],
          "line": 6341
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "btf_mod",
            "tmp",
            "&btf_modules",
            "list"
          ],
          "line": 6337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&btf_module_mutex"
          ],
          "line": 6336
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstruct module *btf_try_get_module(const struct btf *btf)\n{\n\tstruct module *res = NULL;\n#ifdef CONFIG_DEBUG_INFO_BTF_MODULES\n\tstruct btf_module *btf_mod, *tmp;\n\n\tmutex_lock(&btf_module_mutex);\n\tlist_for_each_entry_safe(btf_mod, tmp, &btf_modules, list) {\n\t\tif (btf_mod->btf != btf)\n\t\t\tcontinue;\n\n\t\tif (try_module_get(btf_mod->module))\n\t\t\tres = btf_mod->module;\n\n\t\tbreak;\n\t}\n\tmutex_unlock(&btf_module_mutex);\n#endif\n\n\treturn res;\n}"
  },
  {
    "function_name": "btf_module_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6321-6325",
    "snippet": "static int __init btf_module_init(void)\n{\n\tregister_module_notifier(&btf_module_nb);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&btf_module_nb"
          ],
          "line": 6323
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "307-310",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int __init btf_module_init(void)\n{\n\tregister_module_notifier(&btf_module_nb);\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_module_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6227-6315",
    "snippet": "static int btf_module_notify(struct notifier_block *nb, unsigned long op,\n\t\t\t     void *module)\n{\n\tstruct btf_module *btf_mod, *tmp;\n\tstruct module *mod = module;\n\tstruct btf *btf;\n\tint err = 0;\n\n\tif (mod->btf_data_size == 0 ||\n\t    (op != MODULE_STATE_COMING && op != MODULE_STATE_GOING))\n\t\tgoto out;\n\n\tswitch (op) {\n\tcase MODULE_STATE_COMING:\n\t\tbtf_mod = kzalloc(sizeof(*btf_mod), GFP_KERNEL);\n\t\tif (!btf_mod) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tbtf = btf_parse_module(mod->name, mod->btf_data, mod->btf_data_size);\n\t\tif (IS_ERR(btf)) {\n\t\t\tpr_warn(\"failed to validate module [%s] BTF: %ld\\n\",\n\t\t\t\tmod->name, PTR_ERR(btf));\n\t\t\tkfree(btf_mod);\n\t\t\terr = PTR_ERR(btf);\n\t\t\tgoto out;\n\t\t}\n\t\terr = btf_alloc_id(btf);\n\t\tif (err) {\n\t\t\tbtf_free(btf);\n\t\t\tkfree(btf_mod);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpurge_cand_cache(NULL);\n\t\tmutex_lock(&btf_module_mutex);\n\t\tbtf_mod->module = module;\n\t\tbtf_mod->btf = btf;\n\t\tlist_add(&btf_mod->list, &btf_modules);\n\t\tmutex_unlock(&btf_module_mutex);\n\n\t\tif (IS_ENABLED(CONFIG_SYSFS)) {\n\t\t\tstruct bin_attribute *attr;\n\n\t\t\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\t\t\tif (!attr)\n\t\t\t\tgoto out;\n\n\t\t\tsysfs_bin_attr_init(attr);\n\t\t\tattr->attr.name = btf->name;\n\t\t\tattr->attr.mode = 0444;\n\t\t\tattr->size = btf->data_size;\n\t\t\tattr->private = btf;\n\t\t\tattr->read = btf_module_read;\n\n\t\t\terr = sysfs_create_bin_file(btf_kobj, attr);\n\t\t\tif (err) {\n\t\t\t\tpr_warn(\"failed to register module [%s] BTF in sysfs: %d\\n\",\n\t\t\t\t\tmod->name, err);\n\t\t\t\tkfree(attr);\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbtf_mod->sysfs_attr = attr;\n\t\t}\n\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tmutex_lock(&btf_module_mutex);\n\t\tlist_for_each_entry_safe(btf_mod, tmp, &btf_modules, list) {\n\t\t\tif (btf_mod->module != module)\n\t\t\t\tcontinue;\n\n\t\t\tlist_del(&btf_mod->list);\n\t\t\tif (btf_mod->sysfs_attr)\n\t\t\t\tsysfs_remove_bin_file(btf_kobj, btf_mod->sysfs_attr);\n\t\t\tpurge_cand_cache(btf_mod->btf);\n\t\t\tbtf_put(btf_mod->btf);\n\t\t\tkfree(btf_mod->sysfs_attr);\n\t\t\tkfree(btf_mod);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&btf_module_mutex);\n\t\tbreak;\n\t}\nout:\n\treturn notifier_from_errno(err);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_from_errno",
          "args": [
            "err"
          ],
          "line": 6314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btf_module_mutex"
          ],
          "line": 6310
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "btf_mod"
          ],
          "line": 6307
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "btf_mod->btf"
          ],
          "line": 6305
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1555-1561",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "purge_cand_cache",
          "args": [
            "btf_mod->btf"
          ],
          "line": 6304
        },
        "resolved": true,
        "details": {
          "function_name": "purge_cand_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6641-6646",
          "snippet": "static void purge_cand_cache(struct btf *btf)\n{\n\tmutex_lock(&cand_cache_mutex);\n\t__purge_cand_cache(btf, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tmutex_unlock(&cand_cache_mutex);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MODULE_CAND_CACHE_SIZE 31"
          ],
          "globals_used": [
            "static struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];",
            "static DEFINE_MUTEX(cand_cache_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MODULE_CAND_CACHE_SIZE 31\n\nstatic struct bpf_cand_cache *module_cand_cache[MODULE_CAND_CACHE_SIZE];\nstatic DEFINE_MUTEX(cand_cache_mutex);\n\nstatic void purge_cand_cache(struct btf *btf)\n{\n\tmutex_lock(&cand_cache_mutex);\n\t__purge_cand_cache(btf, module_cand_cache, MODULE_CAND_CACHE_SIZE);\n\tmutex_unlock(&cand_cache_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_remove_bin_file",
          "args": [
            "btf_kobj",
            "btf_mod->sysfs_attr"
          ],
          "line": 6303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&btf_mod->list"
          ],
          "line": 6301
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "btf_mod",
            "tmp",
            "&btf_modules",
            "list"
          ],
          "line": 6297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&btf_module_mutex"
          ],
          "line": 6296
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"failed to register module [%s] BTF in sysfs: %d\\n\"",
            "mod->name",
            "err"
          ],
          "line": 6284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_bin_file",
          "args": [
            "btf_kobj",
            "attr"
          ],
          "line": 6282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_bin_attr_init",
          "args": [
            "attr"
          ],
          "line": 6275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*attr)",
            "GFP_KERNEL"
          ],
          "line": 6271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SYSFS"
          ],
          "line": 6268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&btf_mod->list",
            "&btf_modules"
          ],
          "line": 6265
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_free",
          "args": [
            "btf"
          ],
          "line": 6256
        },
        "resolved": true,
        "details": {
          "function_name": "btf_free_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1543-1548",
          "snippet": "static void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_alloc_id",
          "args": [
            "btf"
          ],
          "line": 6254
        },
        "resolved": true,
        "details": {
          "function_name": "btf_alloc_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1498-1514",
          "snippet": "static int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "btf"
          ],
          "line": 6251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"failed to validate module [%s] BTF: %ld\\n\"",
            "mod->name",
            "PTR_ERR(btf)"
          ],
          "line": 6248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "btf"
          ],
          "line": 6249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "btf"
          ],
          "line": 6247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_parse_module",
          "args": [
            "mod->name",
            "mod->btf_data",
            "mod->btf_data_size"
          ],
          "line": 6246
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse_module",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4748-4815",
          "snippet": "static struct btf *btf_parse_module(const char *module_name, const void *data, unsigned int data_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL, *base_btf;\n\tint err;\n\n\tbase_btf = bpf_get_btf_vmlinux();\n\tif (IS_ERR(base_btf))\n\t\treturn base_btf;\n\tif (!base_btf)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tlog->level = BPF_LOG_KERNEL;\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tbtf->base_btf = base_btf;\n\tbtf->start_id = base_btf->nr_types;\n\tbtf->start_str_off = base_btf->hdr.str_len;\n\tbtf->kernel_btf = true;\n\tsnprintf(btf->name, sizeof(btf->name), \"%s\", module_name);\n\n\tbtf->data = kvmalloc(data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf->data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tmemcpy(btf->data, data, data_size);\n\tbtf->data_size = data_size;\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf) {\n\t\tkvfree(btf->data);\n\t\tkvfree(btf->types);\n\t\tkfree(btf);\n\t}\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf *btf_parse_module(const char *module_name, const void *data, unsigned int data_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL, *base_btf;\n\tint err;\n\n\tbase_btf = bpf_get_btf_vmlinux();\n\tif (IS_ERR(base_btf))\n\t\treturn base_btf;\n\tif (!base_btf)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tlog->level = BPF_LOG_KERNEL;\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tbtf->base_btf = base_btf;\n\tbtf->start_id = base_btf->nr_types;\n\tbtf->start_str_off = base_btf->hdr.str_len;\n\tbtf->kernel_btf = true;\n\tsnprintf(btf->name, sizeof(btf->name), \"%s\", module_name);\n\n\tbtf->data = kvmalloc(data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf->data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tmemcpy(btf->data, data, data_size);\n\tbtf->data_size = data_size;\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf) {\n\t\tkvfree(btf->data);\n\t\tkvfree(btf->types);\n\t\tkfree(btf);\n\t}\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*btf_mod)",
            "GFP_KERNEL"
          ],
          "line": 6241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_module_notify(struct notifier_block *nb, unsigned long op,\n\t\t\t     void *module)\n{\n\tstruct btf_module *btf_mod, *tmp;\n\tstruct module *mod = module;\n\tstruct btf *btf;\n\tint err = 0;\n\n\tif (mod->btf_data_size == 0 ||\n\t    (op != MODULE_STATE_COMING && op != MODULE_STATE_GOING))\n\t\tgoto out;\n\n\tswitch (op) {\n\tcase MODULE_STATE_COMING:\n\t\tbtf_mod = kzalloc(sizeof(*btf_mod), GFP_KERNEL);\n\t\tif (!btf_mod) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tbtf = btf_parse_module(mod->name, mod->btf_data, mod->btf_data_size);\n\t\tif (IS_ERR(btf)) {\n\t\t\tpr_warn(\"failed to validate module [%s] BTF: %ld\\n\",\n\t\t\t\tmod->name, PTR_ERR(btf));\n\t\t\tkfree(btf_mod);\n\t\t\terr = PTR_ERR(btf);\n\t\t\tgoto out;\n\t\t}\n\t\terr = btf_alloc_id(btf);\n\t\tif (err) {\n\t\t\tbtf_free(btf);\n\t\t\tkfree(btf_mod);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpurge_cand_cache(NULL);\n\t\tmutex_lock(&btf_module_mutex);\n\t\tbtf_mod->module = module;\n\t\tbtf_mod->btf = btf;\n\t\tlist_add(&btf_mod->list, &btf_modules);\n\t\tmutex_unlock(&btf_module_mutex);\n\n\t\tif (IS_ENABLED(CONFIG_SYSFS)) {\n\t\t\tstruct bin_attribute *attr;\n\n\t\t\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\t\t\tif (!attr)\n\t\t\t\tgoto out;\n\n\t\t\tsysfs_bin_attr_init(attr);\n\t\t\tattr->attr.name = btf->name;\n\t\t\tattr->attr.mode = 0444;\n\t\t\tattr->size = btf->data_size;\n\t\t\tattr->private = btf;\n\t\t\tattr->read = btf_module_read;\n\n\t\t\terr = sysfs_create_bin_file(btf_kobj, attr);\n\t\t\tif (err) {\n\t\t\t\tpr_warn(\"failed to register module [%s] BTF in sysfs: %d\\n\",\n\t\t\t\t\tmod->name, err);\n\t\t\t\tkfree(attr);\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbtf_mod->sysfs_attr = attr;\n\t\t}\n\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tmutex_lock(&btf_module_mutex);\n\t\tlist_for_each_entry_safe(btf_mod, tmp, &btf_modules, list) {\n\t\t\tif (btf_mod->module != module)\n\t\t\t\tcontinue;\n\n\t\t\tlist_del(&btf_mod->list);\n\t\t\tif (btf_mod->sysfs_attr)\n\t\t\t\tsysfs_remove_bin_file(btf_kobj, btf_mod->sysfs_attr);\n\t\t\tpurge_cand_cache(btf_mod->btf);\n\t\t\tbtf_put(btf_mod->btf);\n\t\t\tkfree(btf_mod->sysfs_attr);\n\t\t\tkfree(btf_mod);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&btf_module_mutex);\n\t\tbreak;\n\t}\nout:\n\treturn notifier_from_errno(err);\n}"
  },
  {
    "function_name": "btf_module_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6214-6223",
    "snippet": "static ssize_t\nbtf_module_read(struct file *file, struct kobject *kobj,\n\t\tstruct bin_attribute *bin_attr,\n\t\tchar *buf, loff_t off, size_t len)\n{\n\tconst struct btf *btf = bin_attr->private;\n\n\tmemcpy(buf, btf->data + off, len);\n\treturn len;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "btf->data + off",
            "len"
          ],
          "line": 6221
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic ssize_t\nbtf_module_read(struct file *file, struct kobject *kobj,\n\t\tstruct bin_attribute *bin_attr,\n\t\tchar *buf, loff_t off, size_t len)\n{\n\tconst struct btf *btf = bin_attr->private;\n\n\tmemcpy(buf, btf->data + off, len);\n\treturn len;\n}"
  },
  {
    "function_name": "btf_id_set_contains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6198-6201",
    "snippet": "bool btf_id_set_contains(const struct btf_id_set *set, u32 id)\n{\n\treturn bsearch(&id, set->ids, set->cnt, sizeof(u32), btf_id_cmp_func) != NULL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&id",
            "set->ids",
            "set->cnt",
            "sizeof(u32)",
            "btf_id_cmp_func"
          ],
          "line": 6200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_id_set_contains(const struct btf_id_set *set, u32 id)\n{\n\treturn bsearch(&id, set->ids, set->cnt, sizeof(u32), btf_id_cmp_func) != NULL;\n}"
  },
  {
    "function_name": "btf_id_cmp_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6191-6196",
    "snippet": "static int btf_id_cmp_func(const void *a, const void *b)\n{\n\tconst int *pa = a, *pb = b;\n\n\treturn *pa - *pb;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_id_cmp_func(const void *a, const void *b)\n{\n\tconst int *pa = a, *pb = b;\n\n\treturn *pa - *pb;\n}"
  },
  {
    "function_name": "btf_is_module",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6186-6189",
    "snippet": "bool btf_is_module(const struct btf *btf)\n{\n\treturn btf->kernel_btf && strcmp(btf->name, \"vmlinux\") != 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "btf->name",
            "\"vmlinux\""
          ],
          "line": 6188
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_is_module(const struct btf *btf)\n{\n\treturn btf->kernel_btf && strcmp(btf->name, \"vmlinux\") != 0;\n}"
  },
  {
    "function_name": "btf_is_kernel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6181-6184",
    "snippet": "bool btf_is_kernel(const struct btf *btf)\n{\n\treturn btf->kernel_btf;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_is_kernel(const struct btf *btf)\n{\n\treturn btf->kernel_btf;\n}"
  },
  {
    "function_name": "btf_obj_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6176-6179",
    "snippet": "u32 btf_obj_id(const struct btf *btf)\n{\n\treturn btf->id;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nu32 btf_obj_id(const struct btf *btf)\n{\n\treturn btf->id;\n}"
  },
  {
    "function_name": "btf_get_fd_by_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6155-6174",
    "snippet": "int btf_get_fd_by_id(u32 id)\n{\n\tstruct btf *btf;\n\tint fd;\n\n\trcu_read_lock();\n\tbtf = idr_find(&btf_idr, id);\n\tif (!btf || !refcount_inc_not_zero(&btf->refcnt))\n\t\tbtf = ERR_PTR(-ENOENT);\n\trcu_read_unlock();\n\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tfd = __btf_new_fd(btf);\n\tif (fd < 0)\n\t\tbtf_put(btf);\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "btf"
          ],
          "line": 6171
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1555-1561",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_new_fd",
          "args": [
            "btf"
          ],
          "line": 6169
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6037-6040",
          "snippet": "static int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};\n\nstatic int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "btf"
          ],
          "line": 6167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "btf"
          ],
          "line": 6166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 6164
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 6163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_inc_not_zero",
          "args": [
            "&btf->refcnt"
          ],
          "line": 6162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&btf_idr",
            "id"
          ],
          "line": 6161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 6160
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_get_fd_by_id(u32 id)\n{\n\tstruct btf *btf;\n\tint fd;\n\n\trcu_read_lock();\n\tbtf = idr_find(&btf_idr, id);\n\tif (!btf || !refcount_inc_not_zero(&btf->refcnt))\n\t\tbtf = ERR_PTR(-ENOENT);\n\trcu_read_unlock();\n\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tfd = __btf_new_fd(btf);\n\tif (fd < 0)\n\t\tbtf_put(btf);\n\n\treturn fd;\n}"
  },
  {
    "function_name": "btf_get_info_by_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6095-6153",
    "snippet": "int btf_get_info_by_fd(const struct btf *btf,\n\t\t       const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo;\n\tstruct bpf_btf_info info;\n\tu32 info_copy, btf_copy;\n\tvoid __user *ubtf;\n\tchar __user *uname;\n\tu32 uinfo_len, uname_len, name_len;\n\tint ret = 0;\n\n\tuinfo = u64_to_user_ptr(attr->info.info);\n\tuinfo_len = attr->info.info_len;\n\n\tinfo_copy = min_t(u32, uinfo_len, sizeof(info));\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_copy))\n\t\treturn -EFAULT;\n\n\tinfo.id = btf->id;\n\tubtf = u64_to_user_ptr(info.btf);\n\tbtf_copy = min_t(u32, btf->data_size, info.btf_size);\n\tif (copy_to_user(ubtf, btf->data, btf_copy))\n\t\treturn -EFAULT;\n\tinfo.btf_size = btf->data_size;\n\n\tinfo.kernel_btf = btf->kernel_btf;\n\n\tuname = u64_to_user_ptr(info.name);\n\tuname_len = info.name_len;\n\tif (!uname ^ !uname_len)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(btf->name);\n\tinfo.name_len = name_len;\n\n\tif (uname) {\n\t\tif (uname_len >= name_len + 1) {\n\t\t\tif (copy_to_user(uname, btf->name, name_len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (copy_to_user(uname, btf->name, uname_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, uname + uname_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\t/* let user-space know about too short buffer */\n\t\t\tret = -ENOSPC;\n\t\t}\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_copy) ||\n\t    put_user(info_copy, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "info_copy",
            "&uattr->info.info_len"
          ],
          "line": 6149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uinfo",
            "&info",
            "info_copy"
          ],
          "line": 6148
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "zero",
            "uname + uname_len - 1"
          ],
          "line": 6141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "btf->name"
          ],
          "line": 6129
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.name"
          ],
          "line": 6124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "btf->data_size",
            "info.btf_size"
          ],
          "line": 6117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.btf"
          ],
          "line": 6116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&info",
            "uinfo",
            "info_copy"
          ],
          "line": 6112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 6111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "uinfo_len",
            "sizeof(info)"
          ],
          "line": 6110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->info.info"
          ],
          "line": 6107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_get_info_by_fd(const struct btf *btf,\n\t\t       const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo;\n\tstruct bpf_btf_info info;\n\tu32 info_copy, btf_copy;\n\tvoid __user *ubtf;\n\tchar __user *uname;\n\tu32 uinfo_len, uname_len, name_len;\n\tint ret = 0;\n\n\tuinfo = u64_to_user_ptr(attr->info.info);\n\tuinfo_len = attr->info.info_len;\n\n\tinfo_copy = min_t(u32, uinfo_len, sizeof(info));\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_copy))\n\t\treturn -EFAULT;\n\n\tinfo.id = btf->id;\n\tubtf = u64_to_user_ptr(info.btf);\n\tbtf_copy = min_t(u32, btf->data_size, info.btf_size);\n\tif (copy_to_user(ubtf, btf->data, btf_copy))\n\t\treturn -EFAULT;\n\tinfo.btf_size = btf->data_size;\n\n\tinfo.kernel_btf = btf->kernel_btf;\n\n\tuname = u64_to_user_ptr(info.name);\n\tuname_len = info.name_len;\n\tif (!uname ^ !uname_len)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(btf->name);\n\tinfo.name_len = name_len;\n\n\tif (uname) {\n\t\tif (uname_len >= name_len + 1) {\n\t\t\tif (copy_to_user(uname, btf->name, name_len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (copy_to_user(uname, btf->name, uname_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, uname + uname_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\t/* let user-space know about too short buffer */\n\t\t\tret = -ENOSPC;\n\t\t}\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_copy) ||\n\t    put_user(info_copy, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btf_get_by_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6073-6093",
    "snippet": "struct btf *btf_get_by_fd(int fd)\n{\n\tstruct btf *btf;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &btf_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbtf = f.file->private_data;\n\trefcount_inc(&btf->refcnt);\n\tfdput(f);\n\n\treturn btf;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 6090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&btf->refcnt"
          ],
          "line": 6089
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 6085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 6084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 6081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 6078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};\n\nstruct btf *btf_get_by_fd(int fd)\n{\n\tstruct btf *btf;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &btf_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbtf = f.file->private_data;\n\trefcount_inc(&btf->refcnt);\n\tfdput(f);\n\n\treturn btf;\n}"
  },
  {
    "function_name": "btf_new_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6042-6071",
    "snippet": "int btf_new_fd(const union bpf_attr *attr, bpfptr_t uattr)\n{\n\tstruct btf *btf;\n\tint ret;\n\n\tbtf = btf_parse(make_bpfptr(attr->btf, uattr.is_kernel),\n\t\t\tattr->btf_size, attr->btf_log_level,\n\t\t\tu64_to_user_ptr(attr->btf_log_buf),\n\t\t\tattr->btf_log_size);\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tret = btf_alloc_id(btf);\n\tif (ret) {\n\t\tbtf_free(btf);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The BTF ID is published to the userspace.\n\t * All BTF free must go through call_rcu() from\n\t * now on (i.e. free by calling btf_put()).\n\t */\n\n\tret = __btf_new_fd(btf);\n\tif (ret < 0)\n\t\tbtf_put(btf);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "btf"
          ],
          "line": 6068
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1555-1561",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_new_fd",
          "args": [
            "btf"
          ],
          "line": 6066
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6037-6040",
          "snippet": "static int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};\n\nstatic int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_free",
          "args": [
            "btf"
          ],
          "line": 6056
        },
        "resolved": true,
        "details": {
          "function_name": "btf_free_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1543-1548",
          "snippet": "static void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_alloc_id",
          "args": [
            "btf"
          ],
          "line": 6054
        },
        "resolved": true,
        "details": {
          "function_name": "btf_alloc_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1498-1514",
          "snippet": "static int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "btf"
          ],
          "line": 6052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "btf"
          ],
          "line": 6051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_parse",
          "args": [
            "make_bpfptr(attr->btf, uattr.is_kernel)",
            "attr->btf_size",
            "attr->btf_log_level",
            "u64_to_user_ptr(attr->btf_log_buf)",
            "attr->btf_log_size"
          ],
          "line": 6047
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4450-4531",
          "snippet": "static struct btf *btf_parse(bpfptr_t btf_data, u32 btf_data_size,\n\t\t\t     u32 log_level, char __user *log_ubuf, u32 log_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tu8 *data;\n\tint err;\n\n\tif (btf_data_size > BTF_MAX_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tif (log_level || log_ubuf || log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = log_level;\n\t\tlog->ubuf = log_ubuf;\n\t\tlog->len_total = log_size;\n\n\t\t/* log attributes have to be sane */\n\t\tif (!bpf_verifier_log_attr_valid(log)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tdata = kvmalloc(btf_data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tbtf->data = data;\n\tbtf->data_size = btf_data_size;\n\n\tif (copy_from_bpfptr(data, btf_data, btf_data_size)) {\n\t\terr = -EFAULT;\n\t\tgoto errout;\n\t}\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_parse_type_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\tif (log->level && bpf_verifier_log_full(log)) {\n\t\terr = -ENOSPC;\n\t\tgoto errout;\n\t}\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf)\n\t\tbtf_free(btf);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define BTF_MAX_SIZE (16 * 1024 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_MAX_SIZE (16 * 1024 * 1024)\n\nstatic struct btf *btf_parse(bpfptr_t btf_data, u32 btf_data_size,\n\t\t\t     u32 log_level, char __user *log_ubuf, u32 log_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tu8 *data;\n\tint err;\n\n\tif (btf_data_size > BTF_MAX_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tif (log_level || log_ubuf || log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = log_level;\n\t\tlog->ubuf = log_ubuf;\n\t\tlog->len_total = log_size;\n\n\t\t/* log attributes have to be sane */\n\t\tif (!bpf_verifier_log_attr_valid(log)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tdata = kvmalloc(btf_data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tbtf->data = data;\n\tbtf->data_size = btf_data_size;\n\n\tif (copy_from_bpfptr(data, btf_data, btf_data_size)) {\n\t\terr = -EFAULT;\n\t\tgoto errout;\n\t}\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_parse_type_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\tif (log->level && bpf_verifier_log_full(log)) {\n\t\terr = -ENOSPC;\n\t\tgoto errout;\n\t}\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf)\n\t\tbtf_free(btf);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->btf_log_buf"
          ],
          "line": 6049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bpfptr",
          "args": [
            "attr->btf",
            "uattr.is_kernel"
          ],
          "line": 6047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_new_fd(const union bpf_attr *attr, bpfptr_t uattr)\n{\n\tstruct btf *btf;\n\tint ret;\n\n\tbtf = btf_parse(make_bpfptr(attr->btf, uattr.is_kernel),\n\t\t\tattr->btf_size, attr->btf_log_level,\n\t\t\tu64_to_user_ptr(attr->btf_log_buf),\n\t\t\tattr->btf_log_size);\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tret = btf_alloc_id(btf);\n\tif (ret) {\n\t\tbtf_free(btf);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The BTF ID is published to the userspace.\n\t * All BTF free must go through call_rcu() from\n\t * now on (i.e. free by calling btf_put()).\n\t */\n\n\tret = __btf_new_fd(btf);\n\tif (ret < 0)\n\t\tbtf_put(btf);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__btf_new_fd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6037-6040",
    "snippet": "static int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"btf\"",
            "&btf_fops",
            "btf",
            "O_RDONLY | O_CLOEXEC"
          ],
          "line": 6039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};\n\nstatic int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}"
  },
  {
    "function_name": "btf_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6024-6028",
    "snippet": "static int btf_release(struct inode *inode, struct file *filp)\n{\n\tbtf_put(filp->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "filp->private_data"
          ],
          "line": 6026
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1555-1561",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_release(struct inode *inode, struct file *filp)\n{\n\tbtf_put(filp->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_btf_show_fdinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "6016-6021",
    "snippet": "static void bpf_btf_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct btf *btf = filp->private_data;\n\n\tseq_printf(m, \"btf_id:\\t%u\\n\", btf->id);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"btf_id:\\t%u\\n\"",
            "btf->id"
          ],
          "line": 6020
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void bpf_btf_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct btf *btf = filp->private_data;\n\n\tseq_printf(m, \"btf_id:\\t%u\\n\", btf->id);\n}"
  },
  {
    "function_name": "btf_type_snprintf_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5994-6013",
    "snippet": "int btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_show",
          "args": [
            "btf",
            "type_id",
            "obj",
            "(struct btf_show *)&ssnprintf"
          ],
          "line": 6005
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5926-5936",
          "snippet": "static void btf_type_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t  struct btf_show *show)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tshow->btf = btf;\n\tmemset(&show->state, 0, sizeof(show->state));\n\tmemset(&show->obj, 0, sizeof(show->obj));\n\n\tbtf_type_ops(t)->show(btf, t, type_id, obj, 0, show);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_type_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t  struct btf_show *show)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tshow->btf = btf;\n\tmemset(&show->state, 0, sizeof(show->state));\n\tmemset(&show->obj, 0, sizeof(show->obj));\n\n\tbtf_type_ops(t)->show(btf, t, type_id, obj, 0, show);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}"
  },
  {
    "function_name": "btf_snprintf_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5972-5992",
    "snippet": "static void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "show->target",
            "ssnprintf->len_left",
            "fmt",
            "args"
          ],
          "line": 5978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}"
  },
  {
    "function_name": "btf_type_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5958-5964",
    "snippet": "void btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_seq_show_flags",
          "args": [
            "btf",
            "type_id",
            "obj",
            "m",
            "BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE"
          ],
          "line": 5961
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_seq_show_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5944-5956",
          "snippet": "int btf_type_seq_show_flags(const struct btf *btf, u32 type_id,\n\t\t\t    void *obj, struct seq_file *m, u64 flags)\n{\n\tstruct btf_show sseq;\n\n\tsseq.target = m;\n\tsseq.showfn = btf_seq_show;\n\tsseq.flags = flags;\n\n\tbtf_type_show(btf, type_id, obj, &sseq);\n\n\treturn sseq.state.status;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_type_seq_show_flags(const struct btf *btf, u32 type_id,\n\t\t\t    void *obj, struct seq_file *m, u64 flags)\n{\n\tstruct btf_show sseq;\n\n\tsseq.target = m;\n\tsseq.showfn = btf_seq_show;\n\tsseq.flags = flags;\n\n\tbtf_type_show(btf, type_id, obj, &sseq);\n\n\treturn sseq.state.status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nvoid btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}"
  },
  {
    "function_name": "btf_type_seq_show_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5944-5956",
    "snippet": "int btf_type_seq_show_flags(const struct btf *btf, u32 type_id,\n\t\t\t    void *obj, struct seq_file *m, u64 flags)\n{\n\tstruct btf_show sseq;\n\n\tsseq.target = m;\n\tsseq.showfn = btf_seq_show;\n\tsseq.flags = flags;\n\n\tbtf_type_show(btf, type_id, obj, &sseq);\n\n\treturn sseq.state.status;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_show",
          "args": [
            "btf",
            "type_id",
            "obj",
            "&sseq"
          ],
          "line": 5953
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5926-5936",
          "snippet": "static void btf_type_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t  struct btf_show *show)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tshow->btf = btf;\n\tmemset(&show->state, 0, sizeof(show->state));\n\tmemset(&show->obj, 0, sizeof(show->obj));\n\n\tbtf_type_ops(t)->show(btf, t, type_id, obj, 0, show);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_type_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t  struct btf_show *show)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tshow->btf = btf;\n\tmemset(&show->state, 0, sizeof(show->state));\n\tmemset(&show->obj, 0, sizeof(show->obj));\n\n\tbtf_type_ops(t)->show(btf, t, type_id, obj, 0, show);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_type_seq_show_flags(const struct btf *btf, u32 type_id,\n\t\t\t    void *obj, struct seq_file *m, u64 flags)\n{\n\tstruct btf_show sseq;\n\n\tsseq.target = m;\n\tsseq.showfn = btf_seq_show;\n\tsseq.flags = flags;\n\n\tbtf_type_show(btf, type_id, obj, &sseq);\n\n\treturn sseq.state.status;\n}"
  },
  {
    "function_name": "btf_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5938-5942",
    "snippet": "static void btf_seq_show(struct btf_show *show, const char *fmt,\n\t\t\t va_list args)\n{\n\tseq_vprintf((struct seq_file *)show->target, fmt, args);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_vprintf",
          "args": [
            "(struct seq_file *)show->target",
            "fmt",
            "args"
          ],
          "line": 5941
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_vprintf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "141-157",
          "snippet": "void trace_seq_vprintf(struct trace_seq *s, const char *fmt, va_list args)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_vprintf(&s->seq, fmt, args);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_vprintf(struct trace_seq *s, const char *fmt, va_list args)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_vprintf(&s->seq, fmt, args);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_seq_show(struct btf_show *show, const char *fmt,\n\t\t\t va_list args)\n{\n\tseq_vprintf((struct seq_file *)show->target, fmt, args);\n}"
  },
  {
    "function_name": "btf_type_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5926-5936",
    "snippet": "static void btf_type_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t  struct btf_show *show)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tshow->btf = btf;\n\tmemset(&show->state, 0, sizeof(show->state));\n\tmemset(&show->obj, 0, sizeof(show->obj));\n\n\tbtf_type_ops(t)->show(btf, t, type_id, obj, 0, show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "btf",
            "t",
            "type_id",
            "obj",
            "0",
            "show"
          ],
          "line": 5935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "t"
          ],
          "line": 5935
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&show->obj",
            "0",
            "sizeof(show->obj)"
          ],
          "line": 5933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&show->state",
            "0",
            "sizeof(show->state)"
          ],
          "line": 5932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "type_id"
          ],
          "line": 5929
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_type_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t  struct btf_show *show)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tshow->btf = btf;\n\tmemset(&show->state, 0, sizeof(show->state));\n\tmemset(&show->obj, 0, sizeof(show->obj));\n\n\tbtf_type_ops(t)->show(btf, t, type_id, obj, 0, show);\n}"
  },
  {
    "function_name": "btf_prepare_func_args",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5816-5924",
    "snippet": "int btf_prepare_func_args(struct bpf_verifier_env *env, int subprog,\n\t\t\t  struct bpf_reg_state *regs)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct bpf_prog *prog = env->prog;\n\tenum bpf_prog_type prog_type = prog->type;\n\tstruct btf *btf = prog->aux->btf;\n\tconst struct btf_param *args;\n\tconst struct btf_type *t, *ref_t;\n\tu32 i, nargs, btf_id;\n\tconst char *tname;\n\n\tif (!prog->aux->func_info ||\n\t    prog->aux->func_info_aux[subprog].linkage != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"Verifier bug\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tbtf_id = prog->aux->func_info[subprog].type_id;\n\tif (!btf_id) {\n\t\tbpf_log(log, \"Global functions need valid BTF\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tt = btf_type_by_id(btf, btf_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info\n\t\t */\n\t\tbpf_log(log, \"BTF of func#%d doesn't point to KIND_FUNC\\n\",\n\t\t\tsubprog);\n\t\treturn -EFAULT;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\n\tif (log->level & BPF_LOG_LEVEL)\n\t\tbpf_log(log, \"Validating %s() func#%d...\\n\",\n\t\t\ttname, subprog);\n\n\tif (prog->aux->func_info_aux[subprog].unreliable) {\n\t\tbpf_log(log, \"Verifier bug in function %s()\\n\", tname);\n\t\treturn -EFAULT;\n\t}\n\tif (prog_type == BPF_PROG_TYPE_EXT)\n\t\tprog_type = prog->aux->dst_prog->type;\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid type of function %s()\\n\", tname);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Global function %s() with %d > %d args. Buggy compiler.\\n\",\n\t\t\ttname, nargs, MAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\t/* check that function returns int */\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_int(t) && !btf_type_is_enum(t)) {\n\t\tbpf_log(log,\n\t\t\t\"Global function %s() doesn't return scalar. Only those are supported.\\n\",\n\t\t\ttname);\n\t\treturn -EINVAL;\n\t}\n\t/* Convert BTF function arguments into verifier types.\n\t * Only PTR_TO_CTX and SCALAR are supported atm.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tstruct bpf_reg_state *reg = &regs[i + 1];\n\n\t\tt = btf_type_by_id(btf, args[i].type);\n\t\twhile (btf_type_is_modifier(t))\n\t\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (btf_type_is_int(t) || btf_type_is_enum(t)) {\n\t\t\treg->type = SCALAR_VALUE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (btf_type_is_ptr(t)) {\n\t\t\tif (btf_get_prog_ctx_type(log, btf, t, prog_type, i)) {\n\t\t\t\treg->type = PTR_TO_CTX;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tt = btf_type_skip_modifiers(btf, t->type, NULL);\n\n\t\t\tref_t = btf_resolve_size(btf, t, &reg->mem_size);\n\t\t\tif (IS_ERR(ref_t)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t    \"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t    i, btf_type_str(t), btf_name_by_offset(btf, t->name_off),\n\t\t\t\t\tPTR_ERR(ref_t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\treg->type = PTR_TO_MEM | PTR_MAYBE_NULL;\n\t\t\treg->id = ++env->id_gen;\n\n\t\t\tcontinue;\n\t\t}\n\t\tbpf_log(log, \"Arg#%d type %s in %s() is not supported yet.\\n\",\n\t\t\ti, btf_kind_str[BTF_INFO_KIND(t->info)], tname);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};",
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"Arg#%d type %s in %s() is not supported yet.\\n\"",
            "i",
            "btf_kind_str[BTF_INFO_KIND(t->info)]",
            "tname"
          ],
          "line": 5919
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 5920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ref_t"
          ],
          "line": 5910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "btf",
            "t->name_off"
          ],
          "line": 5909
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "726-729",
          "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_str",
          "args": [
            "t"
          ],
          "line": 5909
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_str",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "289-292",
          "snippet": "const char *btf_type_str(const struct btf_type *t)\n{\n\treturn btf_kind_str[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\n\nconst char *btf_type_str(const struct btf_type *t)\n{\n\treturn btf_kind_str[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ref_t"
          ],
          "line": 5906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_resolve_size",
          "args": [
            "btf",
            "t",
            "&reg->mem_size"
          ],
          "line": 5905
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolve_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1783-1788",
          "snippet": "const struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_skip_modifiers",
          "args": [
            "btf",
            "t->type",
            "NULL"
          ],
          "line": 5903
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_skip_modifiers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "509-523",
          "snippet": "const struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_get_prog_ctx_type",
          "args": [
            "log",
            "btf",
            "t",
            "prog_type",
            "i"
          ],
          "line": 5898
        },
        "resolved": true,
        "details": {
          "function_name": "btf_get_prog_ctx_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4567-4623",
          "snippet": "static const struct btf_member *\nbtf_get_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, enum bpf_prog_type prog_type,\n\t\t      int arg)\n{\n\tconst struct btf_type *conv_struct;\n\tconst struct btf_type *ctx_struct;\n\tconst struct btf_member *ctx_type;\n\tconst char *tname, *ctx_tname;\n\n\tconv_struct = bpf_ctx_convert.t;\n\tif (!conv_struct) {\n\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");\n\t\treturn NULL;\n\t}\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_struct(t)) {\n\t\t/* Only pointer to struct is supported for now.\n\t\t * That means that BPF_PROG_TYPE_TRACEPOINT with BTF\n\t\t * is not supported yet.\n\t\t * BPF_PROG_TYPE_RAW_TRACEPOINT is fine.\n\t\t */\n\t\treturn NULL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"arg#%d struct doesn't have a name\\n\", arg);\n\t\treturn NULL;\n\t}\n\t/* prog_type is valid bpf program type. No need for bounds check. */\n\tctx_type = btf_type_member(conv_struct) + bpf_ctx_convert_map[prog_type] * 2;\n\t/* ctx_struct is a pointer to prog_ctx_type in vmlinux.\n\t * Like 'struct __sk_buff'\n\t */\n\tctx_struct = btf_type_by_id(btf_vmlinux, ctx_type->type);\n\tif (!ctx_struct)\n\t\t/* should not happen */\n\t\treturn NULL;\n\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_struct->name_off);\n\tif (!ctx_tname) {\n\t\t/* should not happen */\n\t\tbpf_log(log, \"Please fix kernel include/linux/bpf_types.h\\n\");\n\t\treturn NULL;\n\t}\n\t/* only compare that prog's ctx type name is the same as\n\t * kernel expects. No need to compare field by field.\n\t * It's ok for bpf prog to do:\n\t * struct __sk_buff {};\n\t * int socket_filter_bpf_prog(struct __sk_buff *skb)\n\t * { // no fields of skb are ever used }\n\t */\n\tif (strcmp(ctx_tname, tname))\n\t\treturn NULL;\n\treturn ctx_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct btf *btf_vmlinux;",
            "static union {\n\tstruct bpf_ctx_convert {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\tprog_ctx_type _id##_prog; \\\n\tkern_ctx_type _id##_kern;\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t} *__t;\n\t/* 't' is written once under lock. Read many times. */\n\tconst struct btf_type *t;\n} bpf_ctx_convert;",
            "static u8 bpf_ctx_convert_map[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = __ctx_convert##_id,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t0, /* avoid empty array */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nextern struct btf *btf_vmlinux;\nstatic union {\n\tstruct bpf_ctx_convert {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\tprog_ctx_type _id##_prog; \\\n\tkern_ctx_type _id##_kern;\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t} *__t;\n\t/* 't' is written once under lock. Read many times. */\n\tconst struct btf_type *t;\n} bpf_ctx_convert;\nstatic u8 bpf_ctx_convert_map[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = __ctx_convert##_id,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t0, /* avoid empty array */\n};\n\nstatic const struct btf_member *\nbtf_get_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, enum bpf_prog_type prog_type,\n\t\t      int arg)\n{\n\tconst struct btf_type *conv_struct;\n\tconst struct btf_type *ctx_struct;\n\tconst struct btf_member *ctx_type;\n\tconst char *tname, *ctx_tname;\n\n\tconv_struct = bpf_ctx_convert.t;\n\tif (!conv_struct) {\n\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");\n\t\treturn NULL;\n\t}\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_struct(t)) {\n\t\t/* Only pointer to struct is supported for now.\n\t\t * That means that BPF_PROG_TYPE_TRACEPOINT with BTF\n\t\t * is not supported yet.\n\t\t * BPF_PROG_TYPE_RAW_TRACEPOINT is fine.\n\t\t */\n\t\treturn NULL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"arg#%d struct doesn't have a name\\n\", arg);\n\t\treturn NULL;\n\t}\n\t/* prog_type is valid bpf program type. No need for bounds check. */\n\tctx_type = btf_type_member(conv_struct) + bpf_ctx_convert_map[prog_type] * 2;\n\t/* ctx_struct is a pointer to prog_ctx_type in vmlinux.\n\t * Like 'struct __sk_buff'\n\t */\n\tctx_struct = btf_type_by_id(btf_vmlinux, ctx_type->type);\n\tif (!ctx_struct)\n\t\t/* should not happen */\n\t\treturn NULL;\n\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_struct->name_off);\n\tif (!ctx_tname) {\n\t\t/* should not happen */\n\t\tbpf_log(log, \"Please fix kernel include/linux/bpf_types.h\\n\");\n\t\treturn NULL;\n\t}\n\t/* only compare that prog's ctx type name is the same as\n\t * kernel expects. No need to compare field by field.\n\t * It's ok for bpf prog to do:\n\t * struct __sk_buff {};\n\t * int socket_filter_bpf_prog(struct __sk_buff *skb)\n\t * { // no fields of skb are ever used }\n\t */\n\tif (strcmp(ctx_tname, tname))\n\t\treturn NULL;\n\treturn ctx_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t"
          ],
          "line": 5897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_enum",
          "args": [
            "t"
          ],
          "line": 5893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_int",
          "args": [
            "t"
          ],
          "line": 5893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "t->type"
          ],
          "line": 5892
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "t"
          ],
          "line": 5891
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_enum",
          "args": [
            "t"
          ],
          "line": 5878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_int",
          "args": [
            "t"
          ],
          "line": 5878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 5868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_func_proto",
          "args": [
            "t"
          ],
          "line": 5863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_func",
          "args": [
            "t"
          ],
          "line": 5841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_prepare_func_args(struct bpf_verifier_env *env, int subprog,\n\t\t\t  struct bpf_reg_state *regs)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct bpf_prog *prog = env->prog;\n\tenum bpf_prog_type prog_type = prog->type;\n\tstruct btf *btf = prog->aux->btf;\n\tconst struct btf_param *args;\n\tconst struct btf_type *t, *ref_t;\n\tu32 i, nargs, btf_id;\n\tconst char *tname;\n\n\tif (!prog->aux->func_info ||\n\t    prog->aux->func_info_aux[subprog].linkage != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"Verifier bug\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tbtf_id = prog->aux->func_info[subprog].type_id;\n\tif (!btf_id) {\n\t\tbpf_log(log, \"Global functions need valid BTF\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tt = btf_type_by_id(btf, btf_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info\n\t\t */\n\t\tbpf_log(log, \"BTF of func#%d doesn't point to KIND_FUNC\\n\",\n\t\t\tsubprog);\n\t\treturn -EFAULT;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\n\tif (log->level & BPF_LOG_LEVEL)\n\t\tbpf_log(log, \"Validating %s() func#%d...\\n\",\n\t\t\ttname, subprog);\n\n\tif (prog->aux->func_info_aux[subprog].unreliable) {\n\t\tbpf_log(log, \"Verifier bug in function %s()\\n\", tname);\n\t\treturn -EFAULT;\n\t}\n\tif (prog_type == BPF_PROG_TYPE_EXT)\n\t\tprog_type = prog->aux->dst_prog->type;\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid type of function %s()\\n\", tname);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Global function %s() with %d > %d args. Buggy compiler.\\n\",\n\t\t\ttname, nargs, MAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\t/* check that function returns int */\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_int(t) && !btf_type_is_enum(t)) {\n\t\tbpf_log(log,\n\t\t\t\"Global function %s() doesn't return scalar. Only those are supported.\\n\",\n\t\t\ttname);\n\t\treturn -EINVAL;\n\t}\n\t/* Convert BTF function arguments into verifier types.\n\t * Only PTR_TO_CTX and SCALAR are supported atm.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tstruct bpf_reg_state *reg = &regs[i + 1];\n\n\t\tt = btf_type_by_id(btf, args[i].type);\n\t\twhile (btf_type_is_modifier(t))\n\t\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (btf_type_is_int(t) || btf_type_is_enum(t)) {\n\t\t\treg->type = SCALAR_VALUE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (btf_type_is_ptr(t)) {\n\t\t\tif (btf_get_prog_ctx_type(log, btf, t, prog_type, i)) {\n\t\t\t\treg->type = PTR_TO_CTX;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tt = btf_type_skip_modifiers(btf, t->type, NULL);\n\n\t\t\tref_t = btf_resolve_size(btf, t, &reg->mem_size);\n\t\t\tif (IS_ERR(ref_t)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t    \"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t    i, btf_type_str(t), btf_name_by_offset(btf, t->name_off),\n\t\t\t\t\tPTR_ERR(ref_t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\treg->type = PTR_TO_MEM | PTR_MAYBE_NULL;\n\t\t\treg->id = ++env->id_gen;\n\n\t\t\tcontinue;\n\t\t}\n\t\tbpf_log(log, \"Arg#%d type %s in %s() is not supported yet.\\n\",\n\t\t\ti, btf_kind_str[BTF_INFO_KIND(t->info)], tname);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_check_kfunc_arg_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5802-5807",
    "snippet": "int btf_check_kfunc_arg_match(struct bpf_verifier_env *env,\n\t\t\t      const struct btf *btf, u32 func_id,\n\t\t\t      struct bpf_reg_state *regs)\n{\n\treturn btf_check_func_arg_match(env, btf, func_id, regs, true);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_check_func_arg_match",
          "args": [
            "env",
            "btf",
            "func_id",
            "regs",
            "true"
          ],
          "line": 5806
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_func_arg_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5619-5762",
          "snippet": "static int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ptr_off_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolve_ret = btf_resolve_size(btf, ref_t, &type_size);\n\t\t\tif (IS_ERR(resolve_ret)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t\ti, btf_type_str(ref_t), ref_tname,\n\t\t\t\t\tPTR_ERR(resolve_ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (check_mem_reg(env, reg, regno, type_size))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tbpf_log(log, \"reg type unsupported for arg#%d %sfunction %s#%d\\n\", i,\n\t\t\t\tis_kfunc ? \"kernel \" : \"\", func_name, func_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct btf *btf_vmlinux;",
            "static u32 *reg2btf_ids[__BPF_REG_TYPE_MAX] = {\n#ifdef CONFIG_NET\n\t[PTR_TO_SOCKET] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK],\n\t[PTR_TO_SOCK_COMMON] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK_COMMON],\n\t[PTR_TO_TCP_SOCK] = &btf_sock_ids[BTF_SOCK_TYPE_TCP],\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nextern struct btf *btf_vmlinux;\nstatic u32 *reg2btf_ids[__BPF_REG_TYPE_MAX] = {\n#ifdef CONFIG_NET\n\t[PTR_TO_SOCKET] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK],\n\t[PTR_TO_SOCK_COMMON] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK_COMMON],\n\t[PTR_TO_TCP_SOCK] = &btf_sock_ids[BTF_SOCK_TYPE_TCP],\n#endif\n};\n\nstatic int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ptr_off_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolve_ret = btf_resolve_size(btf, ref_t, &type_size);\n\t\t\tif (IS_ERR(resolve_ret)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t\ti, btf_type_str(ref_t), ref_tname,\n\t\t\t\t\tPTR_ERR(resolve_ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (check_mem_reg(env, reg, regno, type_size))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tbpf_log(log, \"reg type unsupported for arg#%d %sfunction %s#%d\\n\", i,\n\t\t\t\tis_kfunc ? \"kernel \" : \"\", func_name, func_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_check_kfunc_arg_match(struct bpf_verifier_env *env,\n\t\t\t      const struct btf *btf, u32 func_id,\n\t\t\t      struct bpf_reg_state *regs)\n{\n\treturn btf_check_func_arg_match(env, btf, func_id, regs, true);\n}"
  },
  {
    "function_name": "btf_check_subprog_arg_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5771-5800",
    "snippet": "int btf_check_subprog_arg_match(struct bpf_verifier_env *env, int subprog,\n\t\t\t\tstruct bpf_reg_state *regs)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tstruct btf *btf = prog->aux->btf;\n\tbool is_global;\n\tu32 btf_id;\n\tint err;\n\n\tif (!prog->aux->func_info)\n\t\treturn -EINVAL;\n\n\tbtf_id = prog->aux->func_info[subprog].type_id;\n\tif (!btf_id)\n\t\treturn -EFAULT;\n\n\tif (prog->aux->func_info_aux[subprog].unreliable)\n\t\treturn -EINVAL;\n\n\tis_global = prog->aux->func_info_aux[subprog].linkage == BTF_FUNC_GLOBAL;\n\terr = btf_check_func_arg_match(env, btf, btf_id, regs, is_global);\n\n\t/* Compiler optimizations can remove arguments from static functions\n\t * or mismatched type can be passed into a global function.\n\t * In such cases mark the function as unreliable from BTF point of view.\n\t */\n\tif (err)\n\t\tprog->aux->func_info_aux[subprog].unreliable = true;\n\treturn err;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_check_func_arg_match",
          "args": [
            "env",
            "btf",
            "btf_id",
            "regs",
            "is_global"
          ],
          "line": 5791
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_func_arg_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5619-5762",
          "snippet": "static int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ptr_off_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolve_ret = btf_resolve_size(btf, ref_t, &type_size);\n\t\t\tif (IS_ERR(resolve_ret)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t\ti, btf_type_str(ref_t), ref_tname,\n\t\t\t\t\tPTR_ERR(resolve_ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (check_mem_reg(env, reg, regno, type_size))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tbpf_log(log, \"reg type unsupported for arg#%d %sfunction %s#%d\\n\", i,\n\t\t\t\tis_kfunc ? \"kernel \" : \"\", func_name, func_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct btf *btf_vmlinux;",
            "static u32 *reg2btf_ids[__BPF_REG_TYPE_MAX] = {\n#ifdef CONFIG_NET\n\t[PTR_TO_SOCKET] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK],\n\t[PTR_TO_SOCK_COMMON] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK_COMMON],\n\t[PTR_TO_TCP_SOCK] = &btf_sock_ids[BTF_SOCK_TYPE_TCP],\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nextern struct btf *btf_vmlinux;\nstatic u32 *reg2btf_ids[__BPF_REG_TYPE_MAX] = {\n#ifdef CONFIG_NET\n\t[PTR_TO_SOCKET] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK],\n\t[PTR_TO_SOCK_COMMON] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK_COMMON],\n\t[PTR_TO_TCP_SOCK] = &btf_sock_ids[BTF_SOCK_TYPE_TCP],\n#endif\n};\n\nstatic int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ptr_off_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolve_ret = btf_resolve_size(btf, ref_t, &type_size);\n\t\t\tif (IS_ERR(resolve_ret)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t\ti, btf_type_str(ref_t), ref_tname,\n\t\t\t\t\tPTR_ERR(resolve_ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (check_mem_reg(env, reg, regno, type_size))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tbpf_log(log, \"reg type unsupported for arg#%d %sfunction %s#%d\\n\", i,\n\t\t\t\tis_kfunc ? \"kernel \" : \"\", func_name, func_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_check_subprog_arg_match(struct bpf_verifier_env *env, int subprog,\n\t\t\t\tstruct bpf_reg_state *regs)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tstruct btf *btf = prog->aux->btf;\n\tbool is_global;\n\tu32 btf_id;\n\tint err;\n\n\tif (!prog->aux->func_info)\n\t\treturn -EINVAL;\n\n\tbtf_id = prog->aux->func_info[subprog].type_id;\n\tif (!btf_id)\n\t\treturn -EFAULT;\n\n\tif (prog->aux->func_info_aux[subprog].unreliable)\n\t\treturn -EINVAL;\n\n\tis_global = prog->aux->func_info_aux[subprog].linkage == BTF_FUNC_GLOBAL;\n\terr = btf_check_func_arg_match(env, btf, btf_id, regs, is_global);\n\n\t/* Compiler optimizations can remove arguments from static functions\n\t * or mismatched type can be passed into a global function.\n\t * In such cases mark the function as unreliable from BTF point of view.\n\t */\n\tif (err)\n\t\tprog->aux->func_info_aux[subprog].unreliable = true;\n\treturn err;\n}"
  },
  {
    "function_name": "btf_check_func_arg_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5619-5762",
    "snippet": "static int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ptr_off_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolve_ret = btf_resolve_size(btf, ref_t, &type_size);\n\t\t\tif (IS_ERR(resolve_ret)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t\ti, btf_type_str(ref_t), ref_tname,\n\t\t\t\t\tPTR_ERR(resolve_ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (check_mem_reg(env, reg, regno, type_size))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tbpf_log(log, \"reg type unsupported for arg#%d %sfunction %s#%d\\n\", i,\n\t\t\t\tis_kfunc ? \"kernel \" : \"\", func_name, func_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct btf *btf_vmlinux;",
      "static u32 *reg2btf_ids[__BPF_REG_TYPE_MAX] = {\n#ifdef CONFIG_NET\n\t[PTR_TO_SOCKET] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK],\n\t[PTR_TO_SOCK_COMMON] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK_COMMON],\n\t[PTR_TO_TCP_SOCK] = &btf_sock_ids[BTF_SOCK_TYPE_TCP],\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"reg type unsupported for arg#%d %sfunction %s#%d\\n\"",
            "i",
            "is_kfunc ? \"kernel \" : \"\"",
            "func_name",
            "func_id"
          ],
          "line": 5755
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_mem_reg",
          "args": [
            "env",
            "reg",
            "regno",
            "type_size"
          ],
          "line": 5752
        },
        "resolved": true,
        "details": {
          "function_name": "check_mem_reg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "4880-4901",
          "snippet": "int check_mem_reg(struct bpf_verifier_env *env, struct bpf_reg_state *reg,\n\t\t   u32 regno, u32 mem_size)\n{\n\tif (register_is_null(reg))\n\t\treturn 0;\n\n\tif (type_may_be_null(reg->type)) {\n\t\t/* Assuming that the register contains a value check if the memory\n\t\t * access is safe. Temporarily save and restore the register's state as\n\t\t * the conversion shouldn't be visible to a caller.\n\t\t */\n\t\tconst struct bpf_reg_state saved_reg = *reg;\n\t\tint rv;\n\n\t\tmark_ptr_not_null_reg(reg);\n\t\trv = check_helper_mem_access(env, regno, mem_size, true, NULL);\n\t\t*reg = saved_reg;\n\t\treturn rv;\n\t}\n\n\treturn check_helper_mem_access(env, regno, mem_size, true, NULL);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nint check_mem_reg(struct bpf_verifier_env *env, struct bpf_reg_state *reg,\n\t\t   u32 regno, u32 mem_size)\n{\n\tif (register_is_null(reg))\n\t\treturn 0;\n\n\tif (type_may_be_null(reg->type)) {\n\t\t/* Assuming that the register contains a value check if the memory\n\t\t * access is safe. Temporarily save and restore the register's state as\n\t\t * the conversion shouldn't be visible to a caller.\n\t\t */\n\t\tconst struct bpf_reg_state saved_reg = *reg;\n\t\tint rv;\n\n\t\tmark_ptr_not_null_reg(reg);\n\t\trv = check_helper_mem_access(env, regno, mem_size, true, NULL);\n\t\t*reg = saved_reg;\n\t\treturn rv;\n\t}\n\n\treturn check_helper_mem_access(env, regno, mem_size, true, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "resolve_ret"
          ],
          "line": 5748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_str",
          "args": [
            "ref_t"
          ],
          "line": 5747
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_str",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "289-292",
          "snippet": "const char *btf_type_str(const struct btf_type *t)\n{\n\treturn btf_kind_str[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\n\nconst char *btf_type_str(const struct btf_type *t)\n{\n\treturn btf_kind_str[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "resolve_ret"
          ],
          "line": 5744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_resolve_size",
          "args": [
            "btf",
            "ref_t",
            "&type_size"
          ],
          "line": 5743
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolve_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1783-1788",
          "snippet": "const struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_type_is_scalar_struct",
          "args": [
            "log",
            "btf",
            "ref_t",
            "0"
          ],
          "line": 5735
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_scalar_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5580-5617",
          "snippet": "static bool __btf_type_is_scalar_struct(struct bpf_verifier_log *log,\n\t\t\t\t\tconst struct btf *btf,\n\t\t\t\t\tconst struct btf_type *t, int rec)\n{\n\tconst struct btf_type *member_type;\n\tconst struct btf_member *member;\n\tu32 i;\n\n\tif (!btf_type_is_struct(t))\n\t\treturn false;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_array *array;\n\n\t\tmember_type = btf_type_skip_modifiers(btf, member->type, NULL);\n\t\tif (btf_type_is_struct(member_type)) {\n\t\t\tif (rec >= 3) {\n\t\t\t\tbpf_log(log, \"max struct nesting depth exceeded\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!__btf_type_is_scalar_struct(log, btf, member_type, rec + 1))\n\t\t\t\treturn false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (btf_type_is_array(member_type)) {\n\t\t\tarray = btf_type_array(member_type);\n\t\t\tif (!array->nelems)\n\t\t\t\treturn false;\n\t\t\tmember_type = btf_type_skip_modifiers(btf, array->type, NULL);\n\t\t\tif (!btf_type_is_scalar(member_type))\n\t\t\t\treturn false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!btf_type_is_scalar(member_type))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_scalar_struct(struct bpf_verifier_log *log,\n\t\t\t\t\tconst struct btf *btf,\n\t\t\t\t\tconst struct btf_type *t, int rec)\n{\n\tconst struct btf_type *member_type;\n\tconst struct btf_member *member;\n\tu32 i;\n\n\tif (!btf_type_is_struct(t))\n\t\treturn false;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_array *array;\n\n\t\tmember_type = btf_type_skip_modifiers(btf, member->type, NULL);\n\t\tif (btf_type_is_struct(member_type)) {\n\t\t\tif (rec >= 3) {\n\t\t\t\tbpf_log(log, \"max struct nesting depth exceeded\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!__btf_type_is_scalar_struct(log, btf, member_type, rec + 1))\n\t\t\t\treturn false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (btf_type_is_array(member_type)) {\n\t\t\tarray = btf_type_array(member_type);\n\t\t\tif (!array->nelems)\n\t\t\t\treturn false;\n\t\t\tmember_type = btf_type_skip_modifiers(btf, array->type, NULL);\n\t\t\tif (!btf_type_is_scalar(member_type))\n\t\t\t\treturn false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!btf_type_is_scalar(member_type))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_scalar",
          "args": [
            "ref_t"
          ],
          "line": 5734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_struct_ids_match",
          "args": [
            "log",
            "reg_btf",
            "reg_ref_id",
            "reg->off",
            "btf",
            "ref_id"
          ],
          "line": 5716
        },
        "resolved": true,
        "details": {
          "function_name": "btf_struct_ids_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5309-5339",
          "snippet": "bool btf_struct_ids_match(struct bpf_verifier_log *log,\n\t\t\t  const struct btf *btf, u32 id, int off,\n\t\t\t  const struct btf *need_btf, u32 need_type_id)\n{\n\tconst struct btf_type *type;\n\tint err;\n\n\t/* Are we already done? */\n\tif (off == 0 && btf_types_are_same(btf, id, need_btf, need_type_id))\n\t\treturn true;\n\nagain:\n\ttype = btf_type_by_id(btf, id);\n\tif (!type)\n\t\treturn false;\n\terr = btf_struct_walk(log, btf, type, off, 1, &id);\n\tif (err != WALK_STRUCT)\n\t\treturn false;\n\n\t/* We found nested struct object. If it matches\n\t * the requested ID, we're done. Otherwise let's\n\t * continue the search with offset 0 in the new\n\t * type.\n\t */\n\tif (!btf_types_are_same(btf, id, need_btf, need_type_id)) {\n\t\toff = 0;\n\t\tgoto again;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_struct_ids_match(struct bpf_verifier_log *log,\n\t\t\t  const struct btf *btf, u32 id, int off,\n\t\t\t  const struct btf *need_btf, u32 need_type_id)\n{\n\tconst struct btf_type *type;\n\tint err;\n\n\t/* Are we already done? */\n\tif (off == 0 && btf_types_are_same(btf, id, need_btf, need_type_id))\n\t\treturn true;\n\nagain:\n\ttype = btf_type_by_id(btf, id);\n\tif (!type)\n\t\treturn false;\n\terr = btf_struct_walk(log, btf, type, off, 1, &id);\n\tif (err != WALK_STRUCT)\n\t\treturn false;\n\n\t/* We found nested struct object. If it matches\n\t * the requested ID, we're done. Otherwise let's\n\t * continue the search with offset 0 in the new\n\t * type.\n\t */\n\tif (!btf_types_are_same(btf, id, need_btf, need_type_id)) {\n\t\toff = 0;\n\t\tgoto again;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "reg_btf",
            "reg_ref_t->name_off"
          ],
          "line": 5714
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "726-729",
          "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_skip_modifiers",
          "args": [
            "reg_btf",
            "reg_ref_id",
            "&reg_ref_id"
          ],
          "line": 5712
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_skip_modifiers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "509-523",
          "snippet": "const struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "ref_t"
          ],
          "line": 5697
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_ptr_off_reg",
          "args": [
            "env",
            "reg",
            "regno"
          ],
          "line": 5689
        },
        "resolved": true,
        "details": {
          "function_name": "check_ptr_off_reg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "4000-4004",
          "snippet": "int check_ptr_off_reg(struct bpf_verifier_env *env,\n\t\t      const struct bpf_reg_state *reg, int regno)\n{\n\treturn __check_ptr_off_reg(env, reg, regno, false);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nint check_ptr_off_reg(struct bpf_verifier_env *env,\n\t\t      const struct bpf_reg_state *reg, int regno)\n{\n\treturn __check_ptr_off_reg(env, reg, regno, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_get_prog_ctx_type",
          "args": [
            "log",
            "btf",
            "t",
            "env->prog->type",
            "i"
          ],
          "line": 5678
        },
        "resolved": true,
        "details": {
          "function_name": "btf_get_prog_ctx_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4567-4623",
          "snippet": "static const struct btf_member *\nbtf_get_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, enum bpf_prog_type prog_type,\n\t\t      int arg)\n{\n\tconst struct btf_type *conv_struct;\n\tconst struct btf_type *ctx_struct;\n\tconst struct btf_member *ctx_type;\n\tconst char *tname, *ctx_tname;\n\n\tconv_struct = bpf_ctx_convert.t;\n\tif (!conv_struct) {\n\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");\n\t\treturn NULL;\n\t}\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_struct(t)) {\n\t\t/* Only pointer to struct is supported for now.\n\t\t * That means that BPF_PROG_TYPE_TRACEPOINT with BTF\n\t\t * is not supported yet.\n\t\t * BPF_PROG_TYPE_RAW_TRACEPOINT is fine.\n\t\t */\n\t\treturn NULL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"arg#%d struct doesn't have a name\\n\", arg);\n\t\treturn NULL;\n\t}\n\t/* prog_type is valid bpf program type. No need for bounds check. */\n\tctx_type = btf_type_member(conv_struct) + bpf_ctx_convert_map[prog_type] * 2;\n\t/* ctx_struct is a pointer to prog_ctx_type in vmlinux.\n\t * Like 'struct __sk_buff'\n\t */\n\tctx_struct = btf_type_by_id(btf_vmlinux, ctx_type->type);\n\tif (!ctx_struct)\n\t\t/* should not happen */\n\t\treturn NULL;\n\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_struct->name_off);\n\tif (!ctx_tname) {\n\t\t/* should not happen */\n\t\tbpf_log(log, \"Please fix kernel include/linux/bpf_types.h\\n\");\n\t\treturn NULL;\n\t}\n\t/* only compare that prog's ctx type name is the same as\n\t * kernel expects. No need to compare field by field.\n\t * It's ok for bpf prog to do:\n\t * struct __sk_buff {};\n\t * int socket_filter_bpf_prog(struct __sk_buff *skb)\n\t * { // no fields of skb are ever used }\n\t */\n\tif (strcmp(ctx_tname, tname))\n\t\treturn NULL;\n\treturn ctx_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct btf *btf_vmlinux;",
            "static union {\n\tstruct bpf_ctx_convert {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\tprog_ctx_type _id##_prog; \\\n\tkern_ctx_type _id##_kern;\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t} *__t;\n\t/* 't' is written once under lock. Read many times. */\n\tconst struct btf_type *t;\n} bpf_ctx_convert;",
            "static u8 bpf_ctx_convert_map[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = __ctx_convert##_id,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t0, /* avoid empty array */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nextern struct btf *btf_vmlinux;\nstatic union {\n\tstruct bpf_ctx_convert {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\tprog_ctx_type _id##_prog; \\\n\tkern_ctx_type _id##_kern;\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t} *__t;\n\t/* 't' is written once under lock. Read many times. */\n\tconst struct btf_type *t;\n} bpf_ctx_convert;\nstatic u8 bpf_ctx_convert_map[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = __ctx_convert##_id,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t0, /* avoid empty array */\n};\n\nstatic const struct btf_member *\nbtf_get_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, enum bpf_prog_type prog_type,\n\t\t      int arg)\n{\n\tconst struct btf_type *conv_struct;\n\tconst struct btf_type *ctx_struct;\n\tconst struct btf_member *ctx_type;\n\tconst char *tname, *ctx_tname;\n\n\tconv_struct = bpf_ctx_convert.t;\n\tif (!conv_struct) {\n\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");\n\t\treturn NULL;\n\t}\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_struct(t)) {\n\t\t/* Only pointer to struct is supported for now.\n\t\t * That means that BPF_PROG_TYPE_TRACEPOINT with BTF\n\t\t * is not supported yet.\n\t\t * BPF_PROG_TYPE_RAW_TRACEPOINT is fine.\n\t\t */\n\t\treturn NULL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"arg#%d struct doesn't have a name\\n\", arg);\n\t\treturn NULL;\n\t}\n\t/* prog_type is valid bpf program type. No need for bounds check. */\n\tctx_type = btf_type_member(conv_struct) + bpf_ctx_convert_map[prog_type] * 2;\n\t/* ctx_struct is a pointer to prog_ctx_type in vmlinux.\n\t * Like 'struct __sk_buff'\n\t */\n\tctx_struct = btf_type_by_id(btf_vmlinux, ctx_type->type);\n\tif (!ctx_struct)\n\t\t/* should not happen */\n\t\treturn NULL;\n\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_struct->name_off);\n\tif (!ctx_tname) {\n\t\t/* should not happen */\n\t\tbpf_log(log, \"Please fix kernel include/linux/bpf_types.h\\n\");\n\t\treturn NULL;\n\t}\n\t/* only compare that prog's ctx type name is the same as\n\t * kernel expects. No need to compare field by field.\n\t * It's ok for bpf prog to do:\n\t * struct __sk_buff {};\n\t * int socket_filter_bpf_prog(struct __sk_buff *skb)\n\t * { // no fields of skb are ever used }\n\t */\n\tif (strcmp(ctx_tname, tname))\n\t\treturn NULL;\n\treturn ctx_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t"
          ],
          "line": 5670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_scalar",
          "args": [
            "t"
          ],
          "line": 5663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 5648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_func_proto",
          "args": [
            "t"
          ],
          "line": 5643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "t->type"
          ],
          "line": 5642
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_func",
          "args": [
            "t"
          ],
          "line": 5632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_is_kernel",
          "args": [
            "btf"
          ],
          "line": 5625
        },
        "resolved": true,
        "details": {
          "function_name": "btf_is_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6181-6184",
          "snippet": "bool btf_is_kernel(const struct btf *btf)\n{\n\treturn btf->kernel_btf;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_is_kernel(const struct btf *btf)\n{\n\treturn btf->kernel_btf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nextern struct btf *btf_vmlinux;\nstatic u32 *reg2btf_ids[__BPF_REG_TYPE_MAX] = {\n#ifdef CONFIG_NET\n\t[PTR_TO_SOCKET] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK],\n\t[PTR_TO_SOCK_COMMON] = &btf_sock_ids[BTF_SOCK_TYPE_SOCK_COMMON],\n\t[PTR_TO_TCP_SOCK] = &btf_sock_ids[BTF_SOCK_TYPE_TCP],\n#endif\n};\n\nstatic int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ptr_off_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolve_ret = btf_resolve_size(btf, ref_t, &type_size);\n\t\t\tif (IS_ERR(resolve_ret)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t\ti, btf_type_str(ref_t), ref_tname,\n\t\t\t\t\tPTR_ERR(resolve_ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (check_mem_reg(env, reg, regno, type_size))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tbpf_log(log, \"reg type unsupported for arg#%d %sfunction %s#%d\\n\", i,\n\t\t\t\tis_kfunc ? \"kernel \" : \"\", func_name, func_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__btf_type_is_scalar_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5580-5617",
    "snippet": "static bool __btf_type_is_scalar_struct(struct bpf_verifier_log *log,\n\t\t\t\t\tconst struct btf *btf,\n\t\t\t\t\tconst struct btf_type *t, int rec)\n{\n\tconst struct btf_type *member_type;\n\tconst struct btf_member *member;\n\tu32 i;\n\n\tif (!btf_type_is_struct(t))\n\t\treturn false;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_array *array;\n\n\t\tmember_type = btf_type_skip_modifiers(btf, member->type, NULL);\n\t\tif (btf_type_is_struct(member_type)) {\n\t\t\tif (rec >= 3) {\n\t\t\t\tbpf_log(log, \"max struct nesting depth exceeded\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!__btf_type_is_scalar_struct(log, btf, member_type, rec + 1))\n\t\t\t\treturn false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (btf_type_is_array(member_type)) {\n\t\t\tarray = btf_type_array(member_type);\n\t\t\tif (!array->nelems)\n\t\t\t\treturn false;\n\t\t\tmember_type = btf_type_skip_modifiers(btf, array->type, NULL);\n\t\t\tif (!btf_type_is_scalar(member_type))\n\t\t\t\treturn false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!btf_type_is_scalar(member_type))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_scalar",
          "args": [
            "member_type"
          ],
          "line": 5613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_scalar",
          "args": [
            "member_type"
          ],
          "line": 5609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_skip_modifiers",
          "args": [
            "btf",
            "array->type",
            "NULL"
          ],
          "line": 5608
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_skip_modifiers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "509-523",
          "snippet": "const struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "member_type"
          ],
          "line": 5605
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "621-624",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "member_type"
          ],
          "line": 5604
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "456-459",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_type_is_scalar_struct",
          "args": [
            "log",
            "btf",
            "member_type",
            "rec + 1"
          ],
          "line": 5600
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_scalar_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5580-5617",
          "snippet": "static bool __btf_type_is_scalar_struct(struct bpf_verifier_log *log,\n\t\t\t\t\tconst struct btf *btf,\n\t\t\t\t\tconst struct btf_type *t, int rec)\n{\n\tconst struct btf_type *member_type;\n\tconst struct btf_member *member;\n\tu32 i;\n\n\tif (!btf_type_is_struct(t))\n\t\treturn false;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_array *array;\n\n\t\tmember_type = btf_type_skip_modifiers(btf, member->type, NULL);\n\t\tif (btf_type_is_struct(member_type)) {\n\t\t\tif (rec >= 3) {\n\t\t\t\tbpf_log(log, \"max struct nesting depth exceeded\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!__btf_type_is_scalar_struct(log, btf, member_type, rec + 1))\n\t\t\t\treturn false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (btf_type_is_array(member_type)) {\n\t\t\tarray = btf_type_array(member_type);\n\t\t\tif (!array->nelems)\n\t\t\t\treturn false;\n\t\t\tmember_type = btf_type_skip_modifiers(btf, array->type, NULL);\n\t\t\tif (!btf_type_is_scalar(member_type))\n\t\t\t\treturn false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!btf_type_is_scalar(member_type))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"max struct nesting depth exceeded\\n\""
          ],
          "line": 5597
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "member_type"
          ],
          "line": 5595
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_member",
          "args": [
            "i",
            "t",
            "member"
          ],
          "line": 5591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_scalar_struct(struct bpf_verifier_log *log,\n\t\t\t\t\tconst struct btf *btf,\n\t\t\t\t\tconst struct btf_type *t, int rec)\n{\n\tconst struct btf_type *member_type;\n\tconst struct btf_member *member;\n\tu32 i;\n\n\tif (!btf_type_is_struct(t))\n\t\treturn false;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_array *array;\n\n\t\tmember_type = btf_type_skip_modifiers(btf, member->type, NULL);\n\t\tif (btf_type_is_struct(member_type)) {\n\t\t\tif (rec >= 3) {\n\t\t\t\tbpf_log(log, \"max struct nesting depth exceeded\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!__btf_type_is_scalar_struct(log, btf, member_type, rec + 1))\n\t\t\t\treturn false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (btf_type_is_array(member_type)) {\n\t\t\tarray = btf_type_array(member_type);\n\t\t\tif (!array->nelems)\n\t\t\t\treturn false;\n\t\t\tmember_type = btf_type_skip_modifiers(btf, array->type, NULL);\n\t\t\tif (!btf_type_is_scalar(member_type))\n\t\t\t\treturn false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!btf_type_is_scalar(member_type))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "btf_check_type_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5548-5569",
    "snippet": "int btf_check_type_match(struct bpf_verifier_log *log, const struct bpf_prog *prog,\n\t\t\t struct btf *btf2, const struct btf_type *t2)\n{\n\tstruct btf *btf1 = prog->aux->btf;\n\tconst struct btf_type *t1;\n\tu32 btf_id = 0;\n\n\tif (!prog->aux->func_info) {\n\t\tbpf_log(log, \"Program extension requires BTF\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_id = prog->aux->func_info[0].type_id;\n\tif (!btf_id)\n\t\treturn -EFAULT;\n\n\tt1 = btf_type_by_id(btf1, btf_id);\n\tif (!t1 || !btf_type_is_func(t1))\n\t\treturn -EFAULT;\n\n\treturn btf_check_func_type_match(log, btf1, t1, btf2, t2);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_check_func_type_match",
          "args": [
            "log",
            "btf1",
            "t1",
            "btf2",
            "t2"
          ],
          "line": 5568
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_func_type_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5437-5545",
          "snippet": "static int btf_check_func_type_match(struct bpf_verifier_log *log,\n\t\t\t\t     struct btf *btf1, const struct btf_type *t1,\n\t\t\t\t     struct btf *btf2, const struct btf_type *t2)\n{\n\tconst struct btf_param *args1, *args2;\n\tconst char *fn1, *fn2, *s1, *s2;\n\tu32 nargs1, nargs2, i;\n\n\tfn1 = btf_name_by_offset(btf1, t1->name_off);\n\tfn2 = btf_name_by_offset(btf2, t2->name_off);\n\n\tif (btf_func_linkage(t1) != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"%s() is not a global function\\n\", fn1);\n\t\treturn -EINVAL;\n\t}\n\tif (btf_func_linkage(t2) != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"%s() is not a global function\\n\", fn2);\n\t\treturn -EINVAL;\n\t}\n\n\tt1 = btf_type_by_id(btf1, t1->type);\n\tif (!t1 || !btf_type_is_func_proto(t1))\n\t\treturn -EFAULT;\n\tt2 = btf_type_by_id(btf2, t2->type);\n\tif (!t2 || !btf_type_is_func_proto(t2))\n\t\treturn -EFAULT;\n\n\targs1 = (const struct btf_param *)(t1 + 1);\n\tnargs1 = btf_type_vlen(t1);\n\targs2 = (const struct btf_param *)(t2 + 1);\n\tnargs2 = btf_type_vlen(t2);\n\n\tif (nargs1 != nargs2) {\n\t\tbpf_log(log, \"%s() has %d args while %s() has %d args\\n\",\n\t\t\tfn1, nargs1, fn2, nargs2);\n\t\treturn -EINVAL;\n\t}\n\n\tt1 = btf_type_skip_modifiers(btf1, t1->type, NULL);\n\tt2 = btf_type_skip_modifiers(btf2, t2->type, NULL);\n\tif (t1->info != t2->info) {\n\t\tbpf_log(log,\n\t\t\t\"Return type %s of %s() doesn't match type %s of %s()\\n\",\n\t\t\tbtf_type_str(t1), fn1,\n\t\t\tbtf_type_str(t2), fn2);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nargs1; i++) {\n\t\tt1 = btf_type_skip_modifiers(btf1, args1[i].type, NULL);\n\t\tt2 = btf_type_skip_modifiers(btf2, args2[i].type, NULL);\n\n\t\tif (t1->info != t2->info) {\n\t\t\tbpf_log(log, \"arg%d in %s() is %s while %s() has %s\\n\",\n\t\t\t\ti, fn1, btf_type_str(t1),\n\t\t\t\tfn2, btf_type_str(t2));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (btf_type_has_size(t1) && t1->size != t2->size) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() has size %d while %s() has %d\\n\",\n\t\t\t\ti, fn1, t1->size,\n\t\t\t\tfn2, t2->size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* global functions are validated with scalars and pointers\n\t\t * to context only. And only global functions can be replaced.\n\t\t * Hence type check only those types.\n\t\t */\n\t\tif (btf_type_is_int(t1) || btf_type_is_enum(t1))\n\t\t\tcontinue;\n\t\tif (!btf_type_is_ptr(t1)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() has unrecognized type\\n\",\n\t\t\t\ti, fn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tt1 = btf_type_skip_modifiers(btf1, t1->type, NULL);\n\t\tt2 = btf_type_skip_modifiers(btf2, t2->type, NULL);\n\t\tif (!btf_type_is_struct(t1)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() is not a pointer to context\\n\",\n\t\t\t\ti, fn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!btf_type_is_struct(t2)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() is not a pointer to context\\n\",\n\t\t\t\ti, fn2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* This is an optional check to make program writing easier.\n\t\t * Compare names of structs and report an error to the user.\n\t\t * btf_prepare_func_args() already checked that t2 struct\n\t\t * is a context type. btf_prepare_func_args() will check\n\t\t * later that t1 struct is a context type as well.\n\t\t */\n\t\ts1 = btf_name_by_offset(btf1, t1->name_off);\n\t\ts2 = btf_name_by_offset(btf2, t2->name_off);\n\t\tif (strcmp(s1, s2)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d %s(struct %s *) doesn't match %s(struct %s *)\\n\",\n\t\t\t\ti, fn1, s1, fn2, s2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_check_func_type_match(struct bpf_verifier_log *log,\n\t\t\t\t     struct btf *btf1, const struct btf_type *t1,\n\t\t\t\t     struct btf *btf2, const struct btf_type *t2)\n{\n\tconst struct btf_param *args1, *args2;\n\tconst char *fn1, *fn2, *s1, *s2;\n\tu32 nargs1, nargs2, i;\n\n\tfn1 = btf_name_by_offset(btf1, t1->name_off);\n\tfn2 = btf_name_by_offset(btf2, t2->name_off);\n\n\tif (btf_func_linkage(t1) != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"%s() is not a global function\\n\", fn1);\n\t\treturn -EINVAL;\n\t}\n\tif (btf_func_linkage(t2) != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"%s() is not a global function\\n\", fn2);\n\t\treturn -EINVAL;\n\t}\n\n\tt1 = btf_type_by_id(btf1, t1->type);\n\tif (!t1 || !btf_type_is_func_proto(t1))\n\t\treturn -EFAULT;\n\tt2 = btf_type_by_id(btf2, t2->type);\n\tif (!t2 || !btf_type_is_func_proto(t2))\n\t\treturn -EFAULT;\n\n\targs1 = (const struct btf_param *)(t1 + 1);\n\tnargs1 = btf_type_vlen(t1);\n\targs2 = (const struct btf_param *)(t2 + 1);\n\tnargs2 = btf_type_vlen(t2);\n\n\tif (nargs1 != nargs2) {\n\t\tbpf_log(log, \"%s() has %d args while %s() has %d args\\n\",\n\t\t\tfn1, nargs1, fn2, nargs2);\n\t\treturn -EINVAL;\n\t}\n\n\tt1 = btf_type_skip_modifiers(btf1, t1->type, NULL);\n\tt2 = btf_type_skip_modifiers(btf2, t2->type, NULL);\n\tif (t1->info != t2->info) {\n\t\tbpf_log(log,\n\t\t\t\"Return type %s of %s() doesn't match type %s of %s()\\n\",\n\t\t\tbtf_type_str(t1), fn1,\n\t\t\tbtf_type_str(t2), fn2);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nargs1; i++) {\n\t\tt1 = btf_type_skip_modifiers(btf1, args1[i].type, NULL);\n\t\tt2 = btf_type_skip_modifiers(btf2, args2[i].type, NULL);\n\n\t\tif (t1->info != t2->info) {\n\t\t\tbpf_log(log, \"arg%d in %s() is %s while %s() has %s\\n\",\n\t\t\t\ti, fn1, btf_type_str(t1),\n\t\t\t\tfn2, btf_type_str(t2));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (btf_type_has_size(t1) && t1->size != t2->size) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() has size %d while %s() has %d\\n\",\n\t\t\t\ti, fn1, t1->size,\n\t\t\t\tfn2, t2->size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* global functions are validated with scalars and pointers\n\t\t * to context only. And only global functions can be replaced.\n\t\t * Hence type check only those types.\n\t\t */\n\t\tif (btf_type_is_int(t1) || btf_type_is_enum(t1))\n\t\t\tcontinue;\n\t\tif (!btf_type_is_ptr(t1)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() has unrecognized type\\n\",\n\t\t\t\ti, fn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tt1 = btf_type_skip_modifiers(btf1, t1->type, NULL);\n\t\tt2 = btf_type_skip_modifiers(btf2, t2->type, NULL);\n\t\tif (!btf_type_is_struct(t1)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() is not a pointer to context\\n\",\n\t\t\t\ti, fn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!btf_type_is_struct(t2)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() is not a pointer to context\\n\",\n\t\t\t\ti, fn2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* This is an optional check to make program writing easier.\n\t\t * Compare names of structs and report an error to the user.\n\t\t * btf_prepare_func_args() already checked that t2 struct\n\t\t * is a context type. btf_prepare_func_args() will check\n\t\t * later that t1 struct is a context type as well.\n\t\t */\n\t\ts1 = btf_name_by_offset(btf1, t1->name_off);\n\t\ts2 = btf_name_by_offset(btf2, t2->name_off);\n\t\tif (strcmp(s1, s2)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d %s(struct %s *) doesn't match %s(struct %s *)\\n\",\n\t\t\t\ti, fn1, s1, fn2, s2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_func",
          "args": [
            "t1"
          ],
          "line": 5565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf1",
            "btf_id"
          ],
          "line": 5564
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"Program extension requires BTF\\n\""
          ],
          "line": 5556
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_check_type_match(struct bpf_verifier_log *log, const struct bpf_prog *prog,\n\t\t\t struct btf *btf2, const struct btf_type *t2)\n{\n\tstruct btf *btf1 = prog->aux->btf;\n\tconst struct btf_type *t1;\n\tu32 btf_id = 0;\n\n\tif (!prog->aux->func_info) {\n\t\tbpf_log(log, \"Program extension requires BTF\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_id = prog->aux->func_info[0].type_id;\n\tif (!btf_id)\n\t\treturn -EFAULT;\n\n\tt1 = btf_type_by_id(btf1, btf_id);\n\tif (!t1 || !btf_type_is_func(t1))\n\t\treturn -EFAULT;\n\n\treturn btf_check_func_type_match(log, btf1, t1, btf2, t2);\n}"
  },
  {
    "function_name": "btf_check_func_type_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5437-5545",
    "snippet": "static int btf_check_func_type_match(struct bpf_verifier_log *log,\n\t\t\t\t     struct btf *btf1, const struct btf_type *t1,\n\t\t\t\t     struct btf *btf2, const struct btf_type *t2)\n{\n\tconst struct btf_param *args1, *args2;\n\tconst char *fn1, *fn2, *s1, *s2;\n\tu32 nargs1, nargs2, i;\n\n\tfn1 = btf_name_by_offset(btf1, t1->name_off);\n\tfn2 = btf_name_by_offset(btf2, t2->name_off);\n\n\tif (btf_func_linkage(t1) != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"%s() is not a global function\\n\", fn1);\n\t\treturn -EINVAL;\n\t}\n\tif (btf_func_linkage(t2) != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"%s() is not a global function\\n\", fn2);\n\t\treturn -EINVAL;\n\t}\n\n\tt1 = btf_type_by_id(btf1, t1->type);\n\tif (!t1 || !btf_type_is_func_proto(t1))\n\t\treturn -EFAULT;\n\tt2 = btf_type_by_id(btf2, t2->type);\n\tif (!t2 || !btf_type_is_func_proto(t2))\n\t\treturn -EFAULT;\n\n\targs1 = (const struct btf_param *)(t1 + 1);\n\tnargs1 = btf_type_vlen(t1);\n\targs2 = (const struct btf_param *)(t2 + 1);\n\tnargs2 = btf_type_vlen(t2);\n\n\tif (nargs1 != nargs2) {\n\t\tbpf_log(log, \"%s() has %d args while %s() has %d args\\n\",\n\t\t\tfn1, nargs1, fn2, nargs2);\n\t\treturn -EINVAL;\n\t}\n\n\tt1 = btf_type_skip_modifiers(btf1, t1->type, NULL);\n\tt2 = btf_type_skip_modifiers(btf2, t2->type, NULL);\n\tif (t1->info != t2->info) {\n\t\tbpf_log(log,\n\t\t\t\"Return type %s of %s() doesn't match type %s of %s()\\n\",\n\t\t\tbtf_type_str(t1), fn1,\n\t\t\tbtf_type_str(t2), fn2);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nargs1; i++) {\n\t\tt1 = btf_type_skip_modifiers(btf1, args1[i].type, NULL);\n\t\tt2 = btf_type_skip_modifiers(btf2, args2[i].type, NULL);\n\n\t\tif (t1->info != t2->info) {\n\t\t\tbpf_log(log, \"arg%d in %s() is %s while %s() has %s\\n\",\n\t\t\t\ti, fn1, btf_type_str(t1),\n\t\t\t\tfn2, btf_type_str(t2));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (btf_type_has_size(t1) && t1->size != t2->size) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() has size %d while %s() has %d\\n\",\n\t\t\t\ti, fn1, t1->size,\n\t\t\t\tfn2, t2->size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* global functions are validated with scalars and pointers\n\t\t * to context only. And only global functions can be replaced.\n\t\t * Hence type check only those types.\n\t\t */\n\t\tif (btf_type_is_int(t1) || btf_type_is_enum(t1))\n\t\t\tcontinue;\n\t\tif (!btf_type_is_ptr(t1)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() has unrecognized type\\n\",\n\t\t\t\ti, fn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tt1 = btf_type_skip_modifiers(btf1, t1->type, NULL);\n\t\tt2 = btf_type_skip_modifiers(btf2, t2->type, NULL);\n\t\tif (!btf_type_is_struct(t1)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() is not a pointer to context\\n\",\n\t\t\t\ti, fn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!btf_type_is_struct(t2)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() is not a pointer to context\\n\",\n\t\t\t\ti, fn2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* This is an optional check to make program writing easier.\n\t\t * Compare names of structs and report an error to the user.\n\t\t * btf_prepare_func_args() already checked that t2 struct\n\t\t * is a context type. btf_prepare_func_args() will check\n\t\t * later that t1 struct is a context type as well.\n\t\t */\n\t\ts1 = btf_name_by_offset(btf1, t1->name_off);\n\t\ts2 = btf_name_by_offset(btf2, t2->name_off);\n\t\tif (strcmp(s1, s2)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d %s(struct %s *) doesn't match %s(struct %s *)\\n\",\n\t\t\t\ti, fn1, s1, fn2, s2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"arg%d %s(struct %s *) doesn't match %s(struct %s *)\\n\"",
            "i",
            "fn1",
            "s1",
            "fn2",
            "s2"
          ],
          "line": 5538
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s1",
            "s2"
          ],
          "line": 5537
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "btf2",
            "t2->name_off"
          ],
          "line": 5536
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "726-729",
          "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "t2"
          ],
          "line": 5523
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_skip_modifiers",
          "args": [
            "btf2",
            "t2->type",
            "NULL"
          ],
          "line": 5516
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_skip_modifiers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "509-523",
          "snippet": "const struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t1"
          ],
          "line": 5509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_enum",
          "args": [
            "t1"
          ],
          "line": 5507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_int",
          "args": [
            "t1"
          ],
          "line": 5507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_has_size",
          "args": [
            "t1"
          ],
          "line": 5495
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_has_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "587-600",
          "snippet": "static bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_DATASEC:\n\tcase BTF_KIND_FLOAT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_DATASEC:\n\tcase BTF_KIND_FLOAT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_str",
          "args": [
            "t2"
          ],
          "line": 5492
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_str",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "289-292",
          "snippet": "const char *btf_type_str(const struct btf_type *t)\n{\n\treturn btf_kind_str[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\n\nconst char *btf_type_str(const struct btf_type *t)\n{\n\treturn btf_kind_str[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t2"
          ],
          "line": 5467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t1"
          ],
          "line": 5465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_func_proto",
          "args": [
            "t2"
          ],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf2",
            "t2->type"
          ],
          "line": 5460
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_func_proto",
          "args": [
            "t1"
          ],
          "line": 5458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_func_linkage",
          "args": [
            "t2"
          ],
          "line": 5452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_func_linkage",
          "args": [
            "t1"
          ],
          "line": 5448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_check_func_type_match(struct bpf_verifier_log *log,\n\t\t\t\t     struct btf *btf1, const struct btf_type *t1,\n\t\t\t\t     struct btf *btf2, const struct btf_type *t2)\n{\n\tconst struct btf_param *args1, *args2;\n\tconst char *fn1, *fn2, *s1, *s2;\n\tu32 nargs1, nargs2, i;\n\n\tfn1 = btf_name_by_offset(btf1, t1->name_off);\n\tfn2 = btf_name_by_offset(btf2, t2->name_off);\n\n\tif (btf_func_linkage(t1) != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"%s() is not a global function\\n\", fn1);\n\t\treturn -EINVAL;\n\t}\n\tif (btf_func_linkage(t2) != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"%s() is not a global function\\n\", fn2);\n\t\treturn -EINVAL;\n\t}\n\n\tt1 = btf_type_by_id(btf1, t1->type);\n\tif (!t1 || !btf_type_is_func_proto(t1))\n\t\treturn -EFAULT;\n\tt2 = btf_type_by_id(btf2, t2->type);\n\tif (!t2 || !btf_type_is_func_proto(t2))\n\t\treturn -EFAULT;\n\n\targs1 = (const struct btf_param *)(t1 + 1);\n\tnargs1 = btf_type_vlen(t1);\n\targs2 = (const struct btf_param *)(t2 + 1);\n\tnargs2 = btf_type_vlen(t2);\n\n\tif (nargs1 != nargs2) {\n\t\tbpf_log(log, \"%s() has %d args while %s() has %d args\\n\",\n\t\t\tfn1, nargs1, fn2, nargs2);\n\t\treturn -EINVAL;\n\t}\n\n\tt1 = btf_type_skip_modifiers(btf1, t1->type, NULL);\n\tt2 = btf_type_skip_modifiers(btf2, t2->type, NULL);\n\tif (t1->info != t2->info) {\n\t\tbpf_log(log,\n\t\t\t\"Return type %s of %s() doesn't match type %s of %s()\\n\",\n\t\t\tbtf_type_str(t1), fn1,\n\t\t\tbtf_type_str(t2), fn2);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nargs1; i++) {\n\t\tt1 = btf_type_skip_modifiers(btf1, args1[i].type, NULL);\n\t\tt2 = btf_type_skip_modifiers(btf2, args2[i].type, NULL);\n\n\t\tif (t1->info != t2->info) {\n\t\t\tbpf_log(log, \"arg%d in %s() is %s while %s() has %s\\n\",\n\t\t\t\ti, fn1, btf_type_str(t1),\n\t\t\t\tfn2, btf_type_str(t2));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (btf_type_has_size(t1) && t1->size != t2->size) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() has size %d while %s() has %d\\n\",\n\t\t\t\ti, fn1, t1->size,\n\t\t\t\tfn2, t2->size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* global functions are validated with scalars and pointers\n\t\t * to context only. And only global functions can be replaced.\n\t\t * Hence type check only those types.\n\t\t */\n\t\tif (btf_type_is_int(t1) || btf_type_is_enum(t1))\n\t\t\tcontinue;\n\t\tif (!btf_type_is_ptr(t1)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() has unrecognized type\\n\",\n\t\t\t\ti, fn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tt1 = btf_type_skip_modifiers(btf1, t1->type, NULL);\n\t\tt2 = btf_type_skip_modifiers(btf2, t2->type, NULL);\n\t\tif (!btf_type_is_struct(t1)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() is not a pointer to context\\n\",\n\t\t\t\ti, fn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!btf_type_is_struct(t2)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() is not a pointer to context\\n\",\n\t\t\t\ti, fn2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* This is an optional check to make program writing easier.\n\t\t * Compare names of structs and report an error to the user.\n\t\t * btf_prepare_func_args() already checked that t2 struct\n\t\t * is a context type. btf_prepare_func_args() will check\n\t\t * later that t1 struct is a context type as well.\n\t\t */\n\t\ts1 = btf_name_by_offset(btf1, t1->name_off);\n\t\ts2 = btf_name_by_offset(btf2, t2->name_off);\n\t\tif (strcmp(s1, s2)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d %s(struct %s *) doesn't match %s(struct %s *)\\n\",\n\t\t\t\ti, fn1, s1, fn2, s2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_distill_func_proto",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5365-5427",
    "snippet": "int btf_distill_func_proto(struct bpf_verifier_log *log,\n\t\t\t   struct btf *btf,\n\t\t\t   const struct btf_type *func,\n\t\t\t   const char *tname,\n\t\t\t   struct btf_func_model *m)\n{\n\tconst struct btf_param *args;\n\tconst struct btf_type *t;\n\tu32 i, nargs;\n\tint ret;\n\n\tif (!func) {\n\t\t/* BTF function prototype doesn't match the verifier types.\n\t\t * Fall back to MAX_BPF_FUNC_REG_ARGS u64 args.\n\t\t */\n\t\tfor (i = 0; i < MAX_BPF_FUNC_REG_ARGS; i++)\n\t\t\tm->arg_size[i] = 8;\n\t\tm->ret_size = 8;\n\t\tm->nr_args = MAX_BPF_FUNC_REG_ARGS;\n\t\treturn 0;\n\t}\n\targs = (const struct btf_param *)(func + 1);\n\tnargs = btf_type_vlen(func);\n\tif (nargs >= MAX_BPF_FUNC_ARGS) {\n\t\tbpf_log(log,\n\t\t\t\"The function %s has %d arguments. Too many.\\n\",\n\t\t\ttname, nargs);\n\t\treturn -EINVAL;\n\t}\n\tret = __get_type_size(btf, func->type, &t);\n\tif (ret < 0) {\n\t\tbpf_log(log,\n\t\t\t\"The function %s return type %s is unsupported.\\n\",\n\t\t\ttname, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\treturn -EINVAL;\n\t}\n\tm->ret_size = ret;\n\n\tfor (i = 0; i < nargs; i++) {\n\t\tif (i == nargs - 1 && args[i].type == 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s with variable args is unsupported.\\n\",\n\t\t\t\ttname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = __get_type_size(btf, args[i].type, &t);\n\t\tif (ret < 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s arg%d type %s is unsupported.\\n\",\n\t\t\t\ttname, i, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s has malformed void argument.\\n\",\n\t\t\t\ttname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tm->arg_size[i] = ret;\n\t}\n\tm->nr_args = nargs;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"The function %s has malformed void argument.\\n\"",
            "tname"
          ],
          "line": 5418
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 5414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_type_size",
          "args": [
            "btf",
            "args[i].type",
            "&t"
          ],
          "line": 5410
        },
        "resolved": true,
        "details": {
          "function_name": "__get_type_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5341-5363",
          "snippet": "static int __get_type_size(struct btf *btf, u32 btf_id,\n\t\t\t   const struct btf_type **bad_type)\n{\n\tconst struct btf_type *t;\n\n\tif (!btf_id)\n\t\t/* void */\n\t\treturn 0;\n\tt = btf_type_by_id(btf, btf_id);\n\twhile (t && btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!t) {\n\t\t*bad_type = btf_type_by_id(btf, 0);\n\t\treturn -EINVAL;\n\t}\n\tif (btf_type_is_ptr(t))\n\t\t/* kernel size of pointer. Not BPF's size of pointer*/\n\t\treturn sizeof(void *);\n\tif (btf_type_is_int(t) || btf_type_is_enum(t))\n\t\treturn t->size;\n\t*bad_type = t;\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int __get_type_size(struct btf *btf, u32 btf_id,\n\t\t\t   const struct btf_type **bad_type)\n{\n\tconst struct btf_type *t;\n\n\tif (!btf_id)\n\t\t/* void */\n\t\treturn 0;\n\tt = btf_type_by_id(btf, btf_id);\n\twhile (t && btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!t) {\n\t\t*bad_type = btf_type_by_id(btf, 0);\n\t\treturn -EINVAL;\n\t}\n\tif (btf_type_is_ptr(t))\n\t\t/* kernel size of pointer. Not BPF's size of pointer*/\n\t\treturn sizeof(void *);\n\tif (btf_type_is_int(t) || btf_type_is_enum(t))\n\t\treturn t->size;\n\t*bad_type = t;\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 5398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "func"
          ],
          "line": 5387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\n\nint btf_distill_func_proto(struct bpf_verifier_log *log,\n\t\t\t   struct btf *btf,\n\t\t\t   const struct btf_type *func,\n\t\t\t   const char *tname,\n\t\t\t   struct btf_func_model *m)\n{\n\tconst struct btf_param *args;\n\tconst struct btf_type *t;\n\tu32 i, nargs;\n\tint ret;\n\n\tif (!func) {\n\t\t/* BTF function prototype doesn't match the verifier types.\n\t\t * Fall back to MAX_BPF_FUNC_REG_ARGS u64 args.\n\t\t */\n\t\tfor (i = 0; i < MAX_BPF_FUNC_REG_ARGS; i++)\n\t\t\tm->arg_size[i] = 8;\n\t\tm->ret_size = 8;\n\t\tm->nr_args = MAX_BPF_FUNC_REG_ARGS;\n\t\treturn 0;\n\t}\n\targs = (const struct btf_param *)(func + 1);\n\tnargs = btf_type_vlen(func);\n\tif (nargs >= MAX_BPF_FUNC_ARGS) {\n\t\tbpf_log(log,\n\t\t\t\"The function %s has %d arguments. Too many.\\n\",\n\t\t\ttname, nargs);\n\t\treturn -EINVAL;\n\t}\n\tret = __get_type_size(btf, func->type, &t);\n\tif (ret < 0) {\n\t\tbpf_log(log,\n\t\t\t\"The function %s return type %s is unsupported.\\n\",\n\t\t\ttname, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\treturn -EINVAL;\n\t}\n\tm->ret_size = ret;\n\n\tfor (i = 0; i < nargs; i++) {\n\t\tif (i == nargs - 1 && args[i].type == 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s with variable args is unsupported.\\n\",\n\t\t\t\ttname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = __get_type_size(btf, args[i].type, &t);\n\t\tif (ret < 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s arg%d type %s is unsupported.\\n\",\n\t\t\t\ttname, i, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s has malformed void argument.\\n\",\n\t\t\t\ttname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tm->arg_size[i] = ret;\n\t}\n\tm->nr_args = nargs;\n\treturn 0;\n}"
  },
  {
    "function_name": "__get_type_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5341-5363",
    "snippet": "static int __get_type_size(struct btf *btf, u32 btf_id,\n\t\t\t   const struct btf_type **bad_type)\n{\n\tconst struct btf_type *t;\n\n\tif (!btf_id)\n\t\t/* void */\n\t\treturn 0;\n\tt = btf_type_by_id(btf, btf_id);\n\twhile (t && btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!t) {\n\t\t*bad_type = btf_type_by_id(btf, 0);\n\t\treturn -EINVAL;\n\t}\n\tif (btf_type_is_ptr(t))\n\t\t/* kernel size of pointer. Not BPF's size of pointer*/\n\t\treturn sizeof(void *);\n\tif (btf_type_is_int(t) || btf_type_is_enum(t))\n\t\treturn t->size;\n\t*bad_type = t;\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_enum",
          "args": [
            "t"
          ],
          "line": 5359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_int",
          "args": [
            "t"
          ],
          "line": 5359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t"
          ],
          "line": 5356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "0"
          ],
          "line": 5353
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "t"
          ],
          "line": 5350
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int __get_type_size(struct btf *btf, u32 btf_id,\n\t\t\t   const struct btf_type **bad_type)\n{\n\tconst struct btf_type *t;\n\n\tif (!btf_id)\n\t\t/* void */\n\t\treturn 0;\n\tt = btf_type_by_id(btf, btf_id);\n\twhile (t && btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!t) {\n\t\t*bad_type = btf_type_by_id(btf, 0);\n\t\treturn -EINVAL;\n\t}\n\tif (btf_type_is_ptr(t))\n\t\t/* kernel size of pointer. Not BPF's size of pointer*/\n\t\treturn sizeof(void *);\n\tif (btf_type_is_int(t) || btf_type_is_enum(t))\n\t\treturn t->size;\n\t*bad_type = t;\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "btf_struct_ids_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5309-5339",
    "snippet": "bool btf_struct_ids_match(struct bpf_verifier_log *log,\n\t\t\t  const struct btf *btf, u32 id, int off,\n\t\t\t  const struct btf *need_btf, u32 need_type_id)\n{\n\tconst struct btf_type *type;\n\tint err;\n\n\t/* Are we already done? */\n\tif (off == 0 && btf_types_are_same(btf, id, need_btf, need_type_id))\n\t\treturn true;\n\nagain:\n\ttype = btf_type_by_id(btf, id);\n\tif (!type)\n\t\treturn false;\n\terr = btf_struct_walk(log, btf, type, off, 1, &id);\n\tif (err != WALK_STRUCT)\n\t\treturn false;\n\n\t/* We found nested struct object. If it matches\n\t * the requested ID, we're done. Otherwise let's\n\t * continue the search with offset 0 in the new\n\t * type.\n\t */\n\tif (!btf_types_are_same(btf, id, need_btf, need_type_id)) {\n\t\toff = 0;\n\t\tgoto again;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_types_are_same",
          "args": [
            "btf",
            "id",
            "need_btf",
            "need_type_id"
          ],
          "line": 5333
        },
        "resolved": true,
        "details": {
          "function_name": "btf_types_are_same",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5299-5307",
          "snippet": "static bool btf_types_are_same(const struct btf *btf1, u32 id1,\n\t\t\t       const struct btf *btf2, u32 id2)\n{\n\tif (id1 != id2)\n\t\treturn false;\n\tif (btf1 == btf2)\n\t\treturn true;\n\treturn btf_type_by_id(btf1, id1) == btf_type_by_id(btf2, id2);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_types_are_same(const struct btf *btf1, u32 id1,\n\t\t\t       const struct btf *btf2, u32 id2)\n{\n\tif (id1 != id2)\n\t\treturn false;\n\tif (btf1 == btf2)\n\t\treturn true;\n\treturn btf_type_by_id(btf1, id1) == btf_type_by_id(btf2, id2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_struct_walk",
          "args": [
            "log",
            "btf",
            "type",
            "off",
            "1",
            "&id"
          ],
          "line": 5324
        },
        "resolved": true,
        "details": {
          "function_name": "btf_struct_walk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5027-5251",
          "snippet": "static int btf_struct_walk(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t\t   const struct btf_type *t, int off, int size,\n\t\t\t   u32 *next_btf_id)\n{\n\tu32 i, moff, mtrue_end, msize = 0, total_nelems = 0;\n\tconst struct btf_type *mtype, *elem_type = NULL;\n\tconst struct btf_member *member;\n\tconst char *tname, *mname;\n\tu32 vlen, elem_id, mid;\n\nagain:\n\ttname = __btf_name_by_offset(btf, t->name_off);\n\tif (!btf_type_is_struct(t)) {\n\t\tbpf_log(log, \"Type '%s' is not a struct\\n\", tname);\n\t\treturn -EINVAL;\n\t}\n\n\tvlen = btf_type_vlen(t);\n\tif (off + size > t->size) {\n\t\t/* If the last element is a variable size array, we may\n\t\t * need to relax the rule.\n\t\t */\n\t\tstruct btf_array *array_elem;\n\n\t\tif (vlen == 0)\n\t\t\tgoto error;\n\n\t\tmember = btf_type_member(t) + vlen - 1;\n\t\tmtype = btf_type_skip_modifiers(btf, member->type,\n\t\t\t\t\t\tNULL);\n\t\tif (!btf_type_is_array(mtype))\n\t\t\tgoto error;\n\n\t\tarray_elem = (struct btf_array *)(mtype + 1);\n\t\tif (array_elem->nelems != 0)\n\t\t\tgoto error;\n\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off < moff)\n\t\t\tgoto error;\n\n\t\t/* Only allow structure for now, can be relaxed for\n\t\t * other types later.\n\t\t */\n\t\tt = btf_type_skip_modifiers(btf, array_elem->type,\n\t\t\t\t\t    NULL);\n\t\tif (!btf_type_is_struct(t))\n\t\t\tgoto error;\n\n\t\toff = (off - moff) % t->size;\n\t\tgoto again;\n\nerror:\n\t\tbpf_log(log, \"access beyond struct %s at off %u size %u\\n\",\n\t\t\ttname, off, size);\n\t\treturn -EACCES;\n\t}\n\n\tfor_each_member(i, t, member) {\n\t\t/* offset of the field in bytes */\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off + size <= moff)\n\t\t\t/* won't find anything, field is already too far */\n\t\t\tbreak;\n\n\t\tif (__btf_member_bitfield_size(t, member)) {\n\t\t\tu32 end_bit = __btf_member_bit_offset(t, member) +\n\t\t\t\t__btf_member_bitfield_size(t, member);\n\n\t\t\t/* off <= moff instead of off == moff because clang\n\t\t\t * does not generate a BTF member for anonymous\n\t\t\t * bitfield like the \":16\" here:\n\t\t\t * struct {\n\t\t\t *\tint :16;\n\t\t\t *\tint x:8;\n\t\t\t * };\n\t\t\t */\n\t\t\tif (off <= moff &&\n\t\t\t    BITS_ROUNDUP_BYTES(end_bit) <= off + size)\n\t\t\t\treturn WALK_SCALAR;\n\n\t\t\t/* off may be accessing a following member\n\t\t\t *\n\t\t\t * or\n\t\t\t *\n\t\t\t * Doing partial access at either end of this\n\t\t\t * bitfield.  Continue on this case also to\n\t\t\t * treat it as not accessing this bitfield\n\t\t\t * and eventually error out as field not\n\t\t\t * found to keep it simple.\n\t\t\t * It could be relaxed if there was a legit\n\t\t\t * partial access case later.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* In case of \"off\" is pointing to holes of a struct */\n\t\tif (off < moff)\n\t\t\tbreak;\n\n\t\t/* type of the field */\n\t\tmid = member->type;\n\t\tmtype = btf_type_by_id(btf, member->type);\n\t\tmname = __btf_name_by_offset(btf, member->name_off);\n\n\t\tmtype = __btf_resolve_size(btf, mtype, &msize,\n\t\t\t\t\t   &elem_type, &elem_id, &total_nelems,\n\t\t\t\t\t   &mid);\n\t\tif (IS_ERR(mtype)) {\n\t\t\tbpf_log(log, \"field %s doesn't have size\\n\", mname);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tmtrue_end = moff + msize;\n\t\tif (off >= mtrue_end)\n\t\t\t/* no overlap with member, keep iterating */\n\t\t\tcontinue;\n\n\t\tif (btf_type_is_array(mtype)) {\n\t\t\tu32 elem_idx;\n\n\t\t\t/* __btf_resolve_size() above helps to\n\t\t\t * linearize a multi-dimensional array.\n\t\t\t *\n\t\t\t * The logic here is treating an array\n\t\t\t * in a struct as the following way:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array[2][2];\n\t\t\t * };\n\t\t\t *\n\t\t\t * looks like:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array_elem0;\n\t\t\t *\tstruct inner array_elem1;\n\t\t\t *\tstruct inner array_elem2;\n\t\t\t *\tstruct inner array_elem3;\n\t\t\t * };\n\t\t\t *\n\t\t\t * When accessing outer->array[1][0], it moves\n\t\t\t * moff to \"array_elem2\", set mtype to\n\t\t\t * \"struct inner\", and msize also becomes\n\t\t\t * sizeof(struct inner).  Then most of the\n\t\t\t * remaining logic will fall through without\n\t\t\t * caring the current member is an array or\n\t\t\t * not.\n\t\t\t *\n\t\t\t * Unlike mtype/msize/moff, mtrue_end does not\n\t\t\t * change.  The naming difference (\"_true\") tells\n\t\t\t * that it is not always corresponding to\n\t\t\t * the current mtype/msize/moff.\n\t\t\t * It is the true end of the current\n\t\t\t * member (i.e. array in this case).  That\n\t\t\t * will allow an int array to be accessed like\n\t\t\t * a scratch space,\n\t\t\t * i.e. allow access beyond the size of\n\t\t\t *      the array's element as long as it is\n\t\t\t *      within the mtrue_end boundary.\n\t\t\t */\n\n\t\t\t/* skip empty array */\n\t\t\tif (moff == mtrue_end)\n\t\t\t\tcontinue;\n\n\t\t\tmsize /= total_nelems;\n\t\t\telem_idx = (off - moff) / msize;\n\t\t\tmoff += elem_idx * msize;\n\t\t\tmtype = elem_type;\n\t\t\tmid = elem_id;\n\t\t}\n\n\t\t/* the 'off' we're looking for is either equal to start\n\t\t * of this field or inside of this struct\n\t\t */\n\t\tif (btf_type_is_struct(mtype)) {\n\t\t\t/* our field must be inside that union or struct */\n\t\t\tt = mtype;\n\n\t\t\t/* return if the offset matches the member offset */\n\t\t\tif (off == moff) {\n\t\t\t\t*next_btf_id = mid;\n\t\t\t\treturn WALK_STRUCT;\n\t\t\t}\n\n\t\t\t/* adjust offset we're looking for */\n\t\t\toff -= moff;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (btf_type_is_ptr(mtype)) {\n\t\t\tconst struct btf_type *stype;\n\t\t\tu32 id;\n\n\t\t\tif (msize != size || off != moff) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"cannot access ptr member %s with moff %u in struct %s with off %u size %u\\n\",\n\t\t\t\t\tmname, moff, tname, off, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tstype = btf_type_skip_modifiers(btf, mtype->type, &id);\n\t\t\tif (btf_type_is_struct(stype)) {\n\t\t\t\t*next_btf_id = id;\n\t\t\t\treturn WALK_PTR;\n\t\t\t}\n\t\t}\n\n\t\t/* Allow more flexible access within an int as long as\n\t\t * it is within mtrue_end.\n\t\t * Since mtrue_end could be the end of an array,\n\t\t * that also allows using an array of int as a scratch\n\t\t * space. e.g. skb->cb[].\n\t\t */\n\t\tif (off + size > mtrue_end) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"access beyond the end of member %s (mend:%u) in struct %s with off %u size %u\\n\",\n\t\t\t\tmname, mtrue_end, tname, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\treturn WALK_SCALAR;\n\t}\n\tbpf_log(log, \"struct %s doesn't have field at offset %d\\n\", tname, off);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_struct_walk(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t\t   const struct btf_type *t, int off, int size,\n\t\t\t   u32 *next_btf_id)\n{\n\tu32 i, moff, mtrue_end, msize = 0, total_nelems = 0;\n\tconst struct btf_type *mtype, *elem_type = NULL;\n\tconst struct btf_member *member;\n\tconst char *tname, *mname;\n\tu32 vlen, elem_id, mid;\n\nagain:\n\ttname = __btf_name_by_offset(btf, t->name_off);\n\tif (!btf_type_is_struct(t)) {\n\t\tbpf_log(log, \"Type '%s' is not a struct\\n\", tname);\n\t\treturn -EINVAL;\n\t}\n\n\tvlen = btf_type_vlen(t);\n\tif (off + size > t->size) {\n\t\t/* If the last element is a variable size array, we may\n\t\t * need to relax the rule.\n\t\t */\n\t\tstruct btf_array *array_elem;\n\n\t\tif (vlen == 0)\n\t\t\tgoto error;\n\n\t\tmember = btf_type_member(t) + vlen - 1;\n\t\tmtype = btf_type_skip_modifiers(btf, member->type,\n\t\t\t\t\t\tNULL);\n\t\tif (!btf_type_is_array(mtype))\n\t\t\tgoto error;\n\n\t\tarray_elem = (struct btf_array *)(mtype + 1);\n\t\tif (array_elem->nelems != 0)\n\t\t\tgoto error;\n\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off < moff)\n\t\t\tgoto error;\n\n\t\t/* Only allow structure for now, can be relaxed for\n\t\t * other types later.\n\t\t */\n\t\tt = btf_type_skip_modifiers(btf, array_elem->type,\n\t\t\t\t\t    NULL);\n\t\tif (!btf_type_is_struct(t))\n\t\t\tgoto error;\n\n\t\toff = (off - moff) % t->size;\n\t\tgoto again;\n\nerror:\n\t\tbpf_log(log, \"access beyond struct %s at off %u size %u\\n\",\n\t\t\ttname, off, size);\n\t\treturn -EACCES;\n\t}\n\n\tfor_each_member(i, t, member) {\n\t\t/* offset of the field in bytes */\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off + size <= moff)\n\t\t\t/* won't find anything, field is already too far */\n\t\t\tbreak;\n\n\t\tif (__btf_member_bitfield_size(t, member)) {\n\t\t\tu32 end_bit = __btf_member_bit_offset(t, member) +\n\t\t\t\t__btf_member_bitfield_size(t, member);\n\n\t\t\t/* off <= moff instead of off == moff because clang\n\t\t\t * does not generate a BTF member for anonymous\n\t\t\t * bitfield like the \":16\" here:\n\t\t\t * struct {\n\t\t\t *\tint :16;\n\t\t\t *\tint x:8;\n\t\t\t * };\n\t\t\t */\n\t\t\tif (off <= moff &&\n\t\t\t    BITS_ROUNDUP_BYTES(end_bit) <= off + size)\n\t\t\t\treturn WALK_SCALAR;\n\n\t\t\t/* off may be accessing a following member\n\t\t\t *\n\t\t\t * or\n\t\t\t *\n\t\t\t * Doing partial access at either end of this\n\t\t\t * bitfield.  Continue on this case also to\n\t\t\t * treat it as not accessing this bitfield\n\t\t\t * and eventually error out as field not\n\t\t\t * found to keep it simple.\n\t\t\t * It could be relaxed if there was a legit\n\t\t\t * partial access case later.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* In case of \"off\" is pointing to holes of a struct */\n\t\tif (off < moff)\n\t\t\tbreak;\n\n\t\t/* type of the field */\n\t\tmid = member->type;\n\t\tmtype = btf_type_by_id(btf, member->type);\n\t\tmname = __btf_name_by_offset(btf, member->name_off);\n\n\t\tmtype = __btf_resolve_size(btf, mtype, &msize,\n\t\t\t\t\t   &elem_type, &elem_id, &total_nelems,\n\t\t\t\t\t   &mid);\n\t\tif (IS_ERR(mtype)) {\n\t\t\tbpf_log(log, \"field %s doesn't have size\\n\", mname);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tmtrue_end = moff + msize;\n\t\tif (off >= mtrue_end)\n\t\t\t/* no overlap with member, keep iterating */\n\t\t\tcontinue;\n\n\t\tif (btf_type_is_array(mtype)) {\n\t\t\tu32 elem_idx;\n\n\t\t\t/* __btf_resolve_size() above helps to\n\t\t\t * linearize a multi-dimensional array.\n\t\t\t *\n\t\t\t * The logic here is treating an array\n\t\t\t * in a struct as the following way:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array[2][2];\n\t\t\t * };\n\t\t\t *\n\t\t\t * looks like:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array_elem0;\n\t\t\t *\tstruct inner array_elem1;\n\t\t\t *\tstruct inner array_elem2;\n\t\t\t *\tstruct inner array_elem3;\n\t\t\t * };\n\t\t\t *\n\t\t\t * When accessing outer->array[1][0], it moves\n\t\t\t * moff to \"array_elem2\", set mtype to\n\t\t\t * \"struct inner\", and msize also becomes\n\t\t\t * sizeof(struct inner).  Then most of the\n\t\t\t * remaining logic will fall through without\n\t\t\t * caring the current member is an array or\n\t\t\t * not.\n\t\t\t *\n\t\t\t * Unlike mtype/msize/moff, mtrue_end does not\n\t\t\t * change.  The naming difference (\"_true\") tells\n\t\t\t * that it is not always corresponding to\n\t\t\t * the current mtype/msize/moff.\n\t\t\t * It is the true end of the current\n\t\t\t * member (i.e. array in this case).  That\n\t\t\t * will allow an int array to be accessed like\n\t\t\t * a scratch space,\n\t\t\t * i.e. allow access beyond the size of\n\t\t\t *      the array's element as long as it is\n\t\t\t *      within the mtrue_end boundary.\n\t\t\t */\n\n\t\t\t/* skip empty array */\n\t\t\tif (moff == mtrue_end)\n\t\t\t\tcontinue;\n\n\t\t\tmsize /= total_nelems;\n\t\t\telem_idx = (off - moff) / msize;\n\t\t\tmoff += elem_idx * msize;\n\t\t\tmtype = elem_type;\n\t\t\tmid = elem_id;\n\t\t}\n\n\t\t/* the 'off' we're looking for is either equal to start\n\t\t * of this field or inside of this struct\n\t\t */\n\t\tif (btf_type_is_struct(mtype)) {\n\t\t\t/* our field must be inside that union or struct */\n\t\t\tt = mtype;\n\n\t\t\t/* return if the offset matches the member offset */\n\t\t\tif (off == moff) {\n\t\t\t\t*next_btf_id = mid;\n\t\t\t\treturn WALK_STRUCT;\n\t\t\t}\n\n\t\t\t/* adjust offset we're looking for */\n\t\t\toff -= moff;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (btf_type_is_ptr(mtype)) {\n\t\t\tconst struct btf_type *stype;\n\t\t\tu32 id;\n\n\t\t\tif (msize != size || off != moff) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"cannot access ptr member %s with moff %u in struct %s with off %u size %u\\n\",\n\t\t\t\t\tmname, moff, tname, off, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tstype = btf_type_skip_modifiers(btf, mtype->type, &id);\n\t\t\tif (btf_type_is_struct(stype)) {\n\t\t\t\t*next_btf_id = id;\n\t\t\t\treturn WALK_PTR;\n\t\t\t}\n\t\t}\n\n\t\t/* Allow more flexible access within an int as long as\n\t\t * it is within mtrue_end.\n\t\t * Since mtrue_end could be the end of an array,\n\t\t * that also allows using an array of int as a scratch\n\t\t * space. e.g. skb->cb[].\n\t\t */\n\t\tif (off + size > mtrue_end) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"access beyond the end of member %s (mend:%u) in struct %s with off %u size %u\\n\",\n\t\t\t\tmname, mtrue_end, tname, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\treturn WALK_SCALAR;\n\t}\n\tbpf_log(log, \"struct %s doesn't have field at offset %d\\n\", tname, off);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "id"
          ],
          "line": 5321
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_struct_ids_match(struct bpf_verifier_log *log,\n\t\t\t  const struct btf *btf, u32 id, int off,\n\t\t\t  const struct btf *need_btf, u32 need_type_id)\n{\n\tconst struct btf_type *type;\n\tint err;\n\n\t/* Are we already done? */\n\tif (off == 0 && btf_types_are_same(btf, id, need_btf, need_type_id))\n\t\treturn true;\n\nagain:\n\ttype = btf_type_by_id(btf, id);\n\tif (!type)\n\t\treturn false;\n\terr = btf_struct_walk(log, btf, type, off, 1, &id);\n\tif (err != WALK_STRUCT)\n\t\treturn false;\n\n\t/* We found nested struct object. If it matches\n\t * the requested ID, we're done. Otherwise let's\n\t * continue the search with offset 0 in the new\n\t * type.\n\t */\n\tif (!btf_types_are_same(btf, id, need_btf, need_type_id)) {\n\t\toff = 0;\n\t\tgoto again;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "btf_types_are_same",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5299-5307",
    "snippet": "static bool btf_types_are_same(const struct btf *btf1, u32 id1,\n\t\t\t       const struct btf *btf2, u32 id2)\n{\n\tif (id1 != id2)\n\t\treturn false;\n\tif (btf1 == btf2)\n\t\treturn true;\n\treturn btf_type_by_id(btf1, id1) == btf_type_by_id(btf2, id2);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf2",
            "id2"
          ],
          "line": 5306
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_types_are_same(const struct btf *btf1, u32 id1,\n\t\t\t       const struct btf *btf2, u32 id2)\n{\n\tif (id1 != id2)\n\t\treturn false;\n\tif (btf1 == btf2)\n\t\treturn true;\n\treturn btf_type_by_id(btf1, id1) == btf_type_by_id(btf2, id2);\n}"
  },
  {
    "function_name": "btf_struct_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5253-5292",
    "snippet": "int btf_struct_access(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, int off, int size,\n\t\t      enum bpf_access_type atype __maybe_unused,\n\t\t      u32 *next_btf_id)\n{\n\tint err;\n\tu32 id;\n\n\tdo {\n\t\terr = btf_struct_walk(log, btf, t, off, size, &id);\n\n\t\tswitch (err) {\n\t\tcase WALK_PTR:\n\t\t\t/* If we found the pointer or scalar on t+off,\n\t\t\t * we're done.\n\t\t\t */\n\t\t\t*next_btf_id = id;\n\t\t\treturn PTR_TO_BTF_ID;\n\t\tcase WALK_SCALAR:\n\t\t\treturn SCALAR_VALUE;\n\t\tcase WALK_STRUCT:\n\t\t\t/* We found nested struct, so continue the search\n\t\t\t * by diving in it. At this point the offset is\n\t\t\t * aligned with the new type, so set it to 0.\n\t\t\t */\n\t\t\tt = btf_type_by_id(btf, id);\n\t\t\toff = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* It's either error or unknown return value..\n\t\t\t * scream and leave.\n\t\t\t */\n\t\t\tif (WARN_ONCE(err > 0, \"unknown btf_struct_walk return value\"))\n\t\t\t\treturn -EINVAL;\n\t\t\treturn err;\n\t\t}\n\t} while (t);\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "err > 0",
            "\"unknown btf_struct_walk return value\""
          ],
          "line": 5285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "id"
          ],
          "line": 5278
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_struct_walk",
          "args": [
            "log",
            "btf",
            "t",
            "off",
            "size",
            "&id"
          ],
          "line": 5262
        },
        "resolved": true,
        "details": {
          "function_name": "btf_struct_walk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5027-5251",
          "snippet": "static int btf_struct_walk(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t\t   const struct btf_type *t, int off, int size,\n\t\t\t   u32 *next_btf_id)\n{\n\tu32 i, moff, mtrue_end, msize = 0, total_nelems = 0;\n\tconst struct btf_type *mtype, *elem_type = NULL;\n\tconst struct btf_member *member;\n\tconst char *tname, *mname;\n\tu32 vlen, elem_id, mid;\n\nagain:\n\ttname = __btf_name_by_offset(btf, t->name_off);\n\tif (!btf_type_is_struct(t)) {\n\t\tbpf_log(log, \"Type '%s' is not a struct\\n\", tname);\n\t\treturn -EINVAL;\n\t}\n\n\tvlen = btf_type_vlen(t);\n\tif (off + size > t->size) {\n\t\t/* If the last element is a variable size array, we may\n\t\t * need to relax the rule.\n\t\t */\n\t\tstruct btf_array *array_elem;\n\n\t\tif (vlen == 0)\n\t\t\tgoto error;\n\n\t\tmember = btf_type_member(t) + vlen - 1;\n\t\tmtype = btf_type_skip_modifiers(btf, member->type,\n\t\t\t\t\t\tNULL);\n\t\tif (!btf_type_is_array(mtype))\n\t\t\tgoto error;\n\n\t\tarray_elem = (struct btf_array *)(mtype + 1);\n\t\tif (array_elem->nelems != 0)\n\t\t\tgoto error;\n\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off < moff)\n\t\t\tgoto error;\n\n\t\t/* Only allow structure for now, can be relaxed for\n\t\t * other types later.\n\t\t */\n\t\tt = btf_type_skip_modifiers(btf, array_elem->type,\n\t\t\t\t\t    NULL);\n\t\tif (!btf_type_is_struct(t))\n\t\t\tgoto error;\n\n\t\toff = (off - moff) % t->size;\n\t\tgoto again;\n\nerror:\n\t\tbpf_log(log, \"access beyond struct %s at off %u size %u\\n\",\n\t\t\ttname, off, size);\n\t\treturn -EACCES;\n\t}\n\n\tfor_each_member(i, t, member) {\n\t\t/* offset of the field in bytes */\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off + size <= moff)\n\t\t\t/* won't find anything, field is already too far */\n\t\t\tbreak;\n\n\t\tif (__btf_member_bitfield_size(t, member)) {\n\t\t\tu32 end_bit = __btf_member_bit_offset(t, member) +\n\t\t\t\t__btf_member_bitfield_size(t, member);\n\n\t\t\t/* off <= moff instead of off == moff because clang\n\t\t\t * does not generate a BTF member for anonymous\n\t\t\t * bitfield like the \":16\" here:\n\t\t\t * struct {\n\t\t\t *\tint :16;\n\t\t\t *\tint x:8;\n\t\t\t * };\n\t\t\t */\n\t\t\tif (off <= moff &&\n\t\t\t    BITS_ROUNDUP_BYTES(end_bit) <= off + size)\n\t\t\t\treturn WALK_SCALAR;\n\n\t\t\t/* off may be accessing a following member\n\t\t\t *\n\t\t\t * or\n\t\t\t *\n\t\t\t * Doing partial access at either end of this\n\t\t\t * bitfield.  Continue on this case also to\n\t\t\t * treat it as not accessing this bitfield\n\t\t\t * and eventually error out as field not\n\t\t\t * found to keep it simple.\n\t\t\t * It could be relaxed if there was a legit\n\t\t\t * partial access case later.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* In case of \"off\" is pointing to holes of a struct */\n\t\tif (off < moff)\n\t\t\tbreak;\n\n\t\t/* type of the field */\n\t\tmid = member->type;\n\t\tmtype = btf_type_by_id(btf, member->type);\n\t\tmname = __btf_name_by_offset(btf, member->name_off);\n\n\t\tmtype = __btf_resolve_size(btf, mtype, &msize,\n\t\t\t\t\t   &elem_type, &elem_id, &total_nelems,\n\t\t\t\t\t   &mid);\n\t\tif (IS_ERR(mtype)) {\n\t\t\tbpf_log(log, \"field %s doesn't have size\\n\", mname);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tmtrue_end = moff + msize;\n\t\tif (off >= mtrue_end)\n\t\t\t/* no overlap with member, keep iterating */\n\t\t\tcontinue;\n\n\t\tif (btf_type_is_array(mtype)) {\n\t\t\tu32 elem_idx;\n\n\t\t\t/* __btf_resolve_size() above helps to\n\t\t\t * linearize a multi-dimensional array.\n\t\t\t *\n\t\t\t * The logic here is treating an array\n\t\t\t * in a struct as the following way:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array[2][2];\n\t\t\t * };\n\t\t\t *\n\t\t\t * looks like:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array_elem0;\n\t\t\t *\tstruct inner array_elem1;\n\t\t\t *\tstruct inner array_elem2;\n\t\t\t *\tstruct inner array_elem3;\n\t\t\t * };\n\t\t\t *\n\t\t\t * When accessing outer->array[1][0], it moves\n\t\t\t * moff to \"array_elem2\", set mtype to\n\t\t\t * \"struct inner\", and msize also becomes\n\t\t\t * sizeof(struct inner).  Then most of the\n\t\t\t * remaining logic will fall through without\n\t\t\t * caring the current member is an array or\n\t\t\t * not.\n\t\t\t *\n\t\t\t * Unlike mtype/msize/moff, mtrue_end does not\n\t\t\t * change.  The naming difference (\"_true\") tells\n\t\t\t * that it is not always corresponding to\n\t\t\t * the current mtype/msize/moff.\n\t\t\t * It is the true end of the current\n\t\t\t * member (i.e. array in this case).  That\n\t\t\t * will allow an int array to be accessed like\n\t\t\t * a scratch space,\n\t\t\t * i.e. allow access beyond the size of\n\t\t\t *      the array's element as long as it is\n\t\t\t *      within the mtrue_end boundary.\n\t\t\t */\n\n\t\t\t/* skip empty array */\n\t\t\tif (moff == mtrue_end)\n\t\t\t\tcontinue;\n\n\t\t\tmsize /= total_nelems;\n\t\t\telem_idx = (off - moff) / msize;\n\t\t\tmoff += elem_idx * msize;\n\t\t\tmtype = elem_type;\n\t\t\tmid = elem_id;\n\t\t}\n\n\t\t/* the 'off' we're looking for is either equal to start\n\t\t * of this field or inside of this struct\n\t\t */\n\t\tif (btf_type_is_struct(mtype)) {\n\t\t\t/* our field must be inside that union or struct */\n\t\t\tt = mtype;\n\n\t\t\t/* return if the offset matches the member offset */\n\t\t\tif (off == moff) {\n\t\t\t\t*next_btf_id = mid;\n\t\t\t\treturn WALK_STRUCT;\n\t\t\t}\n\n\t\t\t/* adjust offset we're looking for */\n\t\t\toff -= moff;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (btf_type_is_ptr(mtype)) {\n\t\t\tconst struct btf_type *stype;\n\t\t\tu32 id;\n\n\t\t\tif (msize != size || off != moff) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"cannot access ptr member %s with moff %u in struct %s with off %u size %u\\n\",\n\t\t\t\t\tmname, moff, tname, off, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tstype = btf_type_skip_modifiers(btf, mtype->type, &id);\n\t\t\tif (btf_type_is_struct(stype)) {\n\t\t\t\t*next_btf_id = id;\n\t\t\t\treturn WALK_PTR;\n\t\t\t}\n\t\t}\n\n\t\t/* Allow more flexible access within an int as long as\n\t\t * it is within mtrue_end.\n\t\t * Since mtrue_end could be the end of an array,\n\t\t * that also allows using an array of int as a scratch\n\t\t * space. e.g. skb->cb[].\n\t\t */\n\t\tif (off + size > mtrue_end) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"access beyond the end of member %s (mend:%u) in struct %s with off %u size %u\\n\",\n\t\t\t\tmname, mtrue_end, tname, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\treturn WALK_SCALAR;\n\t}\n\tbpf_log(log, \"struct %s doesn't have field at offset %d\\n\", tname, off);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_struct_walk(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t\t   const struct btf_type *t, int off, int size,\n\t\t\t   u32 *next_btf_id)\n{\n\tu32 i, moff, mtrue_end, msize = 0, total_nelems = 0;\n\tconst struct btf_type *mtype, *elem_type = NULL;\n\tconst struct btf_member *member;\n\tconst char *tname, *mname;\n\tu32 vlen, elem_id, mid;\n\nagain:\n\ttname = __btf_name_by_offset(btf, t->name_off);\n\tif (!btf_type_is_struct(t)) {\n\t\tbpf_log(log, \"Type '%s' is not a struct\\n\", tname);\n\t\treturn -EINVAL;\n\t}\n\n\tvlen = btf_type_vlen(t);\n\tif (off + size > t->size) {\n\t\t/* If the last element is a variable size array, we may\n\t\t * need to relax the rule.\n\t\t */\n\t\tstruct btf_array *array_elem;\n\n\t\tif (vlen == 0)\n\t\t\tgoto error;\n\n\t\tmember = btf_type_member(t) + vlen - 1;\n\t\tmtype = btf_type_skip_modifiers(btf, member->type,\n\t\t\t\t\t\tNULL);\n\t\tif (!btf_type_is_array(mtype))\n\t\t\tgoto error;\n\n\t\tarray_elem = (struct btf_array *)(mtype + 1);\n\t\tif (array_elem->nelems != 0)\n\t\t\tgoto error;\n\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off < moff)\n\t\t\tgoto error;\n\n\t\t/* Only allow structure for now, can be relaxed for\n\t\t * other types later.\n\t\t */\n\t\tt = btf_type_skip_modifiers(btf, array_elem->type,\n\t\t\t\t\t    NULL);\n\t\tif (!btf_type_is_struct(t))\n\t\t\tgoto error;\n\n\t\toff = (off - moff) % t->size;\n\t\tgoto again;\n\nerror:\n\t\tbpf_log(log, \"access beyond struct %s at off %u size %u\\n\",\n\t\t\ttname, off, size);\n\t\treturn -EACCES;\n\t}\n\n\tfor_each_member(i, t, member) {\n\t\t/* offset of the field in bytes */\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off + size <= moff)\n\t\t\t/* won't find anything, field is already too far */\n\t\t\tbreak;\n\n\t\tif (__btf_member_bitfield_size(t, member)) {\n\t\t\tu32 end_bit = __btf_member_bit_offset(t, member) +\n\t\t\t\t__btf_member_bitfield_size(t, member);\n\n\t\t\t/* off <= moff instead of off == moff because clang\n\t\t\t * does not generate a BTF member for anonymous\n\t\t\t * bitfield like the \":16\" here:\n\t\t\t * struct {\n\t\t\t *\tint :16;\n\t\t\t *\tint x:8;\n\t\t\t * };\n\t\t\t */\n\t\t\tif (off <= moff &&\n\t\t\t    BITS_ROUNDUP_BYTES(end_bit) <= off + size)\n\t\t\t\treturn WALK_SCALAR;\n\n\t\t\t/* off may be accessing a following member\n\t\t\t *\n\t\t\t * or\n\t\t\t *\n\t\t\t * Doing partial access at either end of this\n\t\t\t * bitfield.  Continue on this case also to\n\t\t\t * treat it as not accessing this bitfield\n\t\t\t * and eventually error out as field not\n\t\t\t * found to keep it simple.\n\t\t\t * It could be relaxed if there was a legit\n\t\t\t * partial access case later.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* In case of \"off\" is pointing to holes of a struct */\n\t\tif (off < moff)\n\t\t\tbreak;\n\n\t\t/* type of the field */\n\t\tmid = member->type;\n\t\tmtype = btf_type_by_id(btf, member->type);\n\t\tmname = __btf_name_by_offset(btf, member->name_off);\n\n\t\tmtype = __btf_resolve_size(btf, mtype, &msize,\n\t\t\t\t\t   &elem_type, &elem_id, &total_nelems,\n\t\t\t\t\t   &mid);\n\t\tif (IS_ERR(mtype)) {\n\t\t\tbpf_log(log, \"field %s doesn't have size\\n\", mname);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tmtrue_end = moff + msize;\n\t\tif (off >= mtrue_end)\n\t\t\t/* no overlap with member, keep iterating */\n\t\t\tcontinue;\n\n\t\tif (btf_type_is_array(mtype)) {\n\t\t\tu32 elem_idx;\n\n\t\t\t/* __btf_resolve_size() above helps to\n\t\t\t * linearize a multi-dimensional array.\n\t\t\t *\n\t\t\t * The logic here is treating an array\n\t\t\t * in a struct as the following way:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array[2][2];\n\t\t\t * };\n\t\t\t *\n\t\t\t * looks like:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array_elem0;\n\t\t\t *\tstruct inner array_elem1;\n\t\t\t *\tstruct inner array_elem2;\n\t\t\t *\tstruct inner array_elem3;\n\t\t\t * };\n\t\t\t *\n\t\t\t * When accessing outer->array[1][0], it moves\n\t\t\t * moff to \"array_elem2\", set mtype to\n\t\t\t * \"struct inner\", and msize also becomes\n\t\t\t * sizeof(struct inner).  Then most of the\n\t\t\t * remaining logic will fall through without\n\t\t\t * caring the current member is an array or\n\t\t\t * not.\n\t\t\t *\n\t\t\t * Unlike mtype/msize/moff, mtrue_end does not\n\t\t\t * change.  The naming difference (\"_true\") tells\n\t\t\t * that it is not always corresponding to\n\t\t\t * the current mtype/msize/moff.\n\t\t\t * It is the true end of the current\n\t\t\t * member (i.e. array in this case).  That\n\t\t\t * will allow an int array to be accessed like\n\t\t\t * a scratch space,\n\t\t\t * i.e. allow access beyond the size of\n\t\t\t *      the array's element as long as it is\n\t\t\t *      within the mtrue_end boundary.\n\t\t\t */\n\n\t\t\t/* skip empty array */\n\t\t\tif (moff == mtrue_end)\n\t\t\t\tcontinue;\n\n\t\t\tmsize /= total_nelems;\n\t\t\telem_idx = (off - moff) / msize;\n\t\t\tmoff += elem_idx * msize;\n\t\t\tmtype = elem_type;\n\t\t\tmid = elem_id;\n\t\t}\n\n\t\t/* the 'off' we're looking for is either equal to start\n\t\t * of this field or inside of this struct\n\t\t */\n\t\tif (btf_type_is_struct(mtype)) {\n\t\t\t/* our field must be inside that union or struct */\n\t\t\tt = mtype;\n\n\t\t\t/* return if the offset matches the member offset */\n\t\t\tif (off == moff) {\n\t\t\t\t*next_btf_id = mid;\n\t\t\t\treturn WALK_STRUCT;\n\t\t\t}\n\n\t\t\t/* adjust offset we're looking for */\n\t\t\toff -= moff;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (btf_type_is_ptr(mtype)) {\n\t\t\tconst struct btf_type *stype;\n\t\t\tu32 id;\n\n\t\t\tif (msize != size || off != moff) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"cannot access ptr member %s with moff %u in struct %s with off %u size %u\\n\",\n\t\t\t\t\tmname, moff, tname, off, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tstype = btf_type_skip_modifiers(btf, mtype->type, &id);\n\t\t\tif (btf_type_is_struct(stype)) {\n\t\t\t\t*next_btf_id = id;\n\t\t\t\treturn WALK_PTR;\n\t\t\t}\n\t\t}\n\n\t\t/* Allow more flexible access within an int as long as\n\t\t * it is within mtrue_end.\n\t\t * Since mtrue_end could be the end of an array,\n\t\t * that also allows using an array of int as a scratch\n\t\t * space. e.g. skb->cb[].\n\t\t */\n\t\tif (off + size > mtrue_end) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"access beyond the end of member %s (mend:%u) in struct %s with off %u size %u\\n\",\n\t\t\t\tmname, mtrue_end, tname, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\treturn WALK_SCALAR;\n\t}\n\tbpf_log(log, \"struct %s doesn't have field at offset %d\\n\", tname, off);\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_struct_access(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, int off, int size,\n\t\t      enum bpf_access_type atype __maybe_unused,\n\t\t      u32 *next_btf_id)\n{\n\tint err;\n\tu32 id;\n\n\tdo {\n\t\terr = btf_struct_walk(log, btf, t, off, size, &id);\n\n\t\tswitch (err) {\n\t\tcase WALK_PTR:\n\t\t\t/* If we found the pointer or scalar on t+off,\n\t\t\t * we're done.\n\t\t\t */\n\t\t\t*next_btf_id = id;\n\t\t\treturn PTR_TO_BTF_ID;\n\t\tcase WALK_SCALAR:\n\t\t\treturn SCALAR_VALUE;\n\t\tcase WALK_STRUCT:\n\t\t\t/* We found nested struct, so continue the search\n\t\t\t * by diving in it. At this point the offset is\n\t\t\t * aligned with the new type, so set it to 0.\n\t\t\t */\n\t\t\tt = btf_type_by_id(btf, id);\n\t\t\toff = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* It's either error or unknown return value..\n\t\t\t * scream and leave.\n\t\t\t */\n\t\t\tif (WARN_ONCE(err > 0, \"unknown btf_struct_walk return value\"))\n\t\t\t\treturn -EINVAL;\n\t\t\treturn err;\n\t\t}\n\t} while (t);\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "btf_struct_walk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "5027-5251",
    "snippet": "static int btf_struct_walk(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t\t   const struct btf_type *t, int off, int size,\n\t\t\t   u32 *next_btf_id)\n{\n\tu32 i, moff, mtrue_end, msize = 0, total_nelems = 0;\n\tconst struct btf_type *mtype, *elem_type = NULL;\n\tconst struct btf_member *member;\n\tconst char *tname, *mname;\n\tu32 vlen, elem_id, mid;\n\nagain:\n\ttname = __btf_name_by_offset(btf, t->name_off);\n\tif (!btf_type_is_struct(t)) {\n\t\tbpf_log(log, \"Type '%s' is not a struct\\n\", tname);\n\t\treturn -EINVAL;\n\t}\n\n\tvlen = btf_type_vlen(t);\n\tif (off + size > t->size) {\n\t\t/* If the last element is a variable size array, we may\n\t\t * need to relax the rule.\n\t\t */\n\t\tstruct btf_array *array_elem;\n\n\t\tif (vlen == 0)\n\t\t\tgoto error;\n\n\t\tmember = btf_type_member(t) + vlen - 1;\n\t\tmtype = btf_type_skip_modifiers(btf, member->type,\n\t\t\t\t\t\tNULL);\n\t\tif (!btf_type_is_array(mtype))\n\t\t\tgoto error;\n\n\t\tarray_elem = (struct btf_array *)(mtype + 1);\n\t\tif (array_elem->nelems != 0)\n\t\t\tgoto error;\n\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off < moff)\n\t\t\tgoto error;\n\n\t\t/* Only allow structure for now, can be relaxed for\n\t\t * other types later.\n\t\t */\n\t\tt = btf_type_skip_modifiers(btf, array_elem->type,\n\t\t\t\t\t    NULL);\n\t\tif (!btf_type_is_struct(t))\n\t\t\tgoto error;\n\n\t\toff = (off - moff) % t->size;\n\t\tgoto again;\n\nerror:\n\t\tbpf_log(log, \"access beyond struct %s at off %u size %u\\n\",\n\t\t\ttname, off, size);\n\t\treturn -EACCES;\n\t}\n\n\tfor_each_member(i, t, member) {\n\t\t/* offset of the field in bytes */\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off + size <= moff)\n\t\t\t/* won't find anything, field is already too far */\n\t\t\tbreak;\n\n\t\tif (__btf_member_bitfield_size(t, member)) {\n\t\t\tu32 end_bit = __btf_member_bit_offset(t, member) +\n\t\t\t\t__btf_member_bitfield_size(t, member);\n\n\t\t\t/* off <= moff instead of off == moff because clang\n\t\t\t * does not generate a BTF member for anonymous\n\t\t\t * bitfield like the \":16\" here:\n\t\t\t * struct {\n\t\t\t *\tint :16;\n\t\t\t *\tint x:8;\n\t\t\t * };\n\t\t\t */\n\t\t\tif (off <= moff &&\n\t\t\t    BITS_ROUNDUP_BYTES(end_bit) <= off + size)\n\t\t\t\treturn WALK_SCALAR;\n\n\t\t\t/* off may be accessing a following member\n\t\t\t *\n\t\t\t * or\n\t\t\t *\n\t\t\t * Doing partial access at either end of this\n\t\t\t * bitfield.  Continue on this case also to\n\t\t\t * treat it as not accessing this bitfield\n\t\t\t * and eventually error out as field not\n\t\t\t * found to keep it simple.\n\t\t\t * It could be relaxed if there was a legit\n\t\t\t * partial access case later.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* In case of \"off\" is pointing to holes of a struct */\n\t\tif (off < moff)\n\t\t\tbreak;\n\n\t\t/* type of the field */\n\t\tmid = member->type;\n\t\tmtype = btf_type_by_id(btf, member->type);\n\t\tmname = __btf_name_by_offset(btf, member->name_off);\n\n\t\tmtype = __btf_resolve_size(btf, mtype, &msize,\n\t\t\t\t\t   &elem_type, &elem_id, &total_nelems,\n\t\t\t\t\t   &mid);\n\t\tif (IS_ERR(mtype)) {\n\t\t\tbpf_log(log, \"field %s doesn't have size\\n\", mname);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tmtrue_end = moff + msize;\n\t\tif (off >= mtrue_end)\n\t\t\t/* no overlap with member, keep iterating */\n\t\t\tcontinue;\n\n\t\tif (btf_type_is_array(mtype)) {\n\t\t\tu32 elem_idx;\n\n\t\t\t/* __btf_resolve_size() above helps to\n\t\t\t * linearize a multi-dimensional array.\n\t\t\t *\n\t\t\t * The logic here is treating an array\n\t\t\t * in a struct as the following way:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array[2][2];\n\t\t\t * };\n\t\t\t *\n\t\t\t * looks like:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array_elem0;\n\t\t\t *\tstruct inner array_elem1;\n\t\t\t *\tstruct inner array_elem2;\n\t\t\t *\tstruct inner array_elem3;\n\t\t\t * };\n\t\t\t *\n\t\t\t * When accessing outer->array[1][0], it moves\n\t\t\t * moff to \"array_elem2\", set mtype to\n\t\t\t * \"struct inner\", and msize also becomes\n\t\t\t * sizeof(struct inner).  Then most of the\n\t\t\t * remaining logic will fall through without\n\t\t\t * caring the current member is an array or\n\t\t\t * not.\n\t\t\t *\n\t\t\t * Unlike mtype/msize/moff, mtrue_end does not\n\t\t\t * change.  The naming difference (\"_true\") tells\n\t\t\t * that it is not always corresponding to\n\t\t\t * the current mtype/msize/moff.\n\t\t\t * It is the true end of the current\n\t\t\t * member (i.e. array in this case).  That\n\t\t\t * will allow an int array to be accessed like\n\t\t\t * a scratch space,\n\t\t\t * i.e. allow access beyond the size of\n\t\t\t *      the array's element as long as it is\n\t\t\t *      within the mtrue_end boundary.\n\t\t\t */\n\n\t\t\t/* skip empty array */\n\t\t\tif (moff == mtrue_end)\n\t\t\t\tcontinue;\n\n\t\t\tmsize /= total_nelems;\n\t\t\telem_idx = (off - moff) / msize;\n\t\t\tmoff += elem_idx * msize;\n\t\t\tmtype = elem_type;\n\t\t\tmid = elem_id;\n\t\t}\n\n\t\t/* the 'off' we're looking for is either equal to start\n\t\t * of this field or inside of this struct\n\t\t */\n\t\tif (btf_type_is_struct(mtype)) {\n\t\t\t/* our field must be inside that union or struct */\n\t\t\tt = mtype;\n\n\t\t\t/* return if the offset matches the member offset */\n\t\t\tif (off == moff) {\n\t\t\t\t*next_btf_id = mid;\n\t\t\t\treturn WALK_STRUCT;\n\t\t\t}\n\n\t\t\t/* adjust offset we're looking for */\n\t\t\toff -= moff;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (btf_type_is_ptr(mtype)) {\n\t\t\tconst struct btf_type *stype;\n\t\t\tu32 id;\n\n\t\t\tif (msize != size || off != moff) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"cannot access ptr member %s with moff %u in struct %s with off %u size %u\\n\",\n\t\t\t\t\tmname, moff, tname, off, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tstype = btf_type_skip_modifiers(btf, mtype->type, &id);\n\t\t\tif (btf_type_is_struct(stype)) {\n\t\t\t\t*next_btf_id = id;\n\t\t\t\treturn WALK_PTR;\n\t\t\t}\n\t\t}\n\n\t\t/* Allow more flexible access within an int as long as\n\t\t * it is within mtrue_end.\n\t\t * Since mtrue_end could be the end of an array,\n\t\t * that also allows using an array of int as a scratch\n\t\t * space. e.g. skb->cb[].\n\t\t */\n\t\tif (off + size > mtrue_end) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"access beyond the end of member %s (mend:%u) in struct %s with off %u size %u\\n\",\n\t\t\t\tmname, mtrue_end, tname, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\treturn WALK_SCALAR;\n\t}\n\tbpf_log(log, \"struct %s doesn't have field at offset %d\\n\", tname, off);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"struct %s doesn't have field at offset %d\\n\"",
            "tname",
            "off"
          ],
          "line": 5249
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "stype"
          ],
          "line": 5228
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_skip_modifiers",
          "args": [
            "btf",
            "mtype->type",
            "&id"
          ],
          "line": 5227
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_skip_modifiers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "509-523",
          "snippet": "const struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "mtype"
          ],
          "line": 5217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "mtype"
          ],
          "line": 5145
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "456-459",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mtype"
          ],
          "line": 5135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_resolve_size",
          "args": [
            "btf",
            "mtype",
            "&msize",
            "&elem_type",
            "&elem_id",
            "&total_nelems",
            "&mid"
          ],
          "line": 5132
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_resolve_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1714-1781",
          "snippet": "static const struct btf_type *\n__btf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t   u32 *type_size, const struct btf_type **elem_type,\n\t\t   u32 *elem_id, u32 *total_nelems, u32 *type_id)\n{\n\tconst struct btf_type *array_type = NULL;\n\tconst struct btf_array *array = NULL;\n\tu32 i, size, nelems = 1, id = 0;\n\n\tfor (i = 0; i < MAX_RESOLVE_DEPTH; i++) {\n\t\tswitch (BTF_INFO_KIND(type->info)) {\n\t\t/* type->size can be used */\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\tcase BTF_KIND_ENUM:\n\t\tcase BTF_KIND_FLOAT:\n\t\t\tsize = type->size;\n\t\t\tgoto resolved;\n\n\t\tcase BTF_KIND_PTR:\n\t\t\tsize = sizeof(void *);\n\t\t\tgoto resolved;\n\n\t\t/* Modifiers */\n\t\tcase BTF_KIND_TYPEDEF:\n\t\tcase BTF_KIND_VOLATILE:\n\t\tcase BTF_KIND_CONST:\n\t\tcase BTF_KIND_RESTRICT:\n\t\tcase BTF_KIND_TYPE_TAG:\n\t\t\tid = type->type;\n\t\t\ttype = btf_type_by_id(btf, type->type);\n\t\t\tbreak;\n\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tif (!array_type)\n\t\t\t\tarray_type = type;\n\t\t\tarray = btf_type_array(type);\n\t\t\tif (nelems && array->nelems > U32_MAX / nelems)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\tnelems *= array->nelems;\n\t\t\ttype = btf_type_by_id(btf, array->type);\n\t\t\tbreak;\n\n\t\t/* type without size */\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n\nresolved:\n\tif (nelems && size > U32_MAX / nelems)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*type_size = nelems * size;\n\tif (total_nelems)\n\t\t*total_nelems = nelems;\n\tif (elem_type)\n\t\t*elem_type = type;\n\tif (elem_id)\n\t\t*elem_id = array ? array->type : 0;\n\tif (type_id && id)\n\t\t*type_id = id;\n\n\treturn array_type ? : type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const struct btf_type *\n__btf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t   u32 *type_size, const struct btf_type **elem_type,\n\t\t   u32 *elem_id, u32 *total_nelems, u32 *type_id)\n{\n\tconst struct btf_type *array_type = NULL;\n\tconst struct btf_array *array = NULL;\n\tu32 i, size, nelems = 1, id = 0;\n\n\tfor (i = 0; i < MAX_RESOLVE_DEPTH; i++) {\n\t\tswitch (BTF_INFO_KIND(type->info)) {\n\t\t/* type->size can be used */\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\tcase BTF_KIND_ENUM:\n\t\tcase BTF_KIND_FLOAT:\n\t\t\tsize = type->size;\n\t\t\tgoto resolved;\n\n\t\tcase BTF_KIND_PTR:\n\t\t\tsize = sizeof(void *);\n\t\t\tgoto resolved;\n\n\t\t/* Modifiers */\n\t\tcase BTF_KIND_TYPEDEF:\n\t\tcase BTF_KIND_VOLATILE:\n\t\tcase BTF_KIND_CONST:\n\t\tcase BTF_KIND_RESTRICT:\n\t\tcase BTF_KIND_TYPE_TAG:\n\t\t\tid = type->type;\n\t\t\ttype = btf_type_by_id(btf, type->type);\n\t\t\tbreak;\n\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tif (!array_type)\n\t\t\t\tarray_type = type;\n\t\t\tarray = btf_type_array(type);\n\t\t\tif (nelems && array->nelems > U32_MAX / nelems)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\tnelems *= array->nelems;\n\t\t\ttype = btf_type_by_id(btf, array->type);\n\t\t\tbreak;\n\n\t\t/* type without size */\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n\nresolved:\n\tif (nelems && size > U32_MAX / nelems)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*type_size = nelems * size;\n\tif (total_nelems)\n\t\t*total_nelems = nelems;\n\tif (elem_type)\n\t\t*elem_type = type;\n\tif (elem_id)\n\t\t*elem_id = array ? array->type : 0;\n\tif (type_id && id)\n\t\t*type_id = id;\n\n\treturn array_type ? : type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_name_by_offset",
          "args": [
            "btf",
            "member->name_off"
          ],
          "line": 5130
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "715-724",
          "snippet": "static const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "member->type"
          ],
          "line": 5129
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "end_bit"
          ],
          "line": 5105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_member_bitfield_size",
          "args": [
            "t",
            "member"
          ],
          "line": 5094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_member_bit_offset",
          "args": [
            "t",
            "member"
          ],
          "line": 5093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_member_bitfield_size",
          "args": [
            "t",
            "member"
          ],
          "line": 5092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_member_bit_offset",
          "args": [
            "t",
            "member"
          ],
          "line": 5087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_member",
          "args": [
            "i",
            "t",
            "member"
          ],
          "line": 5085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_member_bit_offset",
          "args": [
            "t",
            "member"
          ],
          "line": 5064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_member",
          "args": [
            "t"
          ],
          "line": 5054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 5044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_struct_walk(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t\t   const struct btf_type *t, int off, int size,\n\t\t\t   u32 *next_btf_id)\n{\n\tu32 i, moff, mtrue_end, msize = 0, total_nelems = 0;\n\tconst struct btf_type *mtype, *elem_type = NULL;\n\tconst struct btf_member *member;\n\tconst char *tname, *mname;\n\tu32 vlen, elem_id, mid;\n\nagain:\n\ttname = __btf_name_by_offset(btf, t->name_off);\n\tif (!btf_type_is_struct(t)) {\n\t\tbpf_log(log, \"Type '%s' is not a struct\\n\", tname);\n\t\treturn -EINVAL;\n\t}\n\n\tvlen = btf_type_vlen(t);\n\tif (off + size > t->size) {\n\t\t/* If the last element is a variable size array, we may\n\t\t * need to relax the rule.\n\t\t */\n\t\tstruct btf_array *array_elem;\n\n\t\tif (vlen == 0)\n\t\t\tgoto error;\n\n\t\tmember = btf_type_member(t) + vlen - 1;\n\t\tmtype = btf_type_skip_modifiers(btf, member->type,\n\t\t\t\t\t\tNULL);\n\t\tif (!btf_type_is_array(mtype))\n\t\t\tgoto error;\n\n\t\tarray_elem = (struct btf_array *)(mtype + 1);\n\t\tif (array_elem->nelems != 0)\n\t\t\tgoto error;\n\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off < moff)\n\t\t\tgoto error;\n\n\t\t/* Only allow structure for now, can be relaxed for\n\t\t * other types later.\n\t\t */\n\t\tt = btf_type_skip_modifiers(btf, array_elem->type,\n\t\t\t\t\t    NULL);\n\t\tif (!btf_type_is_struct(t))\n\t\t\tgoto error;\n\n\t\toff = (off - moff) % t->size;\n\t\tgoto again;\n\nerror:\n\t\tbpf_log(log, \"access beyond struct %s at off %u size %u\\n\",\n\t\t\ttname, off, size);\n\t\treturn -EACCES;\n\t}\n\n\tfor_each_member(i, t, member) {\n\t\t/* offset of the field in bytes */\n\t\tmoff = __btf_member_bit_offset(t, member) / 8;\n\t\tif (off + size <= moff)\n\t\t\t/* won't find anything, field is already too far */\n\t\t\tbreak;\n\n\t\tif (__btf_member_bitfield_size(t, member)) {\n\t\t\tu32 end_bit = __btf_member_bit_offset(t, member) +\n\t\t\t\t__btf_member_bitfield_size(t, member);\n\n\t\t\t/* off <= moff instead of off == moff because clang\n\t\t\t * does not generate a BTF member for anonymous\n\t\t\t * bitfield like the \":16\" here:\n\t\t\t * struct {\n\t\t\t *\tint :16;\n\t\t\t *\tint x:8;\n\t\t\t * };\n\t\t\t */\n\t\t\tif (off <= moff &&\n\t\t\t    BITS_ROUNDUP_BYTES(end_bit) <= off + size)\n\t\t\t\treturn WALK_SCALAR;\n\n\t\t\t/* off may be accessing a following member\n\t\t\t *\n\t\t\t * or\n\t\t\t *\n\t\t\t * Doing partial access at either end of this\n\t\t\t * bitfield.  Continue on this case also to\n\t\t\t * treat it as not accessing this bitfield\n\t\t\t * and eventually error out as field not\n\t\t\t * found to keep it simple.\n\t\t\t * It could be relaxed if there was a legit\n\t\t\t * partial access case later.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* In case of \"off\" is pointing to holes of a struct */\n\t\tif (off < moff)\n\t\t\tbreak;\n\n\t\t/* type of the field */\n\t\tmid = member->type;\n\t\tmtype = btf_type_by_id(btf, member->type);\n\t\tmname = __btf_name_by_offset(btf, member->name_off);\n\n\t\tmtype = __btf_resolve_size(btf, mtype, &msize,\n\t\t\t\t\t   &elem_type, &elem_id, &total_nelems,\n\t\t\t\t\t   &mid);\n\t\tif (IS_ERR(mtype)) {\n\t\t\tbpf_log(log, \"field %s doesn't have size\\n\", mname);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tmtrue_end = moff + msize;\n\t\tif (off >= mtrue_end)\n\t\t\t/* no overlap with member, keep iterating */\n\t\t\tcontinue;\n\n\t\tif (btf_type_is_array(mtype)) {\n\t\t\tu32 elem_idx;\n\n\t\t\t/* __btf_resolve_size() above helps to\n\t\t\t * linearize a multi-dimensional array.\n\t\t\t *\n\t\t\t * The logic here is treating an array\n\t\t\t * in a struct as the following way:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array[2][2];\n\t\t\t * };\n\t\t\t *\n\t\t\t * looks like:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array_elem0;\n\t\t\t *\tstruct inner array_elem1;\n\t\t\t *\tstruct inner array_elem2;\n\t\t\t *\tstruct inner array_elem3;\n\t\t\t * };\n\t\t\t *\n\t\t\t * When accessing outer->array[1][0], it moves\n\t\t\t * moff to \"array_elem2\", set mtype to\n\t\t\t * \"struct inner\", and msize also becomes\n\t\t\t * sizeof(struct inner).  Then most of the\n\t\t\t * remaining logic will fall through without\n\t\t\t * caring the current member is an array or\n\t\t\t * not.\n\t\t\t *\n\t\t\t * Unlike mtype/msize/moff, mtrue_end does not\n\t\t\t * change.  The naming difference (\"_true\") tells\n\t\t\t * that it is not always corresponding to\n\t\t\t * the current mtype/msize/moff.\n\t\t\t * It is the true end of the current\n\t\t\t * member (i.e. array in this case).  That\n\t\t\t * will allow an int array to be accessed like\n\t\t\t * a scratch space,\n\t\t\t * i.e. allow access beyond the size of\n\t\t\t *      the array's element as long as it is\n\t\t\t *      within the mtrue_end boundary.\n\t\t\t */\n\n\t\t\t/* skip empty array */\n\t\t\tif (moff == mtrue_end)\n\t\t\t\tcontinue;\n\n\t\t\tmsize /= total_nelems;\n\t\t\telem_idx = (off - moff) / msize;\n\t\t\tmoff += elem_idx * msize;\n\t\t\tmtype = elem_type;\n\t\t\tmid = elem_id;\n\t\t}\n\n\t\t/* the 'off' we're looking for is either equal to start\n\t\t * of this field or inside of this struct\n\t\t */\n\t\tif (btf_type_is_struct(mtype)) {\n\t\t\t/* our field must be inside that union or struct */\n\t\t\tt = mtype;\n\n\t\t\t/* return if the offset matches the member offset */\n\t\t\tif (off == moff) {\n\t\t\t\t*next_btf_id = mid;\n\t\t\t\treturn WALK_STRUCT;\n\t\t\t}\n\n\t\t\t/* adjust offset we're looking for */\n\t\t\toff -= moff;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (btf_type_is_ptr(mtype)) {\n\t\t\tconst struct btf_type *stype;\n\t\t\tu32 id;\n\n\t\t\tif (msize != size || off != moff) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"cannot access ptr member %s with moff %u in struct %s with off %u size %u\\n\",\n\t\t\t\t\tmname, moff, tname, off, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tstype = btf_type_skip_modifiers(btf, mtype->type, &id);\n\t\t\tif (btf_type_is_struct(stype)) {\n\t\t\t\t*next_btf_id = id;\n\t\t\t\treturn WALK_PTR;\n\t\t\t}\n\t\t}\n\n\t\t/* Allow more flexible access within an int as long as\n\t\t * it is within mtrue_end.\n\t\t * Since mtrue_end could be the end of an array,\n\t\t * that also allows using an array of int as a scratch\n\t\t * space. e.g. skb->cb[].\n\t\t */\n\t\tif (off + size > mtrue_end) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"access beyond the end of member %s (mend:%u) in struct %s with off %u size %u\\n\",\n\t\t\t\tmname, mtrue_end, tname, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\treturn WALK_SCALAR;\n\t}\n\tbpf_log(log, \"struct %s doesn't have field at offset %d\\n\", tname, off);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "btf_ctx_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4841-5018",
    "snippet": "bool btf_ctx_access(int off, int size, enum bpf_access_type type,\n\t\t    const struct bpf_prog *prog,\n\t\t    struct bpf_insn_access_aux *info)\n{\n\tconst struct btf_type *t = prog->aux->attach_func_proto;\n\tstruct bpf_prog *tgt_prog = prog->aux->dst_prog;\n\tstruct btf *btf = bpf_prog_get_target_btf(prog);\n\tconst char *tname = prog->aux->attach_func_name;\n\tstruct bpf_verifier_log *log = info->log;\n\tconst struct btf_param *args;\n\tu32 nr_args, arg;\n\tint i, ret;\n\n\tif (off % 8) {\n\t\tbpf_log(log, \"func '%s' offset %d is not multiple of 8\\n\",\n\t\t\ttname, off);\n\t\treturn false;\n\t}\n\targ = off / 8;\n\targs = (const struct btf_param *)(t + 1);\n\t/* if (t == NULL) Fall back to default BPF prog with\n\t * MAX_BPF_FUNC_REG_ARGS u64 arguments.\n\t */\n\tnr_args = t ? btf_type_vlen(t) : MAX_BPF_FUNC_REG_ARGS;\n\tif (prog->aux->attach_btf_trace) {\n\t\t/* skip first 'void *__data' argument in btf_trace_##name typedef */\n\t\targs++;\n\t\tnr_args--;\n\t}\n\n\tif (arg > nr_args) {\n\t\tbpf_log(log, \"func '%s' doesn't have %d-th argument\\n\",\n\t\t\ttname, arg + 1);\n\t\treturn false;\n\t}\n\n\tif (arg == nr_args) {\n\t\tswitch (prog->expected_attach_type) {\n\t\tcase BPF_LSM_MAC:\n\t\tcase BPF_TRACE_FEXIT:\n\t\t\t/* When LSM programs are attached to void LSM hooks\n\t\t\t * they use FEXIT trampolines and when attached to\n\t\t\t * int LSM hooks, they use MODIFY_RETURN trampolines.\n\t\t\t *\n\t\t\t * While the LSM programs are BPF_MODIFY_RETURN-like\n\t\t\t * the check:\n\t\t\t *\n\t\t\t *\tif (ret_type != 'int')\n\t\t\t *\t\treturn -EINVAL;\n\t\t\t *\n\t\t\t * is _not_ done here. This is still safe as LSM hooks\n\t\t\t * have only void and int return types.\n\t\t\t */\n\t\t\tif (!t)\n\t\t\t\treturn true;\n\t\t\tt = btf_type_by_id(btf, t->type);\n\t\t\tbreak;\n\t\tcase BPF_MODIFY_RETURN:\n\t\t\t/* For now the BPF_MODIFY_RETURN can only be attached to\n\t\t\t * functions that return an int.\n\t\t\t */\n\t\t\tif (!t)\n\t\t\t\treturn false;\n\n\t\t\tt = btf_type_skip_modifiers(btf, t->type, NULL);\n\t\t\tif (!btf_type_is_small_int(t)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"ret type %s not allowed for fmod_ret\\n\",\n\t\t\t\t\tbtf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbpf_log(log, \"func '%s' doesn't have %d-th argument\\n\",\n\t\t\t\ttname, arg + 1);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!t)\n\t\t\t/* Default prog with MAX_BPF_FUNC_REG_ARGS args */\n\t\t\treturn true;\n\t\tt = btf_type_by_id(btf, args[arg].type);\n\t}\n\n\t/* skip modifiers */\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (btf_type_is_small_int(t) || btf_type_is_enum(t))\n\t\t/* accessing a scalar */\n\t\treturn true;\n\tif (!btf_type_is_ptr(t)) {\n\t\tbpf_log(log,\n\t\t\t\"func '%s' arg%d '%s' has type %s. Only pointer access is allowed\\n\",\n\t\t\ttname, arg,\n\t\t\t__btf_name_by_offset(btf, t->name_off),\n\t\t\tbtf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\treturn false;\n\t}\n\n\t/* check for PTR_TO_RDONLY_BUF_OR_NULL or PTR_TO_RDWR_BUF_OR_NULL */\n\tfor (i = 0; i < prog->aux->ctx_arg_info_size; i++) {\n\t\tconst struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];\n\t\tu32 type, flag;\n\n\t\ttype = base_type(ctx_arg_info->reg_type);\n\t\tflag = type_flag(ctx_arg_info->reg_type);\n\t\tif (ctx_arg_info->offset == off && type == PTR_TO_BUF &&\n\t\t    (flag & PTR_MAYBE_NULL)) {\n\t\t\tinfo->reg_type = ctx_arg_info->reg_type;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (t->type == 0)\n\t\t/* This is a pointer to void.\n\t\t * It is the same as scalar from the verifier safety pov.\n\t\t * No further pointer walking is allowed.\n\t\t */\n\t\treturn true;\n\n\tif (is_int_ptr(btf, t))\n\t\treturn true;\n\n\t/* this is a pointer to another type */\n\tfor (i = 0; i < prog->aux->ctx_arg_info_size; i++) {\n\t\tconst struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];\n\n\t\tif (ctx_arg_info->offset == off) {\n\t\t\tif (!ctx_arg_info->btf_id) {\n\t\t\t\tbpf_log(log,\"invalid btf_id for context argument offset %u\\n\", off);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tinfo->reg_type = ctx_arg_info->reg_type;\n\t\t\tinfo->btf = btf_vmlinux;\n\t\t\tinfo->btf_id = ctx_arg_info->btf_id;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tinfo->reg_type = PTR_TO_BTF_ID;\n\tif (tgt_prog) {\n\t\tenum bpf_prog_type tgt_type;\n\n\t\tif (tgt_prog->type == BPF_PROG_TYPE_EXT)\n\t\t\ttgt_type = tgt_prog->aux->saved_dst_prog_type;\n\t\telse\n\t\t\ttgt_type = tgt_prog->type;\n\n\t\tret = btf_translate_to_vmlinux(log, btf, t, tgt_type, arg);\n\t\tif (ret > 0) {\n\t\t\tinfo->btf = btf_vmlinux;\n\t\t\tinfo->btf_id = ret;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tinfo->btf = btf;\n\tinfo->btf_id = t->type;\n\tt = btf_type_by_id(btf, t->type);\n\t/* skip modifiers */\n\twhile (btf_type_is_modifier(t)) {\n\t\tinfo->btf_id = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\tif (!btf_type_is_struct(t)) {\n\t\tbpf_log(log,\n\t\t\t\"func '%s' arg%d type %s is not a struct\\n\",\n\t\t\ttname, arg, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\treturn false;\n\t}\n\tbpf_log(log, \"func '%s' arg%d has btf_id %d type %s '%s'\\n\",\n\t\ttname, arg, info->btf_id, btf_kind_str[BTF_INFO_KIND(t->info)],\n\t\t__btf_name_by_offset(btf, t->name_off));\n\treturn true;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};",
      "extern struct btf *btf_vmlinux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"func '%s' arg%d has btf_id %d type %s '%s'\\n\"",
            "tname",
            "arg",
            "info->btf_id",
            "btf_kind_str[BTF_INFO_KIND(t->info)]",
            "__btf_name_by_offset(btf, t->name_off)"
          ],
          "line": 5014
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_name_by_offset",
          "args": [
            "btf",
            "t->name_off"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "715-724",
          "snippet": "static const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 5015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 5011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "t"
          ],
          "line": 5008
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "t->type"
          ],
          "line": 5006
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "t"
          ],
          "line": 5004
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_translate_to_vmlinux",
          "args": [
            "log",
            "btf",
            "t",
            "tgt_type",
            "arg"
          ],
          "line": 4990
        },
        "resolved": true,
        "details": {
          "function_name": "btf_translate_to_vmlinux",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4660-4673",
          "snippet": "static int btf_translate_to_vmlinux(struct bpf_verifier_log *log,\n\t\t\t\t     struct btf *btf,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     enum bpf_prog_type prog_type,\n\t\t\t\t     int arg)\n{\n\tconst struct btf_member *prog_ctx_type, *kern_ctx_type;\n\n\tprog_ctx_type = btf_get_prog_ctx_type(log, btf, t, prog_type, arg);\n\tif (!prog_ctx_type)\n\t\treturn -ENOENT;\n\tkern_ctx_type = prog_ctx_type + 1;\n\treturn kern_ctx_type->type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_translate_to_vmlinux(struct bpf_verifier_log *log,\n\t\t\t\t     struct btf *btf,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     enum bpf_prog_type prog_type,\n\t\t\t\t     int arg)\n{\n\tconst struct btf_member *prog_ctx_type, *kern_ctx_type;\n\n\tprog_ctx_type = btf_get_prog_ctx_type(log, btf, t, prog_type, arg);\n\tif (!prog_ctx_type)\n\t\treturn -ENOENT;\n\tkern_ctx_type = prog_ctx_type + 1;\n\treturn kern_ctx_type->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_int_ptr",
          "args": [
            "btf",
            "t"
          ],
          "line": 4961
        },
        "resolved": true,
        "details": {
          "function_name": "is_int_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4829-4839",
          "snippet": "static bool is_int_ptr(struct btf *btf, const struct btf_type *t)\n{\n\t/* t comes in already as a pointer */\n\tt = btf_type_by_id(btf, t->type);\n\n\t/* allow const */\n\tif (BTF_INFO_KIND(t->info) == BTF_KIND_CONST)\n\t\tt = btf_type_by_id(btf, t->type);\n\n\treturn btf_type_is_int(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool is_int_ptr(struct btf *btf, const struct btf_type *t)\n{\n\t/* t comes in already as a pointer */\n\tt = btf_type_by_id(btf, t->type);\n\n\t/* allow const */\n\tif (BTF_INFO_KIND(t->info) == BTF_KIND_CONST)\n\t\tt = btf_type_by_id(btf, t->type);\n\n\treturn btf_type_is_int(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "type_flag",
          "args": [
            "ctx_arg_info->reg_type"
          ],
          "line": 4946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base_type",
          "args": [
            "ctx_arg_info->reg_type"
          ],
          "line": 4945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 4936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t"
          ],
          "line": 4931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_enum",
          "args": [
            "t"
          ],
          "line": 4928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_small_int",
          "args": [
            "t"
          ],
          "line": 4928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 4909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_small_int",
          "args": [
            "t"
          ],
          "line": 4906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_skip_modifiers",
          "args": [
            "btf",
            "t->type",
            "NULL"
          ],
          "line": 4905
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_skip_modifiers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "509-523",
          "snippet": "const struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 4864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_target_btf",
          "args": [
            "prog"
          ],
          "line": 4847
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_target_btf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4819-4827",
          "snippet": "struct btf *bpf_prog_get_target_btf(const struct bpf_prog *prog)\n{\n\tstruct bpf_prog *tgt_prog = prog->aux->dst_prog;\n\n\tif (tgt_prog)\n\t\treturn tgt_prog->aux->btf;\n\telse\n\t\treturn prog->aux->attach_btf;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstruct btf *bpf_prog_get_target_btf(const struct bpf_prog *prog)\n{\n\tstruct bpf_prog *tgt_prog = prog->aux->dst_prog;\n\n\tif (tgt_prog)\n\t\treturn tgt_prog->aux->btf;\n\telse\n\t\treturn prog->aux->attach_btf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\nextern struct btf *btf_vmlinux;\n\nbool btf_ctx_access(int off, int size, enum bpf_access_type type,\n\t\t    const struct bpf_prog *prog,\n\t\t    struct bpf_insn_access_aux *info)\n{\n\tconst struct btf_type *t = prog->aux->attach_func_proto;\n\tstruct bpf_prog *tgt_prog = prog->aux->dst_prog;\n\tstruct btf *btf = bpf_prog_get_target_btf(prog);\n\tconst char *tname = prog->aux->attach_func_name;\n\tstruct bpf_verifier_log *log = info->log;\n\tconst struct btf_param *args;\n\tu32 nr_args, arg;\n\tint i, ret;\n\n\tif (off % 8) {\n\t\tbpf_log(log, \"func '%s' offset %d is not multiple of 8\\n\",\n\t\t\ttname, off);\n\t\treturn false;\n\t}\n\targ = off / 8;\n\targs = (const struct btf_param *)(t + 1);\n\t/* if (t == NULL) Fall back to default BPF prog with\n\t * MAX_BPF_FUNC_REG_ARGS u64 arguments.\n\t */\n\tnr_args = t ? btf_type_vlen(t) : MAX_BPF_FUNC_REG_ARGS;\n\tif (prog->aux->attach_btf_trace) {\n\t\t/* skip first 'void *__data' argument in btf_trace_##name typedef */\n\t\targs++;\n\t\tnr_args--;\n\t}\n\n\tif (arg > nr_args) {\n\t\tbpf_log(log, \"func '%s' doesn't have %d-th argument\\n\",\n\t\t\ttname, arg + 1);\n\t\treturn false;\n\t}\n\n\tif (arg == nr_args) {\n\t\tswitch (prog->expected_attach_type) {\n\t\tcase BPF_LSM_MAC:\n\t\tcase BPF_TRACE_FEXIT:\n\t\t\t/* When LSM programs are attached to void LSM hooks\n\t\t\t * they use FEXIT trampolines and when attached to\n\t\t\t * int LSM hooks, they use MODIFY_RETURN trampolines.\n\t\t\t *\n\t\t\t * While the LSM programs are BPF_MODIFY_RETURN-like\n\t\t\t * the check:\n\t\t\t *\n\t\t\t *\tif (ret_type != 'int')\n\t\t\t *\t\treturn -EINVAL;\n\t\t\t *\n\t\t\t * is _not_ done here. This is still safe as LSM hooks\n\t\t\t * have only void and int return types.\n\t\t\t */\n\t\t\tif (!t)\n\t\t\t\treturn true;\n\t\t\tt = btf_type_by_id(btf, t->type);\n\t\t\tbreak;\n\t\tcase BPF_MODIFY_RETURN:\n\t\t\t/* For now the BPF_MODIFY_RETURN can only be attached to\n\t\t\t * functions that return an int.\n\t\t\t */\n\t\t\tif (!t)\n\t\t\t\treturn false;\n\n\t\t\tt = btf_type_skip_modifiers(btf, t->type, NULL);\n\t\t\tif (!btf_type_is_small_int(t)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"ret type %s not allowed for fmod_ret\\n\",\n\t\t\t\t\tbtf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbpf_log(log, \"func '%s' doesn't have %d-th argument\\n\",\n\t\t\t\ttname, arg + 1);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!t)\n\t\t\t/* Default prog with MAX_BPF_FUNC_REG_ARGS args */\n\t\t\treturn true;\n\t\tt = btf_type_by_id(btf, args[arg].type);\n\t}\n\n\t/* skip modifiers */\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (btf_type_is_small_int(t) || btf_type_is_enum(t))\n\t\t/* accessing a scalar */\n\t\treturn true;\n\tif (!btf_type_is_ptr(t)) {\n\t\tbpf_log(log,\n\t\t\t\"func '%s' arg%d '%s' has type %s. Only pointer access is allowed\\n\",\n\t\t\ttname, arg,\n\t\t\t__btf_name_by_offset(btf, t->name_off),\n\t\t\tbtf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\treturn false;\n\t}\n\n\t/* check for PTR_TO_RDONLY_BUF_OR_NULL or PTR_TO_RDWR_BUF_OR_NULL */\n\tfor (i = 0; i < prog->aux->ctx_arg_info_size; i++) {\n\t\tconst struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];\n\t\tu32 type, flag;\n\n\t\ttype = base_type(ctx_arg_info->reg_type);\n\t\tflag = type_flag(ctx_arg_info->reg_type);\n\t\tif (ctx_arg_info->offset == off && type == PTR_TO_BUF &&\n\t\t    (flag & PTR_MAYBE_NULL)) {\n\t\t\tinfo->reg_type = ctx_arg_info->reg_type;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (t->type == 0)\n\t\t/* This is a pointer to void.\n\t\t * It is the same as scalar from the verifier safety pov.\n\t\t * No further pointer walking is allowed.\n\t\t */\n\t\treturn true;\n\n\tif (is_int_ptr(btf, t))\n\t\treturn true;\n\n\t/* this is a pointer to another type */\n\tfor (i = 0; i < prog->aux->ctx_arg_info_size; i++) {\n\t\tconst struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];\n\n\t\tif (ctx_arg_info->offset == off) {\n\t\t\tif (!ctx_arg_info->btf_id) {\n\t\t\t\tbpf_log(log,\"invalid btf_id for context argument offset %u\\n\", off);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tinfo->reg_type = ctx_arg_info->reg_type;\n\t\t\tinfo->btf = btf_vmlinux;\n\t\t\tinfo->btf_id = ctx_arg_info->btf_id;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tinfo->reg_type = PTR_TO_BTF_ID;\n\tif (tgt_prog) {\n\t\tenum bpf_prog_type tgt_type;\n\n\t\tif (tgt_prog->type == BPF_PROG_TYPE_EXT)\n\t\t\ttgt_type = tgt_prog->aux->saved_dst_prog_type;\n\t\telse\n\t\t\ttgt_type = tgt_prog->type;\n\n\t\tret = btf_translate_to_vmlinux(log, btf, t, tgt_type, arg);\n\t\tif (ret > 0) {\n\t\t\tinfo->btf = btf_vmlinux;\n\t\t\tinfo->btf_id = ret;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tinfo->btf = btf;\n\tinfo->btf_id = t->type;\n\tt = btf_type_by_id(btf, t->type);\n\t/* skip modifiers */\n\twhile (btf_type_is_modifier(t)) {\n\t\tinfo->btf_id = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\tif (!btf_type_is_struct(t)) {\n\t\tbpf_log(log,\n\t\t\t\"func '%s' arg%d type %s is not a struct\\n\",\n\t\t\ttname, arg, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\treturn false;\n\t}\n\tbpf_log(log, \"func '%s' arg%d has btf_id %d type %s '%s'\\n\",\n\t\ttname, arg, info->btf_id, btf_kind_str[BTF_INFO_KIND(t->info)],\n\t\t__btf_name_by_offset(btf, t->name_off));\n\treturn true;\n}"
  },
  {
    "function_name": "is_int_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4829-4839",
    "snippet": "static bool is_int_ptr(struct btf *btf, const struct btf_type *t)\n{\n\t/* t comes in already as a pointer */\n\tt = btf_type_by_id(btf, t->type);\n\n\t/* allow const */\n\tif (BTF_INFO_KIND(t->info) == BTF_KIND_CONST)\n\t\tt = btf_type_by_id(btf, t->type);\n\n\treturn btf_type_is_int(t);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_int",
          "args": [
            "t"
          ],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "t->type"
          ],
          "line": 4836
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 4835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool is_int_ptr(struct btf *btf, const struct btf_type *t)\n{\n\t/* t comes in already as a pointer */\n\tt = btf_type_by_id(btf, t->type);\n\n\t/* allow const */\n\tif (BTF_INFO_KIND(t->info) == BTF_KIND_CONST)\n\t\tt = btf_type_by_id(btf, t->type);\n\n\treturn btf_type_is_int(t);\n}"
  },
  {
    "function_name": "bpf_prog_get_target_btf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4819-4827",
    "snippet": "struct btf *bpf_prog_get_target_btf(const struct bpf_prog *prog)\n{\n\tstruct bpf_prog *tgt_prog = prog->aux->dst_prog;\n\n\tif (tgt_prog)\n\t\treturn tgt_prog->aux->btf;\n\telse\n\t\treturn prog->aux->attach_btf;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstruct btf *bpf_prog_get_target_btf(const struct bpf_prog *prog)\n{\n\tstruct bpf_prog *tgt_prog = prog->aux->dst_prog;\n\n\tif (tgt_prog)\n\t\treturn tgt_prog->aux->btf;\n\telse\n\t\treturn prog->aux->attach_btf;\n}"
  },
  {
    "function_name": "btf_parse_module",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4748-4815",
    "snippet": "static struct btf *btf_parse_module(const char *module_name, const void *data, unsigned int data_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL, *base_btf;\n\tint err;\n\n\tbase_btf = bpf_get_btf_vmlinux();\n\tif (IS_ERR(base_btf))\n\t\treturn base_btf;\n\tif (!base_btf)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tlog->level = BPF_LOG_KERNEL;\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tbtf->base_btf = base_btf;\n\tbtf->start_id = base_btf->nr_types;\n\tbtf->start_str_off = base_btf->hdr.str_len;\n\tbtf->kernel_btf = true;\n\tsnprintf(btf->name, sizeof(btf->name), \"%s\", module_name);\n\n\tbtf->data = kvmalloc(data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf->data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tmemcpy(btf->data, data, data_size);\n\tbtf->data_size = data_size;\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf) {\n\t\tkvfree(btf->data);\n\t\tkvfree(btf->types);\n\t\tkfree(btf);\n\t}\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 4814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "btf"
          ],
          "line": 4812
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->types"
          ],
          "line": 4811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->data"
          ],
          "line": 4810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_env_free",
          "args": [
            "env"
          ],
          "line": 4808
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_env_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1599-1603",
          "snippet": "static void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&btf->refcnt",
            "1"
          ],
          "line": 4804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_check_all_metas",
          "args": [
            "env"
          ],
          "line": 4799
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_all_metas",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4119-4144",
          "snippet": "static int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = btf->base_btf ? btf->start_id : 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = btf->base_btf ? btf->start_id : 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_parse_str_sec",
          "args": [
            "env"
          ],
          "line": 4795
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse_str_sec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4283-4312",
          "snippet": "static int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\tif (btf->base_btf && !hdr->str_len)\n\t\treturn 0;\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\tif (!btf->base_btf && start[0]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\tif (btf->base_btf && !hdr->str_len)\n\t\treturn 0;\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\tif (!btf->base_btf && start[0]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_parse_hdr",
          "args": [
            "env"
          ],
          "line": 4789
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse_hdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4380-4448",
          "snippet": "static int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!btf->base_btf && btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!btf->base_btf && btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "btf->data",
            "data",
            "data_size"
          ],
          "line": 4786
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "data_size",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 4781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "btf->name",
            "sizeof(btf->name)",
            "\"%s\"",
            "module_name"
          ],
          "line": 4779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*btf)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*env)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 4761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 4759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "base_btf"
          ],
          "line": 4756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_get_btf_vmlinux",
          "args": [],
          "line": 4755
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_btf_vmlinux",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "14201-14210",
          "snippet": "struct btf *bpf_get_btf_vmlinux(void)\n{\n\tif (!btf_vmlinux && IS_ENABLED(CONFIG_DEBUG_INFO_BTF)) {\n\t\tmutex_lock(&bpf_verifier_lock);\n\t\tif (!btf_vmlinux)\n\t\t\tbtf_vmlinux = btf_parse_vmlinux();\n\t\tmutex_unlock(&bpf_verifier_lock);\n\t}\n\treturn btf_vmlinux;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct btf *btf_vmlinux;",
            "static DEFINE_MUTEX(bpf_verifier_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstruct btf *btf_vmlinux;\nstatic DEFINE_MUTEX(bpf_verifier_lock);\n\nstruct btf *bpf_get_btf_vmlinux(void)\n{\n\tif (!btf_vmlinux && IS_ENABLED(CONFIG_DEBUG_INFO_BTF)) {\n\t\tmutex_lock(&bpf_verifier_lock);\n\t\tif (!btf_vmlinux)\n\t\t\tbtf_vmlinux = btf_parse_vmlinux();\n\t\tmutex_unlock(&bpf_verifier_lock);\n\t}\n\treturn btf_vmlinux;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf *btf_parse_module(const char *module_name, const void *data, unsigned int data_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL, *base_btf;\n\tint err;\n\n\tbase_btf = bpf_get_btf_vmlinux();\n\tif (IS_ERR(base_btf))\n\t\treturn base_btf;\n\tif (!base_btf)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tlog->level = BPF_LOG_KERNEL;\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tbtf->base_btf = base_btf;\n\tbtf->start_id = base_btf->nr_types;\n\tbtf->start_str_off = base_btf->hdr.str_len;\n\tbtf->kernel_btf = true;\n\tsnprintf(btf->name, sizeof(btf->name), \"%s\", module_name);\n\n\tbtf->data = kvmalloc(data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf->data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tmemcpy(btf->data, data, data_size);\n\tbtf->data_size = data_size;\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf) {\n\t\tkvfree(btf->data);\n\t\tkvfree(btf->types);\n\t\tkfree(btf);\n\t}\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "BTF_ID",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4675-4744",
    "snippet": "BTF_ID_LIST(bpf_ctx_convert_btf_id)\nBTF_ID(struct, bpf_ctx_convert)\n\nstruct btf *btf_parse_vmlinux(void)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tint err;\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tlog->level = BPF_LOG_KERNEL;\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tbtf->data = __start_BTF;\n\tbtf->data_size = __stop_BTF - __start_BTF;\n\tbtf->kernel_btf = true;\n\tsnprintf(btf->name, sizeof(btf->name), \"vmlinux\");\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\tgoto errout;\n\n\t/* btf_parse_vmlinux() runs under bpf_verifier_lock */\n\tbpf_ctx_convert.t = btf_type_by_id(btf, bpf_ctx_convert_btf_id[0]);\n\n\t/* find bpf map structs for map_ptr access checking */\n\terr = btf_vmlinux_map_ids_init(btf, log);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tbpf_struct_ops_init(btf, log);\n\n\trefcount_set(&btf->refcnt, 1);\n\n\terr = btf_alloc_id(btf);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf_verifier_env_free(env);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf) {\n\t\tkvfree(btf->types);\n\t\tkfree(btf);\n\t}\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern char __weak __start_BTF[];",
      "extern char __weak __stop_BTF[];",
      "static union {\n\tstruct bpf_ctx_convert {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\tprog_ctx_type _id##_prog; \\\n\tkern_ctx_type _id##_kern;\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t} *__t;\n\t/* 't' is written once under lock. Read many times. */\n\tconst struct btf_type *t;\n} bpf_ctx_convert;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "btf"
          ],
          "line": 4741
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->types"
          ],
          "line": 4740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_env_free",
          "args": [
            "env"
          ],
          "line": 4738
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_env_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1599-1603",
          "snippet": "static void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_alloc_id",
          "args": [
            "btf"
          ],
          "line": 4730
        },
        "resolved": true,
        "details": {
          "function_name": "btf_alloc_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1498-1514",
          "snippet": "static int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&btf->refcnt",
            "1"
          ],
          "line": 4728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_struct_ops_init",
          "args": [
            "btf",
            "log"
          ],
          "line": 4726
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_struct_ops_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_struct_ops.c",
          "lines": "103-200",
          "snippet": "void bpf_struct_ops_init(struct btf *btf, struct bpf_verifier_log *log)\n{\n\ts32 type_id, value_id, module_id;\n\tconst struct btf_member *member;\n\tstruct bpf_struct_ops *st_ops;\n\tconst struct btf_type *t;\n\tchar value_name[128];\n\tconst char *mname;\n\tu32 i, j;\n\n\t/* Ensure BTF type is emitted for \"struct bpf_struct_ops_##_name\" */\n#define BPF_STRUCT_OPS_TYPE(_name) BTF_TYPE_EMIT(struct bpf_struct_ops_##_name);\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n\n\tmodule_id = btf_find_by_name_kind(btf, \"module\", BTF_KIND_STRUCT);\n\tif (module_id < 0) {\n\t\tpr_warn(\"Cannot find struct module in btf_vmlinux\\n\");\n\t\treturn;\n\t}\n\tmodule_type = btf_type_by_id(btf, module_id);\n\n\tfor (i = 0; i < ARRAY_SIZE(bpf_struct_ops); i++) {\n\t\tst_ops = bpf_struct_ops[i];\n\n\t\tif (strlen(st_ops->name) + VALUE_PREFIX_LEN >=\n\t\t    sizeof(value_name)) {\n\t\t\tpr_warn(\"struct_ops name %s is too long\\n\",\n\t\t\t\tst_ops->name);\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(value_name, \"%s%s\", VALUE_PREFIX, st_ops->name);\n\n\t\tvalue_id = btf_find_by_name_kind(btf, value_name,\n\t\t\t\t\t\t BTF_KIND_STRUCT);\n\t\tif (value_id < 0) {\n\t\t\tpr_warn(\"Cannot find struct %s in btf_vmlinux\\n\",\n\t\t\t\tvalue_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttype_id = btf_find_by_name_kind(btf, st_ops->name,\n\t\t\t\t\t\tBTF_KIND_STRUCT);\n\t\tif (type_id < 0) {\n\t\t\tpr_warn(\"Cannot find struct %s in btf_vmlinux\\n\",\n\t\t\t\tst_ops->name);\n\t\t\tcontinue;\n\t\t}\n\t\tt = btf_type_by_id(btf, type_id);\n\t\tif (btf_type_vlen(t) > BPF_STRUCT_OPS_MAX_NR_MEMBERS) {\n\t\t\tpr_warn(\"Cannot support #%u members in struct %s\\n\",\n\t\t\t\tbtf_type_vlen(t), st_ops->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_member(j, t, member) {\n\t\t\tconst struct btf_type *func_proto;\n\n\t\t\tmname = btf_name_by_offset(btf, member->name_off);\n\t\t\tif (!*mname) {\n\t\t\t\tpr_warn(\"anon member in struct %s is not supported\\n\",\n\t\t\t\t\tst_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (__btf_member_bitfield_size(t, member)) {\n\t\t\t\tpr_warn(\"bit field member %s in struct %s is not supported\\n\",\n\t\t\t\t\tmname, st_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfunc_proto = btf_type_resolve_func_ptr(btf,\n\t\t\t\t\t\t\t       member->type,\n\t\t\t\t\t\t\t       NULL);\n\t\t\tif (func_proto &&\n\t\t\t    btf_distill_func_proto(log, btf,\n\t\t\t\t\t\t   func_proto, mname,\n\t\t\t\t\t\t   &st_ops->func_models[j])) {\n\t\t\t\tpr_warn(\"Error in parsing func ptr %s in struct %s\\n\",\n\t\t\t\t\tmname, st_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (j == btf_type_vlen(t)) {\n\t\t\tif (st_ops->init(btf)) {\n\t\t\t\tpr_warn(\"Error in init bpf_struct_ops %s\\n\",\n\t\t\t\t\tst_ops->name);\n\t\t\t} else {\n\t\t\t\tst_ops->type_id = type_id;\n\t\t\t\tst_ops->type = t;\n\t\t\t\tst_ops->value_id = value_id;\n\t\t\t\tst_ops->value_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\t    value_id);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include \"bpf_struct_ops_types.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/refcount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/numa.h>",
            "#include <linux/slab.h>",
            "#include <linux/filter.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define VALUE_PREFIX_LEN (sizeof(VALUE_PREFIX) - 1)",
            "#define VALUE_PREFIX \"bpf_struct_ops_\""
          ],
          "globals_used": [
            "static struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};",
            "static const struct btf_type *module_type;",
            "extern struct btf *btf_vmlinux;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include \"bpf_struct_ops_types.h\"\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/seq_file.h>\n#include <linux/numa.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\n#define VALUE_PREFIX_LEN (sizeof(VALUE_PREFIX) - 1)\n#define VALUE_PREFIX \"bpf_struct_ops_\"\n\nstatic struct bpf_struct_ops * const bpf_struct_ops[] = {\n#define BPF_STRUCT_OPS_TYPE(_name)\t\t\t\t\\\n\t[BPF_STRUCT_OPS_TYPE_##_name] = &bpf_##_name,\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n};\nstatic const struct btf_type *module_type;\nextern struct btf *btf_vmlinux;\n\nvoid bpf_struct_ops_init(struct btf *btf, struct bpf_verifier_log *log)\n{\n\ts32 type_id, value_id, module_id;\n\tconst struct btf_member *member;\n\tstruct bpf_struct_ops *st_ops;\n\tconst struct btf_type *t;\n\tchar value_name[128];\n\tconst char *mname;\n\tu32 i, j;\n\n\t/* Ensure BTF type is emitted for \"struct bpf_struct_ops_##_name\" */\n#define BPF_STRUCT_OPS_TYPE(_name) BTF_TYPE_EMIT(struct bpf_struct_ops_##_name);\n#include \"bpf_struct_ops_types.h\"\n#undef BPF_STRUCT_OPS_TYPE\n\n\tmodule_id = btf_find_by_name_kind(btf, \"module\", BTF_KIND_STRUCT);\n\tif (module_id < 0) {\n\t\tpr_warn(\"Cannot find struct module in btf_vmlinux\\n\");\n\t\treturn;\n\t}\n\tmodule_type = btf_type_by_id(btf, module_id);\n\n\tfor (i = 0; i < ARRAY_SIZE(bpf_struct_ops); i++) {\n\t\tst_ops = bpf_struct_ops[i];\n\n\t\tif (strlen(st_ops->name) + VALUE_PREFIX_LEN >=\n\t\t    sizeof(value_name)) {\n\t\t\tpr_warn(\"struct_ops name %s is too long\\n\",\n\t\t\t\tst_ops->name);\n\t\t\tcontinue;\n\t\t}\n\t\tsprintf(value_name, \"%s%s\", VALUE_PREFIX, st_ops->name);\n\n\t\tvalue_id = btf_find_by_name_kind(btf, value_name,\n\t\t\t\t\t\t BTF_KIND_STRUCT);\n\t\tif (value_id < 0) {\n\t\t\tpr_warn(\"Cannot find struct %s in btf_vmlinux\\n\",\n\t\t\t\tvalue_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttype_id = btf_find_by_name_kind(btf, st_ops->name,\n\t\t\t\t\t\tBTF_KIND_STRUCT);\n\t\tif (type_id < 0) {\n\t\t\tpr_warn(\"Cannot find struct %s in btf_vmlinux\\n\",\n\t\t\t\tst_ops->name);\n\t\t\tcontinue;\n\t\t}\n\t\tt = btf_type_by_id(btf, type_id);\n\t\tif (btf_type_vlen(t) > BPF_STRUCT_OPS_MAX_NR_MEMBERS) {\n\t\t\tpr_warn(\"Cannot support #%u members in struct %s\\n\",\n\t\t\t\tbtf_type_vlen(t), st_ops->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_member(j, t, member) {\n\t\t\tconst struct btf_type *func_proto;\n\n\t\t\tmname = btf_name_by_offset(btf, member->name_off);\n\t\t\tif (!*mname) {\n\t\t\t\tpr_warn(\"anon member in struct %s is not supported\\n\",\n\t\t\t\t\tst_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (__btf_member_bitfield_size(t, member)) {\n\t\t\t\tpr_warn(\"bit field member %s in struct %s is not supported\\n\",\n\t\t\t\t\tmname, st_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfunc_proto = btf_type_resolve_func_ptr(btf,\n\t\t\t\t\t\t\t       member->type,\n\t\t\t\t\t\t\t       NULL);\n\t\t\tif (func_proto &&\n\t\t\t    btf_distill_func_proto(log, btf,\n\t\t\t\t\t\t   func_proto, mname,\n\t\t\t\t\t\t   &st_ops->func_models[j])) {\n\t\t\t\tpr_warn(\"Error in parsing func ptr %s in struct %s\\n\",\n\t\t\t\t\tmname, st_ops->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (j == btf_type_vlen(t)) {\n\t\t\tif (st_ops->init(btf)) {\n\t\t\t\tpr_warn(\"Error in init bpf_struct_ops %s\\n\",\n\t\t\t\t\tst_ops->name);\n\t\t\t} else {\n\t\t\t\tst_ops->type_id = type_id;\n\t\t\t\tst_ops->type = t;\n\t\t\t\tst_ops->value_id = value_id;\n\t\t\t\tst_ops->value_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\t    value_id);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_vmlinux_map_ids_init",
          "args": [
            "btf",
            "log"
          ],
          "line": 4722
        },
        "resolved": true,
        "details": {
          "function_name": "btf_vmlinux_map_ids_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4636-4658",
          "snippet": "static int btf_vmlinux_map_ids_init(const struct btf *btf,\n\t\t\t\t    struct bpf_verifier_log *log)\n{\n\tconst struct bpf_map_ops *ops;\n\tint i, btf_id;\n\n\tfor (i = 0; i < ARRAY_SIZE(btf_vmlinux_map_ops); ++i) {\n\t\tops = btf_vmlinux_map_ops[i];\n\t\tif (!ops || (!ops->map_btf_name && !ops->map_btf_id))\n\t\t\tcontinue;\n\t\tif (!ops->map_btf_name || !ops->map_btf_id) {\n\t\t\tbpf_log(log, \"map type %d is misconfigured\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbtf_id = btf_find_by_name_kind(btf, ops->map_btf_name,\n\t\t\t\t\t       BTF_KIND_STRUCT);\n\t\tif (btf_id < 0)\n\t\t\treturn btf_id;\n\t\t*ops->map_btf_id = btf_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_map_ops * const btf_vmlinux_map_ops[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)\n#define BPF_LINK_TYPE(_id, _name)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_LINK_TYPE\n#undef BPF_MAP_TYPE\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct bpf_map_ops * const btf_vmlinux_map_ops[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)\n#define BPF_LINK_TYPE(_id, _name)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_LINK_TYPE\n#undef BPF_MAP_TYPE\n};\n\nstatic int btf_vmlinux_map_ids_init(const struct btf *btf,\n\t\t\t\t    struct bpf_verifier_log *log)\n{\n\tconst struct bpf_map_ops *ops;\n\tint i, btf_id;\n\n\tfor (i = 0; i < ARRAY_SIZE(btf_vmlinux_map_ops); ++i) {\n\t\tops = btf_vmlinux_map_ops[i];\n\t\tif (!ops || (!ops->map_btf_name && !ops->map_btf_id))\n\t\t\tcontinue;\n\t\tif (!ops->map_btf_name || !ops->map_btf_id) {\n\t\t\tbpf_log(log, \"map type %d is misconfigured\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbtf_id = btf_find_by_name_kind(btf, ops->map_btf_name,\n\t\t\t\t\t       BTF_KIND_STRUCT);\n\t\tif (btf_id < 0)\n\t\t\treturn btf_id;\n\t\t*ops->map_btf_id = btf_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "bpf_ctx_convert_btf_id[0]"
          ],
          "line": 4719
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_check_all_metas",
          "args": [
            "env"
          ],
          "line": 4714
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_all_metas",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4119-4144",
          "snippet": "static int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = btf->base_btf ? btf->start_id : 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = btf->base_btf ? btf->start_id : 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_parse_str_sec",
          "args": [
            "env"
          ],
          "line": 4710
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse_str_sec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4283-4312",
          "snippet": "static int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\tif (btf->base_btf && !hdr->str_len)\n\t\treturn 0;\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\tif (!btf->base_btf && start[0]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\tif (btf->base_btf && !hdr->str_len)\n\t\treturn 0;\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\tif (!btf->base_btf && start[0]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_parse_hdr",
          "args": [
            "env"
          ],
          "line": 4704
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse_hdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4380-4448",
          "snippet": "static int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!btf->base_btf && btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!btf->base_btf && btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "btf->name",
            "sizeof(btf->name)",
            "\"vmlinux\""
          ],
          "line": 4702
        },
        "resolved": true,
        "details": {
          "function_name": "btf_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5972-5992",
          "snippet": "static void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*btf)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 4692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*env)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 4685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_parse_vmlinux",
          "args": [
            "void"
          ],
          "line": 4678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nextern char __weak __start_BTF[];\nextern char __weak __stop_BTF[];\nstatic union {\n\tstruct bpf_ctx_convert {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\tprog_ctx_type _id##_prog; \\\n\tkern_ctx_type _id##_kern;\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t} *__t;\n\t/* 't' is written once under lock. Read many times. */\n\tconst struct btf_type *t;\n} bpf_ctx_convert;\n\nBTF_ID_LIST(bpf_ctx_convert_btf_id)\nBTF_ID(struct, bpf_ctx_convert)\n\nstruct btf *btf_parse_vmlinux(void)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tint err;\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tlog->level = BPF_LOG_KERNEL;\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tbtf->data = __start_BTF;\n\tbtf->data_size = __stop_BTF - __start_BTF;\n\tbtf->kernel_btf = true;\n\tsnprintf(btf->name, sizeof(btf->name), \"vmlinux\");\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\tgoto errout;\n\n\t/* btf_parse_vmlinux() runs under bpf_verifier_lock */\n\tbpf_ctx_convert.t = btf_type_by_id(btf, bpf_ctx_convert_btf_id[0]);\n\n\t/* find bpf map structs for map_ptr access checking */\n\terr = btf_vmlinux_map_ids_init(btf, log);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tbpf_struct_ops_init(btf, log);\n\n\trefcount_set(&btf->refcnt, 1);\n\n\terr = btf_alloc_id(btf);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf_verifier_env_free(env);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf) {\n\t\tkvfree(btf->types);\n\t\tkfree(btf);\n\t}\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "btf_translate_to_vmlinux",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4660-4673",
    "snippet": "static int btf_translate_to_vmlinux(struct bpf_verifier_log *log,\n\t\t\t\t     struct btf *btf,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     enum bpf_prog_type prog_type,\n\t\t\t\t     int arg)\n{\n\tconst struct btf_member *prog_ctx_type, *kern_ctx_type;\n\n\tprog_ctx_type = btf_get_prog_ctx_type(log, btf, t, prog_type, arg);\n\tif (!prog_ctx_type)\n\t\treturn -ENOENT;\n\tkern_ctx_type = prog_ctx_type + 1;\n\treturn kern_ctx_type->type;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_get_prog_ctx_type",
          "args": [
            "log",
            "btf",
            "t",
            "prog_type",
            "arg"
          ],
          "line": 4668
        },
        "resolved": true,
        "details": {
          "function_name": "btf_get_prog_ctx_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4567-4623",
          "snippet": "static const struct btf_member *\nbtf_get_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, enum bpf_prog_type prog_type,\n\t\t      int arg)\n{\n\tconst struct btf_type *conv_struct;\n\tconst struct btf_type *ctx_struct;\n\tconst struct btf_member *ctx_type;\n\tconst char *tname, *ctx_tname;\n\n\tconv_struct = bpf_ctx_convert.t;\n\tif (!conv_struct) {\n\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");\n\t\treturn NULL;\n\t}\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_struct(t)) {\n\t\t/* Only pointer to struct is supported for now.\n\t\t * That means that BPF_PROG_TYPE_TRACEPOINT with BTF\n\t\t * is not supported yet.\n\t\t * BPF_PROG_TYPE_RAW_TRACEPOINT is fine.\n\t\t */\n\t\treturn NULL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"arg#%d struct doesn't have a name\\n\", arg);\n\t\treturn NULL;\n\t}\n\t/* prog_type is valid bpf program type. No need for bounds check. */\n\tctx_type = btf_type_member(conv_struct) + bpf_ctx_convert_map[prog_type] * 2;\n\t/* ctx_struct is a pointer to prog_ctx_type in vmlinux.\n\t * Like 'struct __sk_buff'\n\t */\n\tctx_struct = btf_type_by_id(btf_vmlinux, ctx_type->type);\n\tif (!ctx_struct)\n\t\t/* should not happen */\n\t\treturn NULL;\n\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_struct->name_off);\n\tif (!ctx_tname) {\n\t\t/* should not happen */\n\t\tbpf_log(log, \"Please fix kernel include/linux/bpf_types.h\\n\");\n\t\treturn NULL;\n\t}\n\t/* only compare that prog's ctx type name is the same as\n\t * kernel expects. No need to compare field by field.\n\t * It's ok for bpf prog to do:\n\t * struct __sk_buff {};\n\t * int socket_filter_bpf_prog(struct __sk_buff *skb)\n\t * { // no fields of skb are ever used }\n\t */\n\tif (strcmp(ctx_tname, tname))\n\t\treturn NULL;\n\treturn ctx_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct btf *btf_vmlinux;",
            "static union {\n\tstruct bpf_ctx_convert {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\tprog_ctx_type _id##_prog; \\\n\tkern_ctx_type _id##_kern;\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t} *__t;\n\t/* 't' is written once under lock. Read many times. */\n\tconst struct btf_type *t;\n} bpf_ctx_convert;",
            "static u8 bpf_ctx_convert_map[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = __ctx_convert##_id,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t0, /* avoid empty array */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nextern struct btf *btf_vmlinux;\nstatic union {\n\tstruct bpf_ctx_convert {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\tprog_ctx_type _id##_prog; \\\n\tkern_ctx_type _id##_kern;\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t} *__t;\n\t/* 't' is written once under lock. Read many times. */\n\tconst struct btf_type *t;\n} bpf_ctx_convert;\nstatic u8 bpf_ctx_convert_map[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = __ctx_convert##_id,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t0, /* avoid empty array */\n};\n\nstatic const struct btf_member *\nbtf_get_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, enum bpf_prog_type prog_type,\n\t\t      int arg)\n{\n\tconst struct btf_type *conv_struct;\n\tconst struct btf_type *ctx_struct;\n\tconst struct btf_member *ctx_type;\n\tconst char *tname, *ctx_tname;\n\n\tconv_struct = bpf_ctx_convert.t;\n\tif (!conv_struct) {\n\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");\n\t\treturn NULL;\n\t}\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_struct(t)) {\n\t\t/* Only pointer to struct is supported for now.\n\t\t * That means that BPF_PROG_TYPE_TRACEPOINT with BTF\n\t\t * is not supported yet.\n\t\t * BPF_PROG_TYPE_RAW_TRACEPOINT is fine.\n\t\t */\n\t\treturn NULL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"arg#%d struct doesn't have a name\\n\", arg);\n\t\treturn NULL;\n\t}\n\t/* prog_type is valid bpf program type. No need for bounds check. */\n\tctx_type = btf_type_member(conv_struct) + bpf_ctx_convert_map[prog_type] * 2;\n\t/* ctx_struct is a pointer to prog_ctx_type in vmlinux.\n\t * Like 'struct __sk_buff'\n\t */\n\tctx_struct = btf_type_by_id(btf_vmlinux, ctx_type->type);\n\tif (!ctx_struct)\n\t\t/* should not happen */\n\t\treturn NULL;\n\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_struct->name_off);\n\tif (!ctx_tname) {\n\t\t/* should not happen */\n\t\tbpf_log(log, \"Please fix kernel include/linux/bpf_types.h\\n\");\n\t\treturn NULL;\n\t}\n\t/* only compare that prog's ctx type name is the same as\n\t * kernel expects. No need to compare field by field.\n\t * It's ok for bpf prog to do:\n\t * struct __sk_buff {};\n\t * int socket_filter_bpf_prog(struct __sk_buff *skb)\n\t * { // no fields of skb are ever used }\n\t */\n\tif (strcmp(ctx_tname, tname))\n\t\treturn NULL;\n\treturn ctx_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_translate_to_vmlinux(struct bpf_verifier_log *log,\n\t\t\t\t     struct btf *btf,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     enum bpf_prog_type prog_type,\n\t\t\t\t     int arg)\n{\n\tconst struct btf_member *prog_ctx_type, *kern_ctx_type;\n\n\tprog_ctx_type = btf_get_prog_ctx_type(log, btf, t, prog_type, arg);\n\tif (!prog_ctx_type)\n\t\treturn -ENOENT;\n\tkern_ctx_type = prog_ctx_type + 1;\n\treturn kern_ctx_type->type;\n}"
  },
  {
    "function_name": "btf_vmlinux_map_ids_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4636-4658",
    "snippet": "static int btf_vmlinux_map_ids_init(const struct btf *btf,\n\t\t\t\t    struct bpf_verifier_log *log)\n{\n\tconst struct bpf_map_ops *ops;\n\tint i, btf_id;\n\n\tfor (i = 0; i < ARRAY_SIZE(btf_vmlinux_map_ops); ++i) {\n\t\tops = btf_vmlinux_map_ops[i];\n\t\tif (!ops || (!ops->map_btf_name && !ops->map_btf_id))\n\t\t\tcontinue;\n\t\tif (!ops->map_btf_name || !ops->map_btf_id) {\n\t\t\tbpf_log(log, \"map type %d is misconfigured\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbtf_id = btf_find_by_name_kind(btf, ops->map_btf_name,\n\t\t\t\t\t       BTF_KIND_STRUCT);\n\t\tif (btf_id < 0)\n\t\t\treturn btf_id;\n\t\t*ops->map_btf_id = btf_id;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_map_ops * const btf_vmlinux_map_ops[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)\n#define BPF_LINK_TYPE(_id, _name)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_LINK_TYPE\n#undef BPF_MAP_TYPE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_find_by_name_kind",
          "args": [
            "btf",
            "ops->map_btf_name",
            "BTF_KIND_STRUCT"
          ],
          "line": 4650
        },
        "resolved": true,
        "details": {
          "function_name": "btf_find_by_name_kind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "489-507",
          "snippet": "s32 btf_find_by_name_kind(const struct btf *btf, const char *name, u8 kind)\n{\n\tconst struct btf_type *t;\n\tconst char *tname;\n\tu32 i, total;\n\n\ttotal = btf_nr_types(btf);\n\tfor (i = 1; i < total; i++) {\n\t\tt = btf_type_by_id(btf, i);\n\t\tif (BTF_INFO_KIND(t->info) != kind)\n\t\t\tcontinue;\n\n\t\ttname = btf_name_by_offset(btf, t->name_off);\n\t\tif (!strcmp(tname, name))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\ns32 btf_find_by_name_kind(const struct btf *btf, const char *name, u8 kind)\n{\n\tconst struct btf_type *t;\n\tconst char *tname;\n\tu32 i, total;\n\n\ttotal = btf_nr_types(btf);\n\tfor (i = 1; i < total; i++) {\n\t\tt = btf_type_by_id(btf, i);\n\t\tif (BTF_INFO_KIND(t->info) != kind)\n\t\t\tcontinue;\n\n\t\ttname = btf_name_by_offset(btf, t->name_off);\n\t\tif (!strcmp(tname, name))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"map type %d is misconfigured\\n\"",
            "i"
          ],
          "line": 4647
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "btf_vmlinux_map_ops"
          ],
          "line": 4642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct bpf_map_ops * const btf_vmlinux_map_ops[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)\n#define BPF_LINK_TYPE(_id, _name)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_LINK_TYPE\n#undef BPF_MAP_TYPE\n};\n\nstatic int btf_vmlinux_map_ids_init(const struct btf *btf,\n\t\t\t\t    struct bpf_verifier_log *log)\n{\n\tconst struct bpf_map_ops *ops;\n\tint i, btf_id;\n\n\tfor (i = 0; i < ARRAY_SIZE(btf_vmlinux_map_ops); ++i) {\n\t\tops = btf_vmlinux_map_ops[i];\n\t\tif (!ops || (!ops->map_btf_name && !ops->map_btf_id))\n\t\t\tcontinue;\n\t\tif (!ops->map_btf_name || !ops->map_btf_id) {\n\t\t\tbpf_log(log, \"map type %d is misconfigured\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbtf_id = btf_find_by_name_kind(btf, ops->map_btf_name,\n\t\t\t\t\t       BTF_KIND_STRUCT);\n\t\tif (btf_id < 0)\n\t\t\treturn btf_id;\n\t\t*ops->map_btf_id = btf_id;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_get_prog_ctx_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4567-4623",
    "snippet": "static const struct btf_member *\nbtf_get_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, enum bpf_prog_type prog_type,\n\t\t      int arg)\n{\n\tconst struct btf_type *conv_struct;\n\tconst struct btf_type *ctx_struct;\n\tconst struct btf_member *ctx_type;\n\tconst char *tname, *ctx_tname;\n\n\tconv_struct = bpf_ctx_convert.t;\n\tif (!conv_struct) {\n\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");\n\t\treturn NULL;\n\t}\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_struct(t)) {\n\t\t/* Only pointer to struct is supported for now.\n\t\t * That means that BPF_PROG_TYPE_TRACEPOINT with BTF\n\t\t * is not supported yet.\n\t\t * BPF_PROG_TYPE_RAW_TRACEPOINT is fine.\n\t\t */\n\t\treturn NULL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"arg#%d struct doesn't have a name\\n\", arg);\n\t\treturn NULL;\n\t}\n\t/* prog_type is valid bpf program type. No need for bounds check. */\n\tctx_type = btf_type_member(conv_struct) + bpf_ctx_convert_map[prog_type] * 2;\n\t/* ctx_struct is a pointer to prog_ctx_type in vmlinux.\n\t * Like 'struct __sk_buff'\n\t */\n\tctx_struct = btf_type_by_id(btf_vmlinux, ctx_type->type);\n\tif (!ctx_struct)\n\t\t/* should not happen */\n\t\treturn NULL;\n\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_struct->name_off);\n\tif (!ctx_tname) {\n\t\t/* should not happen */\n\t\tbpf_log(log, \"Please fix kernel include/linux/bpf_types.h\\n\");\n\t\treturn NULL;\n\t}\n\t/* only compare that prog's ctx type name is the same as\n\t * kernel expects. No need to compare field by field.\n\t * It's ok for bpf prog to do:\n\t * struct __sk_buff {};\n\t * int socket_filter_bpf_prog(struct __sk_buff *skb)\n\t * { // no fields of skb are ever used }\n\t */\n\tif (strcmp(ctx_tname, tname))\n\t\treturn NULL;\n\treturn ctx_type;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct btf *btf_vmlinux;",
      "static union {\n\tstruct bpf_ctx_convert {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\tprog_ctx_type _id##_prog; \\\n\tkern_ctx_type _id##_kern;\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t} *__t;\n\t/* 't' is written once under lock. Read many times. */\n\tconst struct btf_type *t;\n} bpf_ctx_convert;",
      "static u8 bpf_ctx_convert_map[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = __ctx_convert##_id,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t0, /* avoid empty array */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ctx_tname",
            "tname"
          ],
          "line": 4620
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_log",
          "args": [
            "log",
            "\"Please fix kernel include/linux/bpf_types.h\\n\""
          ],
          "line": 4610
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "355-366",
          "snippet": "void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "btf_vmlinux",
            "ctx_struct->name_off"
          ],
          "line": 4607
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "726-729",
          "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf_vmlinux",
            "ctx_type->type"
          ],
          "line": 4603
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_member",
          "args": [
            "conv_struct"
          ],
          "line": 4599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "t"
          ],
          "line": 4585
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "t"
          ],
          "line": 4583
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nextern struct btf *btf_vmlinux;\nstatic union {\n\tstruct bpf_ctx_convert {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\tprog_ctx_type _id##_prog; \\\n\tkern_ctx_type _id##_kern;\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t} *__t;\n\t/* 't' is written once under lock. Read many times. */\n\tconst struct btf_type *t;\n} bpf_ctx_convert;\nstatic u8 bpf_ctx_convert_map[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = __ctx_convert##_id,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t0, /* avoid empty array */\n};\n\nstatic const struct btf_member *\nbtf_get_prog_ctx_type(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, enum bpf_prog_type prog_type,\n\t\t      int arg)\n{\n\tconst struct btf_type *conv_struct;\n\tconst struct btf_type *ctx_struct;\n\tconst struct btf_member *ctx_type;\n\tconst char *tname, *ctx_tname;\n\n\tconv_struct = bpf_ctx_convert.t;\n\tif (!conv_struct) {\n\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");\n\t\treturn NULL;\n\t}\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_struct(t)) {\n\t\t/* Only pointer to struct is supported for now.\n\t\t * That means that BPF_PROG_TYPE_TRACEPOINT with BTF\n\t\t * is not supported yet.\n\t\t * BPF_PROG_TYPE_RAW_TRACEPOINT is fine.\n\t\t */\n\t\treturn NULL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"arg#%d struct doesn't have a name\\n\", arg);\n\t\treturn NULL;\n\t}\n\t/* prog_type is valid bpf program type. No need for bounds check. */\n\tctx_type = btf_type_member(conv_struct) + bpf_ctx_convert_map[prog_type] * 2;\n\t/* ctx_struct is a pointer to prog_ctx_type in vmlinux.\n\t * Like 'struct __sk_buff'\n\t */\n\tctx_struct = btf_type_by_id(btf_vmlinux, ctx_type->type);\n\tif (!ctx_struct)\n\t\t/* should not happen */\n\t\treturn NULL;\n\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_struct->name_off);\n\tif (!ctx_tname) {\n\t\t/* should not happen */\n\t\tbpf_log(log, \"Please fix kernel include/linux/bpf_types.h\\n\");\n\t\treturn NULL;\n\t}\n\t/* only compare that prog's ctx type name is the same as\n\t * kernel expects. No need to compare field by field.\n\t * It's ok for bpf prog to do:\n\t * struct __sk_buff {};\n\t * int socket_filter_bpf_prog(struct __sk_buff *skb)\n\t * { // no fields of skb are ever used }\n\t */\n\tif (strcmp(ctx_tname, tname))\n\t\treturn NULL;\n\treturn ctx_type;\n}"
  },
  {
    "function_name": "btf_parse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4450-4531",
    "snippet": "static struct btf *btf_parse(bpfptr_t btf_data, u32 btf_data_size,\n\t\t\t     u32 log_level, char __user *log_ubuf, u32 log_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tu8 *data;\n\tint err;\n\n\tif (btf_data_size > BTF_MAX_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tif (log_level || log_ubuf || log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = log_level;\n\t\tlog->ubuf = log_ubuf;\n\t\tlog->len_total = log_size;\n\n\t\t/* log attributes have to be sane */\n\t\tif (!bpf_verifier_log_attr_valid(log)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tdata = kvmalloc(btf_data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tbtf->data = data;\n\tbtf->data_size = btf_data_size;\n\n\tif (copy_from_bpfptr(data, btf_data, btf_data_size)) {\n\t\terr = -EFAULT;\n\t\tgoto errout;\n\t}\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_parse_type_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\tif (log->level && bpf_verifier_log_full(log)) {\n\t\terr = -ENOSPC;\n\t\tgoto errout;\n\t}\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf)\n\t\tbtf_free(btf);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BTF_MAX_SIZE (16 * 1024 * 1024)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 4530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_free",
          "args": [
            "btf"
          ],
          "line": 4529
        },
        "resolved": true,
        "details": {
          "function_name": "btf_free_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1543-1548",
          "snippet": "static void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_env_free",
          "args": [
            "env"
          ],
          "line": 4527
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_env_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1599-1603",
          "snippet": "static void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&btf->refcnt",
            "1"
          ],
          "line": 4523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_full",
          "args": [
            "log"
          ],
          "line": 4517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_parse_type_sec",
          "args": [
            "env"
          ],
          "line": 4513
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse_type_sec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4260-4281",
          "snippet": "static int btf_parse_type_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr = &env->btf->hdr;\n\tint err;\n\n\t/* Type section must align to 4 bytes */\n\tif (hdr->type_off & (sizeof(u32) - 1)) {\n\t\tbtf_verifier_log(env, \"Unaligned type_off\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env->btf->base_btf && !hdr->type_len) {\n\t\tbtf_verifier_log(env, \"No type found\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_check_all_types(env);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_type_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr = &env->btf->hdr;\n\tint err;\n\n\t/* Type section must align to 4 bytes */\n\tif (hdr->type_off & (sizeof(u32) - 1)) {\n\t\tbtf_verifier_log(env, \"Unaligned type_off\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env->btf->base_btf && !hdr->type_len) {\n\t\tbtf_verifier_log(env, \"No type found\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_check_all_types(env);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_parse_str_sec",
          "args": [
            "env"
          ],
          "line": 4509
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse_str_sec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4283-4312",
          "snippet": "static int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\tif (btf->base_btf && !hdr->str_len)\n\t\treturn 0;\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\tif (!btf->base_btf && start[0]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\tif (btf->base_btf && !hdr->str_len)\n\t\treturn 0;\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\tif (!btf->base_btf && start[0]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_parse_hdr",
          "args": [
            "env"
          ],
          "line": 4503
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse_hdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4380-4448",
          "snippet": "static int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!btf->base_btf && btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!btf->base_btf && btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_bpfptr",
          "args": [
            "data",
            "btf_data",
            "btf_data_size"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "btf_data_size",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*btf)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 4482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_attr_valid",
          "args": [
            "log"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*env)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 4462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-E2BIG"
          ],
          "line": 4460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_MAX_SIZE (16 * 1024 * 1024)\n\nstatic struct btf *btf_parse(bpfptr_t btf_data, u32 btf_data_size,\n\t\t\t     u32 log_level, char __user *log_ubuf, u32 log_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tu8 *data;\n\tint err;\n\n\tif (btf_data_size > BTF_MAX_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tif (log_level || log_ubuf || log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = log_level;\n\t\tlog->ubuf = log_ubuf;\n\t\tlog->len_total = log_size;\n\n\t\t/* log attributes have to be sane */\n\t\tif (!bpf_verifier_log_attr_valid(log)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tdata = kvmalloc(btf_data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tbtf->data = data;\n\tbtf->data_size = btf_data_size;\n\n\tif (copy_from_bpfptr(data, btf_data, btf_data_size)) {\n\t\terr = -EFAULT;\n\t\tgoto errout;\n\t}\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_parse_type_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\tif (log->level && bpf_verifier_log_full(log)) {\n\t\terr = -ENOSPC;\n\t\tgoto errout;\n\t}\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf)\n\t\tbtf_free(btf);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "btf_parse_hdr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4380-4448",
    "snippet": "static int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!btf->base_btf && btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_check_sec_info",
          "args": [
            "env",
            "btf_data_size"
          ],
          "line": 4443
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_sec_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4327-4378",
          "snippet": "static int btf_check_sec_info(struct btf_verifier_env *env,\n\t\t\t      u32 btf_data_size)\n{\n\tstruct btf_sec_info secs[ARRAY_SIZE(btf_sec_info_offset)];\n\tu32 total, expected_total, i;\n\tconst struct btf_header *hdr;\n\tconst struct btf *btf;\n\n\tbtf = env->btf;\n\thdr = &btf->hdr;\n\n\t/* Populate the secs from hdr */\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++)\n\t\tsecs[i] = *(struct btf_sec_info *)((void *)hdr +\n\t\t\t\t\t\t   btf_sec_info_offset[i]);\n\n\tsort(secs, ARRAY_SIZE(btf_sec_info_offset),\n\t     sizeof(struct btf_sec_info), btf_sec_info_cmp, NULL);\n\n\t/* Check for gaps and overlap among sections */\n\ttotal = 0;\n\texpected_total = btf_data_size - hdr->hdr_len;\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++) {\n\t\tif (expected_total < secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Invalid section offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total < secs[i].off) {\n\t\t\t/* gap */\n\t\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total > secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Section overlap found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (expected_total - total < secs[i].len) {\n\t\t\tbtf_verifier_log(env,\n\t\t\t\t\t \"Total section length too long\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttotal += secs[i].len;\n\t}\n\n\t/* There is data other than hdr and known sections */\n\tif (expected_total != total) {\n\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t btf_sec_info_offset[] = {\n\toffsetof(struct btf_header, type_off),\n\toffsetof(struct btf_header, str_off),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const size_t btf_sec_info_offset[] = {\n\toffsetof(struct btf_header, type_off),\n\toffsetof(struct btf_header, str_off),\n};\n\nstatic int btf_check_sec_info(struct btf_verifier_env *env,\n\t\t\t      u32 btf_data_size)\n{\n\tstruct btf_sec_info secs[ARRAY_SIZE(btf_sec_info_offset)];\n\tu32 total, expected_total, i;\n\tconst struct btf_header *hdr;\n\tconst struct btf *btf;\n\n\tbtf = env->btf;\n\thdr = &btf->hdr;\n\n\t/* Populate the secs from hdr */\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++)\n\t\tsecs[i] = *(struct btf_sec_info *)((void *)hdr +\n\t\t\t\t\t\t   btf_sec_info_offset[i]);\n\n\tsort(secs, ARRAY_SIZE(btf_sec_info_offset),\n\t     sizeof(struct btf_sec_info), btf_sec_info_cmp, NULL);\n\n\t/* Check for gaps and overlap among sections */\n\ttotal = 0;\n\texpected_total = btf_data_size - hdr->hdr_len;\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++) {\n\t\tif (expected_total < secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Invalid section offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total < secs[i].off) {\n\t\t\t/* gap */\n\t\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total > secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Section overlap found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (expected_total - total < secs[i].len) {\n\t\t\tbtf_verifier_log(env,\n\t\t\t\t\t \"Total section length too long\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttotal += secs[i].len;\n\t}\n\n\t/* There is data other than hdr and known sections */\n\tif (expected_total != total) {\n\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"No data\""
          ],
          "line": 4439
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_hdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1429-1451",
          "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&btf->hdr",
            "btf->data",
            "hdr_copy"
          ],
          "line": 4417
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "hdr_len",
            "sizeof(btf->hdr)"
          ],
          "line": 4416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!btf->base_btf && btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_check_sec_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4327-4378",
    "snippet": "static int btf_check_sec_info(struct btf_verifier_env *env,\n\t\t\t      u32 btf_data_size)\n{\n\tstruct btf_sec_info secs[ARRAY_SIZE(btf_sec_info_offset)];\n\tu32 total, expected_total, i;\n\tconst struct btf_header *hdr;\n\tconst struct btf *btf;\n\n\tbtf = env->btf;\n\thdr = &btf->hdr;\n\n\t/* Populate the secs from hdr */\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++)\n\t\tsecs[i] = *(struct btf_sec_info *)((void *)hdr +\n\t\t\t\t\t\t   btf_sec_info_offset[i]);\n\n\tsort(secs, ARRAY_SIZE(btf_sec_info_offset),\n\t     sizeof(struct btf_sec_info), btf_sec_info_cmp, NULL);\n\n\t/* Check for gaps and overlap among sections */\n\ttotal = 0;\n\texpected_total = btf_data_size - hdr->hdr_len;\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++) {\n\t\tif (expected_total < secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Invalid section offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total < secs[i].off) {\n\t\t\t/* gap */\n\t\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total > secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Section overlap found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (expected_total - total < secs[i].len) {\n\t\t\tbtf_verifier_log(env,\n\t\t\t\t\t \"Total section length too long\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttotal += secs[i].len;\n\t}\n\n\t/* There is data other than hdr and known sections */\n\tif (expected_total != total) {\n\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const size_t btf_sec_info_offset[] = {\n\toffsetof(struct btf_header, type_off),\n\toffsetof(struct btf_header, str_off),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"Unsupported section found\""
          ],
          "line": 4373
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_hdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1429-1451",
          "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "btf_sec_info_offset"
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "secs",
            "ARRAY_SIZE(btf_sec_info_offset)",
            "sizeof(struct btf_sec_info)",
            "btf_sec_info_cmp",
            "NULL"
          ],
          "line": 4343
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "btf_sec_info_offset"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "btf_sec_info_offset"
          ],
          "line": 4339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "btf_sec_info_offset"
          ],
          "line": 4330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const size_t btf_sec_info_offset[] = {\n\toffsetof(struct btf_header, type_off),\n\toffsetof(struct btf_header, str_off),\n};\n\nstatic int btf_check_sec_info(struct btf_verifier_env *env,\n\t\t\t      u32 btf_data_size)\n{\n\tstruct btf_sec_info secs[ARRAY_SIZE(btf_sec_info_offset)];\n\tu32 total, expected_total, i;\n\tconst struct btf_header *hdr;\n\tconst struct btf *btf;\n\n\tbtf = env->btf;\n\thdr = &btf->hdr;\n\n\t/* Populate the secs from hdr */\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++)\n\t\tsecs[i] = *(struct btf_sec_info *)((void *)hdr +\n\t\t\t\t\t\t   btf_sec_info_offset[i]);\n\n\tsort(secs, ARRAY_SIZE(btf_sec_info_offset),\n\t     sizeof(struct btf_sec_info), btf_sec_info_cmp, NULL);\n\n\t/* Check for gaps and overlap among sections */\n\ttotal = 0;\n\texpected_total = btf_data_size - hdr->hdr_len;\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++) {\n\t\tif (expected_total < secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Invalid section offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total < secs[i].off) {\n\t\t\t/* gap */\n\t\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total > secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Section overlap found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (expected_total - total < secs[i].len) {\n\t\t\tbtf_verifier_log(env,\n\t\t\t\t\t \"Total section length too long\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttotal += secs[i].len;\n\t}\n\n\t/* There is data other than hdr and known sections */\n\tif (expected_total != total) {\n\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_sec_info_cmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4319-4325",
    "snippet": "static int btf_sec_info_cmp(const void *a, const void *b)\n{\n\tconst struct btf_sec_info *x = a;\n\tconst struct btf_sec_info *y = b;\n\n\treturn (int)(x->off - y->off) ? : (int)(x->len - y->len);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_sec_info_cmp(const void *a, const void *b)\n{\n\tconst struct btf_sec_info *x = a;\n\tconst struct btf_sec_info *y = b;\n\n\treturn (int)(x->off - y->off) ? : (int)(x->len - y->len);\n}"
  },
  {
    "function_name": "btf_parse_str_sec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4283-4312",
    "snippet": "static int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\tif (btf->base_btf && !hdr->str_len)\n\t\treturn 0;\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\tif (!btf->base_btf && start[0]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"Invalid string section\""
          ],
          "line": 4307
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_hdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1429-1451",
          "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\tif (btf->base_btf && !hdr->str_len)\n\t\treturn 0;\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\tif (!btf->base_btf && start[0]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_parse_type_sec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4260-4281",
    "snippet": "static int btf_parse_type_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr = &env->btf->hdr;\n\tint err;\n\n\t/* Type section must align to 4 bytes */\n\tif (hdr->type_off & (sizeof(u32) - 1)) {\n\t\tbtf_verifier_log(env, \"Unaligned type_off\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env->btf->base_btf && !hdr->type_len) {\n\t\tbtf_verifier_log(env, \"No type found\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_check_all_types(env);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_check_all_types",
          "args": [
            "env"
          ],
          "line": 4280
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_all_types",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4220-4258",
          "snippet": "static int btf_check_all_types(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tconst struct btf_type *t;\n\tu32 type_id, i;\n\tint err;\n\n\terr = env_resolve_init(env);\n\tif (err)\n\t\treturn err;\n\n\tenv->phase++;\n\tfor (i = btf->base_btf ? 0 : 1; i < btf->nr_types; i++) {\n\t\ttype_id = btf->start_id + i;\n\t\tt = btf_type_by_id(btf, type_id);\n\n\t\tenv->log_type_id = type_id;\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !env_type_is_resolved(env, type_id)) {\n\t\t\terr = btf_resolve(env, t, type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_is_func_proto(t)) {\n\t\t\terr = btf_func_proto_check(env, t);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_is_func(t)) {\n\t\t\terr = btf_func_check(env, t);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_check_all_types(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tconst struct btf_type *t;\n\tu32 type_id, i;\n\tint err;\n\n\terr = env_resolve_init(env);\n\tif (err)\n\t\treturn err;\n\n\tenv->phase++;\n\tfor (i = btf->base_btf ? 0 : 1; i < btf->nr_types; i++) {\n\t\ttype_id = btf->start_id + i;\n\t\tt = btf_type_by_id(btf, type_id);\n\n\t\tenv->log_type_id = type_id;\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !env_type_is_resolved(env, type_id)) {\n\t\t\terr = btf_resolve(env, t, type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_is_func_proto(t)) {\n\t\t\terr = btf_func_proto_check(env, t);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_is_func(t)) {\n\t\t\terr = btf_func_check(env, t);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_check_all_metas",
          "args": [
            "env"
          ],
          "line": 4276
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_all_metas",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4119-4144",
          "snippet": "static int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = btf->base_btf ? btf->start_id : 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = btf->base_btf ? btf->start_id : 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"No type found\""
          ],
          "line": 4272
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_hdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1429-1451",
          "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_type_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr = &env->btf->hdr;\n\tint err;\n\n\t/* Type section must align to 4 bytes */\n\tif (hdr->type_off & (sizeof(u32) - 1)) {\n\t\tbtf_verifier_log(env, \"Unaligned type_off\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env->btf->base_btf && !hdr->type_len) {\n\t\tbtf_verifier_log(env, \"No type found\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_check_all_types(env);\n}"
  },
  {
    "function_name": "btf_check_all_types",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4220-4258",
    "snippet": "static int btf_check_all_types(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tconst struct btf_type *t;\n\tu32 type_id, i;\n\tint err;\n\n\terr = env_resolve_init(env);\n\tif (err)\n\t\treturn err;\n\n\tenv->phase++;\n\tfor (i = btf->base_btf ? 0 : 1; i < btf->nr_types; i++) {\n\t\ttype_id = btf->start_id + i;\n\t\tt = btf_type_by_id(btf, type_id);\n\n\t\tenv->log_type_id = type_id;\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !env_type_is_resolved(env, type_id)) {\n\t\t\terr = btf_resolve(env, t, type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_is_func_proto(t)) {\n\t\t\terr = btf_func_proto_check(env, t);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_is_func(t)) {\n\t\t\terr = btf_func_check(env, t);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_func_check",
          "args": [
            "env",
            "t"
          ],
          "line": 4251
        },
        "resolved": true,
        "details": {
          "function_name": "btf_func_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4028-4054",
          "snippet": "static int btf_func_check(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tconst struct btf_type *proto_type;\n\tconst struct btf_param *args;\n\tconst struct btf *btf;\n\tu16 nr_args, i;\n\n\tbtf = env->btf;\n\tproto_type = btf_type_by_id(btf, t->type);\n\n\tif (!proto_type || !btf_type_is_func_proto(proto_type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\targs = (const struct btf_param *)(proto_type + 1);\n\tnr_args = btf_type_vlen(proto_type);\n\tfor (i = 0; i < nr_args; i++) {\n\t\tif (!args[i].name_off && args[i].type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_func_check(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tconst struct btf_type *proto_type;\n\tconst struct btf_param *args;\n\tconst struct btf *btf;\n\tu16 nr_args, i;\n\n\tbtf = env->btf;\n\tproto_type = btf_type_by_id(btf, t->type);\n\n\tif (!proto_type || !btf_type_is_func_proto(proto_type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\targs = (const struct btf_param *)(proto_type + 1);\n\tnr_args = btf_type_vlen(proto_type);\n\tfor (i = 0; i < nr_args; i++) {\n\t\tif (!args[i].name_off && args[i].type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_func",
          "args": [
            "t"
          ],
          "line": 4250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_func_proto_check",
          "args": [
            "env",
            "t"
          ],
          "line": 4245
        },
        "resolved": true,
        "details": {
          "function_name": "btf_func_proto_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "3939-4026",
          "snippet": "static int btf_func_proto_check(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t)\n{\n\tconst struct btf_type *ret_type;\n\tconst struct btf_param *args;\n\tconst struct btf *btf;\n\tu16 nr_args, i;\n\tint err;\n\n\tbtf = env->btf;\n\targs = (const struct btf_param *)(t + 1);\n\tnr_args = btf_type_vlen(t);\n\n\t/* Check func return type which could be \"void\" (t->type == 0) */\n\tif (t->type) {\n\t\tu32 ret_type_id = t->type;\n\n\t\tret_type = btf_type_by_id(btf, ret_type_id);\n\t\tif (!ret_type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid return type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(ret_type) &&\n\t\t    !env_type_is_resolved(env, ret_type_id)) {\n\t\t\terr = btf_resolve(env, ret_type, ret_type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t/* Ensure the return type is a type that has a size */\n\t\tif (!btf_type_id_size(btf, &ret_type_id, NULL)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid return type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!nr_args)\n\t\treturn 0;\n\n\t/* Last func arg type_id could be 0 if it is a vararg */\n\tif (!args[nr_args - 1].type) {\n\t\tif (args[nr_args - 1].name_off) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\",\n\t\t\t\t\t      nr_args);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tnr_args--;\n\t}\n\n\terr = 0;\n\tfor (i = 0; i < nr_args; i++) {\n\t\tconst struct btf_type *arg_type;\n\t\tu32 arg_type_id;\n\n\t\targ_type_id = args[i].type;\n\t\targ_type = btf_type_by_id(btf, arg_type_id);\n\t\tif (!arg_type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (args[i].name_off &&\n\t\t    (!btf_name_offset_valid(btf, args[i].name_off) ||\n\t\t     !btf_name_valid_identifier(btf, args[i].name_off))) {\n\t\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t\t      \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(arg_type) &&\n\t\t    !env_type_is_resolved(env, arg_type_id)) {\n\t\t\terr = btf_resolve(env, arg_type, arg_type_id);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!btf_type_id_size(btf, &arg_type_id, NULL)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_func_proto_check(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t)\n{\n\tconst struct btf_type *ret_type;\n\tconst struct btf_param *args;\n\tconst struct btf *btf;\n\tu16 nr_args, i;\n\tint err;\n\n\tbtf = env->btf;\n\targs = (const struct btf_param *)(t + 1);\n\tnr_args = btf_type_vlen(t);\n\n\t/* Check func return type which could be \"void\" (t->type == 0) */\n\tif (t->type) {\n\t\tu32 ret_type_id = t->type;\n\n\t\tret_type = btf_type_by_id(btf, ret_type_id);\n\t\tif (!ret_type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid return type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(ret_type) &&\n\t\t    !env_type_is_resolved(env, ret_type_id)) {\n\t\t\terr = btf_resolve(env, ret_type, ret_type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t/* Ensure the return type is a type that has a size */\n\t\tif (!btf_type_id_size(btf, &ret_type_id, NULL)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid return type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!nr_args)\n\t\treturn 0;\n\n\t/* Last func arg type_id could be 0 if it is a vararg */\n\tif (!args[nr_args - 1].type) {\n\t\tif (args[nr_args - 1].name_off) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\",\n\t\t\t\t\t      nr_args);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tnr_args--;\n\t}\n\n\terr = 0;\n\tfor (i = 0; i < nr_args; i++) {\n\t\tconst struct btf_type *arg_type;\n\t\tu32 arg_type_id;\n\n\t\targ_type_id = args[i].type;\n\t\targ_type = btf_type_by_id(btf, arg_type_id);\n\t\tif (!arg_type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (args[i].name_off &&\n\t\t    (!btf_name_offset_valid(btf, args[i].name_off) ||\n\t\t     !btf_name_valid_identifier(btf, args[i].name_off))) {\n\t\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t\t      \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(arg_type) &&\n\t\t    !env_type_is_resolved(env, arg_type_id)) {\n\t\t\terr = btf_resolve(env, arg_type, arg_type_id);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!btf_type_id_size(btf, &arg_type_id, NULL)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_func_proto",
          "args": [
            "t"
          ],
          "line": 4244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_resolve",
          "args": [
            "env",
            "t",
            "type_id"
          ],
          "line": 4239
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4187-4218",
          "snippet": "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id)\n{\n\tu32 save_log_type_id = env->log_type_id;\n\tconst struct resolve_vertex *v;\n\tint err = 0;\n\n\tenv->resolve_mode = RESOLVE_TBD;\n\tenv_stack_push(env, t, type_id);\n\twhile (!err && (v = env_stack_peak(env))) {\n\t\tenv->log_type_id = v->type_id;\n\t\terr = btf_type_ops(v->t)->resolve(env, v);\n\t}\n\n\tenv->log_type_id = type_id;\n\tif (err == -E2BIG) {\n\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t      \"Exceeded max resolving depth:%u\",\n\t\t\t\t      MAX_RESOLVE_DEPTH);\n\t} else if (err == -EEXIST) {\n\t\tbtf_verifier_log_type(env, t, \"Loop detected\");\n\t}\n\n\t/* Final sanity check */\n\tif (!err && !btf_resolve_valid(env, t, type_id)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");\n\t\terr = -EINVAL;\n\t}\n\n\tenv->log_type_id = save_log_type_id;\n\treturn err;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id)\n{\n\tu32 save_log_type_id = env->log_type_id;\n\tconst struct resolve_vertex *v;\n\tint err = 0;\n\n\tenv->resolve_mode = RESOLVE_TBD;\n\tenv_stack_push(env, t, type_id);\n\twhile (!err && (v = env_stack_peak(env))) {\n\t\tenv->log_type_id = v->type_id;\n\t\terr = btf_type_ops(v->t)->resolve(env, v);\n\t}\n\n\tenv->log_type_id = type_id;\n\tif (err == -E2BIG) {\n\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t      \"Exceeded max resolving depth:%u\",\n\t\t\t\t      MAX_RESOLVE_DEPTH);\n\t} else if (err == -EEXIST) {\n\t\tbtf_verifier_log_type(env, t, \"Loop detected\");\n\t}\n\n\t/* Final sanity check */\n\tif (!err && !btf_resolve_valid(env, t, type_id)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");\n\t\terr = -EINVAL;\n\t}\n\n\tenv->log_type_id = save_log_type_id;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "type_id"
          ],
          "line": 4238
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1630-1638",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_needs_resolve",
          "args": [
            "t"
          ],
          "line": 4237
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_needs_resolve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "575-584",
          "snippet": "static bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t       btf_type_is_ptr(t) ||\n\t       btf_type_is_struct(t) ||\n\t       btf_type_is_array(t) ||\n\t       btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t       btf_type_is_ptr(t) ||\n\t       btf_type_is_struct(t) ||\n\t       btf_type_is_array(t) ||\n\t       btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "type_id"
          ],
          "line": 4234
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_resolve_init",
          "args": [
            "env"
          ],
          "line": 4227
        },
        "resolved": true,
        "details": {
          "function_name": "env_resolve_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1563-1597",
          "snippet": "static int env_resolve_init(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 nr_types = btf->nr_types;\n\tu32 *resolved_sizes = NULL;\n\tu32 *resolved_ids = NULL;\n\tu8 *visit_states = NULL;\n\n\tresolved_sizes = kvcalloc(nr_types, sizeof(*resolved_sizes),\n\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_sizes)\n\t\tgoto nomem;\n\n\tresolved_ids = kvcalloc(nr_types, sizeof(*resolved_ids),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_ids)\n\t\tgoto nomem;\n\n\tvisit_states = kvcalloc(nr_types, sizeof(*visit_states),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!visit_states)\n\t\tgoto nomem;\n\n\tbtf->resolved_sizes = resolved_sizes;\n\tbtf->resolved_ids = resolved_ids;\n\tenv->visit_states = visit_states;\n\n\treturn 0;\n\nnomem:\n\tkvfree(resolved_sizes);\n\tkvfree(resolved_ids);\n\tkvfree(visit_states);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int env_resolve_init(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 nr_types = btf->nr_types;\n\tu32 *resolved_sizes = NULL;\n\tu32 *resolved_ids = NULL;\n\tu8 *visit_states = NULL;\n\n\tresolved_sizes = kvcalloc(nr_types, sizeof(*resolved_sizes),\n\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_sizes)\n\t\tgoto nomem;\n\n\tresolved_ids = kvcalloc(nr_types, sizeof(*resolved_ids),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_ids)\n\t\tgoto nomem;\n\n\tvisit_states = kvcalloc(nr_types, sizeof(*visit_states),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!visit_states)\n\t\tgoto nomem;\n\n\tbtf->resolved_sizes = resolved_sizes;\n\tbtf->resolved_ids = resolved_ids;\n\tenv->visit_states = visit_states;\n\n\treturn 0;\n\nnomem:\n\tkvfree(resolved_sizes);\n\tkvfree(resolved_ids);\n\tkvfree(visit_states);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_check_all_types(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tconst struct btf_type *t;\n\tu32 type_id, i;\n\tint err;\n\n\terr = env_resolve_init(env);\n\tif (err)\n\t\treturn err;\n\n\tenv->phase++;\n\tfor (i = btf->base_btf ? 0 : 1; i < btf->nr_types; i++) {\n\t\ttype_id = btf->start_id + i;\n\t\tt = btf_type_by_id(btf, type_id);\n\n\t\tenv->log_type_id = type_id;\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !env_type_is_resolved(env, type_id)) {\n\t\t\terr = btf_resolve(env, t, type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_is_func_proto(t)) {\n\t\t\terr = btf_func_proto_check(env, t);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_is_func(t)) {\n\t\t\terr = btf_func_check(env, t);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_resolve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4187-4218",
    "snippet": "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id)\n{\n\tu32 save_log_type_id = env->log_type_id;\n\tconst struct resolve_vertex *v;\n\tint err = 0;\n\n\tenv->resolve_mode = RESOLVE_TBD;\n\tenv_stack_push(env, t, type_id);\n\twhile (!err && (v = env_stack_peak(env))) {\n\t\tenv->log_type_id = v->type_id;\n\t\terr = btf_type_ops(v->t)->resolve(env, v);\n\t}\n\n\tenv->log_type_id = type_id;\n\tif (err == -E2BIG) {\n\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t      \"Exceeded max resolving depth:%u\",\n\t\t\t\t      MAX_RESOLVE_DEPTH);\n\t} else if (err == -EEXIST) {\n\t\tbtf_verifier_log_type(env, t, \"Loop detected\");\n\t}\n\n\t/* Final sanity check */\n\tif (!err && !btf_resolve_valid(env, t, type_id)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");\n\t\terr = -EINVAL;\n\t}\n\n\tenv->log_type_id = save_log_type_id;\n\treturn err;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define MAX_RESOLVE_DEPTH 32"
    ],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid resolve state\""
          ],
          "line": 4212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_resolve_valid",
          "args": [
            "env",
            "t",
            "type_id"
          ],
          "line": 4211
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolve_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4146-4185",
          "snippet": "static bool btf_resolve_valid(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (!env_type_is_resolved(env, type_id))\n\t\treturn false;\n\n\tif (btf_type_is_struct(t) || btf_type_is_datasec(t))\n\t\treturn !btf_resolved_type_id(btf, type_id) &&\n\t\t       !btf_resolved_type_size(btf, type_id);\n\n\tif (btf_type_is_decl_tag(t))\n\t\treturn btf_resolved_type_id(btf, type_id) &&\n\t\t       !btf_resolved_type_size(btf, type_id);\n\n\tif (btf_type_is_modifier(t) || btf_type_is_ptr(t) ||\n\t    btf_type_is_var(t)) {\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\t\treturn t &&\n\t\t       !btf_type_is_modifier(t) &&\n\t\t       !btf_type_is_var(t) &&\n\t\t       !btf_type_is_datasec(t);\n\t}\n\n\tif (btf_type_is_array(t)) {\n\t\tconst struct btf_array *array = btf_type_array(t);\n\t\tconst struct btf_type *elem_type;\n\t\tu32 elem_type_id = array->type;\n\t\tu32 elem_size;\n\n\t\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\t\treturn elem_type && !btf_type_is_modifier(elem_type) &&\n\t\t\t(array->nelems * elem_size ==\n\t\t\t btf_resolved_type_size(btf, type_id));\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool btf_resolve_valid(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (!env_type_is_resolved(env, type_id))\n\t\treturn false;\n\n\tif (btf_type_is_struct(t) || btf_type_is_datasec(t))\n\t\treturn !btf_resolved_type_id(btf, type_id) &&\n\t\t       !btf_resolved_type_size(btf, type_id);\n\n\tif (btf_type_is_decl_tag(t))\n\t\treturn btf_resolved_type_id(btf, type_id) &&\n\t\t       !btf_resolved_type_size(btf, type_id);\n\n\tif (btf_type_is_modifier(t) || btf_type_is_ptr(t) ||\n\t    btf_type_is_var(t)) {\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\t\treturn t &&\n\t\t       !btf_type_is_modifier(t) &&\n\t\t       !btf_type_is_var(t) &&\n\t\t       !btf_type_is_datasec(t);\n\t}\n\n\tif (btf_type_is_array(t)) {\n\t\tconst struct btf_array *array = btf_type_array(t);\n\t\tconst struct btf_type *elem_type;\n\t\tu32 elem_type_id = array->type;\n\t\tu32 elem_size;\n\n\t\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\t\treturn elem_type && !btf_type_is_modifier(elem_type) &&\n\t\t\t(array->nelems * elem_size ==\n\t\t\t btf_resolved_type_size(btf, type_id));\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Loop detected\""
          ],
          "line": 4207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Exceeded max resolving depth:%u\"",
            "MAX_RESOLVE_DEPTH"
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1311-1348",
          "snippet": "static void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* btf verifier prints all types it is processing via\n\t * btf_verifier_log_type(..., fmt = NULL).\n\t * Skip those prints for in-kernel BTF verification.\n\t */\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   __btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\n\nstatic void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* btf verifier prints all types it is processing via\n\t * btf_verifier_log_type(..., fmt = NULL).\n\t * Skip those prints for in-kernel BTF verification.\n\t */\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   __btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "v"
          ],
          "line": 4198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "v->t"
          ],
          "line": 4198
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_peak",
          "args": [
            "env"
          ],
          "line": 4196
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_peak",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1689-1692",
          "snippet": "static const struct resolve_vertex *env_stack_peak(struct btf_verifier_env *env)\n{\n\treturn env->top_stack ? &env->stack[env->top_stack - 1] : NULL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct resolve_vertex *env_stack_peak(struct btf_verifier_env *env)\n{\n\treturn env->top_stack ? &env->stack[env->top_stack - 1] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "t",
            "type_id"
          ],
          "line": 4195
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1640-1668",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id)\n{\n\tu32 save_log_type_id = env->log_type_id;\n\tconst struct resolve_vertex *v;\n\tint err = 0;\n\n\tenv->resolve_mode = RESOLVE_TBD;\n\tenv_stack_push(env, t, type_id);\n\twhile (!err && (v = env_stack_peak(env))) {\n\t\tenv->log_type_id = v->type_id;\n\t\terr = btf_type_ops(v->t)->resolve(env, v);\n\t}\n\n\tenv->log_type_id = type_id;\n\tif (err == -E2BIG) {\n\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t      \"Exceeded max resolving depth:%u\",\n\t\t\t\t      MAX_RESOLVE_DEPTH);\n\t} else if (err == -EEXIST) {\n\t\tbtf_verifier_log_type(env, t, \"Loop detected\");\n\t}\n\n\t/* Final sanity check */\n\tif (!err && !btf_resolve_valid(env, t, type_id)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");\n\t\terr = -EINVAL;\n\t}\n\n\tenv->log_type_id = save_log_type_id;\n\treturn err;\n}"
  },
  {
    "function_name": "btf_resolve_valid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4146-4185",
    "snippet": "static bool btf_resolve_valid(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (!env_type_is_resolved(env, type_id))\n\t\treturn false;\n\n\tif (btf_type_is_struct(t) || btf_type_is_datasec(t))\n\t\treturn !btf_resolved_type_id(btf, type_id) &&\n\t\t       !btf_resolved_type_size(btf, type_id);\n\n\tif (btf_type_is_decl_tag(t))\n\t\treturn btf_resolved_type_id(btf, type_id) &&\n\t\t       !btf_resolved_type_size(btf, type_id);\n\n\tif (btf_type_is_modifier(t) || btf_type_is_ptr(t) ||\n\t    btf_type_is_var(t)) {\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\t\treturn t &&\n\t\t       !btf_type_is_modifier(t) &&\n\t\t       !btf_type_is_var(t) &&\n\t\t       !btf_type_is_datasec(t);\n\t}\n\n\tif (btf_type_is_array(t)) {\n\t\tconst struct btf_array *array = btf_type_array(t);\n\t\tconst struct btf_type *elem_type;\n\t\tu32 elem_type_id = array->type;\n\t\tu32 elem_size;\n\n\t\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\t\treturn elem_type && !btf_type_is_modifier(elem_type) &&\n\t\t\t(array->nelems * elem_size ==\n\t\t\t btf_resolved_type_size(btf, type_id));\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_resolved_type_size",
          "args": [
            "btf",
            "type_id"
          ],
          "line": 4181
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolved_type_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1806-1812",
          "snippet": "static u32 btf_resolved_type_size(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_sizes[type_id - btf->start_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic u32 btf_resolved_type_size(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_sizes[type_id - btf->start_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "elem_type"
          ],
          "line": 4179
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&elem_type_id",
            "&elem_size"
          ],
          "line": 4178
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "t"
          ],
          "line": 4173
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "621-624",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "t"
          ],
          "line": 4172
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "456-459",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_datasec",
          "args": [
            "t"
          ],
          "line": 4169
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_datasec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "461-464",
          "snippet": "static bool btf_type_is_datasec(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DATASEC;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_datasec(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DATASEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_var",
          "args": [
            "t"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_id_resolve",
          "args": [
            "btf",
            "&type_id"
          ],
          "line": 4165
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_resolve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1799-1804",
          "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_var",
          "args": [
            "t"
          ],
          "line": 4164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_resolved_type_id",
          "args": [
            "btf",
            "type_id"
          ],
          "line": 4160
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolved_type_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1790-1796",
          "snippet": "static u32 btf_resolved_type_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_ids[type_id - btf->start_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic u32 btf_resolved_type_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_ids[type_id - btf->start_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_decl_tag",
          "args": [
            "t"
          ],
          "line": 4159
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_decl_tag_target",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "471-475",
          "snippet": "static bool btf_type_is_decl_tag_target(const struct btf_type *t)\n{\n\treturn btf_type_is_func(t) || btf_type_is_struct(t) ||\n\t       btf_type_is_var(t) || btf_type_is_typedef(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_decl_tag_target(const struct btf_type *t)\n{\n\treturn btf_type_is_func(t) || btf_type_is_struct(t) ||\n\t       btf_type_is_var(t) || btf_type_is_typedef(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "t"
          ],
          "line": 4155
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "type_id"
          ],
          "line": 4152
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1630-1638",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool btf_resolve_valid(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (!env_type_is_resolved(env, type_id))\n\t\treturn false;\n\n\tif (btf_type_is_struct(t) || btf_type_is_datasec(t))\n\t\treturn !btf_resolved_type_id(btf, type_id) &&\n\t\t       !btf_resolved_type_size(btf, type_id);\n\n\tif (btf_type_is_decl_tag(t))\n\t\treturn btf_resolved_type_id(btf, type_id) &&\n\t\t       !btf_resolved_type_size(btf, type_id);\n\n\tif (btf_type_is_modifier(t) || btf_type_is_ptr(t) ||\n\t    btf_type_is_var(t)) {\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\t\treturn t &&\n\t\t       !btf_type_is_modifier(t) &&\n\t\t       !btf_type_is_var(t) &&\n\t\t       !btf_type_is_datasec(t);\n\t}\n\n\tif (btf_type_is_array(t)) {\n\t\tconst struct btf_array *array = btf_type_array(t);\n\t\tconst struct btf_type *elem_type;\n\t\tu32 elem_type_id = array->type;\n\t\tu32 elem_size;\n\n\t\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\t\treturn elem_type && !btf_type_is_modifier(elem_type) &&\n\t\t\t(array->nelems * elem_size ==\n\t\t\t btf_resolved_type_size(btf, type_id));\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "btf_check_all_metas",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4119-4144",
    "snippet": "static int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = btf->base_btf ? btf->start_id : 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_add_type",
          "args": [
            "env",
            "t"
          ],
          "line": 4138
        },
        "resolved": true,
        "details": {
          "function_name": "btf_add_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1453-1496",
          "snippet": "static int btf_add_type(struct btf_verifier_env *env, struct btf_type *t)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (btf->types_size == btf->nr_types) {\n\t\t/* Expand 'types' array */\n\n\t\tstruct btf_type **new_types;\n\t\tu32 expand_by, new_size;\n\n\t\tif (btf->start_id + btf->types_size == BTF_MAX_TYPE) {\n\t\t\tbtf_verifier_log(env, \"Exceeded max num of types\");\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\texpand_by = max_t(u32, btf->types_size >> 2, 16);\n\t\tnew_size = min_t(u32, BTF_MAX_TYPE,\n\t\t\t\t btf->types_size + expand_by);\n\n\t\tnew_types = kvcalloc(new_size, sizeof(*new_types),\n\t\t\t\t     GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!new_types)\n\t\t\treturn -ENOMEM;\n\n\t\tif (btf->nr_types == 0) {\n\t\t\tif (!btf->base_btf) {\n\t\t\t\t/* lazily init VOID type */\n\t\t\t\tnew_types[0] = &btf_void;\n\t\t\t\tbtf->nr_types++;\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(new_types, btf->types,\n\t\t\t       sizeof(*btf->types) * btf->nr_types);\n\t\t}\n\n\t\tkvfree(btf->types);\n\t\tbtf->types = new_types;\n\t\tbtf->types_size = new_size;\n\t}\n\n\tbtf->types[btf->nr_types++] = t;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btf_type btf_void;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nstatic int btf_add_type(struct btf_verifier_env *env, struct btf_type *t)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (btf->types_size == btf->nr_types) {\n\t\t/* Expand 'types' array */\n\n\t\tstruct btf_type **new_types;\n\t\tu32 expand_by, new_size;\n\n\t\tif (btf->start_id + btf->types_size == BTF_MAX_TYPE) {\n\t\t\tbtf_verifier_log(env, \"Exceeded max num of types\");\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\texpand_by = max_t(u32, btf->types_size >> 2, 16);\n\t\tnew_size = min_t(u32, BTF_MAX_TYPE,\n\t\t\t\t btf->types_size + expand_by);\n\n\t\tnew_types = kvcalloc(new_size, sizeof(*new_types),\n\t\t\t\t     GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!new_types)\n\t\t\treturn -ENOMEM;\n\n\t\tif (btf->nr_types == 0) {\n\t\t\tif (!btf->base_btf) {\n\t\t\t\t/* lazily init VOID type */\n\t\t\t\tnew_types[0] = &btf_void;\n\t\t\t\tbtf->nr_types++;\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(new_types, btf->types,\n\t\t\t       sizeof(*btf->types) * btf->nr_types);\n\t\t}\n\n\t\tkvfree(btf->types);\n\t\tbtf->types = new_types;\n\t\tbtf->types_size = new_size;\n\t}\n\n\tbtf->types[btf->nr_types++] = t;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_check_meta",
          "args": [
            "env",
            "t",
            "end - cur"
          ],
          "line": 4134
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_meta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4077-4117",
          "snippet": "static s32 btf_check_meta(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t,\n\t\t\t  u32 meta_left)\n{\n\tu32 saved_meta_left = meta_left;\n\ts32 var_meta_size;\n\n\tif (meta_left < sizeof(*t)) {\n\t\tbtf_verifier_log(env, \"[%u] meta_left:%u meta_needed:%zu\",\n\t\t\t\t env->log_type_id, meta_left, sizeof(*t));\n\t\treturn -EINVAL;\n\t}\n\tmeta_left -= sizeof(*t);\n\n\tif (t->info & ~BTF_INFO_MASK) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid btf_info:%x\",\n\t\t\t\t env->log_type_id, t->info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BTF_INFO_KIND(t->info) > BTF_KIND_MAX ||\n\t    BTF_INFO_KIND(t->info) == BTF_KIND_UNKN) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid kind:%u\",\n\t\t\t\t env->log_type_id, BTF_INFO_KIND(t->info));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btf_name_offset_valid(env->btf, t->name_off)) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid name_offset:%u\",\n\t\t\t\t env->log_type_id, t->name_off);\n\t\treturn -EINVAL;\n\t}\n\n\tvar_meta_size = btf_type_ops(t)->check_meta(env, t, meta_left);\n\tif (var_meta_size < 0)\n\t\treturn var_meta_size;\n\n\tmeta_left -= var_meta_size;\n\n\treturn saved_meta_left - meta_left;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define BTF_INFO_MASK 0x9f00ffff"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_INFO_MASK 0x9f00ffff\n\nstatic s32 btf_check_meta(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t,\n\t\t\t  u32 meta_left)\n{\n\tu32 saved_meta_left = meta_left;\n\ts32 var_meta_size;\n\n\tif (meta_left < sizeof(*t)) {\n\t\tbtf_verifier_log(env, \"[%u] meta_left:%u meta_needed:%zu\",\n\t\t\t\t env->log_type_id, meta_left, sizeof(*t));\n\t\treturn -EINVAL;\n\t}\n\tmeta_left -= sizeof(*t);\n\n\tif (t->info & ~BTF_INFO_MASK) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid btf_info:%x\",\n\t\t\t\t env->log_type_id, t->info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BTF_INFO_KIND(t->info) > BTF_KIND_MAX ||\n\t    BTF_INFO_KIND(t->info) == BTF_KIND_UNKN) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid kind:%u\",\n\t\t\t\t env->log_type_id, BTF_INFO_KIND(t->info));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btf_name_offset_valid(env->btf, t->name_off)) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid name_offset:%u\",\n\t\t\t\t env->log_type_id, t->name_off);\n\t\treturn -EINVAL;\n\t}\n\n\tvar_meta_size = btf_type_ops(t)->check_meta(env, t, meta_left);\n\tif (var_meta_size < 0)\n\t\treturn var_meta_size;\n\n\tmeta_left -= var_meta_size;\n\n\treturn saved_meta_left - meta_left;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = btf->base_btf ? btf->start_id : 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4077-4117",
    "snippet": "static s32 btf_check_meta(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t,\n\t\t\t  u32 meta_left)\n{\n\tu32 saved_meta_left = meta_left;\n\ts32 var_meta_size;\n\n\tif (meta_left < sizeof(*t)) {\n\t\tbtf_verifier_log(env, \"[%u] meta_left:%u meta_needed:%zu\",\n\t\t\t\t env->log_type_id, meta_left, sizeof(*t));\n\t\treturn -EINVAL;\n\t}\n\tmeta_left -= sizeof(*t);\n\n\tif (t->info & ~BTF_INFO_MASK) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid btf_info:%x\",\n\t\t\t\t env->log_type_id, t->info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BTF_INFO_KIND(t->info) > BTF_KIND_MAX ||\n\t    BTF_INFO_KIND(t->info) == BTF_KIND_UNKN) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid kind:%u\",\n\t\t\t\t env->log_type_id, BTF_INFO_KIND(t->info));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btf_name_offset_valid(env->btf, t->name_off)) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid name_offset:%u\",\n\t\t\t\t env->log_type_id, t->name_off);\n\t\treturn -EINVAL;\n\t}\n\n\tvar_meta_size = btf_type_ops(t)->check_meta(env, t, meta_left);\n\tif (var_meta_size < 0)\n\t\treturn var_meta_size;\n\n\tmeta_left -= var_meta_size;\n\n\treturn saved_meta_left - meta_left;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BTF_INFO_MASK 0x9f00ffff"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "t",
            "meta_left"
          ],
          "line": 4110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "t"
          ],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"[%u] Invalid name_offset:%u\"",
            "env->log_type_id",
            "t->name_off"
          ],
          "line": 4105
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_offset_valid",
          "args": [
            "env->btf",
            "t->name_off"
          ],
          "line": 4104
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_offset_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "646-656",
          "snippet": "static bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\tif (!BTF_STR_OFFSET_VALID(offset))\n\t\treturn false;\n\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\treturn offset < btf->hdr.str_len;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\tif (!BTF_STR_OFFSET_VALID(offset))\n\t\treturn false;\n\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\treturn offset < btf->hdr.str_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 4097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_INFO_MASK 0x9f00ffff\n\nstatic s32 btf_check_meta(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t,\n\t\t\t  u32 meta_left)\n{\n\tu32 saved_meta_left = meta_left;\n\ts32 var_meta_size;\n\n\tif (meta_left < sizeof(*t)) {\n\t\tbtf_verifier_log(env, \"[%u] meta_left:%u meta_needed:%zu\",\n\t\t\t\t env->log_type_id, meta_left, sizeof(*t));\n\t\treturn -EINVAL;\n\t}\n\tmeta_left -= sizeof(*t);\n\n\tif (t->info & ~BTF_INFO_MASK) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid btf_info:%x\",\n\t\t\t\t env->log_type_id, t->info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BTF_INFO_KIND(t->info) > BTF_KIND_MAX ||\n\t    BTF_INFO_KIND(t->info) == BTF_KIND_UNKN) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid kind:%u\",\n\t\t\t\t env->log_type_id, BTF_INFO_KIND(t->info));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btf_name_offset_valid(env->btf, t->name_off)) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid name_offset:%u\",\n\t\t\t\t env->log_type_id, t->name_off);\n\t\treturn -EINVAL;\n\t}\n\n\tvar_meta_size = btf_type_ops(t)->check_meta(env, t, meta_left);\n\tif (var_meta_size < 0)\n\t\treturn var_meta_size;\n\n\tmeta_left -= var_meta_size;\n\n\treturn saved_meta_left - meta_left;\n}"
  },
  {
    "function_name": "btf_func_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "4028-4054",
    "snippet": "static int btf_func_check(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tconst struct btf_type *proto_type;\n\tconst struct btf_param *args;\n\tconst struct btf *btf;\n\tu16 nr_args, i;\n\n\tbtf = env->btf;\n\tproto_type = btf_type_by_id(btf, t->type);\n\n\tif (!proto_type || !btf_type_is_func_proto(proto_type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\targs = (const struct btf_param *)(proto_type + 1);\n\tnr_args = btf_type_vlen(proto_type);\n\tfor (i = 0; i < nr_args; i++) {\n\t\tif (!args[i].name_off && args[i].type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid arg#%u\"",
            "i + 1"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1311-1348",
          "snippet": "static void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* btf verifier prints all types it is processing via\n\t * btf_verifier_log_type(..., fmt = NULL).\n\t * Skip those prints for in-kernel BTF verification.\n\t */\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   __btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\n\nstatic void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* btf verifier prints all types it is processing via\n\t * btf_verifier_log_type(..., fmt = NULL).\n\t * Skip those prints for in-kernel BTF verification.\n\t */\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   __btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "proto_type"
          ],
          "line": 4045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid type_id\""
          ],
          "line": 4040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_func_proto",
          "args": [
            "proto_type"
          ],
          "line": 4039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "t->type"
          ],
          "line": 4037
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_func_check(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tconst struct btf_type *proto_type;\n\tconst struct btf_param *args;\n\tconst struct btf *btf;\n\tu16 nr_args, i;\n\n\tbtf = env->btf;\n\tproto_type = btf_type_by_id(btf, t->type);\n\n\tif (!proto_type || !btf_type_is_func_proto(proto_type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\targs = (const struct btf_param *)(proto_type + 1);\n\tnr_args = btf_type_vlen(proto_type);\n\tfor (i = 0; i < nr_args; i++) {\n\t\tif (!args[i].name_off && args[i].type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_func_proto_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3939-4026",
    "snippet": "static int btf_func_proto_check(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t)\n{\n\tconst struct btf_type *ret_type;\n\tconst struct btf_param *args;\n\tconst struct btf *btf;\n\tu16 nr_args, i;\n\tint err;\n\n\tbtf = env->btf;\n\targs = (const struct btf_param *)(t + 1);\n\tnr_args = btf_type_vlen(t);\n\n\t/* Check func return type which could be \"void\" (t->type == 0) */\n\tif (t->type) {\n\t\tu32 ret_type_id = t->type;\n\n\t\tret_type = btf_type_by_id(btf, ret_type_id);\n\t\tif (!ret_type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid return type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(ret_type) &&\n\t\t    !env_type_is_resolved(env, ret_type_id)) {\n\t\t\terr = btf_resolve(env, ret_type, ret_type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t/* Ensure the return type is a type that has a size */\n\t\tif (!btf_type_id_size(btf, &ret_type_id, NULL)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid return type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!nr_args)\n\t\treturn 0;\n\n\t/* Last func arg type_id could be 0 if it is a vararg */\n\tif (!args[nr_args - 1].type) {\n\t\tif (args[nr_args - 1].name_off) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\",\n\t\t\t\t\t      nr_args);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tnr_args--;\n\t}\n\n\terr = 0;\n\tfor (i = 0; i < nr_args; i++) {\n\t\tconst struct btf_type *arg_type;\n\t\tu32 arg_type_id;\n\n\t\targ_type_id = args[i].type;\n\t\targ_type = btf_type_by_id(btf, arg_type_id);\n\t\tif (!arg_type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (args[i].name_off &&\n\t\t    (!btf_name_offset_valid(btf, args[i].name_off) ||\n\t\t     !btf_name_valid_identifier(btf, args[i].name_off))) {\n\t\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t\t      \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(arg_type) &&\n\t\t    !env_type_is_resolved(env, arg_type_id)) {\n\t\t\terr = btf_resolve(env, arg_type, arg_type_id);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!btf_type_id_size(btf, &arg_type_id, NULL)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid arg#%u\"",
            "i + 1"
          ],
          "line": 4019
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1311-1348",
          "snippet": "static void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* btf verifier prints all types it is processing via\n\t * btf_verifier_log_type(..., fmt = NULL).\n\t * Skip those prints for in-kernel BTF verification.\n\t */\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   __btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\n\nstatic void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* btf verifier prints all types it is processing via\n\t * btf_verifier_log_type(..., fmt = NULL).\n\t * Skip those prints for in-kernel BTF verification.\n\t */\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   __btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&arg_type_id",
            "NULL"
          ],
          "line": 4018
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_resolve",
          "args": [
            "env",
            "arg_type",
            "arg_type_id"
          ],
          "line": 4013
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "4187-4218",
          "snippet": "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id)\n{\n\tu32 save_log_type_id = env->log_type_id;\n\tconst struct resolve_vertex *v;\n\tint err = 0;\n\n\tenv->resolve_mode = RESOLVE_TBD;\n\tenv_stack_push(env, t, type_id);\n\twhile (!err && (v = env_stack_peak(env))) {\n\t\tenv->log_type_id = v->type_id;\n\t\terr = btf_type_ops(v->t)->resolve(env, v);\n\t}\n\n\tenv->log_type_id = type_id;\n\tif (err == -E2BIG) {\n\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t      \"Exceeded max resolving depth:%u\",\n\t\t\t\t      MAX_RESOLVE_DEPTH);\n\t} else if (err == -EEXIST) {\n\t\tbtf_verifier_log_type(env, t, \"Loop detected\");\n\t}\n\n\t/* Final sanity check */\n\tif (!err && !btf_resolve_valid(env, t, type_id)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");\n\t\terr = -EINVAL;\n\t}\n\n\tenv->log_type_id = save_log_type_id;\n\treturn err;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id)\n{\n\tu32 save_log_type_id = env->log_type_id;\n\tconst struct resolve_vertex *v;\n\tint err = 0;\n\n\tenv->resolve_mode = RESOLVE_TBD;\n\tenv_stack_push(env, t, type_id);\n\twhile (!err && (v = env_stack_peak(env))) {\n\t\tenv->log_type_id = v->type_id;\n\t\terr = btf_type_ops(v->t)->resolve(env, v);\n\t}\n\n\tenv->log_type_id = type_id;\n\tif (err == -E2BIG) {\n\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t      \"Exceeded max resolving depth:%u\",\n\t\t\t\t      MAX_RESOLVE_DEPTH);\n\t} else if (err == -EEXIST) {\n\t\tbtf_verifier_log_type(env, t, \"Loop detected\");\n\t}\n\n\t/* Final sanity check */\n\tif (!err && !btf_resolve_valid(env, t, type_id)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");\n\t\terr = -EINVAL;\n\t}\n\n\tenv->log_type_id = save_log_type_id;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "arg_type_id"
          ],
          "line": 4012
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1630-1638",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_needs_resolve",
          "args": [
            "arg_type"
          ],
          "line": 4011
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_needs_resolve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "575-584",
          "snippet": "static bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t       btf_type_is_ptr(t) ||\n\t       btf_type_is_struct(t) ||\n\t       btf_type_is_array(t) ||\n\t       btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t       btf_type_is_ptr(t) ||\n\t       btf_type_is_struct(t) ||\n\t       btf_type_is_array(t) ||\n\t       btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_valid_identifier",
          "args": [
            "btf",
            "args[i].name_off"
          ],
          "line": 4004
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_valid_identifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "705-708",
          "snippet": "static bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_offset_valid",
          "args": [
            "btf",
            "args[i].name_off"
          ],
          "line": 4003
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_offset_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "646-656",
          "snippet": "static bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\tif (!BTF_STR_OFFSET_VALID(offset))\n\t\treturn false;\n\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\treturn offset < btf->hdr.str_len;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\tif (!BTF_STR_OFFSET_VALID(offset))\n\t\treturn false;\n\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\treturn offset < btf->hdr.str_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "arg_type_id"
          ],
          "line": 3995
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid return type\""
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid return type\""
          ],
          "line": 3958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_func_proto_check(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t)\n{\n\tconst struct btf_type *ret_type;\n\tconst struct btf_param *args;\n\tconst struct btf *btf;\n\tu16 nr_args, i;\n\tint err;\n\n\tbtf = env->btf;\n\targs = (const struct btf_param *)(t + 1);\n\tnr_args = btf_type_vlen(t);\n\n\t/* Check func return type which could be \"void\" (t->type == 0) */\n\tif (t->type) {\n\t\tu32 ret_type_id = t->type;\n\n\t\tret_type = btf_type_by_id(btf, ret_type_id);\n\t\tif (!ret_type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid return type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(ret_type) &&\n\t\t    !env_type_is_resolved(env, ret_type_id)) {\n\t\t\terr = btf_resolve(env, ret_type, ret_type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t/* Ensure the return type is a type that has a size */\n\t\tif (!btf_type_id_size(btf, &ret_type_id, NULL)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid return type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!nr_args)\n\t\treturn 0;\n\n\t/* Last func arg type_id could be 0 if it is a vararg */\n\tif (!args[nr_args - 1].type) {\n\t\tif (args[nr_args - 1].name_off) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\",\n\t\t\t\t\t      nr_args);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tnr_args--;\n\t}\n\n\terr = 0;\n\tfor (i = 0; i < nr_args; i++) {\n\t\tconst struct btf_type *arg_type;\n\t\tu32 arg_type_id;\n\n\t\targ_type_id = args[i].type;\n\t\targ_type = btf_type_by_id(btf, arg_type_id);\n\t\tif (!arg_type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (args[i].name_off &&\n\t\t    (!btf_name_offset_valid(btf, args[i].name_off) ||\n\t\t     !btf_name_valid_identifier(btf, args[i].name_off))) {\n\t\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t\t      \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(arg_type) &&\n\t\t    !env_type_is_resolved(env, arg_type_id)) {\n\t\t\terr = btf_resolve(env, arg_type, arg_type_id);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!btf_type_id_size(btf, &arg_type_id, NULL)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "btf_decl_tag_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3924-3928",
    "snippet": "static void btf_decl_tag_log(struct btf_verifier_env *env, const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"type=%u component_idx=%d\", t->type,\n\t\t\t btf_type_decl_tag(t)->component_idx);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"type=%u component_idx=%d\"",
            "t->type",
            "btf_type_decl_tag(t)->component_idx"
          ],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_decl_tag",
          "args": [
            "t"
          ],
          "line": 3927
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_decl_tag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "636-639",
          "snippet": "static const struct btf_decl_tag *btf_type_decl_tag(const struct btf_type *t)\n{\n\treturn (const struct btf_decl_tag *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_decl_tag *btf_type_decl_tag(const struct btf_type *t)\n{\n\treturn (const struct btf_decl_tag *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_decl_tag_log(struct btf_verifier_env *env, const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"type=%u component_idx=%d\", t->type,\n\t\t\t btf_type_decl_tag(t)->component_idx);\n}"
  },
  {
    "function_name": "btf_decl_tag_resolve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3878-3922",
    "snippet": "static int btf_decl_tag_resolve(struct btf_verifier_env *env,\n\t\t\t   const struct resolve_vertex *v)\n{\n\tconst struct btf_type *next_type;\n\tconst struct btf_type *t = v->t;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\ts32 component_idx;\n\tu32 vlen;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type || !btf_type_is_decl_tag_target(next_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\tcomponent_idx = btf_type_decl_tag(t)->component_idx;\n\tif (component_idx != -1) {\n\t\tif (btf_type_is_var(next_type) || btf_type_is_typedef(next_type)) {\n\t\t\tbtf_verifier_log_type(env, v->t, \"Invalid component_idx\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (btf_type_is_struct(next_type)) {\n\t\t\tvlen = btf_type_vlen(next_type);\n\t\t} else {\n\t\t\t/* next_type should be a function */\n\t\t\tnext_type = btf_type_by_id(btf, next_type->type);\n\t\t\tvlen = btf_type_vlen(next_type);\n\t\t}\n\n\t\tif ((u32)component_idx >= vlen) {\n\t\t\tbtf_verifier_log_type(env, v->t, \"Invalid component_idx\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_stack_pop_resolved",
          "args": [
            "env",
            "next_type_id",
            "0"
          ],
          "line": 3919
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_pop_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1676-1687",
          "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid component_idx\""
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "next_type"
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "next_type->type"
          ],
          "line": 3909
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "next_type"
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "next_type"
          ],
          "line": 3905
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid component_idx\""
          ],
          "line": 3901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_typedef",
          "args": [
            "next_type"
          ],
          "line": 3900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_var",
          "args": [
            "next_type"
          ],
          "line": 3900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_decl_tag",
          "args": [
            "t"
          ],
          "line": 3898
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_decl_tag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "636-639",
          "snippet": "static const struct btf_decl_tag *btf_type_decl_tag(const struct btf_type *t)\n{\n\treturn (const struct btf_decl_tag *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_decl_tag *btf_type_decl_tag(const struct btf_type *t)\n{\n\treturn (const struct btf_decl_tag *)(t + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "next_type",
            "next_type_id"
          ],
          "line": 3896
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1640-1668",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "next_type_id"
          ],
          "line": 3895
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1630-1638",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolve_sink",
          "args": [
            "env",
            "next_type"
          ],
          "line": 3894
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolve_sink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1605-1628",
          "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid type_id\""
          ],
          "line": 3890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_decl_tag_target",
          "args": [
            "next_type"
          ],
          "line": 3889
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_decl_tag_target",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "471-475",
          "snippet": "static bool btf_type_is_decl_tag_target(const struct btf_type *t)\n{\n\treturn btf_type_is_func(t) || btf_type_is_struct(t) ||\n\t       btf_type_is_var(t) || btf_type_is_typedef(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_decl_tag_target(const struct btf_type *t)\n{\n\treturn btf_type_is_func(t) || btf_type_is_struct(t) ||\n\t       btf_type_is_var(t) || btf_type_is_typedef(t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_decl_tag_resolve(struct btf_verifier_env *env,\n\t\t\t   const struct resolve_vertex *v)\n{\n\tconst struct btf_type *next_type;\n\tconst struct btf_type *t = v->t;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\ts32 component_idx;\n\tu32 vlen;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type || !btf_type_is_decl_tag_target(next_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\tcomponent_idx = btf_type_decl_tag(t)->component_idx;\n\tif (component_idx != -1) {\n\t\tif (btf_type_is_var(next_type) || btf_type_is_typedef(next_type)) {\n\t\t\tbtf_verifier_log_type(env, v->t, \"Invalid component_idx\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (btf_type_is_struct(next_type)) {\n\t\t\tvlen = btf_type_vlen(next_type);\n\t\t} else {\n\t\t\t/* next_type should be a function */\n\t\t\tnext_type = btf_type_by_id(btf, next_type->type);\n\t\t\tvlen = btf_type_vlen(next_type);\n\t\t}\n\n\t\tif ((u32)component_idx >= vlen) {\n\t\t\tbtf_verifier_log_type(env, v->t, \"Invalid component_idx\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_decl_tag_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3835-3876",
    "snippet": "static s32 btf_decl_tag_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tconst struct btf_decl_tag *tag;\n\tu32 meta_needed = sizeof(*tag);\n\ts32 component_idx;\n\tconst char *value;\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tvalue = btf_name_by_offset(env->btf, t->name_off);\n\tif (!value || !value[0]) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid value\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tcomponent_idx = btf_type_decl_tag(t)->component_idx;\n\tif (component_idx < -1) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid component_idx\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid component_idx\""
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_decl_tag",
          "args": [
            "t"
          ],
          "line": 3867
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_decl_tag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "636-639",
          "snippet": "static const struct btf_decl_tag *btf_type_decl_tag(const struct btf_type *t)\n{\n\treturn (const struct btf_decl_tag *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_decl_tag *btf_type_decl_tag(const struct btf_type *t)\n{\n\treturn (const struct btf_decl_tag *)(t + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid btf_info kind_flag\""
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "t"
          ],
          "line": 3862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"vlen != 0\""
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid value\""
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "env->btf",
            "t->name_off"
          ],
          "line": 3851
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "726-729",
          "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic s32 btf_decl_tag_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tconst struct btf_decl_tag *tag;\n\tu32 meta_needed = sizeof(*tag);\n\ts32 component_idx;\n\tconst char *value;\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tvalue = btf_name_by_offset(env->btf, t->name_off);\n\tif (!value || !value[0]) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid value\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tcomponent_idx = btf_type_decl_tag(t)->component_idx;\n\tif (component_idx < -1) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid component_idx\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_float_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3820-3824",
    "snippet": "static void btf_float_log(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u\", t->size);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"size=%u\"",
            "t->size"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_float_log(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u\", t->size);\n}"
  },
  {
    "function_name": "btf_float_check_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3785-3818",
    "snippet": "static int btf_float_check_member(struct btf_verifier_env *env,\n\t\t\t\t  const struct btf_type *struct_type,\n\t\t\t\t  const struct btf_member *member,\n\t\t\t\t  const struct btf_type *member_type)\n{\n\tu64 start_offset_bytes;\n\tu64 end_offset_bytes;\n\tu64 misalign_bits;\n\tu64 align_bytes;\n\tu64 align_bits;\n\n\t/* Different architectures have different alignment requirements, so\n\t * here we check only for the reasonable minimum. This way we ensure\n\t * that types after CO-RE can pass the kernel BTF verifier.\n\t */\n\talign_bytes = min_t(u64, sizeof(void *), member_type->size);\n\talign_bits = align_bytes * BITS_PER_BYTE;\n\tdiv64_u64_rem(member->offset, align_bits, &misalign_bits);\n\tif (misalign_bits) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not properly aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstart_offset_bytes = member->offset / BITS_PER_BYTE;\n\tend_offset_bytes = start_offset_bytes + member_type->size;\n\tif (end_offset_bytes > struct_type->size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 3812
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "div64_u64_rem",
          "args": [
            "member->offset",
            "align_bits",
            "&misalign_bits"
          ],
          "line": 3802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "sizeof(void *)",
            "member_type->size"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_float_check_member(struct btf_verifier_env *env,\n\t\t\t\t  const struct btf_type *struct_type,\n\t\t\t\t  const struct btf_member *member,\n\t\t\t\t  const struct btf_type *member_type)\n{\n\tu64 start_offset_bytes;\n\tu64 end_offset_bytes;\n\tu64 misalign_bits;\n\tu64 align_bytes;\n\tu64 align_bits;\n\n\t/* Different architectures have different alignment requirements, so\n\t * here we check only for the reasonable minimum. This way we ensure\n\t * that types after CO-RE can pass the kernel BTF verifier.\n\t */\n\talign_bytes = min_t(u64, sizeof(void *), member_type->size);\n\talign_bits = align_bytes * BITS_PER_BYTE;\n\tdiv64_u64_rem(member->offset, align_bits, &misalign_bits);\n\tif (misalign_bits) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not properly aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstart_offset_bytes = member->offset / BITS_PER_BYTE;\n\tend_offset_bytes = start_offset_bytes + member_type->size;\n\tif (end_offset_bytes > struct_type->size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_float_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3760-3783",
    "snippet": "static s32 btf_float_check_meta(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t,\n\t\t\t\tu32 meta_left)\n{\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size != 2 && t->size != 4 && t->size != 8 && t->size != 12 &&\n\t    t->size != 16) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid type_size\""
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid btf_info kind_flag\""
          ],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "t"
          ],
          "line": 3769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"vlen != 0\""
          ],
          "line": 3765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic s32 btf_float_check_meta(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t,\n\t\t\t\tu32 meta_left)\n{\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size != 2 && t->size != 4 && t->size != 8 && t->size != 12 &&\n\t    t->size != 16) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_datasec_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3727-3749",
    "snippet": "static void btf_datasec_show(const struct btf *btf,\n\t\t\t     const struct btf_type *t, u32 type_id,\n\t\t\t     void *data, u8 bits_offset,\n\t\t\t     struct btf_show *show)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tconst struct btf_type *var;\n\tu32 i;\n\n\tif (!btf_show_start_type(show, t, type_id, data))\n\t\treturn;\n\n\tbtf_show_type_value(show, \"section (\\\"%s\\\") = {\",\n\t\t\t    __btf_name_by_offset(btf, t->name_off));\n\tfor_each_vsi(i, t, vsi) {\n\t\tvar = btf_type_by_id(btf, vsi->type);\n\t\tif (i)\n\t\t\tbtf_show(show, \",\");\n\t\tbtf_type_ops(var)->show(btf, var, vsi->type,\n\t\t\t\t\tdata + vsi->offset, bits_offset, show);\n\t}\n\tbtf_show_end_type(show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_end_type",
          "args": [
            "show"
          ],
          "line": 3748
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1201-1206",
          "snippet": "static void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "btf",
            "var",
            "vsi->type",
            "data + vsi->offset",
            "bits_offset",
            "show"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "var"
          ],
          "line": 3745
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show",
          "args": [
            "show",
            "\",\""
          ],
          "line": 3744
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_btf_show_fdinfo",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "6016-6021",
          "snippet": "static void bpf_btf_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct btf *btf = filp->private_data;\n\n\tseq_printf(m, \"btf_id:\\t%u\\n\", btf->id);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void bpf_btf_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct btf *btf = filp->private_data;\n\n\tseq_printf(m, \"btf_id:\\t%u\\n\", btf->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "vsi->type"
          ],
          "line": 3742
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_vsi",
          "args": [
            "i",
            "t",
            "vsi"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"section (\\\"%s\\\") = {\"",
            "__btf_name_by_offset(btf, t->name_off)"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_name_by_offset",
          "args": [
            "btf",
            "t->name_off"
          ],
          "line": 3740
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "715-724",
          "snippet": "static const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_start_type",
          "args": [
            "show",
            "t",
            "type_id",
            "data"
          ],
          "line": 3736
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1190-1199",
          "snippet": "static void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_datasec_show(const struct btf *btf,\n\t\t\t     const struct btf_type *t, u32 type_id,\n\t\t\t     void *data, u8 bits_offset,\n\t\t\t     struct btf_show *show)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tconst struct btf_type *var;\n\tu32 i;\n\n\tif (!btf_show_start_type(show, t, type_id, data))\n\t\treturn;\n\n\tbtf_show_type_value(show, \"section (\\\"%s\\\") = {\",\n\t\t\t    __btf_name_by_offset(btf, t->name_off));\n\tfor_each_vsi(i, t, vsi) {\n\t\tvar = btf_type_by_id(btf, vsi->type);\n\t\tif (i)\n\t\t\tbtf_show(show, \",\");\n\t\tbtf_type_ops(var)->show(btf, var, vsi->type,\n\t\t\t\t\tdata + vsi->offset, bits_offset, show);\n\t}\n\tbtf_show_end_type(show);\n}"
  },
  {
    "function_name": "btf_datasec_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3721-3725",
    "snippet": "static void btf_datasec_log(struct btf_verifier_env *env,\n\t\t\t    const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"size=%u vlen=%u\"",
            "t->size",
            "btf_type_vlen(t)"
          ],
          "line": 3724
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_datasec_log(struct btf_verifier_env *env,\n\t\t\t    const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}"
  },
  {
    "function_name": "btf_datasec_resolve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3682-3719",
    "snippet": "static int btf_datasec_resolve(struct btf_verifier_env *env,\n\t\t\t       const struct resolve_vertex *v)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tstruct btf *btf = env->btf;\n\tu16 i;\n\n\tfor_each_vsi_from(i, v->next_member, v->t, vsi) {\n\t\tu32 var_type_id = vsi->type, type_id, type_size = 0;\n\t\tconst struct btf_type *var_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t\t\t var_type_id);\n\t\tif (!var_type || !btf_type_is_var(var_type)) {\n\t\t\tbtf_verifier_log_vsi(env, v->t, vsi,\n\t\t\t\t\t     \"Not a VAR kind member\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!env_type_is_resolve_sink(env, var_type) &&\n\t\t    !env_type_is_resolved(env, var_type_id)) {\n\t\t\tenv_stack_set_next_member(env, i + 1);\n\t\t\treturn env_stack_push(env, var_type, var_type_id);\n\t\t}\n\n\t\ttype_id = var_type->type;\n\t\tif (!btf_type_id_size(btf, &type_id, &type_size)) {\n\t\t\tbtf_verifier_log_vsi(env, v->t, vsi, \"Invalid type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (vsi->size < type_size) {\n\t\t\tbtf_verifier_log_vsi(env, v->t, vsi, \"Invalid size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tenv_stack_pop_resolved(env, 0, 0);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_stack_pop_resolved",
          "args": [
            "env",
            "0",
            "0"
          ],
          "line": 3717
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_pop_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1676-1687",
          "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_vsi",
          "args": [
            "env",
            "v->t",
            "vsi",
            "\"Invalid size\""
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_vsi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1402-1427",
          "snippet": "static void btf_verifier_log_vsi(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *datasec_type,\n\t\t\t\t const struct btf_var_secinfo *vsi,\n\t\t\t\t const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, datasec_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t type_id=%u offset=%u size=%u\",\n\t\t\t   vsi->type, vsi->offset, vsi->size);\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_vsi(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *datasec_type,\n\t\t\t\t const struct btf_var_secinfo *vsi,\n\t\t\t\t const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, datasec_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t type_id=%u offset=%u size=%u\",\n\t\t\t   vsi->type, vsi->offset, vsi->size);\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&type_id",
            "&type_size"
          ],
          "line": 3706
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "var_type",
            "var_type_id"
          ],
          "line": 3702
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1640-1668",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_set_next_member",
          "args": [
            "env",
            "i + 1"
          ],
          "line": 3701
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_set_next_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1670-1674",
          "snippet": "static void env_stack_set_next_member(struct btf_verifier_env *env,\n\t\t\t\t      u16 next_member)\n{\n\tenv->stack[env->top_stack - 1].next_member = next_member;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void env_stack_set_next_member(struct btf_verifier_env *env,\n\t\t\t\t      u16 next_member)\n{\n\tenv->stack[env->top_stack - 1].next_member = next_member;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "var_type_id"
          ],
          "line": 3700
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1630-1638",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolve_sink",
          "args": [
            "env",
            "var_type"
          ],
          "line": 3699
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolve_sink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1605-1628",
          "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_var",
          "args": [
            "var_type"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "env->btf",
            "var_type_id"
          ],
          "line": 3691
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_vsi_from",
          "args": [
            "i",
            "v->next_member",
            "v->t",
            "vsi"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_datasec_resolve(struct btf_verifier_env *env,\n\t\t\t       const struct resolve_vertex *v)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tstruct btf *btf = env->btf;\n\tu16 i;\n\n\tfor_each_vsi_from(i, v->next_member, v->t, vsi) {\n\t\tu32 var_type_id = vsi->type, type_id, type_size = 0;\n\t\tconst struct btf_type *var_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t\t\t var_type_id);\n\t\tif (!var_type || !btf_type_is_var(var_type)) {\n\t\t\tbtf_verifier_log_vsi(env, v->t, vsi,\n\t\t\t\t\t     \"Not a VAR kind member\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!env_type_is_resolve_sink(env, var_type) &&\n\t\t    !env_type_is_resolved(env, var_type_id)) {\n\t\t\tenv_stack_set_next_member(env, i + 1);\n\t\t\treturn env_stack_push(env, var_type, var_type_id);\n\t\t}\n\n\t\ttype_id = var_type->type;\n\t\tif (!btf_type_id_size(btf, &type_id, &type_size)) {\n\t\t\tbtf_verifier_log_vsi(env, v->t, vsi, \"Invalid type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (vsi->size < type_size) {\n\t\t\tbtf_verifier_log_vsi(env, v->t, vsi, \"Invalid size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tenv_stack_pop_resolved(env, 0, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_datasec_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3609-3680",
    "snippet": "static s32 btf_datasec_check_meta(struct btf_verifier_env *env,\n\t\t\t\t  const struct btf_type *t,\n\t\t\t\t  u32 meta_left)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tu64 last_vsi_end_off = 0, sum = 0;\n\tu32 i, meta_needed;\n\n\tmeta_needed = btf_type_vlen(t) * sizeof(*vsi);\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!t->size) {\n\t\tbtf_verifier_log_type(env, t, \"size == 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!t->name_off ||\n\t    !btf_name_valid_section(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tfor_each_vsi(i, t, vsi) {\n\t\t/* A var cannot be in type void */\n\t\tif (!vsi->type || !BTF_TYPE_ID_VALID(vsi->type)) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (vsi->offset < last_vsi_end_off || vsi->offset >= t->size) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!vsi->size || vsi->size > t->size) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlast_vsi_end_off = vsi->offset + vsi->size;\n\t\tif (last_vsi_end_off > t->size) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid offset+size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbtf_verifier_log_vsi(env, t, vsi, NULL);\n\t\tsum += vsi->size;\n\t}\n\n\tif (t->size < sum) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid btf_info size\""
          ],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_vsi",
          "args": [
            "env",
            "t",
            "vsi",
            "NULL"
          ],
          "line": 3670
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_vsi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1402-1427",
          "snippet": "static void btf_verifier_log_vsi(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *datasec_type,\n\t\t\t\t const struct btf_var_secinfo *vsi,\n\t\t\t\t const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, datasec_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t type_id=%u offset=%u size=%u\",\n\t\t\t   vsi->type, vsi->offset, vsi->size);\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_vsi(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *datasec_type,\n\t\t\t\t const struct btf_var_secinfo *vsi,\n\t\t\t\t const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, datasec_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t type_id=%u offset=%u size=%u\",\n\t\t\t   vsi->type, vsi->offset, vsi->size);\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_TYPE_ID_VALID",
          "args": [
            "vsi->type"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_vsi",
          "args": [
            "i",
            "t",
            "vsi"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 3637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_valid_section",
          "args": [
            "env->btf",
            "t->name_off"
          ],
          "line": 3636
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_valid_section",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "710-713",
          "snippet": "static bool btf_name_valid_section(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, true);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_valid_section(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid btf_info kind_flag\""
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "t"
          ],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"size == 0\""
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic s32 btf_datasec_check_meta(struct btf_verifier_env *env,\n\t\t\t\t  const struct btf_type *t,\n\t\t\t\t  u32 meta_left)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tu64 last_vsi_end_off = 0, sum = 0;\n\tu32 i, meta_needed;\n\n\tmeta_needed = btf_type_vlen(t) * sizeof(*vsi);\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!t->size) {\n\t\tbtf_verifier_log_type(env, t, \"size == 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!t->name_off ||\n\t    !btf_name_valid_section(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tfor_each_vsi(i, t, vsi) {\n\t\t/* A var cannot be in type void */\n\t\tif (!vsi->type || !BTF_TYPE_ID_VALID(vsi->type)) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (vsi->offset < last_vsi_end_off || vsi->offset >= t->size) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!vsi->size || vsi->size > t->size) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlast_vsi_end_off = vsi->offset + vsi->size;\n\t\tif (last_vsi_end_off > t->size) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid offset+size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbtf_verifier_log_vsi(env, t, vsi, NULL);\n\t\tsum += vsi->size;\n\t}\n\n\tif (t->size < sum) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_var_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3593-3598",
    "snippet": "static void btf_var_log(struct btf_verifier_env *env, const struct btf_type *t)\n{\n\tconst struct btf_var *var = btf_type_var(t);\n\n\tbtf_verifier_log(env, \"type_id=%u linkage=%u\", t->type, var->linkage);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"type_id=%u linkage=%u\"",
            "t->type",
            "var->linkage"
          ],
          "line": 3597
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_var",
          "args": [
            "t"
          ],
          "line": 3595
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "631-634",
          "snippet": "static const struct btf_var *btf_type_var(const struct btf_type *t)\n{\n\treturn (const struct btf_var *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_var *btf_type_var(const struct btf_type *t)\n{\n\treturn (const struct btf_var *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_var_log(struct btf_verifier_env *env, const struct btf_type *t)\n{\n\tconst struct btf_var *var = btf_type_var(t);\n\n\tbtf_verifier_log(env, \"type_id=%u linkage=%u\", t->type, var->linkage);\n}"
  },
  {
    "function_name": "btf_var_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3545-3591",
    "snippet": "static s32 btf_var_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tconst struct btf_var *var;\n\tu32 meta_needed = sizeof(*var);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!t->name_off ||\n\t    !__btf_name_valid(env->btf, t->name_off, true)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* A var cannot be in type void */\n\tif (!t->type || !BTF_TYPE_ID_VALID(t->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tvar = btf_type_var(t);\n\tif (var->linkage != BTF_VAR_STATIC &&\n\t    var->linkage != BTF_VAR_GLOBAL_ALLOCATED) {\n\t\tbtf_verifier_log_type(env, t, \"Linkage not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Linkage not supported\""
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_var",
          "args": [
            "t"
          ],
          "line": 3581
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "631-634",
          "snippet": "static const struct btf_var *btf_type_var(const struct btf_type *t)\n{\n\treturn (const struct btf_var *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_var *btf_type_var(const struct btf_type *t)\n{\n\treturn (const struct btf_var *)(t + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid type_id\""
          ],
          "line": 3577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_TYPE_ID_VALID",
          "args": [
            "t->type"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_name_valid",
          "args": [
            "env->btf",
            "t->name_off",
            "true"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "681-700",
          "snippet": "static bool __btf_name_valid(const struct btf *btf, u32 offset, bool dot_ok)\n{\n\t/* offset must be valid */\n\tconst char *src = btf_str_by_offset(btf, offset);\n\tconst char *src_limit;\n\n\tif (!__btf_name_char_ok(*src, true, dot_ok))\n\t\treturn false;\n\n\t/* set a limit on identifier length */\n\tsrc_limit = src + KSYM_NAME_LEN;\n\tsrc++;\n\twhile (*src && src < src_limit) {\n\t\tif (!__btf_name_char_ok(*src, false, dot_ok))\n\t\t\treturn false;\n\t\tsrc++;\n\t}\n\n\treturn !*src;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_name_valid(const struct btf *btf, u32 offset, bool dot_ok)\n{\n\t/* offset must be valid */\n\tconst char *src = btf_str_by_offset(btf, offset);\n\tconst char *src_limit;\n\n\tif (!__btf_name_char_ok(*src, true, dot_ok))\n\t\treturn false;\n\n\t/* set a limit on identifier length */\n\tsrc_limit = src + KSYM_NAME_LEN;\n\tsrc++;\n\twhile (*src && src < src_limit) {\n\t\tif (!__btf_name_char_ok(*src, false, dot_ok))\n\t\t\treturn false;\n\t\tsrc++;\n\t}\n\n\treturn !*src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid btf_info kind_flag\""
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "t"
          ],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"vlen != 0\""
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic s32 btf_var_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tconst struct btf_var *var;\n\tu32 meta_needed = sizeof(*var);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!t->name_off ||\n\t    !__btf_name_valid(env->btf, t->name_off, true)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* A var cannot be in type void */\n\tif (!t->type || !BTF_TYPE_ID_VALID(t->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tvar = btf_type_var(t);\n\tif (var->linkage != BTF_VAR_STATIC &&\n\t    var->linkage != BTF_VAR_GLOBAL_ALLOCATED) {\n\t\tbtf_verifier_log_type(env, t, \"Linkage not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_func_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3511-3534",
    "snippet": "static s32 btf_func_check_meta(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *t,\n\t\t\t       u32 meta_left)\n{\n\tif (!t->name_off ||\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t) > BTF_FUNC_GLOBAL) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid func linkage\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid btf_info kind_flag\""
          ],
          "line": 3527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "t"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid func linkage\""
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_valid_identifier",
          "args": [
            "env->btf",
            "t->name_off"
          ],
          "line": 3516
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_valid_identifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "705-708",
          "snippet": "static bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic s32 btf_func_check_meta(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *t,\n\t\t\t       u32 meta_left)\n{\n\tif (!t->name_off ||\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t) > BTF_FUNC_GLOBAL) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid func linkage\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_func_proto_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3452-3491",
    "snippet": "static void btf_func_proto_log(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *t)\n{\n\tconst struct btf_param *args = (const struct btf_param *)(t + 1);\n\tu16 nr_args = btf_type_vlen(t), i;\n\n\tbtf_verifier_log(env, \"return=%u args=(\", t->type);\n\tif (!nr_args) {\n\t\tbtf_verifier_log(env, \"void\");\n\t\tgoto done;\n\t}\n\n\tif (nr_args == 1 && !args[0].type) {\n\t\t/* Only one vararg */\n\t\tbtf_verifier_log(env, \"vararg\");\n\t\tgoto done;\n\t}\n\n\tbtf_verifier_log(env, \"%u %s\", args[0].type,\n\t\t\t __btf_name_by_offset(env->btf,\n\t\t\t\t\t      args[0].name_off));\n\tfor (i = 1; i < nr_args - 1; i++)\n\t\tbtf_verifier_log(env, \", %u %s\", args[i].type,\n\t\t\t\t __btf_name_by_offset(env->btf,\n\t\t\t\t\t\t      args[i].name_off));\n\n\tif (nr_args > 1) {\n\t\tconst struct btf_param *last_arg = &args[nr_args - 1];\n\n\t\tif (last_arg->type)\n\t\t\tbtf_verifier_log(env, \", %u %s\", last_arg->type,\n\t\t\t\t\t __btf_name_by_offset(env->btf,\n\t\t\t\t\t\t\t      last_arg->name_off));\n\t\telse\n\t\t\tbtf_verifier_log(env, \", vararg\");\n\t}\n\ndone:\n\tbtf_verifier_log(env, \")\");\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\")\""
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_hdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1429-1451",
          "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\", %u %s\"",
            "last_arg->type",
            "__btf_name_by_offset(env->btf,\n\t\t\t\t\t\t\t      last_arg->name_off)"
          ],
          "line": 3482
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_name_by_offset",
          "args": [
            "env->btf",
            "last_arg->name_off"
          ],
          "line": 3483
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "715-724",
          "snippet": "static const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_func_proto_log(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *t)\n{\n\tconst struct btf_param *args = (const struct btf_param *)(t + 1);\n\tu16 nr_args = btf_type_vlen(t), i;\n\n\tbtf_verifier_log(env, \"return=%u args=(\", t->type);\n\tif (!nr_args) {\n\t\tbtf_verifier_log(env, \"void\");\n\t\tgoto done;\n\t}\n\n\tif (nr_args == 1 && !args[0].type) {\n\t\t/* Only one vararg */\n\t\tbtf_verifier_log(env, \"vararg\");\n\t\tgoto done;\n\t}\n\n\tbtf_verifier_log(env, \"%u %s\", args[0].type,\n\t\t\t __btf_name_by_offset(env->btf,\n\t\t\t\t\t      args[0].name_off));\n\tfor (i = 1; i < nr_args - 1; i++)\n\t\tbtf_verifier_log(env, \", %u %s\", args[i].type,\n\t\t\t\t __btf_name_by_offset(env->btf,\n\t\t\t\t\t\t      args[i].name_off));\n\n\tif (nr_args > 1) {\n\t\tconst struct btf_param *last_arg = &args[nr_args - 1];\n\n\t\tif (last_arg->type)\n\t\t\tbtf_verifier_log(env, \", %u %s\", last_arg->type,\n\t\t\t\t\t __btf_name_by_offset(env->btf,\n\t\t\t\t\t\t\t      last_arg->name_off));\n\t\telse\n\t\t\tbtf_verifier_log(env, \", vararg\");\n\t}\n\ndone:\n\tbtf_verifier_log(env, \")\");\n}"
  },
  {
    "function_name": "btf_func_proto_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3424-3450",
    "snippet": "static s32 btf_func_proto_check_meta(struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     u32 meta_left)\n{\n\tu32 meta_needed = btf_type_vlen(t) * sizeof(struct btf_param);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->name_off) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid btf_info kind_flag\""
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "t"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 3431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic s32 btf_func_proto_check_meta(struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     u32 meta_left)\n{\n\tu32 meta_needed = btf_type_vlen(t) * sizeof(struct btf_param);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->name_off) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_enum_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3384-3413",
    "snippet": "static void btf_enum_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t  u32 type_id, void *data, u8 bits_offset,\n\t\t\t  struct btf_show *show)\n{\n\tconst struct btf_enum *enums = btf_type_enum(t);\n\tu32 i, nr_enums = btf_type_vlen(t);\n\tvoid *safe_data;\n\tint v;\n\n\tsafe_data = btf_show_start_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\tv = *(int *)safe_data;\n\n\tfor (i = 0; i < nr_enums; i++) {\n\t\tif (v != enums[i].val)\n\t\t\tcontinue;\n\n\t\tbtf_show_type_value(show, \"%s\",\n\t\t\t\t    __btf_name_by_offset(btf,\n\t\t\t\t\t\t\t enums[i].name_off));\n\n\t\tbtf_show_end_type(show);\n\t\treturn;\n\t}\n\n\tbtf_show_type_value(show, \"%d\", v);\n\tbtf_show_end_type(show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_end_type",
          "args": [
            "show"
          ],
          "line": 3412
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1201-1206",
          "snippet": "static void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"%d\"",
            "v"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"%s\"",
            "__btf_name_by_offset(btf,\n\t\t\t\t\t\t\t enums[i].name_off)"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_name_by_offset",
          "args": [
            "btf",
            "enums[i].name_off"
          ],
          "line": 3404
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "715-724",
          "snippet": "static const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_start_type",
          "args": [
            "show",
            "t",
            "type_id",
            "data"
          ],
          "line": 3393
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1190-1199",
          "snippet": "static void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_enum",
          "args": [
            "t"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_enum",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "626-629",
          "snippet": "static const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_enum_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t  u32 type_id, void *data, u8 bits_offset,\n\t\t\t  struct btf_show *show)\n{\n\tconst struct btf_enum *enums = btf_type_enum(t);\n\tu32 i, nr_enums = btf_type_vlen(t);\n\tvoid *safe_data;\n\tint v;\n\n\tsafe_data = btf_show_start_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\tv = *(int *)safe_data;\n\n\tfor (i = 0; i < nr_enums; i++) {\n\t\tif (v != enums[i].val)\n\t\t\tcontinue;\n\n\t\tbtf_show_type_value(show, \"%s\",\n\t\t\t\t    __btf_name_by_offset(btf,\n\t\t\t\t\t\t\t enums[i].name_off));\n\n\t\tbtf_show_end_type(show);\n\t\treturn;\n\t}\n\n\tbtf_show_type_value(show, \"%d\", v);\n\tbtf_show_end_type(show);\n}"
  },
  {
    "function_name": "btf_enum_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3378-3382",
    "snippet": "static void btf_enum_log(struct btf_verifier_env *env,\n\t\t\t const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"size=%u vlen=%u\"",
            "t->size",
            "btf_type_vlen(t)"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_enum_log(struct btf_verifier_env *env,\n\t\t\t const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}"
  },
  {
    "function_name": "btf_enum_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3316-3376",
    "snippet": "static s32 btf_enum_check_meta(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *t,\n\t\t\t       u32 meta_left)\n{\n\tconst struct btf_enum *enums = btf_type_enum(t);\n\tstruct btf *btf = env->btf;\n\tu16 i, nr_enums;\n\tu32 meta_needed;\n\n\tnr_enums = btf_type_vlen(t);\n\tmeta_needed = nr_enums * sizeof(*enums);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size > 8 || !is_power_of_2(t->size)) {\n\t\tbtf_verifier_log_type(env, t, \"Unexpected size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* enum type either no name or a valid one */\n\tif (t->name_off &&\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tfor (i = 0; i < nr_enums; i++) {\n\t\tif (!btf_name_offset_valid(btf, enums[i].name_off)) {\n\t\t\tbtf_verifier_log(env, \"\\tInvalid name_offset:%u\",\n\t\t\t\t\t enums[i].name_off);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* enum member must have a valid name */\n\t\tif (!enums[i].name_off ||\n\t\t    !btf_name_valid_identifier(btf, enums[i].name_off)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (env->log.level == BPF_LOG_KERNEL)\n\t\t\tcontinue;\n\t\tbtf_verifier_log(env, \"\\t%s val=%d\\n\",\n\t\t\t\t __btf_name_by_offset(btf, enums[i].name_off),\n\t\t\t\t enums[i].val);\n\t}\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"\\t%s val=%d\\n\"",
            "__btf_name_by_offset(btf, enums[i].name_off)",
            "enums[i].val"
          ],
          "line": 3370
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_name_by_offset",
          "args": [
            "btf",
            "enums[i].name_off"
          ],
          "line": 3371
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "715-724",
          "snippet": "static const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_valid_identifier",
          "args": [
            "btf",
            "enums[i].name_off"
          ],
          "line": 3363
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_valid_identifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "705-708",
          "snippet": "static bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_offset_valid",
          "args": [
            "btf",
            "enums[i].name_off"
          ],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_offset_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "646-656",
          "snippet": "static bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\tif (!BTF_STR_OFFSET_VALID(offset))\n\t\treturn false;\n\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\treturn offset < btf->hdr.str_len;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\tif (!BTF_STR_OFFSET_VALID(offset))\n\t\treturn false;\n\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\treturn offset < btf->hdr.str_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Unexpected size\""
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "t->size"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid btf_info kind_flag\""
          ],
          "line": 3336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "t"
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_enum",
          "args": [
            "t"
          ],
          "line": 3320
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_enum",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "626-629",
          "snippet": "static const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic s32 btf_enum_check_meta(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *t,\n\t\t\t       u32 meta_left)\n{\n\tconst struct btf_enum *enums = btf_type_enum(t);\n\tstruct btf *btf = env->btf;\n\tu16 i, nr_enums;\n\tu32 meta_needed;\n\n\tnr_enums = btf_type_vlen(t);\n\tmeta_needed = nr_enums * sizeof(*enums);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size > 8 || !is_power_of_2(t->size)) {\n\t\tbtf_verifier_log_type(env, t, \"Unexpected size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* enum type either no name or a valid one */\n\tif (t->name_off &&\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tfor (i = 0; i < nr_enums; i++) {\n\t\tif (!btf_name_offset_valid(btf, enums[i].name_off)) {\n\t\t\tbtf_verifier_log(env, \"\\tInvalid name_offset:%u\",\n\t\t\t\t\t enums[i].name_off);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* enum member must have a valid name */\n\t\tif (!enums[i].name_off ||\n\t\t    !btf_name_valid_identifier(btf, enums[i].name_off)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (env->log.level == BPF_LOG_KERNEL)\n\t\t\tcontinue;\n\t\tbtf_verifier_log(env, \"\\t%s val=%d\\n\",\n\t\t\t\t __btf_name_by_offset(btf, enums[i].name_off),\n\t\t\t\t enums[i].val);\n\t}\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_enum_check_kflag_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3281-3314",
    "snippet": "static int btf_enum_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t       const struct btf_type *struct_type,\n\t\t\t\t       const struct btf_member *member,\n\t\t\t\t       const struct btf_type *member_type)\n{\n\tu32 struct_bits_off, nr_bits, bytes_end, struct_size;\n\tu32 int_bitsize = sizeof(int) * BITS_PER_BYTE;\n\n\tstruct_bits_off = BTF_MEMBER_BIT_OFFSET(member->offset);\n\tnr_bits = BTF_MEMBER_BITFIELD_SIZE(member->offset);\n\tif (!nr_bits) {\n\t\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\t\"Member is not byte aligned\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnr_bits = int_bitsize;\n\t} else if (nr_bits > int_bitsize) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member bitfield_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_end = BITS_ROUNDUP_BYTES(struct_bits_off + nr_bits);\n\tif (struct_size < bytes_end) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 3308
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "struct_bits_off + nr_bits"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_MEMBER_BITFIELD_SIZE",
          "args": [
            "member->offset"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_MEMBER_BIT_OFFSET",
          "args": [
            "member->offset"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_enum_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t       const struct btf_type *struct_type,\n\t\t\t\t       const struct btf_member *member,\n\t\t\t\t       const struct btf_type *member_type)\n{\n\tu32 struct_bits_off, nr_bits, bytes_end, struct_size;\n\tu32 int_bitsize = sizeof(int) * BITS_PER_BYTE;\n\n\tstruct_bits_off = BTF_MEMBER_BIT_OFFSET(member->offset);\n\tnr_bits = BTF_MEMBER_BITFIELD_SIZE(member->offset);\n\tif (!nr_bits) {\n\t\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\t\"Member is not byte aligned\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnr_bits = int_bitsize;\n\t} else if (nr_bits > int_bitsize) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member bitfield_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_end = BITS_ROUNDUP_BYTES(struct_bits_off + nr_bits);\n\tif (struct_size < bytes_end) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_enum_check_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3256-3279",
    "snippet": "static int btf_enum_check_member(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *struct_type,\n\t\t\t\t const struct btf_member *member,\n\t\t\t\t const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < member_type->size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 3273
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "struct_bits_off"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_enum_check_member(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *struct_type,\n\t\t\t\t const struct btf_member *member,\n\t\t\t\t const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < member_type->size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_struct_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3213-3245",
    "snippet": "static void btf_struct_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t    u32 type_id, void *data, u8 bits_offset,\n\t\t\t    struct btf_show *show)\n{\n\tconst struct btf_member *m = show->state.member;\n\n\t/*\n\t * First check if any members would be shown (are non-zero).\n\t * See comments above \"struct btf_show\" definition for more\n\t * details on how this works at a high-level.\n\t */\n\tif (show->state.depth > 0 && !(show->flags & BTF_SHOW_ZERO)) {\n\t\tif (!show->state.depth_check) {\n\t\t\tshow->state.depth_check = show->state.depth + 1;\n\t\t\tshow->state.depth_to_show = 0;\n\t\t}\n\t\t__btf_struct_show(btf, t, type_id, data, bits_offset, show);\n\t\t/* Restore saved member data here */\n\t\tshow->state.member = m;\n\t\tif (show->state.depth_check != show->state.depth + 1)\n\t\t\treturn;\n\t\tshow->state.depth_check = 0;\n\n\t\tif (show->state.depth_to_show <= show->state.depth)\n\t\t\treturn;\n\t\t/*\n\t\t * Reaching here indicates we have recursed and found\n\t\t * non-zero child values.\n\t\t */\n\t}\n\n\t__btf_struct_show(btf, t, type_id, data, bits_offset, show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_struct_show",
          "args": [
            "btf",
            "t",
            "type_id",
            "data",
            "bits_offset",
            "show"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_struct_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "3166-3211",
          "snippet": "static void __btf_struct_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t      u32 type_id, void *data, u8 bits_offset,\n\t\t\t      struct btf_show *show)\n{\n\tconst struct btf_member *member;\n\tvoid *safe_data;\n\tu32 i;\n\n\tsafe_data = btf_show_start_struct_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\tmember->type);\n\t\tconst struct btf_kind_operations *ops;\n\t\tu32 member_offset, bitfield_size;\n\t\tu32 bytes_offset;\n\t\tu8 bits8_offset;\n\n\t\tbtf_show_start_member(show, member);\n\n\t\tmember_offset = __btf_member_bit_offset(t, member);\n\t\tbitfield_size = __btf_member_bitfield_size(t, member);\n\t\tbytes_offset = BITS_ROUNDDOWN_BYTES(member_offset);\n\t\tbits8_offset = BITS_PER_BYTE_MASKED(member_offset);\n\t\tif (bitfield_size) {\n\t\t\tsafe_data = btf_show_start_type(show, member_type,\n\t\t\t\t\t\t\tmember->type,\n\t\t\t\t\t\t\tdata + bytes_offset);\n\t\t\tif (safe_data)\n\t\t\t\tbtf_bitfield_show(safe_data,\n\t\t\t\t\t\t  bits8_offset,\n\t\t\t\t\t\t  bitfield_size, show);\n\t\t\tbtf_show_end_type(show);\n\t\t} else {\n\t\t\tops = btf_type_ops(member_type);\n\t\t\tops->show(btf, member_type, member->type,\n\t\t\t\t  data + bytes_offset, bits8_offset, show);\n\t\t}\n\n\t\tbtf_show_end_member(show);\n\t}\n\n\tbtf_show_end_struct_type(show);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void __btf_struct_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t      u32 type_id, void *data, u8 bits_offset,\n\t\t\t      struct btf_show *show)\n{\n\tconst struct btf_member *member;\n\tvoid *safe_data;\n\tu32 i;\n\n\tsafe_data = btf_show_start_struct_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\tmember->type);\n\t\tconst struct btf_kind_operations *ops;\n\t\tu32 member_offset, bitfield_size;\n\t\tu32 bytes_offset;\n\t\tu8 bits8_offset;\n\n\t\tbtf_show_start_member(show, member);\n\n\t\tmember_offset = __btf_member_bit_offset(t, member);\n\t\tbitfield_size = __btf_member_bitfield_size(t, member);\n\t\tbytes_offset = BITS_ROUNDDOWN_BYTES(member_offset);\n\t\tbits8_offset = BITS_PER_BYTE_MASKED(member_offset);\n\t\tif (bitfield_size) {\n\t\t\tsafe_data = btf_show_start_type(show, member_type,\n\t\t\t\t\t\t\tmember->type,\n\t\t\t\t\t\t\tdata + bytes_offset);\n\t\t\tif (safe_data)\n\t\t\t\tbtf_bitfield_show(safe_data,\n\t\t\t\t\t\t  bits8_offset,\n\t\t\t\t\t\t  bitfield_size, show);\n\t\t\tbtf_show_end_type(show);\n\t\t} else {\n\t\t\tops = btf_type_ops(member_type);\n\t\t\tops->show(btf, member_type, member->type,\n\t\t\t\t  data + bytes_offset, bits8_offset, show);\n\t\t}\n\n\t\tbtf_show_end_member(show);\n\t}\n\n\tbtf_show_end_struct_type(show);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_struct_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t    u32 type_id, void *data, u8 bits_offset,\n\t\t\t    struct btf_show *show)\n{\n\tconst struct btf_member *m = show->state.member;\n\n\t/*\n\t * First check if any members would be shown (are non-zero).\n\t * See comments above \"struct btf_show\" definition for more\n\t * details on how this works at a high-level.\n\t */\n\tif (show->state.depth > 0 && !(show->flags & BTF_SHOW_ZERO)) {\n\t\tif (!show->state.depth_check) {\n\t\t\tshow->state.depth_check = show->state.depth + 1;\n\t\t\tshow->state.depth_to_show = 0;\n\t\t}\n\t\t__btf_struct_show(btf, t, type_id, data, bits_offset, show);\n\t\t/* Restore saved member data here */\n\t\tshow->state.member = m;\n\t\tif (show->state.depth_check != show->state.depth + 1)\n\t\t\treturn;\n\t\tshow->state.depth_check = 0;\n\n\t\tif (show->state.depth_to_show <= show->state.depth)\n\t\t\treturn;\n\t\t/*\n\t\t * Reaching here indicates we have recursed and found\n\t\t * non-zero child values.\n\t\t */\n\t}\n\n\t__btf_struct_show(btf, t, type_id, data, bits_offset, show);\n}"
  },
  {
    "function_name": "__btf_struct_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3166-3211",
    "snippet": "static void __btf_struct_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t      u32 type_id, void *data, u8 bits_offset,\n\t\t\t      struct btf_show *show)\n{\n\tconst struct btf_member *member;\n\tvoid *safe_data;\n\tu32 i;\n\n\tsafe_data = btf_show_start_struct_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\tmember->type);\n\t\tconst struct btf_kind_operations *ops;\n\t\tu32 member_offset, bitfield_size;\n\t\tu32 bytes_offset;\n\t\tu8 bits8_offset;\n\n\t\tbtf_show_start_member(show, member);\n\n\t\tmember_offset = __btf_member_bit_offset(t, member);\n\t\tbitfield_size = __btf_member_bitfield_size(t, member);\n\t\tbytes_offset = BITS_ROUNDDOWN_BYTES(member_offset);\n\t\tbits8_offset = BITS_PER_BYTE_MASKED(member_offset);\n\t\tif (bitfield_size) {\n\t\t\tsafe_data = btf_show_start_type(show, member_type,\n\t\t\t\t\t\t\tmember->type,\n\t\t\t\t\t\t\tdata + bytes_offset);\n\t\t\tif (safe_data)\n\t\t\t\tbtf_bitfield_show(safe_data,\n\t\t\t\t\t\t  bits8_offset,\n\t\t\t\t\t\t  bitfield_size, show);\n\t\t\tbtf_show_end_type(show);\n\t\t} else {\n\t\t\tops = btf_type_ops(member_type);\n\t\t\tops->show(btf, member_type, member->type,\n\t\t\t\t  data + bytes_offset, bits8_offset, show);\n\t\t}\n\n\t\tbtf_show_end_member(show);\n\t}\n\n\tbtf_show_end_struct_type(show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_end_struct_type",
          "args": [
            "show"
          ],
          "line": 3210
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_struct_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1282-1285",
          "snippet": "static void btf_show_end_struct_type(struct btf_show *show)\n{\n\tbtf_show_end_aggr_type(show, \"}\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_struct_type(struct btf_show *show)\n{\n\tbtf_show_end_aggr_type(show, \"}\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_end_member",
          "args": [
            "show"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1245-1248",
          "snippet": "static void btf_show_end_member(struct btf_show *show)\n{\n\tshow->state.member = NULL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_member(struct btf_show *show)\n{\n\tshow->state.member = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->show",
          "args": [
            "btf",
            "member_type",
            "member->type",
            "data + bytes_offset",
            "bits8_offset",
            "show"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "member_type"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_end_type",
          "args": [
            "show"
          ],
          "line": 3200
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1201-1206",
          "snippet": "static void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_bitfield_show",
          "args": [
            "safe_data",
            "bits8_offset",
            "bitfield_size",
            "show"
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "btf_bitfield_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "2149-2171",
          "snippet": "static void btf_bitfield_show(void *data, u8 bits_offset,\n\t\t\t      u8 nr_bits, struct btf_show *show)\n{\n\tu16 left_shift_bits, right_shift_bits;\n\tu8 nr_copy_bytes;\n\tu8 nr_copy_bits;\n\tu64 print_num[2] = {};\n\n\tnr_copy_bits = nr_bits + bits_offset;\n\tnr_copy_bytes = BITS_ROUNDUP_BYTES(nr_copy_bits);\n\n\tmemcpy(print_num, data, nr_copy_bytes);\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tleft_shift_bits = bits_offset;\n#else\n\tleft_shift_bits = BITS_PER_U128 - nr_copy_bits;\n#endif\n\tright_shift_bits = BITS_PER_U128 - nr_bits;\n\n\tbtf_int128_shift(print_num, left_shift_bits, right_shift_bits);\n\tbtf_int128_print(show, print_num);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)\n\nstatic void btf_bitfield_show(void *data, u8 bits_offset,\n\t\t\t      u8 nr_bits, struct btf_show *show)\n{\n\tu16 left_shift_bits, right_shift_bits;\n\tu8 nr_copy_bytes;\n\tu8 nr_copy_bits;\n\tu64 print_num[2] = {};\n\n\tnr_copy_bits = nr_bits + bits_offset;\n\tnr_copy_bytes = BITS_ROUNDUP_BYTES(nr_copy_bits);\n\n\tmemcpy(print_num, data, nr_copy_bytes);\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tleft_shift_bits = bits_offset;\n#else\n\tleft_shift_bits = BITS_PER_U128 - nr_copy_bits;\n#endif\n\tright_shift_bits = BITS_PER_U128 - nr_bits;\n\n\tbtf_int128_shift(print_num, left_shift_bits, right_shift_bits);\n\tbtf_int128_print(show, print_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_start_type",
          "args": [
            "show",
            "member_type",
            "member->type",
            "data + bytes_offset"
          ],
          "line": 3193
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1190-1199",
          "snippet": "static void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "member_offset"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "member_offset"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_member_bitfield_size",
          "args": [
            "t",
            "member"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_member_bit_offset",
          "args": [
            "t",
            "member"
          ],
          "line": 3188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_start_member",
          "args": [
            "show",
            "member"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1233-1237",
          "snippet": "static void btf_show_start_member(struct btf_show *show,\n\t\t\t\t  const struct btf_member *m)\n{\n\tshow->state.member = m;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_start_member(struct btf_show *show,\n\t\t\t\t  const struct btf_member *m)\n{\n\tshow->state.member = m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "member->type"
          ],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_member",
          "args": [
            "i",
            "t",
            "member"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_start_struct_type",
          "args": [
            "show",
            "t",
            "type_id",
            "data"
          ],
          "line": 3174
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_struct_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1274-1280",
          "snippet": "static void *btf_show_start_struct_type(struct btf_show *show,\n\t\t\t\t\tconst struct btf_type *t,\n\t\t\t\t\tu32 type_id,\n\t\t\t\t\tvoid *data)\n{\n\treturn btf_show_start_aggr_type(show, t, type_id, data);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_struct_type(struct btf_show *show,\n\t\t\t\t\tconst struct btf_type *t,\n\t\t\t\t\tu32 type_id,\n\t\t\t\t\tvoid *data)\n{\n\treturn btf_show_start_aggr_type(show, t, type_id, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void __btf_struct_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t      u32 type_id, void *data, u8 bits_offset,\n\t\t\t      struct btf_show *show)\n{\n\tconst struct btf_member *member;\n\tvoid *safe_data;\n\tu32 i;\n\n\tsafe_data = btf_show_start_struct_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\tmember->type);\n\t\tconst struct btf_kind_operations *ops;\n\t\tu32 member_offset, bitfield_size;\n\t\tu32 bytes_offset;\n\t\tu8 bits8_offset;\n\n\t\tbtf_show_start_member(show, member);\n\n\t\tmember_offset = __btf_member_bit_offset(t, member);\n\t\tbitfield_size = __btf_member_bitfield_size(t, member);\n\t\tbytes_offset = BITS_ROUNDDOWN_BYTES(member_offset);\n\t\tbits8_offset = BITS_PER_BYTE_MASKED(member_offset);\n\t\tif (bitfield_size) {\n\t\t\tsafe_data = btf_show_start_type(show, member_type,\n\t\t\t\t\t\t\tmember->type,\n\t\t\t\t\t\t\tdata + bytes_offset);\n\t\t\tif (safe_data)\n\t\t\t\tbtf_bitfield_show(safe_data,\n\t\t\t\t\t\t  bits8_offset,\n\t\t\t\t\t\t  bitfield_size, show);\n\t\t\tbtf_show_end_type(show);\n\t\t} else {\n\t\t\tops = btf_type_ops(member_type);\n\t\t\tops->show(btf, member_type, member->type,\n\t\t\t\t  data + bytes_offset, bits8_offset, show);\n\t\t}\n\n\t\tbtf_show_end_member(show);\n\t}\n\n\tbtf_show_end_struct_type(show);\n}"
  },
  {
    "function_name": "btf_find_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3159-3164",
    "snippet": "int btf_find_timer(const struct btf *btf, const struct btf_type *t)\n{\n\treturn btf_find_field(btf, t, \"bpf_timer\",\n\t\t\t      sizeof(struct bpf_timer),\n\t\t\t      __alignof__(struct bpf_timer));\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_find_field",
          "args": [
            "btf",
            "t",
            "\"bpf_timer\"",
            "sizeof(struct bpf_timer)",
            "__alignof__(struct bpf_timer)"
          ],
          "line": 3161
        },
        "resolved": true,
        "details": {
          "function_name": "btf_find_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "3137-3146",
          "snippet": "static int btf_find_field(const struct btf *btf, const struct btf_type *t,\n\t\t\t  const char *name, int sz, int align)\n{\n\n\tif (__btf_type_is_struct(t))\n\t\treturn btf_find_struct_field(btf, t, name, sz, align);\n\telse if (btf_type_is_datasec(t))\n\t\treturn btf_find_datasec_var(btf, t, name, sz, align);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_find_field(const struct btf *btf, const struct btf_type *t,\n\t\t\t  const char *name, int sz, int align)\n{\n\n\tif (__btf_type_is_struct(t))\n\t\treturn btf_find_struct_field(btf, t, name, sz, align);\n\telse if (btf_type_is_datasec(t))\n\t\treturn btf_find_datasec_var(btf, t, name, sz, align);\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_find_timer(const struct btf *btf, const struct btf_type *t)\n{\n\treturn btf_find_field(btf, t, \"bpf_timer\",\n\t\t\t      sizeof(struct bpf_timer),\n\t\t\t      __alignof__(struct bpf_timer));\n}"
  },
  {
    "function_name": "btf_find_spin_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3152-3157",
    "snippet": "int btf_find_spin_lock(const struct btf *btf, const struct btf_type *t)\n{\n\treturn btf_find_field(btf, t, \"bpf_spin_lock\",\n\t\t\t      sizeof(struct bpf_spin_lock),\n\t\t\t      __alignof__(struct bpf_spin_lock));\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_find_field",
          "args": [
            "btf",
            "t",
            "\"bpf_spin_lock\"",
            "sizeof(struct bpf_spin_lock)",
            "__alignof__(struct bpf_spin_lock)"
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "btf_find_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "3137-3146",
          "snippet": "static int btf_find_field(const struct btf *btf, const struct btf_type *t,\n\t\t\t  const char *name, int sz, int align)\n{\n\n\tif (__btf_type_is_struct(t))\n\t\treturn btf_find_struct_field(btf, t, name, sz, align);\n\telse if (btf_type_is_datasec(t))\n\t\treturn btf_find_datasec_var(btf, t, name, sz, align);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_find_field(const struct btf *btf, const struct btf_type *t,\n\t\t\t  const char *name, int sz, int align)\n{\n\n\tif (__btf_type_is_struct(t))\n\t\treturn btf_find_struct_field(btf, t, name, sz, align);\n\telse if (btf_type_is_datasec(t))\n\t\treturn btf_find_datasec_var(btf, t, name, sz, align);\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nint btf_find_spin_lock(const struct btf *btf, const struct btf_type *t)\n{\n\treturn btf_find_field(btf, t, \"bpf_spin_lock\",\n\t\t\t      sizeof(struct bpf_spin_lock),\n\t\t\t      __alignof__(struct bpf_spin_lock));\n}"
  },
  {
    "function_name": "btf_find_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3137-3146",
    "snippet": "static int btf_find_field(const struct btf *btf, const struct btf_type *t,\n\t\t\t  const char *name, int sz, int align)\n{\n\n\tif (__btf_type_is_struct(t))\n\t\treturn btf_find_struct_field(btf, t, name, sz, align);\n\telse if (btf_type_is_datasec(t))\n\t\treturn btf_find_datasec_var(btf, t, name, sz, align);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_find_datasec_var",
          "args": [
            "btf",
            "t",
            "name",
            "sz",
            "align"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "btf_find_datasec_var",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "3109-3135",
          "snippet": "static int btf_find_datasec_var(const struct btf *btf, const struct btf_type *t,\n\t\t\t\tconst char *name, int sz, int align)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tu32 i, off = -ENOENT;\n\n\tfor_each_vsi(i, t, vsi) {\n\t\tconst struct btf_type *var = btf_type_by_id(btf, vsi->type);\n\t\tconst struct btf_type *var_type = btf_type_by_id(btf, var->type);\n\n\t\tif (!__btf_type_is_struct(var_type))\n\t\t\tcontinue;\n\t\tif (var_type->size != sz)\n\t\t\tcontinue;\n\t\tif (vsi->size != sz)\n\t\t\tcontinue;\n\t\tif (strcmp(__btf_name_by_offset(btf, var_type->name_off), name))\n\t\t\tcontinue;\n\t\tif (off != -ENOENT)\n\t\t\t/* only one such field is allowed */\n\t\t\treturn -E2BIG;\n\t\toff = vsi->offset;\n\t\tif (off % align)\n\t\t\treturn -EINVAL;\n\t}\n\treturn off;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_find_datasec_var(const struct btf *btf, const struct btf_type *t,\n\t\t\t\tconst char *name, int sz, int align)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tu32 i, off = -ENOENT;\n\n\tfor_each_vsi(i, t, vsi) {\n\t\tconst struct btf_type *var = btf_type_by_id(btf, vsi->type);\n\t\tconst struct btf_type *var_type = btf_type_by_id(btf, var->type);\n\n\t\tif (!__btf_type_is_struct(var_type))\n\t\t\tcontinue;\n\t\tif (var_type->size != sz)\n\t\t\tcontinue;\n\t\tif (vsi->size != sz)\n\t\t\tcontinue;\n\t\tif (strcmp(__btf_name_by_offset(btf, var_type->name_off), name))\n\t\t\tcontinue;\n\t\tif (off != -ENOENT)\n\t\t\t/* only one such field is allowed */\n\t\t\treturn -E2BIG;\n\t\toff = vsi->offset;\n\t\tif (off % align)\n\t\t\treturn -EINVAL;\n\t}\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_datasec",
          "args": [
            "t"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_datasec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "461-464",
          "snippet": "static bool btf_type_is_datasec(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DATASEC;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_datasec(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DATASEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_find_struct_field",
          "args": [
            "btf",
            "t",
            "name",
            "sz",
            "align"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "btf_find_struct_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "3080-3107",
          "snippet": "static int btf_find_struct_field(const struct btf *btf, const struct btf_type *t,\n\t\t\t\t const char *name, int sz, int align)\n{\n\tconst struct btf_member *member;\n\tu32 i, off = -ENOENT;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\t    member->type);\n\t\tif (!__btf_type_is_struct(member_type))\n\t\t\tcontinue;\n\t\tif (member_type->size != sz)\n\t\t\tcontinue;\n\t\tif (strcmp(__btf_name_by_offset(btf, member_type->name_off), name))\n\t\t\tcontinue;\n\t\tif (off != -ENOENT)\n\t\t\t/* only one such field is allowed */\n\t\t\treturn -E2BIG;\n\t\toff = __btf_member_bit_offset(t, member);\n\t\tif (off % 8)\n\t\t\t/* valid C code cannot generate such BTF */\n\t\t\treturn -EINVAL;\n\t\toff /= 8;\n\t\tif (off % align)\n\t\t\treturn -EINVAL;\n\t}\n\treturn off;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_find_struct_field(const struct btf *btf, const struct btf_type *t,\n\t\t\t\t const char *name, int sz, int align)\n{\n\tconst struct btf_member *member;\n\tu32 i, off = -ENOENT;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\t    member->type);\n\t\tif (!__btf_type_is_struct(member_type))\n\t\t\tcontinue;\n\t\tif (member_type->size != sz)\n\t\t\tcontinue;\n\t\tif (strcmp(__btf_name_by_offset(btf, member_type->name_off), name))\n\t\t\tcontinue;\n\t\tif (off != -ENOENT)\n\t\t\t/* only one such field is allowed */\n\t\t\treturn -E2BIG;\n\t\toff = __btf_member_bit_offset(t, member);\n\t\tif (off % 8)\n\t\t\t/* valid C code cannot generate such BTF */\n\t\t\treturn -EINVAL;\n\t\toff /= 8;\n\t\tif (off % align)\n\t\t\treturn -EINVAL;\n\t}\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_type_is_struct",
          "args": [
            "t"
          ],
          "line": 3141
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_find_field(const struct btf *btf, const struct btf_type *t,\n\t\t\t  const char *name, int sz, int align)\n{\n\n\tif (__btf_type_is_struct(t))\n\t\treturn btf_find_struct_field(btf, t, name, sz, align);\n\telse if (btf_type_is_datasec(t))\n\t\treturn btf_find_datasec_var(btf, t, name, sz, align);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "btf_find_datasec_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3109-3135",
    "snippet": "static int btf_find_datasec_var(const struct btf *btf, const struct btf_type *t,\n\t\t\t\tconst char *name, int sz, int align)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tu32 i, off = -ENOENT;\n\n\tfor_each_vsi(i, t, vsi) {\n\t\tconst struct btf_type *var = btf_type_by_id(btf, vsi->type);\n\t\tconst struct btf_type *var_type = btf_type_by_id(btf, var->type);\n\n\t\tif (!__btf_type_is_struct(var_type))\n\t\t\tcontinue;\n\t\tif (var_type->size != sz)\n\t\t\tcontinue;\n\t\tif (vsi->size != sz)\n\t\t\tcontinue;\n\t\tif (strcmp(__btf_name_by_offset(btf, var_type->name_off), name))\n\t\t\tcontinue;\n\t\tif (off != -ENOENT)\n\t\t\t/* only one such field is allowed */\n\t\t\treturn -E2BIG;\n\t\toff = vsi->offset;\n\t\tif (off % align)\n\t\t\treturn -EINVAL;\n\t}\n\treturn off;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "__btf_name_by_offset(btf, var_type->name_off)",
            "name"
          ],
          "line": 3125
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_name_by_offset",
          "args": [
            "btf",
            "var_type->name_off"
          ],
          "line": 3125
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "715-724",
          "snippet": "static const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_type_is_struct",
          "args": [
            "var_type"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "var->type"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_vsi",
          "args": [
            "i",
            "t",
            "vsi"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_find_datasec_var(const struct btf *btf, const struct btf_type *t,\n\t\t\t\tconst char *name, int sz, int align)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tu32 i, off = -ENOENT;\n\n\tfor_each_vsi(i, t, vsi) {\n\t\tconst struct btf_type *var = btf_type_by_id(btf, vsi->type);\n\t\tconst struct btf_type *var_type = btf_type_by_id(btf, var->type);\n\n\t\tif (!__btf_type_is_struct(var_type))\n\t\t\tcontinue;\n\t\tif (var_type->size != sz)\n\t\t\tcontinue;\n\t\tif (vsi->size != sz)\n\t\t\tcontinue;\n\t\tif (strcmp(__btf_name_by_offset(btf, var_type->name_off), name))\n\t\t\tcontinue;\n\t\tif (off != -ENOENT)\n\t\t\t/* only one such field is allowed */\n\t\t\treturn -E2BIG;\n\t\toff = vsi->offset;\n\t\tif (off % align)\n\t\t\treturn -EINVAL;\n\t}\n\treturn off;\n}"
  },
  {
    "function_name": "btf_find_struct_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3080-3107",
    "snippet": "static int btf_find_struct_field(const struct btf *btf, const struct btf_type *t,\n\t\t\t\t const char *name, int sz, int align)\n{\n\tconst struct btf_member *member;\n\tu32 i, off = -ENOENT;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\t    member->type);\n\t\tif (!__btf_type_is_struct(member_type))\n\t\t\tcontinue;\n\t\tif (member_type->size != sz)\n\t\t\tcontinue;\n\t\tif (strcmp(__btf_name_by_offset(btf, member_type->name_off), name))\n\t\t\tcontinue;\n\t\tif (off != -ENOENT)\n\t\t\t/* only one such field is allowed */\n\t\t\treturn -E2BIG;\n\t\toff = __btf_member_bit_offset(t, member);\n\t\tif (off % 8)\n\t\t\t/* valid C code cannot generate such BTF */\n\t\t\treturn -EINVAL;\n\t\toff /= 8;\n\t\tif (off % align)\n\t\t\treturn -EINVAL;\n\t}\n\treturn off;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_member_bit_offset",
          "args": [
            "t",
            "member"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "__btf_name_by_offset(btf, member_type->name_off)",
            "name"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_name_by_offset",
          "args": [
            "btf",
            "member_type->name_off"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "715-724",
          "snippet": "static const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_type_is_struct",
          "args": [
            "member_type"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "member->type"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_member",
          "args": [
            "i",
            "t",
            "member"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_find_struct_field(const struct btf *btf, const struct btf_type *t,\n\t\t\t\t const char *name, int sz, int align)\n{\n\tconst struct btf_member *member;\n\tu32 i, off = -ENOENT;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\t    member->type);\n\t\tif (!__btf_type_is_struct(member_type))\n\t\t\tcontinue;\n\t\tif (member_type->size != sz)\n\t\t\tcontinue;\n\t\tif (strcmp(__btf_name_by_offset(btf, member_type->name_off), name))\n\t\t\tcontinue;\n\t\tif (off != -ENOENT)\n\t\t\t/* only one such field is allowed */\n\t\t\treturn -E2BIG;\n\t\toff = __btf_member_bit_offset(t, member);\n\t\tif (off % 8)\n\t\t\t/* valid C code cannot generate such BTF */\n\t\t\treturn -EINVAL;\n\t\toff /= 8;\n\t\tif (off % align)\n\t\t\treturn -EINVAL;\n\t}\n\treturn off;\n}"
  },
  {
    "function_name": "btf_struct_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3074-3078",
    "snippet": "static void btf_struct_log(struct btf_verifier_env *env,\n\t\t\t   const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"size=%u vlen=%u\"",
            "t->size",
            "btf_type_vlen(t)"
          ],
          "line": 3077
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_struct_log(struct btf_verifier_env *env,\n\t\t\t   const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}"
  },
  {
    "function_name": "btf_struct_resolve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "3003-3072",
    "snippet": "static int btf_struct_resolve(struct btf_verifier_env *env,\n\t\t\t      const struct resolve_vertex *v)\n{\n\tconst struct btf_member *member;\n\tint err;\n\tu16 i;\n\n\t/* Before continue resolving the next_member,\n\t * ensure the last member is indeed resolved to a\n\t * type with size info.\n\t */\n\tif (v->next_member) {\n\t\tconst struct btf_type *last_member_type;\n\t\tconst struct btf_member *last_member;\n\t\tu16 last_member_type_id;\n\n\t\tlast_member = btf_type_member(v->t) + v->next_member - 1;\n\t\tlast_member_type_id = last_member->type;\n\t\tif (WARN_ON_ONCE(!env_type_is_resolved(env,\n\t\t\t\t\t\t       last_member_type_id)))\n\t\t\treturn -EINVAL;\n\n\t\tlast_member_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t  last_member_type_id);\n\t\tif (btf_type_kflag(v->t))\n\t\t\terr = btf_type_ops(last_member_type)->check_kflag_member(env, v->t,\n\t\t\t\t\t\t\t\tlast_member,\n\t\t\t\t\t\t\t\tlast_member_type);\n\t\telse\n\t\t\terr = btf_type_ops(last_member_type)->check_member(env, v->t,\n\t\t\t\t\t\t\t\tlast_member,\n\t\t\t\t\t\t\t\tlast_member_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor_each_member_from(i, v->next_member, v->t, member) {\n\t\tu32 member_type_id = member->type;\n\t\tconst struct btf_type *member_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t\t\tmember_type_id);\n\n\t\tif (btf_type_nosize_or_null(member_type) ||\n\t\t    btf_type_is_resolve_source_only(member_type)) {\n\t\t\tbtf_verifier_log_member(env, v->t, member,\n\t\t\t\t\t\t\"Invalid member\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!env_type_is_resolve_sink(env, member_type) &&\n\t\t    !env_type_is_resolved(env, member_type_id)) {\n\t\t\tenv_stack_set_next_member(env, i + 1);\n\t\t\treturn env_stack_push(env, member_type, member_type_id);\n\t\t}\n\n\t\tif (btf_type_kflag(v->t))\n\t\t\terr = btf_type_ops(member_type)->check_kflag_member(env, v->t,\n\t\t\t\t\t\t\t\t\t    member,\n\t\t\t\t\t\t\t\t\t    member_type);\n\t\telse\n\t\t\terr = btf_type_ops(member_type)->check_member(env, v->t,\n\t\t\t\t\t\t\t\t      member,\n\t\t\t\t\t\t\t\t      member_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tenv_stack_pop_resolved(env, 0, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_stack_pop_resolved",
          "args": [
            "env",
            "0",
            "0"
          ],
          "line": 3069
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_pop_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1676-1687",
          "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "v->t",
            "member",
            "member_type"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "member_type"
          ],
          "line": 3062
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "v->t",
            "member",
            "member_type"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "v->t"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "member_type",
            "member_type_id"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1640-1668",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_set_next_member",
          "args": [
            "env",
            "i + 1"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_set_next_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1670-1674",
          "snippet": "static void env_stack_set_next_member(struct btf_verifier_env *env,\n\t\t\t\t      u16 next_member)\n{\n\tenv->stack[env->top_stack - 1].next_member = next_member;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void env_stack_set_next_member(struct btf_verifier_env *env,\n\t\t\t\t      u16 next_member)\n{\n\tenv->stack[env->top_stack - 1].next_member = next_member;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "member_type_id"
          ],
          "line": 3052
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1630-1638",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolve_sink",
          "args": [
            "env",
            "member_type"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolve_sink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1605-1628",
          "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "v->t",
            "member",
            "\"Invalid member\""
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_resolve_source_only",
          "args": [
            "member_type"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_resolve_source_only",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "552-557",
          "snippet": "static bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_nosize_or_null",
          "args": [
            "member_type"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_nosize_or_null",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "446-449",
          "snippet": "static bool btf_type_nosize_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_nosize(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_nosize_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_nosize(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "env->btf",
            "member_type_id"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_member_from",
          "args": [
            "i",
            "v->next_member",
            "v->t",
            "member"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "v->t",
            "last_member",
            "last_member_type"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "v->t",
            "last_member",
            "last_member_type"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "v->t"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!env_type_is_resolved(env,\n\t\t\t\t\t\t       last_member_type_id)"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_member",
          "args": [
            "v->t"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_struct_resolve(struct btf_verifier_env *env,\n\t\t\t      const struct resolve_vertex *v)\n{\n\tconst struct btf_member *member;\n\tint err;\n\tu16 i;\n\n\t/* Before continue resolving the next_member,\n\t * ensure the last member is indeed resolved to a\n\t * type with size info.\n\t */\n\tif (v->next_member) {\n\t\tconst struct btf_type *last_member_type;\n\t\tconst struct btf_member *last_member;\n\t\tu16 last_member_type_id;\n\n\t\tlast_member = btf_type_member(v->t) + v->next_member - 1;\n\t\tlast_member_type_id = last_member->type;\n\t\tif (WARN_ON_ONCE(!env_type_is_resolved(env,\n\t\t\t\t\t\t       last_member_type_id)))\n\t\t\treturn -EINVAL;\n\n\t\tlast_member_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t  last_member_type_id);\n\t\tif (btf_type_kflag(v->t))\n\t\t\terr = btf_type_ops(last_member_type)->check_kflag_member(env, v->t,\n\t\t\t\t\t\t\t\tlast_member,\n\t\t\t\t\t\t\t\tlast_member_type);\n\t\telse\n\t\t\terr = btf_type_ops(last_member_type)->check_member(env, v->t,\n\t\t\t\t\t\t\t\tlast_member,\n\t\t\t\t\t\t\t\tlast_member_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor_each_member_from(i, v->next_member, v->t, member) {\n\t\tu32 member_type_id = member->type;\n\t\tconst struct btf_type *member_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t\t\tmember_type_id);\n\n\t\tif (btf_type_nosize_or_null(member_type) ||\n\t\t    btf_type_is_resolve_source_only(member_type)) {\n\t\t\tbtf_verifier_log_member(env, v->t, member,\n\t\t\t\t\t\t\"Invalid member\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!env_type_is_resolve_sink(env, member_type) &&\n\t\t    !env_type_is_resolved(env, member_type_id)) {\n\t\t\tenv_stack_set_next_member(env, i + 1);\n\t\t\treturn env_stack_push(env, member_type, member_type_id);\n\t\t}\n\n\t\tif (btf_type_kflag(v->t))\n\t\t\terr = btf_type_ops(member_type)->check_kflag_member(env, v->t,\n\t\t\t\t\t\t\t\t\t    member,\n\t\t\t\t\t\t\t\t\t    member_type);\n\t\telse\n\t\t\terr = btf_type_ops(member_type)->check_member(env, v->t,\n\t\t\t\t\t\t\t\t      member,\n\t\t\t\t\t\t\t\t      member_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tenv_stack_pop_resolved(env, 0, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_struct_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2922-3001",
    "snippet": "static s32 btf_struct_check_meta(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 meta_left)\n{\n\tbool is_union = BTF_INFO_KIND(t->info) == BTF_KIND_UNION;\n\tconst struct btf_member *member;\n\tu32 meta_needed, last_offset;\n\tstruct btf *btf = env->btf;\n\tu32 struct_size = t->size;\n\tu32 offset;\n\tu16 i;\n\n\tmeta_needed = btf_type_vlen(t) * sizeof(*member);\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\t/* struct type either no name or a valid one */\n\tif (t->name_off &&\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tlast_offset = 0;\n\tfor_each_member(i, t, member) {\n\t\tif (!btf_name_offset_valid(btf, member->name_off)) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member name_offset:%u\",\n\t\t\t\t\t\tmember->name_off);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* struct member either no name or a valid one */\n\t\tif (member->name_off &&\n\t\t    !btf_name_valid_identifier(btf, member->name_off)) {\n\t\t\tbtf_verifier_log_member(env, t, member, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* A member cannot be in type void */\n\t\tif (!member->type || !BTF_TYPE_ID_VALID(member->type)) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = __btf_member_bit_offset(t, member);\n\t\tif (is_union && offset) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member bits_offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * \">\" instead of \">=\" because the last member could be\n\t\t * \"char a[0];\"\n\t\t */\n\t\tif (last_offset > offset) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member bits_offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BITS_ROUNDUP_BYTES(offset) > struct_size) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Member bits_offset exceeds its struct size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbtf_verifier_log_member(env, t, member, NULL);\n\t\tlast_offset = offset;\n\t}\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "t",
            "member",
            "NULL"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "offset"
          ],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_member_bit_offset",
          "args": [
            "t",
            "member"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_TYPE_ID_VALID",
          "args": [
            "member->type"
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_valid_identifier",
          "args": [
            "btf",
            "member->name_off"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_valid_identifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "705-708",
          "snippet": "static bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_offset_valid",
          "args": [
            "btf",
            "member->name_off"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_offset_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "646-656",
          "snippet": "static bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\tif (!BTF_STR_OFFSET_VALID(offset))\n\t\treturn false;\n\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\treturn offset < btf->hdr.str_len;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\tif (!BTF_STR_OFFSET_VALID(offset))\n\t\treturn false;\n\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\treturn offset < btf->hdr.str_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_member",
          "args": [
            "i",
            "t",
            "member"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic s32 btf_struct_check_meta(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 meta_left)\n{\n\tbool is_union = BTF_INFO_KIND(t->info) == BTF_KIND_UNION;\n\tconst struct btf_member *member;\n\tu32 meta_needed, last_offset;\n\tstruct btf *btf = env->btf;\n\tu32 struct_size = t->size;\n\tu32 offset;\n\tu16 i;\n\n\tmeta_needed = btf_type_vlen(t) * sizeof(*member);\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\t/* struct type either no name or a valid one */\n\tif (t->name_off &&\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tlast_offset = 0;\n\tfor_each_member(i, t, member) {\n\t\tif (!btf_name_offset_valid(btf, member->name_off)) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member name_offset:%u\",\n\t\t\t\t\t\tmember->name_off);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* struct member either no name or a valid one */\n\t\tif (member->name_off &&\n\t\t    !btf_name_valid_identifier(btf, member->name_off)) {\n\t\t\tbtf_verifier_log_member(env, t, member, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* A member cannot be in type void */\n\t\tif (!member->type || !BTF_TYPE_ID_VALID(member->type)) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = __btf_member_bit_offset(t, member);\n\t\tif (is_union && offset) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member bits_offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * \">\" instead of \">=\" because the last member could be\n\t\t * \"char a[0];\"\n\t\t */\n\t\tif (last_offset > offset) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member bits_offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BITS_ROUNDUP_BYTES(offset) > struct_size) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Member bits_offset exceeds its struct size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbtf_verifier_log_member(env, t, member, NULL);\n\t\tlast_offset = offset;\n\t}\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_struct_check_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2897-2920",
    "snippet": "static int btf_struct_check_member(struct btf_verifier_env *env,\n\t\t\t\t   const struct btf_type *struct_type,\n\t\t\t\t   const struct btf_member *member,\n\t\t\t\t   const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < member_type->size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "struct_bits_off"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_struct_check_member(struct btf_verifier_env *env,\n\t\t\t\t   const struct btf_type *struct_type,\n\t\t\t\t   const struct btf_member *member,\n\t\t\t\t   const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < member_type->size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_array_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2855-2886",
    "snippet": "static void btf_array_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t   u32 type_id, void *data, u8 bits_offset,\n\t\t\t   struct btf_show *show)\n{\n\tconst struct btf_member *m = show->state.member;\n\n\t/*\n\t * First check if any members would be shown (are non-zero).\n\t * See comments above \"struct btf_show\" definition for more\n\t * details on how this works at a high-level.\n\t */\n\tif (show->state.depth > 0 && !(show->flags & BTF_SHOW_ZERO)) {\n\t\tif (!show->state.depth_check) {\n\t\t\tshow->state.depth_check = show->state.depth + 1;\n\t\t\tshow->state.depth_to_show = 0;\n\t\t}\n\t\t__btf_array_show(btf, t, type_id, data, bits_offset, show);\n\t\tshow->state.member = m;\n\n\t\tif (show->state.depth_check != show->state.depth + 1)\n\t\t\treturn;\n\t\tshow->state.depth_check = 0;\n\n\t\tif (show->state.depth_to_show <= show->state.depth)\n\t\t\treturn;\n\t\t/*\n\t\t * Reaching here indicates we have recursed and found\n\t\t * non-zero array member(s).\n\t\t */\n\t}\n\t__btf_array_show(btf, t, type_id, data, bits_offset, show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_array_show",
          "args": [
            "btf",
            "t",
            "type_id",
            "data",
            "bits_offset",
            "show"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_array_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "2802-2853",
          "snippet": "static void __btf_array_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t     u32 type_id, void *data, u8 bits_offset,\n\t\t\t     struct btf_show *show)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tconst struct btf_kind_operations *elem_ops;\n\tconst struct btf_type *elem_type;\n\tu32 i, elem_size = 0, elem_type_id;\n\tu16 encoding = 0;\n\n\telem_type_id = array->type;\n\telem_type = btf_type_skip_modifiers(btf, elem_type_id, NULL);\n\tif (elem_type && btf_type_has_size(elem_type))\n\t\telem_size = elem_type->size;\n\n\tif (elem_type && btf_type_is_int(elem_type)) {\n\t\tu32 int_type = btf_type_int(elem_type);\n\n\t\tencoding = BTF_INT_ENCODING(int_type);\n\n\t\t/*\n\t\t * BTF_INT_CHAR encoding never seems to be set for\n\t\t * char arrays, so if size is 1 and element is\n\t\t * printable as a char, we'll do that.\n\t\t */\n\t\tif (elem_size == 1)\n\t\t\tencoding = BTF_INT_CHAR;\n\t}\n\n\tif (!btf_show_start_array_type(show, t, type_id, encoding, data))\n\t\treturn;\n\n\tif (!elem_type)\n\t\tgoto out;\n\telem_ops = btf_type_ops(elem_type);\n\n\tfor (i = 0; i < array->nelems; i++) {\n\n\t\tbtf_show_start_array_member(show);\n\n\t\telem_ops->show(btf, elem_type, elem_type_id, data,\n\t\t\t       bits_offset, show);\n\t\tdata += elem_size;\n\n\t\tbtf_show_end_array_member(show);\n\n\t\tif (show->state.array_terminated)\n\t\t\tbreak;\n\t}\nout:\n\tbtf_show_end_array_type(show);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void __btf_array_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t     u32 type_id, void *data, u8 bits_offset,\n\t\t\t     struct btf_show *show)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tconst struct btf_kind_operations *elem_ops;\n\tconst struct btf_type *elem_type;\n\tu32 i, elem_size = 0, elem_type_id;\n\tu16 encoding = 0;\n\n\telem_type_id = array->type;\n\telem_type = btf_type_skip_modifiers(btf, elem_type_id, NULL);\n\tif (elem_type && btf_type_has_size(elem_type))\n\t\telem_size = elem_type->size;\n\n\tif (elem_type && btf_type_is_int(elem_type)) {\n\t\tu32 int_type = btf_type_int(elem_type);\n\n\t\tencoding = BTF_INT_ENCODING(int_type);\n\n\t\t/*\n\t\t * BTF_INT_CHAR encoding never seems to be set for\n\t\t * char arrays, so if size is 1 and element is\n\t\t * printable as a char, we'll do that.\n\t\t */\n\t\tif (elem_size == 1)\n\t\t\tencoding = BTF_INT_CHAR;\n\t}\n\n\tif (!btf_show_start_array_type(show, t, type_id, encoding, data))\n\t\treturn;\n\n\tif (!elem_type)\n\t\tgoto out;\n\telem_ops = btf_type_ops(elem_type);\n\n\tfor (i = 0; i < array->nelems; i++) {\n\n\t\tbtf_show_start_array_member(show);\n\n\t\telem_ops->show(btf, elem_type, elem_type_id, data,\n\t\t\t       bits_offset, show);\n\t\tdata += elem_size;\n\n\t\tbtf_show_end_array_member(show);\n\n\t\tif (show->state.array_terminated)\n\t\t\tbreak;\n\t}\nout:\n\tbtf_show_end_array_type(show);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_array_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t   u32 type_id, void *data, u8 bits_offset,\n\t\t\t   struct btf_show *show)\n{\n\tconst struct btf_member *m = show->state.member;\n\n\t/*\n\t * First check if any members would be shown (are non-zero).\n\t * See comments above \"struct btf_show\" definition for more\n\t * details on how this works at a high-level.\n\t */\n\tif (show->state.depth > 0 && !(show->flags & BTF_SHOW_ZERO)) {\n\t\tif (!show->state.depth_check) {\n\t\t\tshow->state.depth_check = show->state.depth + 1;\n\t\t\tshow->state.depth_to_show = 0;\n\t\t}\n\t\t__btf_array_show(btf, t, type_id, data, bits_offset, show);\n\t\tshow->state.member = m;\n\n\t\tif (show->state.depth_check != show->state.depth + 1)\n\t\t\treturn;\n\t\tshow->state.depth_check = 0;\n\n\t\tif (show->state.depth_to_show <= show->state.depth)\n\t\t\treturn;\n\t\t/*\n\t\t * Reaching here indicates we have recursed and found\n\t\t * non-zero array member(s).\n\t\t */\n\t}\n\t__btf_array_show(btf, t, type_id, data, bits_offset, show);\n}"
  },
  {
    "function_name": "__btf_array_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2802-2853",
    "snippet": "static void __btf_array_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t     u32 type_id, void *data, u8 bits_offset,\n\t\t\t     struct btf_show *show)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tconst struct btf_kind_operations *elem_ops;\n\tconst struct btf_type *elem_type;\n\tu32 i, elem_size = 0, elem_type_id;\n\tu16 encoding = 0;\n\n\telem_type_id = array->type;\n\telem_type = btf_type_skip_modifiers(btf, elem_type_id, NULL);\n\tif (elem_type && btf_type_has_size(elem_type))\n\t\telem_size = elem_type->size;\n\n\tif (elem_type && btf_type_is_int(elem_type)) {\n\t\tu32 int_type = btf_type_int(elem_type);\n\n\t\tencoding = BTF_INT_ENCODING(int_type);\n\n\t\t/*\n\t\t * BTF_INT_CHAR encoding never seems to be set for\n\t\t * char arrays, so if size is 1 and element is\n\t\t * printable as a char, we'll do that.\n\t\t */\n\t\tif (elem_size == 1)\n\t\t\tencoding = BTF_INT_CHAR;\n\t}\n\n\tif (!btf_show_start_array_type(show, t, type_id, encoding, data))\n\t\treturn;\n\n\tif (!elem_type)\n\t\tgoto out;\n\telem_ops = btf_type_ops(elem_type);\n\n\tfor (i = 0; i < array->nelems; i++) {\n\n\t\tbtf_show_start_array_member(show);\n\n\t\telem_ops->show(btf, elem_type, elem_type_id, data,\n\t\t\t       bits_offset, show);\n\t\tdata += elem_size;\n\n\t\tbtf_show_end_array_member(show);\n\n\t\tif (show->state.array_terminated)\n\t\t\tbreak;\n\t}\nout:\n\tbtf_show_end_array_type(show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_end_array_type",
          "args": [
            "show"
          ],
          "line": 2852
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_array_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1267-1272",
          "snippet": "static void btf_show_end_array_type(struct btf_show *show)\n{\n\tshow->state.array_encoding = 0;\n\tshow->state.array_terminated = 0;\n\tbtf_show_end_aggr_type(show, \"]\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_array_type(struct btf_show *show)\n{\n\tshow->state.array_encoding = 0;\n\tshow->state.array_terminated = 0;\n\tbtf_show_end_aggr_type(show, \"]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_end_array_member",
          "args": [
            "show"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_array_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1250-1254",
          "snippet": "static void btf_show_end_array_member(struct btf_show *show)\n{\n\tshow->state.array_member = 0;\n\tbtf_show_end_member(show);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_array_member(struct btf_show *show)\n{\n\tshow->state.array_member = 0;\n\tbtf_show_end_member(show);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elem_ops->show",
          "args": [
            "btf",
            "elem_type",
            "elem_type_id",
            "data",
            "bits_offset",
            "show"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_start_array_member",
          "args": [
            "show"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_array_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1239-1243",
          "snippet": "static void btf_show_start_array_member(struct btf_show *show)\n{\n\tshow->state.array_member = 1;\n\tbtf_show_start_member(show, NULL);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_start_array_member(struct btf_show *show)\n{\n\tshow->state.array_member = 1;\n\tbtf_show_start_member(show, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "elem_type"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_start_array_type",
          "args": [
            "show",
            "t",
            "type_id",
            "encoding",
            "data"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_array_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1256-1265",
          "snippet": "static void *btf_show_start_array_type(struct btf_show *show,\n\t\t\t\t       const struct btf_type *t,\n\t\t\t\t       u32 type_id,\n\t\t\t\t       u16 array_encoding,\n\t\t\t\t       void *data)\n{\n\tshow->state.array_encoding = array_encoding;\n\tshow->state.array_terminated = 0;\n\treturn btf_show_start_aggr_type(show, t, type_id, data);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_array_type(struct btf_show *show,\n\t\t\t\t       const struct btf_type *t,\n\t\t\t\t       u32 type_id,\n\t\t\t\t       u16 array_encoding,\n\t\t\t\t       void *data)\n{\n\tshow->state.array_encoding = array_encoding;\n\tshow->state.array_terminated = 0;\n\treturn btf_show_start_aggr_type(show, t, type_id, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INT_ENCODING",
          "args": [
            "int_type"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "elem_type"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "746-763",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_int",
          "args": [
            "elem_type"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_has_size",
          "args": [
            "elem_type"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_has_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "587-600",
          "snippet": "static bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_DATASEC:\n\tcase BTF_KIND_FLOAT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_DATASEC:\n\tcase BTF_KIND_FLOAT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_skip_modifiers",
          "args": [
            "btf",
            "elem_type_id",
            "NULL"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_skip_modifiers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "509-523",
          "snippet": "const struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "t"
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "621-624",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void __btf_array_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t     u32 type_id, void *data, u8 bits_offset,\n\t\t\t     struct btf_show *show)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tconst struct btf_kind_operations *elem_ops;\n\tconst struct btf_type *elem_type;\n\tu32 i, elem_size = 0, elem_type_id;\n\tu16 encoding = 0;\n\n\telem_type_id = array->type;\n\telem_type = btf_type_skip_modifiers(btf, elem_type_id, NULL);\n\tif (elem_type && btf_type_has_size(elem_type))\n\t\telem_size = elem_type->size;\n\n\tif (elem_type && btf_type_is_int(elem_type)) {\n\t\tu32 int_type = btf_type_int(elem_type);\n\n\t\tencoding = BTF_INT_ENCODING(int_type);\n\n\t\t/*\n\t\t * BTF_INT_CHAR encoding never seems to be set for\n\t\t * char arrays, so if size is 1 and element is\n\t\t * printable as a char, we'll do that.\n\t\t */\n\t\tif (elem_size == 1)\n\t\t\tencoding = BTF_INT_CHAR;\n\t}\n\n\tif (!btf_show_start_array_type(show, t, type_id, encoding, data))\n\t\treturn;\n\n\tif (!elem_type)\n\t\tgoto out;\n\telem_ops = btf_type_ops(elem_type);\n\n\tfor (i = 0; i < array->nelems; i++) {\n\n\t\tbtf_show_start_array_member(show);\n\n\t\telem_ops->show(btf, elem_type, elem_type_id, data,\n\t\t\t       bits_offset, show);\n\t\tdata += elem_size;\n\n\t\tbtf_show_end_array_member(show);\n\n\t\tif (show->state.array_terminated)\n\t\t\tbreak;\n\t}\nout:\n\tbtf_show_end_array_type(show);\n}"
  },
  {
    "function_name": "btf_array_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2793-2800",
    "snippet": "static void btf_array_log(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\n\tbtf_verifier_log(env, \"type_id=%u index_type_id=%u nr_elems=%u\",\n\t\t\t array->type, array->index_type, array->nelems);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"type_id=%u index_type_id=%u nr_elems=%u\"",
            "array->type",
            "array->index_type",
            "array->nelems"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "t"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "621-624",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_array_log(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\n\tbtf_verifier_log(env, \"type_id=%u index_type_id=%u nr_elems=%u\",\n\t\t\t array->type, array->index_type, array->nelems);\n}"
  },
  {
    "function_name": "btf_array_resolve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2728-2791",
    "snippet": "static int btf_array_resolve(struct btf_verifier_env *env,\n\t\t\t     const struct resolve_vertex *v)\n{\n\tconst struct btf_array *array = btf_type_array(v->t);\n\tconst struct btf_type *elem_type, *index_type;\n\tu32 elem_type_id, index_type_id;\n\tstruct btf *btf = env->btf;\n\tu32 elem_size;\n\n\t/* Check array->index_type */\n\tindex_type_id = array->index_type;\n\tindex_type = btf_type_by_id(btf, index_type_id);\n\tif (btf_type_nosize_or_null(index_type) ||\n\t    btf_type_is_resolve_source_only(index_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, index_type) &&\n\t    !env_type_is_resolved(env, index_type_id))\n\t\treturn env_stack_push(env, index_type, index_type_id);\n\n\tindex_type = btf_type_id_size(btf, &index_type_id, NULL);\n\tif (!index_type || !btf_type_is_int(index_type) ||\n\t    !btf_type_int_is_regular(index_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check array->type */\n\telem_type_id = array->type;\n\telem_type = btf_type_by_id(btf, elem_type_id);\n\tif (btf_type_nosize_or_null(elem_type) ||\n\t    btf_type_is_resolve_source_only(elem_type)) {\n\t\tbtf_verifier_log_type(env, v->t,\n\t\t\t\t      \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, elem_type) &&\n\t    !env_type_is_resolved(env, elem_type_id))\n\t\treturn env_stack_push(env, elem_type, elem_type_id);\n\n\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\tif (!elem_type) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_is_int(elem_type) && !btf_type_int_is_regular(elem_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid array of int\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (array->nelems && elem_size > U32_MAX / array->nelems) {\n\t\tbtf_verifier_log_type(env, v->t,\n\t\t\t\t      \"Array size overflows U32_MAX\");\n\t\treturn -EINVAL;\n\t}\n\n\tenv_stack_pop_resolved(env, elem_type_id, elem_size * array->nelems);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_stack_pop_resolved",
          "args": [
            "env",
            "elem_type_id",
            "elem_size * array->nelems"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_pop_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1676-1687",
          "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Array size overflows U32_MAX\""
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid array of int\""
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int_is_regular",
          "args": [
            "elem_type"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "746-763",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_int",
          "args": [
            "elem_type"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid elem\""
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&elem_type_id",
            "&elem_size"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "elem_type",
            "elem_type_id"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1640-1668",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "elem_type_id"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1630-1638",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolve_sink",
          "args": [
            "env",
            "elem_type"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolve_sink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1605-1628",
          "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid elem\""
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_resolve_source_only",
          "args": [
            "elem_type"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_resolve_source_only",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "552-557",
          "snippet": "static bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_nosize_or_null",
          "args": [
            "elem_type"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_nosize_or_null",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "446-449",
          "snippet": "static bool btf_type_nosize_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_nosize(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_nosize_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_nosize(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "elem_type_id"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid index\""
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_int",
          "args": [
            "index_type"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid index\""
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "v->t"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "621-624",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_array_resolve(struct btf_verifier_env *env,\n\t\t\t     const struct resolve_vertex *v)\n{\n\tconst struct btf_array *array = btf_type_array(v->t);\n\tconst struct btf_type *elem_type, *index_type;\n\tu32 elem_type_id, index_type_id;\n\tstruct btf *btf = env->btf;\n\tu32 elem_size;\n\n\t/* Check array->index_type */\n\tindex_type_id = array->index_type;\n\tindex_type = btf_type_by_id(btf, index_type_id);\n\tif (btf_type_nosize_or_null(index_type) ||\n\t    btf_type_is_resolve_source_only(index_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, index_type) &&\n\t    !env_type_is_resolved(env, index_type_id))\n\t\treturn env_stack_push(env, index_type, index_type_id);\n\n\tindex_type = btf_type_id_size(btf, &index_type_id, NULL);\n\tif (!index_type || !btf_type_is_int(index_type) ||\n\t    !btf_type_int_is_regular(index_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check array->type */\n\telem_type_id = array->type;\n\telem_type = btf_type_by_id(btf, elem_type_id);\n\tif (btf_type_nosize_or_null(elem_type) ||\n\t    btf_type_is_resolve_source_only(elem_type)) {\n\t\tbtf_verifier_log_type(env, v->t,\n\t\t\t\t      \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, elem_type) &&\n\t    !env_type_is_resolved(env, elem_type_id))\n\t\treturn env_stack_push(env, elem_type, elem_type_id);\n\n\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\tif (!elem_type) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_is_int(elem_type) && !btf_type_int_is_regular(elem_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid array of int\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (array->nelems && elem_size > U32_MAX / array->nelems) {\n\t\tbtf_verifier_log_type(env, v->t,\n\t\t\t\t      \"Array size overflows U32_MAX\");\n\t\treturn -EINVAL;\n\t}\n\n\tenv_stack_pop_resolved(env, elem_type_id, elem_size * array->nelems);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_array_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2675-2726",
    "snippet": "static s32 btf_array_check_meta(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t,\n\t\t\t\tu32 meta_left)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tu32 meta_needed = sizeof(*array);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\t/* array type should not have a name */\n\tif (t->name_off) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size) {\n\t\tbtf_verifier_log_type(env, t, \"size != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Array elem type and index type cannot be in type void,\n\t * so !array->type and !array->index_type are not allowed.\n\t */\n\tif (!array->type || !BTF_TYPE_ID_VALID(array->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!array->index_type || !BTF_TYPE_ID_VALID(array->index_type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid index\""
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_TYPE_ID_VALID",
          "args": [
            "array->index_type"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid elem\""
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_TYPE_ID_VALID",
          "args": [
            "array->type"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"size != 0\""
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid btf_info kind_flag\""
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "t"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"vlen != 0\""
          ],
          "line": 2696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "t"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "621-624",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic s32 btf_array_check_meta(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t,\n\t\t\t\tu32 meta_left)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tu32 meta_needed = sizeof(*array);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\t/* array type should not have a name */\n\tif (t->name_off) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size) {\n\t\tbtf_verifier_log_type(env, t, \"size != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Array elem type and index type cannot be in type void,\n\t * so !array->type and !array->index_type are not allowed.\n\t */\n\tif (!array->type || !BTF_TYPE_ID_VALID(array->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!array->index_type || !BTF_TYPE_ID_VALID(array->index_type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_array_check_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2646-2673",
    "snippet": "static int btf_array_check_member(struct btf_verifier_env *env,\n\t\t\t\t  const struct btf_type *struct_type,\n\t\t\t\t  const struct btf_member *member,\n\t\t\t\t  const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\tu32 array_type_id, array_size;\n\tstruct btf *btf = env->btf;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tarray_type_id = member->type;\n\tbtf_type_id_size(btf, &array_type_id, &array_size);\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < array_size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "struct_bits_off"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&array_type_id",
            "&array_size"
          ],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_array_check_member(struct btf_verifier_env *env,\n\t\t\t\t  const struct btf_type *struct_type,\n\t\t\t\t  const struct btf_member *member,\n\t\t\t\t  const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\tu32 array_type_id, array_size;\n\tstruct btf *btf = env->btf;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tarray_type_id = member->type;\n\tbtf_type_id_size(btf, &array_type_id, &array_size);\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < array_size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_fwd_type_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2631-2635",
    "snippet": "static void btf_fwd_type_log(struct btf_verifier_env *env,\n\t\t\t     const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"%s\", btf_type_kflag(t) ? \"union\" : \"struct\");\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"%s\"",
            "btf_type_kflag(t) ? \"union\" : \"struct\""
          ],
          "line": 2634
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "t"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_fwd_type_log(struct btf_verifier_env *env,\n\t\t\t     const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"%s\", btf_type_kflag(t) ? \"union\" : \"struct\");\n}"
  },
  {
    "function_name": "btf_fwd_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2605-2629",
    "snippet": "static s32 btf_fwd_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->type) {\n\t\tbtf_verifier_log_type(env, t, \"type != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* fwd type must have a valid name */\n\tif (!t->name_off ||\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_valid_identifier",
          "args": [
            "env->btf",
            "t->name_off"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_valid_identifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "705-708",
          "snippet": "static bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"type != 0\""
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"vlen != 0\""
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic s32 btf_fwd_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->type) {\n\t\tbtf_verifier_log_type(env, t, \"type != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* fwd type must have a valid name */\n\tif (!t->name_off ||\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_ref_type_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2581-2585",
    "snippet": "static void btf_ref_type_log(struct btf_verifier_env *env,\n\t\t\t     const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"type_id=%u\", t->type);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"type_id=%u\"",
            "t->type"
          ],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_ref_type_log(struct btf_verifier_env *env,\n\t\t\t     const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"type_id=%u\", t->type);\n}"
  },
  {
    "function_name": "btf_ptr_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2563-2579",
    "snippet": "static void btf_ptr_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t u32 type_id, void *data, u8 bits_offset,\n\t\t\t struct btf_show *show)\n{\n\tvoid *safe_data;\n\n\tsafe_data = btf_show_start_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\t/* It is a hashed value unless BTF_SHOW_PTR_RAW is specified */\n\tif (show->flags & BTF_SHOW_PTR_RAW)\n\t\tbtf_show_type_value(show, \"0x%px\", *(void **)safe_data);\n\telse\n\t\tbtf_show_type_value(show, \"0x%p\", *(void **)safe_data);\n\tbtf_show_end_type(show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_end_type",
          "args": [
            "show"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1201-1206",
          "snippet": "static void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"0x%p\"",
            "*(void **)safe_data"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"0x%px\"",
            "*(void **)safe_data"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_start_type",
          "args": [
            "show",
            "t",
            "type_id",
            "data"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1190-1199",
          "snippet": "static void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_ptr_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t u32 type_id, void *data, u8 bits_offset,\n\t\t\t struct btf_show *show)\n{\n\tvoid *safe_data;\n\n\tsafe_data = btf_show_start_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\t/* It is a hashed value unless BTF_SHOW_PTR_RAW is specified */\n\tif (show->flags & BTF_SHOW_PTR_RAW)\n\t\tbtf_show_type_value(show, \"0x%px\", *(void **)safe_data);\n\telse\n\t\tbtf_show_type_value(show, \"0x%p\", *(void **)safe_data);\n\tbtf_show_end_type(show);\n}"
  },
  {
    "function_name": "btf_var_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2554-2561",
    "snippet": "static void btf_var_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t u32 type_id, void *data, u8 bits_offset,\n\t\t\t struct btf_show *show)\n{\n\tt = btf_type_id_resolve(btf, &type_id);\n\n\tbtf_type_ops(t)->show(btf, t, type_id, data, bits_offset, show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "btf",
            "t",
            "type_id",
            "data",
            "bits_offset",
            "show"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "t"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_resolve",
          "args": [
            "btf",
            "&type_id"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_resolve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1799-1804",
          "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_var_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t u32 type_id, void *data, u8 bits_offset,\n\t\t\t struct btf_show *show)\n{\n\tt = btf_type_id_resolve(btf, &type_id);\n\n\tbtf_type_ops(t)->show(btf, t, type_id, data, bits_offset, show);\n}"
  },
  {
    "function_name": "btf_modifier_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2541-2552",
    "snippet": "static void btf_modifier_show(const struct btf *btf,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id, void *data,\n\t\t\t      u8 bits_offset, struct btf_show *show)\n{\n\tif (btf->resolved_ids)\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\telse\n\t\tt = btf_type_skip_modifiers(btf, type_id, NULL);\n\n\tbtf_type_ops(t)->show(btf, t, type_id, data, bits_offset, show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "btf",
            "t",
            "type_id",
            "data",
            "bits_offset",
            "show"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "t"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_skip_modifiers",
          "args": [
            "btf",
            "type_id",
            "NULL"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_skip_modifiers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "509-523",
          "snippet": "const struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_resolve",
          "args": [
            "btf",
            "&type_id"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_resolve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1799-1804",
          "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_modifier_show(const struct btf *btf,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id, void *data,\n\t\t\t      u8 bits_offset, struct btf_show *show)\n{\n\tif (btf->resolved_ids)\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\telse\n\t\tt = btf_type_skip_modifiers(btf, type_id, NULL);\n\n\tbtf_type_ops(t)->show(btf, t, type_id, data, bits_offset, show);\n}"
  },
  {
    "function_name": "btf_ptr_resolve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2484-2539",
    "snippet": "static int btf_ptr_resolve(struct btf_verifier_env *env,\n\t\t\t   const struct resolve_vertex *v)\n{\n\tconst struct btf_type *next_type;\n\tconst struct btf_type *t = v->t;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type || btf_type_is_resolve_source_only(next_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\t/* If the modifier was RESOLVED during RESOLVE_STRUCT_OR_ARRAY,\n\t * the modifier may have stopped resolving when it was resolved\n\t * to a ptr (last-resolved-ptr).\n\t *\n\t * We now need to continue from the last-resolved-ptr to\n\t * ensure the last-resolved-ptr will not referring back to\n\t * the currenct ptr (t).\n\t */\n\tif (btf_type_is_modifier(next_type)) {\n\t\tconst struct btf_type *resolved_type;\n\t\tu32 resolved_type_id;\n\n\t\tresolved_type_id = next_type_id;\n\t\tresolved_type = btf_type_id_resolve(btf, &resolved_type_id);\n\n\t\tif (btf_type_is_ptr(resolved_type) &&\n\t\t    !env_type_is_resolve_sink(env, resolved_type) &&\n\t\t    !env_type_is_resolved(env, resolved_type_id))\n\t\t\treturn env_stack_push(env, resolved_type,\n\t\t\t\t\t      resolved_type_id);\n\t}\n\n\tif (!btf_type_id_size(btf, &next_type_id, NULL)) {\n\t\tif (env_type_is_resolved(env, next_type_id))\n\t\t\tnext_type = btf_type_id_resolve(btf, &next_type_id);\n\n\t\tif (!btf_type_is_void(next_type) &&\n\t\t    !btf_type_is_fwd(next_type) &&\n\t\t    !btf_type_is_func_proto(next_type)) {\n\t\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_stack_pop_resolved",
          "args": [
            "env",
            "next_type_id",
            "0"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_pop_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1676-1687",
          "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid type_id\""
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_func_proto",
          "args": [
            "next_type"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_fwd",
          "args": [
            "next_type"
          ],
          "line": 2529
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_fwd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "435-438",
          "snippet": "static bool btf_type_is_fwd(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_FWD;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_fwd(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_FWD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_void",
          "args": [
            "next_type"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_void",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "430-433",
          "snippet": "bool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btf_type btf_void;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nbool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_resolve",
          "args": [
            "btf",
            "&next_type_id"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_resolve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1799-1804",
          "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "next_type_id"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1630-1638",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&next_type_id",
            "NULL"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "resolved_type",
            "resolved_type_id"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1640-1668",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolve_sink",
          "args": [
            "env",
            "resolved_type"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolve_sink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1605-1628",
          "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "resolved_type"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "next_type"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid type_id\""
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_resolve_source_only",
          "args": [
            "next_type"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_resolve_source_only",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "552-557",
          "snippet": "static bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "next_type_id"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_ptr_resolve(struct btf_verifier_env *env,\n\t\t\t   const struct resolve_vertex *v)\n{\n\tconst struct btf_type *next_type;\n\tconst struct btf_type *t = v->t;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type || btf_type_is_resolve_source_only(next_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\t/* If the modifier was RESOLVED during RESOLVE_STRUCT_OR_ARRAY,\n\t * the modifier may have stopped resolving when it was resolved\n\t * to a ptr (last-resolved-ptr).\n\t *\n\t * We now need to continue from the last-resolved-ptr to\n\t * ensure the last-resolved-ptr will not referring back to\n\t * the currenct ptr (t).\n\t */\n\tif (btf_type_is_modifier(next_type)) {\n\t\tconst struct btf_type *resolved_type;\n\t\tu32 resolved_type_id;\n\n\t\tresolved_type_id = next_type_id;\n\t\tresolved_type = btf_type_id_resolve(btf, &resolved_type_id);\n\n\t\tif (btf_type_is_ptr(resolved_type) &&\n\t\t    !env_type_is_resolve_sink(env, resolved_type) &&\n\t\t    !env_type_is_resolved(env, resolved_type_id))\n\t\t\treturn env_stack_push(env, resolved_type,\n\t\t\t\t\t      resolved_type_id);\n\t}\n\n\tif (!btf_type_id_size(btf, &next_type_id, NULL)) {\n\t\tif (env_type_is_resolved(env, next_type_id))\n\t\t\tnext_type = btf_type_id_resolve(btf, &next_type_id);\n\n\t\tif (!btf_type_is_void(next_type) &&\n\t\t    !btf_type_is_fwd(next_type) &&\n\t\t    !btf_type_is_func_proto(next_type)) {\n\t\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_var_resolve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2438-2482",
    "snippet": "static int btf_var_resolve(struct btf_verifier_env *env,\n\t\t\t   const struct resolve_vertex *v)\n{\n\tconst struct btf_type *next_type;\n\tconst struct btf_type *t = v->t;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type || btf_type_is_resolve_source_only(next_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\tif (btf_type_is_modifier(next_type)) {\n\t\tconst struct btf_type *resolved_type;\n\t\tu32 resolved_type_id;\n\n\t\tresolved_type_id = next_type_id;\n\t\tresolved_type = btf_type_id_resolve(btf, &resolved_type_id);\n\n\t\tif (btf_type_is_ptr(resolved_type) &&\n\t\t    !env_type_is_resolve_sink(env, resolved_type) &&\n\t\t    !env_type_is_resolved(env, resolved_type_id))\n\t\t\treturn env_stack_push(env, resolved_type,\n\t\t\t\t\t      resolved_type_id);\n\t}\n\n\t/* We must resolve to something concrete at this point, no\n\t * forward types or similar that would resolve to size of\n\t * zero is allowed.\n\t */\n\tif (!btf_type_id_size(btf, &next_type_id, NULL)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_stack_pop_resolved",
          "args": [
            "env",
            "next_type_id",
            "0"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_pop_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1676-1687",
          "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid type_id\""
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&next_type_id",
            "NULL"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "resolved_type",
            "resolved_type_id"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1640-1668",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "resolved_type_id"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1630-1638",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolve_sink",
          "args": [
            "env",
            "resolved_type"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolve_sink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1605-1628",
          "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "resolved_type"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_id_resolve",
          "args": [
            "btf",
            "&resolved_type_id"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_resolve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1799-1804",
          "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "next_type"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid type_id\""
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_resolve_source_only",
          "args": [
            "next_type"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_resolve_source_only",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "552-557",
          "snippet": "static bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "next_type_id"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_var_resolve(struct btf_verifier_env *env,\n\t\t\t   const struct resolve_vertex *v)\n{\n\tconst struct btf_type *next_type;\n\tconst struct btf_type *t = v->t;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type || btf_type_is_resolve_source_only(next_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\tif (btf_type_is_modifier(next_type)) {\n\t\tconst struct btf_type *resolved_type;\n\t\tu32 resolved_type_id;\n\n\t\tresolved_type_id = next_type_id;\n\t\tresolved_type = btf_type_id_resolve(btf, &resolved_type_id);\n\n\t\tif (btf_type_is_ptr(resolved_type) &&\n\t\t    !env_type_is_resolve_sink(env, resolved_type) &&\n\t\t    !env_type_is_resolved(env, resolved_type_id))\n\t\t\treturn env_stack_push(env, resolved_type,\n\t\t\t\t\t      resolved_type_id);\n\t}\n\n\t/* We must resolve to something concrete at this point, no\n\t * forward types or similar that would resolve to size of\n\t * zero is allowed.\n\t */\n\tif (!btf_type_id_size(btf, &next_type_id, NULL)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_modifier_resolve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2396-2436",
    "snippet": "static int btf_modifier_resolve(struct btf_verifier_env *env,\n\t\t\t\tconst struct resolve_vertex *v)\n{\n\tconst struct btf_type *t = v->t;\n\tconst struct btf_type *next_type;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type || btf_type_is_resolve_source_only(next_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\t/* Figure out the resolved next_type_id with size.\n\t * They will be stored in the current modifier's\n\t * resolved_ids and resolved_sizes such that it can\n\t * save us a few type-following when we use it later (e.g. in\n\t * pretty print).\n\t */\n\tif (!btf_type_id_size(btf, &next_type_id, NULL)) {\n\t\tif (env_type_is_resolved(env, next_type_id))\n\t\t\tnext_type = btf_type_id_resolve(btf, &next_type_id);\n\n\t\t/* \"typedef void new_void\", \"const void\"...etc */\n\t\tif (!btf_type_is_void(next_type) &&\n\t\t    !btf_type_is_fwd(next_type) &&\n\t\t    !btf_type_is_func_proto(next_type)) {\n\t\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_stack_pop_resolved",
          "args": [
            "env",
            "next_type_id",
            "0"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_pop_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1676-1687",
          "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid type_id\""
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_func_proto",
          "args": [
            "next_type"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_fwd",
          "args": [
            "next_type"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_fwd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "435-438",
          "snippet": "static bool btf_type_is_fwd(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_FWD;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_fwd(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_FWD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_void",
          "args": [
            "next_type"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_void",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "430-433",
          "snippet": "bool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btf_type btf_void;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nbool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_resolve",
          "args": [
            "btf",
            "&next_type_id"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_resolve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1799-1804",
          "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "next_type_id"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1630-1638",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&next_type_id",
            "NULL"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "next_type",
            "next_type_id"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1640-1668",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolve_sink",
          "args": [
            "env",
            "next_type"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolve_sink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1605-1628",
          "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid type_id\""
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_resolve_source_only",
          "args": [
            "next_type"
          ],
          "line": 2405
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_resolve_source_only",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "552-557",
          "snippet": "static bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "next_type_id"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_modifier_resolve(struct btf_verifier_env *env,\n\t\t\t\tconst struct resolve_vertex *v)\n{\n\tconst struct btf_type *t = v->t;\n\tconst struct btf_type *next_type;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type || btf_type_is_resolve_source_only(next_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\t/* Figure out the resolved next_type_id with size.\n\t * They will be stored in the current modifier's\n\t * resolved_ids and resolved_sizes such that it can\n\t * save us a few type-following when we use it later (e.g. in\n\t * pretty print).\n\t */\n\tif (!btf_type_id_size(btf, &next_type_id, NULL)) {\n\t\tif (env_type_is_resolved(env, next_type_id))\n\t\t\tnext_type = btf_type_id_resolve(btf, &next_type_id);\n\n\t\t/* \"typedef void new_void\", \"const void\"...etc */\n\t\tif (!btf_type_is_void(next_type) &&\n\t\t    !btf_type_is_fwd(next_type) &&\n\t\t    !btf_type_is_func_proto(next_type)) {\n\t\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_ref_type_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2348-2394",
    "snippet": "static int btf_ref_type_check_meta(struct btf_verifier_env *env,\n\t\t\t\t   const struct btf_type *t,\n\t\t\t\t   u32 meta_left)\n{\n\tconst char *value;\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!BTF_TYPE_ID_VALID(t->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* typedef/type_tag type must have a valid name, and other ref types,\n\t * volatile, const, restrict, should have a null name.\n\t */\n\tif (BTF_INFO_KIND(t->info) == BTF_KIND_TYPEDEF) {\n\t\tif (!t->name_off ||\n\t\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (BTF_INFO_KIND(t->info) == BTF_KIND_TYPE_TAG) {\n\t\tvalue = btf_name_by_offset(env->btf, t->name_off);\n\t\tif (!value || !value[0]) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (t->name_off) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "env->btf",
            "t->name_off"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "726-729",
          "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid name\""
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_valid_identifier",
          "args": [
            "env->btf",
            "t->name_off"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_valid_identifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "705-708",
          "snippet": "static bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid type_id\""
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_TYPE_ID_VALID",
          "args": [
            "t->type"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid btf_info kind_flag\""
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "t"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"vlen != 0\""
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int btf_ref_type_check_meta(struct btf_verifier_env *env,\n\t\t\t\t   const struct btf_type *t,\n\t\t\t\t   u32 meta_left)\n{\n\tconst char *value;\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!BTF_TYPE_ID_VALID(t->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* typedef/type_tag type must have a valid name, and other ref types,\n\t * volatile, const, restrict, should have a null name.\n\t */\n\tif (BTF_INFO_KIND(t->info) == BTF_KIND_TYPEDEF) {\n\t\tif (!t->name_off ||\n\t\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (BTF_INFO_KIND(t->info) == BTF_KIND_TYPE_TAG) {\n\t\tvalue = btf_name_by_offset(env->btf, t->name_off);\n\t\tif (!value || !value[0]) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (t->name_off) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_ptr_check_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2322-2346",
    "snippet": "static int btf_ptr_check_member(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *struct_type,\n\t\t\t\tconst struct btf_member *member,\n\t\t\t\tconst struct btf_type *member_type)\n{\n\tu32 struct_size, struct_bits_off, bytes_offset;\n\n\tstruct_size = struct_type->size;\n\tstruct_bits_off = member->offset;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size - bytes_offset < sizeof(void *)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "struct_bits_off"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_ptr_check_member(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *struct_type,\n\t\t\t\tconst struct btf_member *member,\n\t\t\t\tconst struct btf_type *member_type)\n{\n\tu32 struct_size, struct_bits_off, bytes_offset;\n\n\tstruct_size = struct_type->size;\n\tstruct_bits_off = member->offset;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size - bytes_offset < sizeof(void *)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_modifier_check_kflag_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2297-2320",
    "snippet": "static int btf_modifier_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t\t   const struct btf_type *struct_type,\n\t\t\t\t\t   const struct btf_member *member,\n\t\t\t\t\t   const struct btf_type *member_type)\n{\n\tconst struct btf_type *resolved_type;\n\tu32 resolved_type_id = member->type;\n\tstruct btf_member resolved_member;\n\tstruct btf *btf = env->btf;\n\n\tresolved_type = btf_type_id_size(btf, &resolved_type_id, NULL);\n\tif (!resolved_type) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member\");\n\t\treturn -EINVAL;\n\t}\n\n\tresolved_member = *member;\n\tresolved_member.type = resolved_type_id;\n\n\treturn btf_type_ops(resolved_type)->check_kflag_member(env, struct_type,\n\t\t\t\t\t\t\t       &resolved_member,\n\t\t\t\t\t\t\t       resolved_type);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "struct_type",
            "&resolved_member",
            "resolved_type"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "resolved_type"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Invalid member\""
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&resolved_type_id",
            "NULL"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_modifier_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t\t   const struct btf_type *struct_type,\n\t\t\t\t\t   const struct btf_member *member,\n\t\t\t\t\t   const struct btf_type *member_type)\n{\n\tconst struct btf_type *resolved_type;\n\tu32 resolved_type_id = member->type;\n\tstruct btf_member resolved_member;\n\tstruct btf *btf = env->btf;\n\n\tresolved_type = btf_type_id_size(btf, &resolved_type_id, NULL);\n\tif (!resolved_type) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member\");\n\t\treturn -EINVAL;\n\t}\n\n\tresolved_member = *member;\n\tresolved_member.type = resolved_type_id;\n\n\treturn btf_type_ops(resolved_type)->check_kflag_member(env, struct_type,\n\t\t\t\t\t\t\t       &resolved_member,\n\t\t\t\t\t\t\t       resolved_type);\n}"
  },
  {
    "function_name": "btf_modifier_check_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2272-2295",
    "snippet": "static int btf_modifier_check_member(struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *struct_type,\n\t\t\t\t     const struct btf_member *member,\n\t\t\t\t     const struct btf_type *member_type)\n{\n\tconst struct btf_type *resolved_type;\n\tu32 resolved_type_id = member->type;\n\tstruct btf_member resolved_member;\n\tstruct btf *btf = env->btf;\n\n\tresolved_type = btf_type_id_size(btf, &resolved_type_id, NULL);\n\tif (!resolved_type) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member\");\n\t\treturn -EINVAL;\n\t}\n\n\tresolved_member = *member;\n\tresolved_member.type = resolved_type_id;\n\n\treturn btf_type_ops(resolved_type)->check_member(env, struct_type,\n\t\t\t\t\t\t\t &resolved_member,\n\t\t\t\t\t\t\t resolved_type);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "struct_type",
            "&resolved_member",
            "resolved_type"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "resolved_type"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Invalid member\""
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&resolved_type_id",
            "NULL"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_modifier_check_member(struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *struct_type,\n\t\t\t\t     const struct btf_member *member,\n\t\t\t\t     const struct btf_type *member_type)\n{\n\tconst struct btf_type *resolved_type;\n\tu32 resolved_type_id = member->type;\n\tstruct btf_member resolved_member;\n\tstruct btf *btf = env->btf;\n\n\tresolved_type = btf_type_id_size(btf, &resolved_type_id, NULL);\n\tif (!resolved_type) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member\");\n\t\treturn -EINVAL;\n\t}\n\n\tresolved_member = *member;\n\tresolved_member.type = resolved_type_id;\n\n\treturn btf_type_ops(resolved_type)->check_member(env, struct_type,\n\t\t\t\t\t\t\t &resolved_member,\n\t\t\t\t\t\t\t resolved_type);\n}"
  },
  {
    "function_name": "btf_int_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2193-2261",
    "snippet": "static void btf_int_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t u32 type_id, void *data, u8 bits_offset,\n\t\t\t struct btf_show *show)\n{\n\tu32 int_data = btf_type_int(t);\n\tu8 encoding = BTF_INT_ENCODING(int_data);\n\tbool sign = encoding & BTF_INT_SIGNED;\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tvoid *safe_data;\n\n\tsafe_data = btf_show_start_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\tif (bits_offset || BTF_INT_OFFSET(int_data) ||\n\t    BITS_PER_BYTE_MASKED(nr_bits)) {\n\t\tbtf_int_bits_show(btf, t, safe_data, bits_offset, show);\n\t\tgoto out;\n\t}\n\n\tswitch (nr_bits) {\n\tcase 128:\n\t\tbtf_int128_print(show, safe_data);\n\t\tbreak;\n\tcase 64:\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%lld\", *(s64 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%llu\", *(u64 *)safe_data);\n\t\tbreak;\n\tcase 32:\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%d\", *(s32 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%u\", *(u32 *)safe_data);\n\t\tbreak;\n\tcase 16:\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%d\", *(s16 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%u\", *(u16 *)safe_data);\n\t\tbreak;\n\tcase 8:\n\t\tif (show->state.array_encoding == BTF_INT_CHAR) {\n\t\t\t/* check for null terminator */\n\t\t\tif (show->state.array_terminated)\n\t\t\t\tbreak;\n\t\t\tif (*(char *)data == '\\0') {\n\t\t\t\tshow->state.array_terminated = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isprint(*(char *)data)) {\n\t\t\t\tbtf_show_type_value(show, \"'%c'\",\n\t\t\t\t\t\t    *(char *)safe_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%d\", *(s8 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%u\", *(u8 *)safe_data);\n\t\tbreak;\n\tdefault:\n\t\tbtf_int_bits_show(btf, t, safe_data, bits_offset, show);\n\t\tbreak;\n\t}\nout:\n\tbtf_show_end_type(show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_end_type",
          "args": [
            "show"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1201-1206",
          "snippet": "static void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_int_bits_show",
          "args": [
            "btf",
            "t",
            "safe_data",
            "bits_offset",
            "show"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "btf_int_bits_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "2174-2191",
          "snippet": "static void btf_int_bits_show(const struct btf *btf,\n\t\t\t      const struct btf_type *t,\n\t\t\t      void *data, u8 bits_offset,\n\t\t\t      struct btf_show *show)\n{\n\tu32 int_data = btf_type_int(t);\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tu8 total_bits_offset;\n\n\t/*\n\t * bits_offset is at most 7.\n\t * BTF_INT_OFFSET() cannot exceed 128 bits.\n\t */\n\ttotal_bits_offset = bits_offset + BTF_INT_OFFSET(int_data);\n\tdata += BITS_ROUNDDOWN_BYTES(total_bits_offset);\n\tbits_offset = BITS_PER_BYTE_MASKED(total_bits_offset);\n\tbtf_bitfield_show(data, bits_offset, nr_bits, show);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_int_bits_show(const struct btf *btf,\n\t\t\t      const struct btf_type *t,\n\t\t\t      void *data, u8 bits_offset,\n\t\t\t      struct btf_show *show)\n{\n\tu32 int_data = btf_type_int(t);\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tu8 total_bits_offset;\n\n\t/*\n\t * bits_offset is at most 7.\n\t * BTF_INT_OFFSET() cannot exceed 128 bits.\n\t */\n\ttotal_bits_offset = bits_offset + BTF_INT_OFFSET(int_data);\n\tdata += BITS_ROUNDDOWN_BYTES(total_bits_offset);\n\tbits_offset = BITS_PER_BYTE_MASKED(total_bits_offset);\n\tbtf_bitfield_show(data, bits_offset, nr_bits, show);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"%u\"",
            "*(u8 *)safe_data"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"%d\"",
            "*(s8 *)safe_data"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"'%c'\"",
            "*(char *)safe_data"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "*(char *)data"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"%u\"",
            "*(u16 *)safe_data"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"%d\"",
            "*(s16 *)safe_data"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"%u\"",
            "*(u32 *)safe_data"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"%d\"",
            "*(s32 *)safe_data"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"%llu\"",
            "*(u64 *)safe_data"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"%lld\"",
            "*(s64 *)safe_data"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_int128_print",
          "args": [
            "show",
            "safe_data"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "btf_int128_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "2083-2106",
          "snippet": "static void btf_int128_print(struct btf_show *show, void *data)\n{\n\t/* data points to a __int128 number.\n\t * Suppose\n\t *     int128_num = *(__int128 *)data;\n\t * The below formulas shows what upper_num and lower_num represents:\n\t *     upper_num = int128_num >> 64;\n\t *     lower_num = int128_num & 0xffffffffFFFFFFFFULL;\n\t */\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = *(u64 *)data;\n\tlower_num = *(u64 *)(data + 8);\n#else\n\tupper_num = *(u64 *)(data + 8);\n\tlower_num = *(u64 *)data;\n#endif\n\tif (upper_num == 0)\n\t\tbtf_show_type_value(show, \"0x%llx\", lower_num);\n\telse\n\t\tbtf_show_type_values(show, \"0x%llx%016llx\", upper_num,\n\t\t\t\t     lower_num);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_int128_print(struct btf_show *show, void *data)\n{\n\t/* data points to a __int128 number.\n\t * Suppose\n\t *     int128_num = *(__int128 *)data;\n\t * The below formulas shows what upper_num and lower_num represents:\n\t *     upper_num = int128_num >> 64;\n\t *     lower_num = int128_num & 0xffffffffFFFFFFFFULL;\n\t */\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = *(u64 *)data;\n\tlower_num = *(u64 *)(data + 8);\n#else\n\tupper_num = *(u64 *)(data + 8);\n\tlower_num = *(u64 *)data;\n#endif\n\tif (upper_num == 0)\n\t\tbtf_show_type_value(show, \"0x%llx\", lower_num);\n\telse\n\t\tbtf_show_type_values(show, \"0x%llx%016llx\", upper_num,\n\t\t\t\t     lower_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "nr_bits"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_start_type",
          "args": [
            "show",
            "t",
            "type_id",
            "data"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1190-1199",
          "snippet": "static void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_ENCODING",
          "args": [
            "int_data"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "t"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "746-763",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_int_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t u32 type_id, void *data, u8 bits_offset,\n\t\t\t struct btf_show *show)\n{\n\tu32 int_data = btf_type_int(t);\n\tu8 encoding = BTF_INT_ENCODING(int_data);\n\tbool sign = encoding & BTF_INT_SIGNED;\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tvoid *safe_data;\n\n\tsafe_data = btf_show_start_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\tif (bits_offset || BTF_INT_OFFSET(int_data) ||\n\t    BITS_PER_BYTE_MASKED(nr_bits)) {\n\t\tbtf_int_bits_show(btf, t, safe_data, bits_offset, show);\n\t\tgoto out;\n\t}\n\n\tswitch (nr_bits) {\n\tcase 128:\n\t\tbtf_int128_print(show, safe_data);\n\t\tbreak;\n\tcase 64:\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%lld\", *(s64 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%llu\", *(u64 *)safe_data);\n\t\tbreak;\n\tcase 32:\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%d\", *(s32 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%u\", *(u32 *)safe_data);\n\t\tbreak;\n\tcase 16:\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%d\", *(s16 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%u\", *(u16 *)safe_data);\n\t\tbreak;\n\tcase 8:\n\t\tif (show->state.array_encoding == BTF_INT_CHAR) {\n\t\t\t/* check for null terminator */\n\t\t\tif (show->state.array_terminated)\n\t\t\t\tbreak;\n\t\t\tif (*(char *)data == '\\0') {\n\t\t\t\tshow->state.array_terminated = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isprint(*(char *)data)) {\n\t\t\t\tbtf_show_type_value(show, \"'%c'\",\n\t\t\t\t\t\t    *(char *)safe_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%d\", *(s8 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%u\", *(u8 *)safe_data);\n\t\tbreak;\n\tdefault:\n\t\tbtf_int_bits_show(btf, t, safe_data, bits_offset, show);\n\t\tbreak;\n\t}\nout:\n\tbtf_show_end_type(show);\n}"
  },
  {
    "function_name": "btf_int_bits_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2174-2191",
    "snippet": "static void btf_int_bits_show(const struct btf *btf,\n\t\t\t      const struct btf_type *t,\n\t\t\t      void *data, u8 bits_offset,\n\t\t\t      struct btf_show *show)\n{\n\tu32 int_data = btf_type_int(t);\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tu8 total_bits_offset;\n\n\t/*\n\t * bits_offset is at most 7.\n\t * BTF_INT_OFFSET() cannot exceed 128 bits.\n\t */\n\ttotal_bits_offset = bits_offset + BTF_INT_OFFSET(int_data);\n\tdata += BITS_ROUNDDOWN_BYTES(total_bits_offset);\n\tbits_offset = BITS_PER_BYTE_MASKED(total_bits_offset);\n\tbtf_bitfield_show(data, bits_offset, nr_bits, show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_bitfield_show",
          "args": [
            "data",
            "bits_offset",
            "nr_bits",
            "show"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "btf_bitfield_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "2149-2171",
          "snippet": "static void btf_bitfield_show(void *data, u8 bits_offset,\n\t\t\t      u8 nr_bits, struct btf_show *show)\n{\n\tu16 left_shift_bits, right_shift_bits;\n\tu8 nr_copy_bytes;\n\tu8 nr_copy_bits;\n\tu64 print_num[2] = {};\n\n\tnr_copy_bits = nr_bits + bits_offset;\n\tnr_copy_bytes = BITS_ROUNDUP_BYTES(nr_copy_bits);\n\n\tmemcpy(print_num, data, nr_copy_bytes);\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tleft_shift_bits = bits_offset;\n#else\n\tleft_shift_bits = BITS_PER_U128 - nr_copy_bits;\n#endif\n\tright_shift_bits = BITS_PER_U128 - nr_bits;\n\n\tbtf_int128_shift(print_num, left_shift_bits, right_shift_bits);\n\tbtf_int128_print(show, print_num);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)\n\nstatic void btf_bitfield_show(void *data, u8 bits_offset,\n\t\t\t      u8 nr_bits, struct btf_show *show)\n{\n\tu16 left_shift_bits, right_shift_bits;\n\tu8 nr_copy_bytes;\n\tu8 nr_copy_bits;\n\tu64 print_num[2] = {};\n\n\tnr_copy_bits = nr_bits + bits_offset;\n\tnr_copy_bytes = BITS_ROUNDUP_BYTES(nr_copy_bits);\n\n\tmemcpy(print_num, data, nr_copy_bytes);\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tleft_shift_bits = bits_offset;\n#else\n\tleft_shift_bits = BITS_PER_U128 - nr_copy_bits;\n#endif\n\tright_shift_bits = BITS_PER_U128 - nr_bits;\n\n\tbtf_int128_shift(print_num, left_shift_bits, right_shift_bits);\n\tbtf_int128_print(show, print_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "total_bits_offset"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "total_bits_offset"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "t"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "746-763",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_int_bits_show(const struct btf *btf,\n\t\t\t      const struct btf_type *t,\n\t\t\t      void *data, u8 bits_offset,\n\t\t\t      struct btf_show *show)\n{\n\tu32 int_data = btf_type_int(t);\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tu8 total_bits_offset;\n\n\t/*\n\t * bits_offset is at most 7.\n\t * BTF_INT_OFFSET() cannot exceed 128 bits.\n\t */\n\ttotal_bits_offset = bits_offset + BTF_INT_OFFSET(int_data);\n\tdata += BITS_ROUNDDOWN_BYTES(total_bits_offset);\n\tbits_offset = BITS_PER_BYTE_MASKED(total_bits_offset);\n\tbtf_bitfield_show(data, bits_offset, nr_bits, show);\n}"
  },
  {
    "function_name": "btf_bitfield_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2149-2171",
    "snippet": "static void btf_bitfield_show(void *data, u8 bits_offset,\n\t\t\t      u8 nr_bits, struct btf_show *show)\n{\n\tu16 left_shift_bits, right_shift_bits;\n\tu8 nr_copy_bytes;\n\tu8 nr_copy_bits;\n\tu64 print_num[2] = {};\n\n\tnr_copy_bits = nr_bits + bits_offset;\n\tnr_copy_bytes = BITS_ROUNDUP_BYTES(nr_copy_bits);\n\n\tmemcpy(print_num, data, nr_copy_bytes);\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tleft_shift_bits = bits_offset;\n#else\n\tleft_shift_bits = BITS_PER_U128 - nr_copy_bits;\n#endif\n\tright_shift_bits = BITS_PER_U128 - nr_bits;\n\n\tbtf_int128_shift(print_num, left_shift_bits, right_shift_bits);\n\tbtf_int128_print(show, print_num);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_int128_print",
          "args": [
            "show",
            "print_num"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "btf_int128_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "2083-2106",
          "snippet": "static void btf_int128_print(struct btf_show *show, void *data)\n{\n\t/* data points to a __int128 number.\n\t * Suppose\n\t *     int128_num = *(__int128 *)data;\n\t * The below formulas shows what upper_num and lower_num represents:\n\t *     upper_num = int128_num >> 64;\n\t *     lower_num = int128_num & 0xffffffffFFFFFFFFULL;\n\t */\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = *(u64 *)data;\n\tlower_num = *(u64 *)(data + 8);\n#else\n\tupper_num = *(u64 *)(data + 8);\n\tlower_num = *(u64 *)data;\n#endif\n\tif (upper_num == 0)\n\t\tbtf_show_type_value(show, \"0x%llx\", lower_num);\n\telse\n\t\tbtf_show_type_values(show, \"0x%llx%016llx\", upper_num,\n\t\t\t\t     lower_num);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_int128_print(struct btf_show *show, void *data)\n{\n\t/* data points to a __int128 number.\n\t * Suppose\n\t *     int128_num = *(__int128 *)data;\n\t * The below formulas shows what upper_num and lower_num represents:\n\t *     upper_num = int128_num >> 64;\n\t *     lower_num = int128_num & 0xffffffffFFFFFFFFULL;\n\t */\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = *(u64 *)data;\n\tlower_num = *(u64 *)(data + 8);\n#else\n\tupper_num = *(u64 *)(data + 8);\n\tlower_num = *(u64 *)data;\n#endif\n\tif (upper_num == 0)\n\t\tbtf_show_type_value(show, \"0x%llx\", lower_num);\n\telse\n\t\tbtf_show_type_values(show, \"0x%llx%016llx\", upper_num,\n\t\t\t\t     lower_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_int128_shift",
          "args": [
            "print_num",
            "left_shift_bits",
            "right_shift_bits"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "btf_int128_shift",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "2108-2147",
          "snippet": "static void btf_int128_shift(u64 *print_num, u16 left_shift_bits,\n\t\t\t     u16 right_shift_bits)\n{\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = print_num[0];\n\tlower_num = print_num[1];\n#else\n\tupper_num = print_num[1];\n\tlower_num = print_num[0];\n#endif\n\n\t/* shake out un-needed bits by shift/or operations */\n\tif (left_shift_bits >= 64) {\n\t\tupper_num = lower_num << (left_shift_bits - 64);\n\t\tlower_num = 0;\n\t} else {\n\t\tupper_num = (upper_num << left_shift_bits) |\n\t\t\t    (lower_num >> (64 - left_shift_bits));\n\t\tlower_num = lower_num << left_shift_bits;\n\t}\n\n\tif (right_shift_bits >= 64) {\n\t\tlower_num = upper_num >> (right_shift_bits - 64);\n\t\tupper_num = 0;\n\t} else {\n\t\tlower_num = (lower_num >> right_shift_bits) |\n\t\t\t    (upper_num << (64 - right_shift_bits));\n\t\tupper_num = upper_num >> right_shift_bits;\n\t}\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tprint_num[0] = upper_num;\n\tprint_num[1] = lower_num;\n#else\n\tprint_num[0] = lower_num;\n\tprint_num[1] = upper_num;\n#endif\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_int128_shift(u64 *print_num, u16 left_shift_bits,\n\t\t\t     u16 right_shift_bits)\n{\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = print_num[0];\n\tlower_num = print_num[1];\n#else\n\tupper_num = print_num[1];\n\tlower_num = print_num[0];\n#endif\n\n\t/* shake out un-needed bits by shift/or operations */\n\tif (left_shift_bits >= 64) {\n\t\tupper_num = lower_num << (left_shift_bits - 64);\n\t\tlower_num = 0;\n\t} else {\n\t\tupper_num = (upper_num << left_shift_bits) |\n\t\t\t    (lower_num >> (64 - left_shift_bits));\n\t\tlower_num = lower_num << left_shift_bits;\n\t}\n\n\tif (right_shift_bits >= 64) {\n\t\tlower_num = upper_num >> (right_shift_bits - 64);\n\t\tupper_num = 0;\n\t} else {\n\t\tlower_num = (lower_num >> right_shift_bits) |\n\t\t\t    (upper_num << (64 - right_shift_bits));\n\t\tupper_num = upper_num >> right_shift_bits;\n\t}\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tprint_num[0] = upper_num;\n\tprint_num[1] = lower_num;\n#else\n\tprint_num[0] = lower_num;\n\tprint_num[1] = upper_num;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "print_num",
            "data",
            "nr_copy_bytes"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "nr_copy_bits"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)\n\nstatic void btf_bitfield_show(void *data, u8 bits_offset,\n\t\t\t      u8 nr_bits, struct btf_show *show)\n{\n\tu16 left_shift_bits, right_shift_bits;\n\tu8 nr_copy_bytes;\n\tu8 nr_copy_bits;\n\tu64 print_num[2] = {};\n\n\tnr_copy_bits = nr_bits + bits_offset;\n\tnr_copy_bytes = BITS_ROUNDUP_BYTES(nr_copy_bits);\n\n\tmemcpy(print_num, data, nr_copy_bytes);\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tleft_shift_bits = bits_offset;\n#else\n\tleft_shift_bits = BITS_PER_U128 - nr_copy_bits;\n#endif\n\tright_shift_bits = BITS_PER_U128 - nr_bits;\n\n\tbtf_int128_shift(print_num, left_shift_bits, right_shift_bits);\n\tbtf_int128_print(show, print_num);\n}"
  },
  {
    "function_name": "btf_int128_shift",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2108-2147",
    "snippet": "static void btf_int128_shift(u64 *print_num, u16 left_shift_bits,\n\t\t\t     u16 right_shift_bits)\n{\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = print_num[0];\n\tlower_num = print_num[1];\n#else\n\tupper_num = print_num[1];\n\tlower_num = print_num[0];\n#endif\n\n\t/* shake out un-needed bits by shift/or operations */\n\tif (left_shift_bits >= 64) {\n\t\tupper_num = lower_num << (left_shift_bits - 64);\n\t\tlower_num = 0;\n\t} else {\n\t\tupper_num = (upper_num << left_shift_bits) |\n\t\t\t    (lower_num >> (64 - left_shift_bits));\n\t\tlower_num = lower_num << left_shift_bits;\n\t}\n\n\tif (right_shift_bits >= 64) {\n\t\tlower_num = upper_num >> (right_shift_bits - 64);\n\t\tupper_num = 0;\n\t} else {\n\t\tlower_num = (lower_num >> right_shift_bits) |\n\t\t\t    (upper_num << (64 - right_shift_bits));\n\t\tupper_num = upper_num >> right_shift_bits;\n\t}\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tprint_num[0] = upper_num;\n\tprint_num[1] = lower_num;\n#else\n\tprint_num[0] = lower_num;\n\tprint_num[1] = upper_num;\n#endif\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_int128_shift(u64 *print_num, u16 left_shift_bits,\n\t\t\t     u16 right_shift_bits)\n{\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = print_num[0];\n\tlower_num = print_num[1];\n#else\n\tupper_num = print_num[1];\n\tlower_num = print_num[0];\n#endif\n\n\t/* shake out un-needed bits by shift/or operations */\n\tif (left_shift_bits >= 64) {\n\t\tupper_num = lower_num << (left_shift_bits - 64);\n\t\tlower_num = 0;\n\t} else {\n\t\tupper_num = (upper_num << left_shift_bits) |\n\t\t\t    (lower_num >> (64 - left_shift_bits));\n\t\tlower_num = lower_num << left_shift_bits;\n\t}\n\n\tif (right_shift_bits >= 64) {\n\t\tlower_num = upper_num >> (right_shift_bits - 64);\n\t\tupper_num = 0;\n\t} else {\n\t\tlower_num = (lower_num >> right_shift_bits) |\n\t\t\t    (upper_num << (64 - right_shift_bits));\n\t\tupper_num = upper_num >> right_shift_bits;\n\t}\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tprint_num[0] = upper_num;\n\tprint_num[1] = lower_num;\n#else\n\tprint_num[0] = lower_num;\n\tprint_num[1] = upper_num;\n#endif\n}"
  },
  {
    "function_name": "btf_int128_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2083-2106",
    "snippet": "static void btf_int128_print(struct btf_show *show, void *data)\n{\n\t/* data points to a __int128 number.\n\t * Suppose\n\t *     int128_num = *(__int128 *)data;\n\t * The below formulas shows what upper_num and lower_num represents:\n\t *     upper_num = int128_num >> 64;\n\t *     lower_num = int128_num & 0xffffffffFFFFFFFFULL;\n\t */\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = *(u64 *)data;\n\tlower_num = *(u64 *)(data + 8);\n#else\n\tupper_num = *(u64 *)(data + 8);\n\tlower_num = *(u64 *)data;\n#endif\n\tif (upper_num == 0)\n\t\tbtf_show_type_value(show, \"0x%llx\", lower_num);\n\telse\n\t\tbtf_show_type_values(show, \"0x%llx%016llx\", upper_num,\n\t\t\t\t     lower_num);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_type_values",
          "args": [
            "show",
            "\"0x%llx%016llx\"",
            "upper_num",
            "lower_num"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_type_value",
          "args": [
            "show",
            "\"0x%llx\"",
            "lower_num"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_int128_print(struct btf_show *show, void *data)\n{\n\t/* data points to a __int128 number.\n\t * Suppose\n\t *     int128_num = *(__int128 *)data;\n\t * The below formulas shows what upper_num and lower_num represents:\n\t *     upper_num = int128_num >> 64;\n\t *     lower_num = int128_num & 0xffffffffFFFFFFFFULL;\n\t */\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = *(u64 *)data;\n\tlower_num = *(u64 *)(data + 8);\n#else\n\tupper_num = *(u64 *)(data + 8);\n\tlower_num = *(u64 *)data;\n#endif\n\tif (upper_num == 0)\n\t\tbtf_show_type_value(show, \"0x%llx\", lower_num);\n\telse\n\t\tbtf_show_type_values(show, \"0x%llx%016llx\", upper_num,\n\t\t\t\t     lower_num);\n}"
  },
  {
    "function_name": "btf_int_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2071-2081",
    "snippet": "static void btf_int_log(struct btf_verifier_env *env,\n\t\t\tconst struct btf_type *t)\n{\n\tint int_data = btf_type_int(t);\n\n\tbtf_verifier_log(env,\n\t\t\t \"size=%u bits_offset=%u nr_bits=%u encoding=%s\",\n\t\t\t t->size, BTF_INT_OFFSET(int_data),\n\t\t\t BTF_INT_BITS(int_data),\n\t\t\t btf_int_encoding_str(BTF_INT_ENCODING(int_data)));\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"size=%u bits_offset=%u nr_bits=%u encoding=%s\"",
            "t->size",
            "BTF_INT_OFFSET(int_data)",
            "BTF_INT_BITS(int_data)",
            "btf_int_encoding_str(BTF_INT_ENCODING(int_data))"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1297-1309",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_int_encoding_str",
          "args": [
            "BTF_INT_ENCODING(int_data)"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "btf_int_encoding_str",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "602-614",
          "snippet": "static const char *btf_int_encoding_str(u8 encoding)\n{\n\tif (encoding == 0)\n\t\treturn \"(none)\";\n\telse if (encoding == BTF_INT_SIGNED)\n\t\treturn \"SIGNED\";\n\telse if (encoding == BTF_INT_CHAR)\n\t\treturn \"CHAR\";\n\telse if (encoding == BTF_INT_BOOL)\n\t\treturn \"BOOL\";\n\telse\n\t\treturn \"UNKN\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_int_encoding_str(u8 encoding)\n{\n\tif (encoding == 0)\n\t\treturn \"(none)\";\n\telse if (encoding == BTF_INT_SIGNED)\n\t\treturn \"SIGNED\";\n\telse if (encoding == BTF_INT_CHAR)\n\t\treturn \"CHAR\";\n\telse if (encoding == BTF_INT_BOOL)\n\t\treturn \"BOOL\";\n\telse\n\t\treturn \"UNKN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INT_ENCODING",
          "args": [
            "int_data"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "t"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "746-763",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_int_log(struct btf_verifier_env *env,\n\t\t\tconst struct btf_type *t)\n{\n\tint int_data = btf_type_int(t);\n\n\tbtf_verifier_log(env,\n\t\t\t \"size=%u bits_offset=%u nr_bits=%u encoding=%s\",\n\t\t\t t->size, BTF_INT_OFFSET(int_data),\n\t\t\t BTF_INT_BITS(int_data),\n\t\t\t btf_int_encoding_str(BTF_INT_ENCODING(int_data)));\n}"
  },
  {
    "function_name": "btf_int_check_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "2007-2069",
    "snippet": "static s32 btf_int_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tu32 int_data, nr_bits, meta_needed = sizeof(int_data);\n\tu16 encoding;\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tint_data = btf_type_int(t);\n\tif (int_data & ~BTF_INT_MASK) {\n\t\tbtf_verifier_log_basic(env, t, \"Invalid int_data:%x\",\n\t\t\t\t       int_data);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_bits = BTF_INT_BITS(int_data) + BTF_INT_OFFSET(int_data);\n\n\tif (nr_bits > BITS_PER_U128) {\n\t\tbtf_verifier_log_type(env, t, \"nr_bits exceeds %zu\",\n\t\t\t\t      BITS_PER_U128);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BITS_ROUNDUP_BYTES(nr_bits) > t->size) {\n\t\tbtf_verifier_log_type(env, t, \"nr_bits exceeds type_size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Only one of the encoding bits is allowed and it\n\t * should be sufficient for the pretty print purpose (i.e. decoding).\n\t * Multiple bits can be allowed later if it is found\n\t * to be insufficient.\n\t */\n\tencoding = BTF_INT_ENCODING(int_data);\n\tif (encoding &&\n\t    encoding != BTF_INT_SIGNED &&\n\t    encoding != BTF_INT_CHAR &&\n\t    encoding != BTF_INT_BOOL) {\n\t\tbtf_verifier_log_type(env, t, \"Unsupported encoding\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BTF_INT_MASK 0x0fffffff",
      "#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Unsupported encoding\""
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_ENCODING",
          "args": [
            "int_data"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"nr_bits exceeds type_size\""
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "nr_bits"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"nr_bits exceeds %zu\"",
            "BITS_PER_U128"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1311-1348",
          "snippet": "static void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* btf verifier prints all types it is processing via\n\t * btf_verifier_log_type(..., fmt = NULL).\n\t * Skip those prints for in-kernel BTF verification.\n\t */\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   __btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\n\nstatic void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* btf verifier prints all types it is processing via\n\t * btf_verifier_log_type(..., fmt = NULL).\n\t * Skip those prints for in-kernel BTF verification.\n\t */\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   __btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"Invalid int_data:%x\"",
            "int_data"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "t"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "746-763",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid btf_info kind_flag\""
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "t"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"vlen != 0\""
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_INT_MASK 0x0fffffff\n#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)\n\nstatic s32 btf_int_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tu32 int_data, nr_bits, meta_needed = sizeof(int_data);\n\tu16 encoding;\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tint_data = btf_type_int(t);\n\tif (int_data & ~BTF_INT_MASK) {\n\t\tbtf_verifier_log_basic(env, t, \"Invalid int_data:%x\",\n\t\t\t\t       int_data);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_bits = BTF_INT_BITS(int_data) + BTF_INT_OFFSET(int_data);\n\n\tif (nr_bits > BITS_PER_U128) {\n\t\tbtf_verifier_log_type(env, t, \"nr_bits exceeds %zu\",\n\t\t\t\t      BITS_PER_U128);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BITS_ROUNDUP_BYTES(nr_bits) > t->size) {\n\t\tbtf_verifier_log_type(env, t, \"nr_bits exceeds type_size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Only one of the encoding bits is allowed and it\n\t * should be sufficient for the pretty print purpose (i.e. decoding).\n\t * Multiple bits can be allowed later if it is found\n\t * to be insufficient.\n\t */\n\tencoding = BTF_INT_ENCODING(int_data);\n\tif (encoding &&\n\t    encoding != BTF_INT_SIGNED &&\n\t    encoding != BTF_INT_CHAR &&\n\t    encoding != BTF_INT_BOOL) {\n\t\tbtf_verifier_log_type(env, t, \"Unsupported encoding\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_int_check_kflag_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1951-2005",
    "snippet": "static int btf_int_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t      const struct btf_type *struct_type,\n\t\t\t\t      const struct btf_member *member,\n\t\t\t\t      const struct btf_type *member_type)\n{\n\tu32 struct_bits_off, nr_bits, nr_int_data_bits, bytes_offset;\n\tu32 int_data = btf_type_int(member_type);\n\tu32 struct_size = struct_type->size;\n\tu32 nr_copy_bits;\n\n\t/* a regular int type is required for the kflag int member */\n\tif (!btf_type_int_is_regular(member_type)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member base type\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check sanity of bitfield size */\n\tnr_bits = BTF_MEMBER_BITFIELD_SIZE(member->offset);\n\tstruct_bits_off = BTF_MEMBER_BIT_OFFSET(member->offset);\n\tnr_int_data_bits = BTF_INT_BITS(int_data);\n\tif (!nr_bits) {\n\t\t/* Not a bitfield member, member offset must be at byte\n\t\t * boundary.\n\t\t */\n\t\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\t\"Invalid member offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnr_bits = nr_int_data_bits;\n\t} else if (nr_bits > nr_int_data_bits) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member bitfield_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tnr_copy_bits = nr_bits + BITS_PER_BYTE_MASKED(struct_bits_off);\n\tif (nr_copy_bits > BITS_PER_U128) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"nr_copy_bits exceeds 128\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size < bytes_offset ||\n\t    struct_size - bytes_offset < BITS_ROUNDUP_BYTES(nr_copy_bits)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "nr_copy_bits"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "struct_bits_off"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_MEMBER_BIT_OFFSET",
          "args": [
            "member->offset"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_MEMBER_BITFIELD_SIZE",
          "args": [
            "member->offset"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int_is_regular",
          "args": [
            "member_type"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "746-763",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)\n\nstatic int btf_int_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t      const struct btf_type *struct_type,\n\t\t\t\t      const struct btf_member *member,\n\t\t\t\t      const struct btf_type *member_type)\n{\n\tu32 struct_bits_off, nr_bits, nr_int_data_bits, bytes_offset;\n\tu32 int_data = btf_type_int(member_type);\n\tu32 struct_size = struct_type->size;\n\tu32 nr_copy_bits;\n\n\t/* a regular int type is required for the kflag int member */\n\tif (!btf_type_int_is_regular(member_type)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member base type\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check sanity of bitfield size */\n\tnr_bits = BTF_MEMBER_BITFIELD_SIZE(member->offset);\n\tstruct_bits_off = BTF_MEMBER_BIT_OFFSET(member->offset);\n\tnr_int_data_bits = BTF_INT_BITS(int_data);\n\tif (!nr_bits) {\n\t\t/* Not a bitfield member, member offset must be at byte\n\t\t * boundary.\n\t\t */\n\t\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\t\"Invalid member offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnr_bits = nr_int_data_bits;\n\t} else if (nr_bits > nr_int_data_bits) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member bitfield_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tnr_copy_bits = nr_bits + BITS_PER_BYTE_MASKED(struct_bits_off);\n\tif (nr_copy_bits > BITS_PER_U128) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"nr_copy_bits exceeds 128\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size < bytes_offset ||\n\t    struct_size - bytes_offset < BITS_ROUNDUP_BYTES(nr_copy_bits)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_int_check_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1913-1949",
    "snippet": "static int btf_int_check_member(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *struct_type,\n\t\t\t\tconst struct btf_member *member,\n\t\t\t\tconst struct btf_type *member_type)\n{\n\tu32 int_data = btf_type_int(member_type);\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size = struct_type->size;\n\tu32 nr_copy_bits;\n\tu32 bytes_offset;\n\n\tif (U32_MAX - struct_bits_off < BTF_INT_OFFSET(int_data)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"bits_offset exceeds U32_MAX\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_bits_off += BTF_INT_OFFSET(int_data);\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tnr_copy_bits = BTF_INT_BITS(int_data) +\n\t\tBITS_PER_BYTE_MASKED(struct_bits_off);\n\n\tif (nr_copy_bits > BITS_PER_U128) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"nr_copy_bits exceeds 128\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size < bytes_offset ||\n\t    struct_size - bytes_offset < BITS_ROUNDUP_BYTES(nr_copy_bits)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "nr_copy_bits"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "struct_bits_off"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "member_type"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "746-763",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)\n\nstatic int btf_int_check_member(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *struct_type,\n\t\t\t\tconst struct btf_member *member,\n\t\t\t\tconst struct btf_type *member_type)\n{\n\tu32 int_data = btf_type_int(member_type);\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size = struct_type->size;\n\tu32 nr_copy_bits;\n\tu32 bytes_offset;\n\n\tif (U32_MAX - struct_bits_off < BTF_INT_OFFSET(int_data)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"bits_offset exceeds U32_MAX\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_bits_off += BTF_INT_OFFSET(int_data);\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tnr_copy_bits = BTF_INT_BITS(int_data) +\n\t\tBITS_PER_BYTE_MASKED(struct_bits_off);\n\n\tif (nr_copy_bits > BITS_PER_U128) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"nr_copy_bits exceeds 128\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size < bytes_offset ||\n\t    struct_size - bytes_offset < BITS_ROUNDUP_BYTES(nr_copy_bits)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_df_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1906-1911",
    "snippet": "static void btf_df_show(const struct btf *btf, const struct btf_type *t,\n\t\t\tu32 type_id, void *data, u8 bits_offsets,\n\t\t\tstruct btf_show *show)\n{\n\tbtf_show(show, \"<unsupported kind:%u>\", BTF_INFO_KIND(t->info));\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show",
          "args": [
            "show",
            "\"<unsupported kind:%u>\"",
            "BTF_INFO_KIND(t->info)"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1020-1029",
          "snippet": "static void btf_show(struct btf_show *show, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!show->state.depth_check) {\n\t\tva_start(args, fmt);\n\t\tshow->showfn(show, fmt, args);\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show(struct btf_show *show, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!show->state.depth_check) {\n\t\tva_start(args, fmt);\n\t\tshow->showfn(show, fmt, args);\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_df_show(const struct btf *btf, const struct btf_type *t,\n\t\t\tu32 type_id, void *data, u8 bits_offsets,\n\t\t\tstruct btf_show *show)\n{\n\tbtf_show(show, \"<unsupported kind:%u>\", BTF_INFO_KIND(t->info));\n}"
  },
  {
    "function_name": "btf_df_resolve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1899-1904",
    "snippet": "static int btf_df_resolve(struct btf_verifier_env *env,\n\t\t\t  const struct resolve_vertex *v)\n{\n\tbtf_verifier_log_basic(env, v->t, \"Unsupported resolve\");\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "v->t",
            "\"Unsupported resolve\""
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_df_resolve(struct btf_verifier_env *env,\n\t\t\t  const struct resolve_vertex *v)\n{\n\tbtf_verifier_log_basic(env, v->t, \"Unsupported resolve\");\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "btf_generic_check_kflag_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1880-1897",
    "snippet": "static int btf_generic_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t\t  const struct btf_type *struct_type,\n\t\t\t\t\t  const struct btf_member *member,\n\t\t\t\t\t  const struct btf_type *member_type)\n{\n\tif (BTF_MEMBER_BITFIELD_SIZE(member->offset)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member bitfield_size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* bitfield size is 0, so member->offset represents bit offset only.\n\t * It is safe to call non kflag check_member variants.\n\t */\n\treturn btf_type_ops(member_type)->check_member(env, struct_type,\n\t\t\t\t\t\t       member,\n\t\t\t\t\t\t       member_type);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "struct_type",
            "member",
            "member_type"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "member_type"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Invalid member bitfield_size\""
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1356-1399",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_MEMBER_BITFIELD_SIZE",
          "args": [
            "member->offset"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_generic_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t\t  const struct btf_type *struct_type,\n\t\t\t\t\t  const struct btf_member *member,\n\t\t\t\t\t  const struct btf_type *member_type)\n{\n\tif (BTF_MEMBER_BITFIELD_SIZE(member->offset)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member bitfield_size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* bitfield size is 0, so member->offset represents bit offset only.\n\t * It is safe to call non kflag check_member variants.\n\t */\n\treturn btf_type_ops(member_type)->check_member(env, struct_type,\n\t\t\t\t\t\t       member,\n\t\t\t\t\t\t       member_type);\n}"
  },
  {
    "function_name": "btf_df_check_kflag_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1867-1875",
    "snippet": "static int btf_df_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *struct_type,\n\t\t\t\t     const struct btf_member *member,\n\t\t\t\t     const struct btf_type *member_type)\n{\n\tbtf_verifier_log_basic(env, struct_type,\n\t\t\t       \"Unsupported check_kflag_member\");\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "struct_type",
            "\"Unsupported check_kflag_member\""
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_df_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *struct_type,\n\t\t\t\t     const struct btf_member *member,\n\t\t\t\t     const struct btf_type *member_type)\n{\n\tbtf_verifier_log_basic(env, struct_type,\n\t\t\t       \"Unsupported check_kflag_member\");\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "btf_df_check_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1857-1865",
    "snippet": "static int btf_df_check_member(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *struct_type,\n\t\t\t       const struct btf_member *member,\n\t\t\t       const struct btf_type *member_type)\n{\n\tbtf_verifier_log_basic(env, struct_type,\n\t\t\t       \"Unsupported check_member\");\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "struct_type",
            "\"Unsupported check_member\""
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_df_check_member(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *struct_type,\n\t\t\t       const struct btf_member *member,\n\t\t\t       const struct btf_type *member_type)\n{\n\tbtf_verifier_log_basic(env, struct_type,\n\t\t\t       \"Unsupported check_member\");\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "btf_type_id_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1814-1855",
    "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "size_type"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_resolved_type_size",
          "args": [
            "btf",
            "size_type_id"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolved_type_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1806-1812",
          "snippet": "static u32 btf_resolved_type_size(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_sizes[type_id - btf->start_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic u32 btf_resolved_type_size(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_sizes[type_id - btf->start_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "size_type"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "456-459",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_has_size",
          "args": [
            "size_type"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_has_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "587-600",
          "snippet": "static bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_DATASEC:\n\tcase BTF_KIND_FLOAT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_DATASEC:\n\tcase BTF_KIND_FLOAT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_nosize_or_null",
          "args": [
            "size_type"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_nosize_or_null",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "446-449",
          "snippet": "static bool btf_type_nosize_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_nosize(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_nosize_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_nosize(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "size_type_id"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_resolved_type_id",
          "args": [
            "btf",
            "size_type_id"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolved_type_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1790-1796",
          "snippet": "static u32 btf_resolved_type_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_ids[type_id - btf->start_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic u32 btf_resolved_type_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_ids[type_id - btf->start_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_var",
          "args": [
            "size_type"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "size_type"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "size_type"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
  },
  {
    "function_name": "btf_resolved_type_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1806-1812",
    "snippet": "static u32 btf_resolved_type_size(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_sizes[type_id - btf->start_id];\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic u32 btf_resolved_type_size(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_sizes[type_id - btf->start_id];\n}"
  },
  {
    "function_name": "btf_type_id_resolve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1799-1804",
    "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "*type_id"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_resolved_type_id",
          "args": [
            "btf",
            "*type_id"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolved_type_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1790-1796",
          "snippet": "static u32 btf_resolved_type_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_ids[type_id - btf->start_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic u32 btf_resolved_type_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_ids[type_id - btf->start_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}"
  },
  {
    "function_name": "btf_resolved_type_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1790-1796",
    "snippet": "static u32 btf_resolved_type_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_ids[type_id - btf->start_id];\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic u32 btf_resolved_type_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_ids[type_id - btf->start_id];\n}"
  },
  {
    "function_name": "btf_resolve_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1783-1788",
    "snippet": "const struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_resolve_size",
          "args": [
            "btf",
            "type",
            "type_size",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_resolve_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1714-1781",
          "snippet": "static const struct btf_type *\n__btf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t   u32 *type_size, const struct btf_type **elem_type,\n\t\t   u32 *elem_id, u32 *total_nelems, u32 *type_id)\n{\n\tconst struct btf_type *array_type = NULL;\n\tconst struct btf_array *array = NULL;\n\tu32 i, size, nelems = 1, id = 0;\n\n\tfor (i = 0; i < MAX_RESOLVE_DEPTH; i++) {\n\t\tswitch (BTF_INFO_KIND(type->info)) {\n\t\t/* type->size can be used */\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\tcase BTF_KIND_ENUM:\n\t\tcase BTF_KIND_FLOAT:\n\t\t\tsize = type->size;\n\t\t\tgoto resolved;\n\n\t\tcase BTF_KIND_PTR:\n\t\t\tsize = sizeof(void *);\n\t\t\tgoto resolved;\n\n\t\t/* Modifiers */\n\t\tcase BTF_KIND_TYPEDEF:\n\t\tcase BTF_KIND_VOLATILE:\n\t\tcase BTF_KIND_CONST:\n\t\tcase BTF_KIND_RESTRICT:\n\t\tcase BTF_KIND_TYPE_TAG:\n\t\t\tid = type->type;\n\t\t\ttype = btf_type_by_id(btf, type->type);\n\t\t\tbreak;\n\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tif (!array_type)\n\t\t\t\tarray_type = type;\n\t\t\tarray = btf_type_array(type);\n\t\t\tif (nelems && array->nelems > U32_MAX / nelems)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\tnelems *= array->nelems;\n\t\t\ttype = btf_type_by_id(btf, array->type);\n\t\t\tbreak;\n\n\t\t/* type without size */\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n\nresolved:\n\tif (nelems && size > U32_MAX / nelems)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*type_size = nelems * size;\n\tif (total_nelems)\n\t\t*total_nelems = nelems;\n\tif (elem_type)\n\t\t*elem_type = type;\n\tif (elem_id)\n\t\t*elem_id = array ? array->type : 0;\n\tif (type_id && id)\n\t\t*type_id = id;\n\n\treturn array_type ? : type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const struct btf_type *\n__btf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t   u32 *type_size, const struct btf_type **elem_type,\n\t\t   u32 *elem_id, u32 *total_nelems, u32 *type_id)\n{\n\tconst struct btf_type *array_type = NULL;\n\tconst struct btf_array *array = NULL;\n\tu32 i, size, nelems = 1, id = 0;\n\n\tfor (i = 0; i < MAX_RESOLVE_DEPTH; i++) {\n\t\tswitch (BTF_INFO_KIND(type->info)) {\n\t\t/* type->size can be used */\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\tcase BTF_KIND_ENUM:\n\t\tcase BTF_KIND_FLOAT:\n\t\t\tsize = type->size;\n\t\t\tgoto resolved;\n\n\t\tcase BTF_KIND_PTR:\n\t\t\tsize = sizeof(void *);\n\t\t\tgoto resolved;\n\n\t\t/* Modifiers */\n\t\tcase BTF_KIND_TYPEDEF:\n\t\tcase BTF_KIND_VOLATILE:\n\t\tcase BTF_KIND_CONST:\n\t\tcase BTF_KIND_RESTRICT:\n\t\tcase BTF_KIND_TYPE_TAG:\n\t\t\tid = type->type;\n\t\t\ttype = btf_type_by_id(btf, type->type);\n\t\t\tbreak;\n\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tif (!array_type)\n\t\t\t\tarray_type = type;\n\t\t\tarray = btf_type_array(type);\n\t\t\tif (nelems && array->nelems > U32_MAX / nelems)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\tnelems *= array->nelems;\n\t\t\ttype = btf_type_by_id(btf, array->type);\n\t\t\tbreak;\n\n\t\t/* type without size */\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n\nresolved:\n\tif (nelems && size > U32_MAX / nelems)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*type_size = nelems * size;\n\tif (total_nelems)\n\t\t*total_nelems = nelems;\n\tif (elem_type)\n\t\t*elem_type = type;\n\tif (elem_id)\n\t\t*elem_id = array ? array->type : 0;\n\tif (type_id && id)\n\t\t*type_id = id;\n\n\treturn array_type ? : type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}"
  },
  {
    "function_name": "__btf_resolve_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1714-1781",
    "snippet": "static const struct btf_type *\n__btf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t   u32 *type_size, const struct btf_type **elem_type,\n\t\t   u32 *elem_id, u32 *total_nelems, u32 *type_id)\n{\n\tconst struct btf_type *array_type = NULL;\n\tconst struct btf_array *array = NULL;\n\tu32 i, size, nelems = 1, id = 0;\n\n\tfor (i = 0; i < MAX_RESOLVE_DEPTH; i++) {\n\t\tswitch (BTF_INFO_KIND(type->info)) {\n\t\t/* type->size can be used */\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\tcase BTF_KIND_ENUM:\n\t\tcase BTF_KIND_FLOAT:\n\t\t\tsize = type->size;\n\t\t\tgoto resolved;\n\n\t\tcase BTF_KIND_PTR:\n\t\t\tsize = sizeof(void *);\n\t\t\tgoto resolved;\n\n\t\t/* Modifiers */\n\t\tcase BTF_KIND_TYPEDEF:\n\t\tcase BTF_KIND_VOLATILE:\n\t\tcase BTF_KIND_CONST:\n\t\tcase BTF_KIND_RESTRICT:\n\t\tcase BTF_KIND_TYPE_TAG:\n\t\t\tid = type->type;\n\t\t\ttype = btf_type_by_id(btf, type->type);\n\t\t\tbreak;\n\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tif (!array_type)\n\t\t\t\tarray_type = type;\n\t\t\tarray = btf_type_array(type);\n\t\t\tif (nelems && array->nelems > U32_MAX / nelems)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\tnelems *= array->nelems;\n\t\t\ttype = btf_type_by_id(btf, array->type);\n\t\t\tbreak;\n\n\t\t/* type without size */\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n\nresolved:\n\tif (nelems && size > U32_MAX / nelems)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*type_size = nelems * size;\n\tif (total_nelems)\n\t\t*total_nelems = nelems;\n\tif (elem_type)\n\t\t*elem_type = type;\n\tif (elem_id)\n\t\t*elem_id = array ? array->type : 0;\n\tif (type_id && id)\n\t\t*type_id = id;\n\n\treturn array_type ? : type;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define MAX_RESOLVE_DEPTH 32"
    ],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "array->type"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "type"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "621-624",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "type->info"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const struct btf_type *\n__btf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t   u32 *type_size, const struct btf_type **elem_type,\n\t\t   u32 *elem_id, u32 *total_nelems, u32 *type_id)\n{\n\tconst struct btf_type *array_type = NULL;\n\tconst struct btf_array *array = NULL;\n\tu32 i, size, nelems = 1, id = 0;\n\n\tfor (i = 0; i < MAX_RESOLVE_DEPTH; i++) {\n\t\tswitch (BTF_INFO_KIND(type->info)) {\n\t\t/* type->size can be used */\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\tcase BTF_KIND_ENUM:\n\t\tcase BTF_KIND_FLOAT:\n\t\t\tsize = type->size;\n\t\t\tgoto resolved;\n\n\t\tcase BTF_KIND_PTR:\n\t\t\tsize = sizeof(void *);\n\t\t\tgoto resolved;\n\n\t\t/* Modifiers */\n\t\tcase BTF_KIND_TYPEDEF:\n\t\tcase BTF_KIND_VOLATILE:\n\t\tcase BTF_KIND_CONST:\n\t\tcase BTF_KIND_RESTRICT:\n\t\tcase BTF_KIND_TYPE_TAG:\n\t\t\tid = type->type;\n\t\t\ttype = btf_type_by_id(btf, type->type);\n\t\t\tbreak;\n\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tif (!array_type)\n\t\t\t\tarray_type = type;\n\t\t\tarray = btf_type_array(type);\n\t\t\tif (nelems && array->nelems > U32_MAX / nelems)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\tnelems *= array->nelems;\n\t\t\ttype = btf_type_by_id(btf, array->type);\n\t\t\tbreak;\n\n\t\t/* type without size */\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n\nresolved:\n\tif (nelems && size > U32_MAX / nelems)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*type_size = nelems * size;\n\tif (total_nelems)\n\t\t*total_nelems = nelems;\n\tif (elem_type)\n\t\t*elem_type = type;\n\tif (elem_id)\n\t\t*elem_id = array ? array->type : 0;\n\tif (type_id && id)\n\t\t*type_id = id;\n\n\treturn array_type ? : type;\n}"
  },
  {
    "function_name": "env_stack_peak",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1689-1692",
    "snippet": "static const struct resolve_vertex *env_stack_peak(struct btf_verifier_env *env)\n{\n\treturn env->top_stack ? &env->stack[env->top_stack - 1] : NULL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct resolve_vertex *env_stack_peak(struct btf_verifier_env *env)\n{\n\treturn env->top_stack ? &env->stack[env->top_stack - 1] : NULL;\n}"
  },
  {
    "function_name": "env_stack_pop_resolved",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1676-1687",
    "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
  },
  {
    "function_name": "env_stack_set_next_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1670-1674",
    "snippet": "static void env_stack_set_next_member(struct btf_verifier_env *env,\n\t\t\t\t      u16 next_member)\n{\n\tenv->stack[env->top_stack - 1].next_member = next_member;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void env_stack_set_next_member(struct btf_verifier_env *env,\n\t\t\t\t      u16 next_member)\n{\n\tenv->stack[env->top_stack - 1].next_member = next_member;\n}"
  },
  {
    "function_name": "env_stack_push",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1640-1668",
    "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define MAX_RESOLVE_DEPTH 32"
    ],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "t"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "456-459",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "t"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "env_type_is_resolved",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1630-1638",
    "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}"
  },
  {
    "function_name": "env_type_is_resolve_sink",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1605-1628",
    "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "next_type"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "next_type"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "456-459",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "next_type"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "next_type"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_needs_resolve",
          "args": [
            "next_type"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_needs_resolve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "575-584",
          "snippet": "static bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t       btf_type_is_ptr(t) ||\n\t       btf_type_is_struct(t) ||\n\t       btf_type_is_array(t) ||\n\t       btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t       btf_type_is_ptr(t) ||\n\t       btf_type_is_struct(t) ||\n\t       btf_type_is_array(t) ||\n\t       btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "btf_verifier_env_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1599-1603",
    "snippet": "static void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "env"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "env->visit_states"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}"
  },
  {
    "function_name": "env_resolve_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1563-1597",
    "snippet": "static int env_resolve_init(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 nr_types = btf->nr_types;\n\tu32 *resolved_sizes = NULL;\n\tu32 *resolved_ids = NULL;\n\tu8 *visit_states = NULL;\n\n\tresolved_sizes = kvcalloc(nr_types, sizeof(*resolved_sizes),\n\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_sizes)\n\t\tgoto nomem;\n\n\tresolved_ids = kvcalloc(nr_types, sizeof(*resolved_ids),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_ids)\n\t\tgoto nomem;\n\n\tvisit_states = kvcalloc(nr_types, sizeof(*visit_states),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!visit_states)\n\t\tgoto nomem;\n\n\tbtf->resolved_sizes = resolved_sizes;\n\tbtf->resolved_ids = resolved_ids;\n\tenv->visit_states = visit_states;\n\n\treturn 0;\n\nnomem:\n\tkvfree(resolved_sizes);\n\tkvfree(resolved_ids);\n\tkvfree(visit_states);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "visit_states"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "resolved_ids"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "resolved_sizes"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "nr_types",
            "sizeof(*visit_states)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "nr_types",
            "sizeof(*resolved_ids)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "nr_types",
            "sizeof(*resolved_sizes)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int env_resolve_init(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 nr_types = btf->nr_types;\n\tu32 *resolved_sizes = NULL;\n\tu32 *resolved_ids = NULL;\n\tu8 *visit_states = NULL;\n\n\tresolved_sizes = kvcalloc(nr_types, sizeof(*resolved_sizes),\n\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_sizes)\n\t\tgoto nomem;\n\n\tresolved_ids = kvcalloc(nr_types, sizeof(*resolved_ids),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_ids)\n\t\tgoto nomem;\n\n\tvisit_states = kvcalloc(nr_types, sizeof(*visit_states),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!visit_states)\n\t\tgoto nomem;\n\n\tbtf->resolved_sizes = resolved_sizes;\n\tbtf->resolved_ids = resolved_ids;\n\tenv->visit_states = visit_states;\n\n\treturn 0;\n\nnomem:\n\tkvfree(resolved_sizes);\n\tkvfree(resolved_ids);\n\tkvfree(visit_states);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "btf_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1555-1561",
    "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&btf->rcu",
            "btf_free_rcu"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_free_id",
          "args": [
            "btf"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "btf_free_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1516-1532",
          "snippet": "static void btf_free_id(struct btf *btf)\n{\n\tunsigned long flags;\n\n\t/*\n\t * In map-in-map, calling map_delete_elem() on outer\n\t * map will call bpf_map_put on the inner map.\n\t * It will then eventually call btf_free_id()\n\t * on the inner map.  Some of the map_delete_elem()\n\t * implementation may have irq disabled, so\n\t * we need to use the _irqsave() version instead\n\t * of the _bh() version.\n\t */\n\tspin_lock_irqsave(&btf_idr_lock, flags);\n\tidr_remove(&btf_idr, btf->id);\n\tspin_unlock_irqrestore(&btf_idr_lock, flags);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_free_id(struct btf *btf)\n{\n\tunsigned long flags;\n\n\t/*\n\t * In map-in-map, calling map_delete_elem() on outer\n\t * map will call bpf_map_put on the inner map.\n\t * It will then eventually call btf_free_id()\n\t * on the inner map.  Some of the map_delete_elem()\n\t * implementation may have irq disabled, so\n\t * we need to use the _irqsave() version instead\n\t * of the _bh() version.\n\t */\n\tspin_lock_irqsave(&btf_idr_lock, flags);\n\tidr_remove(&btf_idr, btf->id);\n\tspin_unlock_irqrestore(&btf_idr_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&btf->refcnt"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
  },
  {
    "function_name": "btf_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1550-1553",
    "snippet": "void btf_get(struct btf *btf)\n{\n\trefcount_inc(&btf->refcnt);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&btf->refcnt"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_get(struct btf *btf)\n{\n\trefcount_inc(&btf->refcnt);\n}"
  },
  {
    "function_name": "btf_free_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1543-1548",
    "snippet": "static void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_free",
          "args": [
            "btf"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "btf_free_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1543-1548",
          "snippet": "static void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbtf",
            "rcu"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}"
  },
  {
    "function_name": "btf_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1534-1541",
    "snippet": "static void btf_free(struct btf *btf)\n{\n\tkvfree(btf->types);\n\tkvfree(btf->resolved_sizes);\n\tkvfree(btf->resolved_ids);\n\tkvfree(btf->data);\n\tkfree(btf);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "btf"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->data"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->resolved_ids"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->resolved_sizes"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->types"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_free(struct btf *btf)\n{\n\tkvfree(btf->types);\n\tkvfree(btf->resolved_sizes);\n\tkvfree(btf->resolved_ids);\n\tkvfree(btf->data);\n\tkfree(btf);\n}"
  },
  {
    "function_name": "btf_free_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1516-1532",
    "snippet": "static void btf_free_id(struct btf *btf)\n{\n\tunsigned long flags;\n\n\t/*\n\t * In map-in-map, calling map_delete_elem() on outer\n\t * map will call bpf_map_put on the inner map.\n\t * It will then eventually call btf_free_id()\n\t * on the inner map.  Some of the map_delete_elem()\n\t * implementation may have irq disabled, so\n\t * we need to use the _irqsave() version instead\n\t * of the _bh() version.\n\t */\n\tspin_lock_irqsave(&btf_idr_lock, flags);\n\tidr_remove(&btf_idr, btf->id);\n\tspin_unlock_irqrestore(&btf_idr_lock, flags);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&btf_idr_lock",
            "flags"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&btf_idr",
            "btf->id"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "342-347",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&btf_idr_lock",
            "flags"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_free_id(struct btf *btf)\n{\n\tunsigned long flags;\n\n\t/*\n\t * In map-in-map, calling map_delete_elem() on outer\n\t * map will call bpf_map_put on the inner map.\n\t * It will then eventually call btf_free_id()\n\t * on the inner map.  Some of the map_delete_elem()\n\t * implementation may have irq disabled, so\n\t * we need to use the _irqsave() version instead\n\t * of the _bh() version.\n\t */\n\tspin_lock_irqsave(&btf_idr_lock, flags);\n\tidr_remove(&btf_idr, btf->id);\n\tspin_unlock_irqrestore(&btf_idr_lock, flags);\n}"
  },
  {
    "function_name": "btf_alloc_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1498-1514",
    "snippet": "static int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!id"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&btf_idr_lock"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&btf_idr",
            "btf",
            "1",
            "INT_MAX",
            "GFP_ATOMIC"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&btf_idr_lock"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
  },
  {
    "function_name": "btf_add_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1453-1496",
    "snippet": "static int btf_add_type(struct btf_verifier_env *env, struct btf_type *t)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (btf->types_size == btf->nr_types) {\n\t\t/* Expand 'types' array */\n\n\t\tstruct btf_type **new_types;\n\t\tu32 expand_by, new_size;\n\n\t\tif (btf->start_id + btf->types_size == BTF_MAX_TYPE) {\n\t\t\tbtf_verifier_log(env, \"Exceeded max num of types\");\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\texpand_by = max_t(u32, btf->types_size >> 2, 16);\n\t\tnew_size = min_t(u32, BTF_MAX_TYPE,\n\t\t\t\t btf->types_size + expand_by);\n\n\t\tnew_types = kvcalloc(new_size, sizeof(*new_types),\n\t\t\t\t     GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!new_types)\n\t\t\treturn -ENOMEM;\n\n\t\tif (btf->nr_types == 0) {\n\t\t\tif (!btf->base_btf) {\n\t\t\t\t/* lazily init VOID type */\n\t\t\t\tnew_types[0] = &btf_void;\n\t\t\t\tbtf->nr_types++;\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(new_types, btf->types,\n\t\t\t       sizeof(*btf->types) * btf->nr_types);\n\t\t}\n\n\t\tkvfree(btf->types);\n\t\tbtf->types = new_types;\n\t\tbtf->types_size = new_size;\n\t}\n\n\tbtf->types[btf->nr_types++] = t;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct btf_type btf_void;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->types"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_types",
            "btf->types",
            "sizeof(*btf->types) * btf->nr_types"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "new_size",
            "sizeof(*new_types)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "BTF_MAX_TYPE",
            "btf->types_size + expand_by"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u32",
            "btf->types_size >> 2",
            "16"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1831-1865",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"Exceeded max num of types\""
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_hdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1429-1451",
          "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nstatic int btf_add_type(struct btf_verifier_env *env, struct btf_type *t)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (btf->types_size == btf->nr_types) {\n\t\t/* Expand 'types' array */\n\n\t\tstruct btf_type **new_types;\n\t\tu32 expand_by, new_size;\n\n\t\tif (btf->start_id + btf->types_size == BTF_MAX_TYPE) {\n\t\t\tbtf_verifier_log(env, \"Exceeded max num of types\");\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\texpand_by = max_t(u32, btf->types_size >> 2, 16);\n\t\tnew_size = min_t(u32, BTF_MAX_TYPE,\n\t\t\t\t btf->types_size + expand_by);\n\n\t\tnew_types = kvcalloc(new_size, sizeof(*new_types),\n\t\t\t\t     GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!new_types)\n\t\t\treturn -ENOMEM;\n\n\t\tif (btf->nr_types == 0) {\n\t\t\tif (!btf->base_btf) {\n\t\t\t\t/* lazily init VOID type */\n\t\t\t\tnew_types[0] = &btf_void;\n\t\t\t\tbtf->nr_types++;\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(new_types, btf->types,\n\t\t\t       sizeof(*btf->types) * btf->nr_types);\n\t\t}\n\n\t\tkvfree(btf->types);\n\t\tbtf->types = new_types;\n\t\tbtf->types_size = new_size;\n\t}\n\n\tbtf->types[btf->nr_types++] = t;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_verifier_log_hdr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1429-1451",
    "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_verifier_log",
          "args": [
            "log",
            "\"btf_total_size: %u\\n\"",
            "btf_data_size"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1287-1295",
          "snippet": "static void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_needed",
          "args": [
            "log"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
  },
  {
    "function_name": "btf_verifier_log_vsi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1402-1427",
    "snippet": "static void btf_verifier_log_vsi(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *datasec_type,\n\t\t\t\t const struct btf_var_secinfo *vsi,\n\t\t\t\t const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, datasec_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t type_id=%u offset=%u size=%u\",\n\t\t\t   vsi->type, vsi->offset, vsi->size);\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_verifier_log",
          "args": [
            "log",
            "\"\\n\""
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1287-1295",
          "snippet": "static void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_vlog",
          "args": [
            "log",
            "fmt",
            "args"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_verifier_vlog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "287-310",
          "snippet": "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';\n\n\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");\n\t\treturn;\n\t}\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';\n\n\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");\n\t\treturn;\n\t}\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "datasec_type",
            "NULL"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_needed",
          "args": [
            "log"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_vsi(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *datasec_type,\n\t\t\t\t const struct btf_var_secinfo *vsi,\n\t\t\t\t const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, datasec_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t type_id=%u offset=%u size=%u\",\n\t\t\t   vsi->type, vsi->offset, vsi->size);\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
  },
  {
    "function_name": "btf_verifier_log_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1356-1399",
    "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_verifier_log",
          "args": [
            "log",
            "\"\\n\""
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1287-1295",
          "snippet": "static void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_vlog",
          "args": [
            "log",
            "fmt",
            "args"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_verifier_vlog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "287-310",
          "snippet": "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';\n\n\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");\n\t\treturn;\n\t}\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';\n\n\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");\n\t\treturn;\n\t}\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btf_name_by_offset",
          "args": [
            "btf",
            "member->name_off"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "715-724",
          "snippet": "static const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_MEMBER_BIT_OFFSET",
          "args": [
            "member->offset"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_MEMBER_BITFIELD_SIZE",
          "args": [
            "member->offset"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "struct_type"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "struct_type",
            "NULL"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_needed",
          "args": [
            "log"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
  },
  {
    "function_name": "__btf_verifier_log_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1311-1348",
    "snippet": "static void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* btf verifier prints all types it is processing via\n\t * btf_verifier_log_type(..., fmt = NULL).\n\t * Skip those prints for in-kernel BTF verification.\n\t */\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   __btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_verifier_log",
          "args": [
            "log",
            "\"\\n\""
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1287-1295",
          "snippet": "static void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_vlog",
          "args": [
            "log",
            "fmt",
            "args"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_verifier_vlog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "287-310",
          "snippet": "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';\n\n\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");\n\t\treturn;\n\t}\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';\n\n\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");\n\t\treturn;\n\t}\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "t"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "t"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "641-644",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_name_by_offset",
          "args": [
            "btf",
            "t->name_off"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "715-724",
          "snippet": "static const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_needed",
          "args": [
            "log"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\n\nstatic void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* btf verifier prints all types it is processing via\n\t * btf_verifier_log_type(..., fmt = NULL).\n\t * Skip those prints for in-kernel BTF verification.\n\t */\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   __btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
  },
  {
    "function_name": "btf_verifier_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1297-1309",
    "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_vlog",
          "args": [
            "log",
            "fmt",
            "args"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_verifier_vlog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "287-310",
          "snippet": "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';\n\n\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");\n\t\treturn;\n\t}\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';\n\n\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");\n\t\treturn;\n\t}\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_needed",
          "args": [
            "log"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
  },
  {
    "function_name": "__btf_verifier_log",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1287-1295",
    "snippet": "static void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_vlog",
          "args": [
            "log",
            "fmt",
            "args"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_verifier_vlog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "287-310",
          "snippet": "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';\n\n\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");\n\t\treturn;\n\t}\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';\n\n\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");\n\t\treturn;\n\t}\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
  },
  {
    "function_name": "btf_show_end_struct_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1282-1285",
    "snippet": "static void btf_show_end_struct_type(struct btf_show *show)\n{\n\tbtf_show_end_aggr_type(show, \"}\");\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_end_aggr_type",
          "args": [
            "show",
            "\"}\""
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_aggr_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1224-1231",
          "snippet": "static void btf_show_end_aggr_type(struct btf_show *show,\n\t\t\t\t   const char *suffix)\n{\n\tshow->state.depth--;\n\tbtf_show(show, \"%s%s%s%s\", btf_show_indent(show), suffix,\n\t\t btf_show_delim(show), btf_show_newline(show));\n\tbtf_show_end_type(show);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_aggr_type(struct btf_show *show,\n\t\t\t\t   const char *suffix)\n{\n\tshow->state.depth--;\n\tbtf_show(show, \"%s%s%s%s\", btf_show_indent(show), suffix,\n\t\t btf_show_delim(show), btf_show_newline(show));\n\tbtf_show_end_type(show);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_struct_type(struct btf_show *show)\n{\n\tbtf_show_end_aggr_type(show, \"}\");\n}"
  },
  {
    "function_name": "btf_show_start_struct_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1274-1280",
    "snippet": "static void *btf_show_start_struct_type(struct btf_show *show,\n\t\t\t\t\tconst struct btf_type *t,\n\t\t\t\t\tu32 type_id,\n\t\t\t\t\tvoid *data)\n{\n\treturn btf_show_start_aggr_type(show, t, type_id, data);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_start_aggr_type",
          "args": [
            "show",
            "t",
            "type_id",
            "data"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_aggr_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1208-1222",
          "snippet": "static void *btf_show_start_aggr_type(struct btf_show *show,\n\t\t\t\t      const struct btf_type *t,\n\t\t\t\t      u32 type_id, void *data)\n{\n\tvoid *safe_data = btf_show_start_type(show, t, type_id, data);\n\n\tif (!safe_data)\n\t\treturn safe_data;\n\n\tbtf_show(show, \"%s%s%s\", btf_show_indent(show),\n\t\t btf_show_name(show),\n\t\t btf_show_newline(show));\n\tshow->state.depth++;\n\treturn safe_data;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_aggr_type(struct btf_show *show,\n\t\t\t\t      const struct btf_type *t,\n\t\t\t\t      u32 type_id, void *data)\n{\n\tvoid *safe_data = btf_show_start_type(show, t, type_id, data);\n\n\tif (!safe_data)\n\t\treturn safe_data;\n\n\tbtf_show(show, \"%s%s%s\", btf_show_indent(show),\n\t\t btf_show_name(show),\n\t\t btf_show_newline(show));\n\tshow->state.depth++;\n\treturn safe_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_struct_type(struct btf_show *show,\n\t\t\t\t\tconst struct btf_type *t,\n\t\t\t\t\tu32 type_id,\n\t\t\t\t\tvoid *data)\n{\n\treturn btf_show_start_aggr_type(show, t, type_id, data);\n}"
  },
  {
    "function_name": "btf_show_end_array_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1267-1272",
    "snippet": "static void btf_show_end_array_type(struct btf_show *show)\n{\n\tshow->state.array_encoding = 0;\n\tshow->state.array_terminated = 0;\n\tbtf_show_end_aggr_type(show, \"]\");\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_end_aggr_type",
          "args": [
            "show",
            "\"]\""
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_aggr_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1224-1231",
          "snippet": "static void btf_show_end_aggr_type(struct btf_show *show,\n\t\t\t\t   const char *suffix)\n{\n\tshow->state.depth--;\n\tbtf_show(show, \"%s%s%s%s\", btf_show_indent(show), suffix,\n\t\t btf_show_delim(show), btf_show_newline(show));\n\tbtf_show_end_type(show);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_aggr_type(struct btf_show *show,\n\t\t\t\t   const char *suffix)\n{\n\tshow->state.depth--;\n\tbtf_show(show, \"%s%s%s%s\", btf_show_indent(show), suffix,\n\t\t btf_show_delim(show), btf_show_newline(show));\n\tbtf_show_end_type(show);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_array_type(struct btf_show *show)\n{\n\tshow->state.array_encoding = 0;\n\tshow->state.array_terminated = 0;\n\tbtf_show_end_aggr_type(show, \"]\");\n}"
  },
  {
    "function_name": "btf_show_start_array_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1256-1265",
    "snippet": "static void *btf_show_start_array_type(struct btf_show *show,\n\t\t\t\t       const struct btf_type *t,\n\t\t\t\t       u32 type_id,\n\t\t\t\t       u16 array_encoding,\n\t\t\t\t       void *data)\n{\n\tshow->state.array_encoding = array_encoding;\n\tshow->state.array_terminated = 0;\n\treturn btf_show_start_aggr_type(show, t, type_id, data);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_start_aggr_type",
          "args": [
            "show",
            "t",
            "type_id",
            "data"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_aggr_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1208-1222",
          "snippet": "static void *btf_show_start_aggr_type(struct btf_show *show,\n\t\t\t\t      const struct btf_type *t,\n\t\t\t\t      u32 type_id, void *data)\n{\n\tvoid *safe_data = btf_show_start_type(show, t, type_id, data);\n\n\tif (!safe_data)\n\t\treturn safe_data;\n\n\tbtf_show(show, \"%s%s%s\", btf_show_indent(show),\n\t\t btf_show_name(show),\n\t\t btf_show_newline(show));\n\tshow->state.depth++;\n\treturn safe_data;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_aggr_type(struct btf_show *show,\n\t\t\t\t      const struct btf_type *t,\n\t\t\t\t      u32 type_id, void *data)\n{\n\tvoid *safe_data = btf_show_start_type(show, t, type_id, data);\n\n\tif (!safe_data)\n\t\treturn safe_data;\n\n\tbtf_show(show, \"%s%s%s\", btf_show_indent(show),\n\t\t btf_show_name(show),\n\t\t btf_show_newline(show));\n\tshow->state.depth++;\n\treturn safe_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_array_type(struct btf_show *show,\n\t\t\t\t       const struct btf_type *t,\n\t\t\t\t       u32 type_id,\n\t\t\t\t       u16 array_encoding,\n\t\t\t\t       void *data)\n{\n\tshow->state.array_encoding = array_encoding;\n\tshow->state.array_terminated = 0;\n\treturn btf_show_start_aggr_type(show, t, type_id, data);\n}"
  },
  {
    "function_name": "btf_show_end_array_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1250-1254",
    "snippet": "static void btf_show_end_array_member(struct btf_show *show)\n{\n\tshow->state.array_member = 0;\n\tbtf_show_end_member(show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_end_member",
          "args": [
            "show"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1245-1248",
          "snippet": "static void btf_show_end_member(struct btf_show *show)\n{\n\tshow->state.member = NULL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_member(struct btf_show *show)\n{\n\tshow->state.member = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_array_member(struct btf_show *show)\n{\n\tshow->state.array_member = 0;\n\tbtf_show_end_member(show);\n}"
  },
  {
    "function_name": "btf_show_end_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1245-1248",
    "snippet": "static void btf_show_end_member(struct btf_show *show)\n{\n\tshow->state.member = NULL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_member(struct btf_show *show)\n{\n\tshow->state.member = NULL;\n}"
  },
  {
    "function_name": "btf_show_start_array_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1239-1243",
    "snippet": "static void btf_show_start_array_member(struct btf_show *show)\n{\n\tshow->state.array_member = 1;\n\tbtf_show_start_member(show, NULL);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_start_member",
          "args": [
            "show",
            "NULL"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_member",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1233-1237",
          "snippet": "static void btf_show_start_member(struct btf_show *show,\n\t\t\t\t  const struct btf_member *m)\n{\n\tshow->state.member = m;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_start_member(struct btf_show *show,\n\t\t\t\t  const struct btf_member *m)\n{\n\tshow->state.member = m;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_start_array_member(struct btf_show *show)\n{\n\tshow->state.array_member = 1;\n\tbtf_show_start_member(show, NULL);\n}"
  },
  {
    "function_name": "btf_show_start_member",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1233-1237",
    "snippet": "static void btf_show_start_member(struct btf_show *show,\n\t\t\t\t  const struct btf_member *m)\n{\n\tshow->state.member = m;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_start_member(struct btf_show *show,\n\t\t\t\t  const struct btf_member *m)\n{\n\tshow->state.member = m;\n}"
  },
  {
    "function_name": "btf_show_end_aggr_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1224-1231",
    "snippet": "static void btf_show_end_aggr_type(struct btf_show *show,\n\t\t\t\t   const char *suffix)\n{\n\tshow->state.depth--;\n\tbtf_show(show, \"%s%s%s%s\", btf_show_indent(show), suffix,\n\t\t btf_show_delim(show), btf_show_newline(show));\n\tbtf_show_end_type(show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_end_type",
          "args": [
            "show"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_end_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1201-1206",
          "snippet": "static void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show",
          "args": [
            "show",
            "\"%s%s%s%s\"",
            "btf_show_indent(show)",
            "suffix",
            "btf_show_delim(show)",
            "btf_show_newline(show)"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1020-1029",
          "snippet": "static void btf_show(struct btf_show *show, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!show->state.depth_check) {\n\t\tva_start(args, fmt);\n\t\tshow->showfn(show, fmt, args);\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show(struct btf_show *show, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!show->state.depth_check) {\n\t\tva_start(args, fmt);\n\t\tshow->showfn(show, fmt, args);\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_newline",
          "args": [
            "show"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_newline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1003-1006",
          "snippet": "static const char *btf_show_newline(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : \"\\n\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_show_newline(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : \"\\n\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_delim",
          "args": [
            "show"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_delim",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1008-1018",
          "snippet": "static const char *btf_show_delim(struct btf_show *show)\n{\n\tif (show->state.depth == 0)\n\t\treturn \"\";\n\n\tif ((show->flags & BTF_SHOW_COMPACT) && show->state.type &&\n\t\tBTF_INFO_KIND(show->state.type->info) == BTF_KIND_UNION)\n\t\treturn \"|\";\n\n\treturn \",\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_show_delim(struct btf_show *show)\n{\n\tif (show->state.depth == 0)\n\t\treturn \"\";\n\n\tif ((show->flags & BTF_SHOW_COMPACT) && show->state.type &&\n\t\tBTF_INFO_KIND(show->state.type->info) == BTF_KIND_UNION)\n\t\treturn \"|\";\n\n\treturn \",\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_indent",
          "args": [
            "show"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_indent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "998-1001",
          "snippet": "static const char *btf_show_indent(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : __btf_show_indent(show);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_show_indent(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : __btf_show_indent(show);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show_end_aggr_type(struct btf_show *show,\n\t\t\t\t   const char *suffix)\n{\n\tshow->state.depth--;\n\tbtf_show(show, \"%s%s%s%s\", btf_show_indent(show), suffix,\n\t\t btf_show_delim(show), btf_show_newline(show));\n\tbtf_show_end_type(show);\n}"
  },
  {
    "function_name": "btf_show_start_aggr_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1208-1222",
    "snippet": "static void *btf_show_start_aggr_type(struct btf_show *show,\n\t\t\t\t      const struct btf_type *t,\n\t\t\t\t      u32 type_id, void *data)\n{\n\tvoid *safe_data = btf_show_start_type(show, t, type_id, data);\n\n\tif (!safe_data)\n\t\treturn safe_data;\n\n\tbtf_show(show, \"%s%s%s\", btf_show_indent(show),\n\t\t btf_show_name(show),\n\t\t btf_show_newline(show));\n\tshow->state.depth++;\n\treturn safe_data;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show",
          "args": [
            "show",
            "\"%s%s%s\"",
            "btf_show_indent(show)",
            "btf_show_name(show)",
            "btf_show_newline(show)"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1020-1029",
          "snippet": "static void btf_show(struct btf_show *show, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!show->state.depth_check) {\n\t\tva_start(args, fmt);\n\t\tshow->showfn(show, fmt, args);\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show(struct btf_show *show, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!show->state.depth_check) {\n\t\tva_start(args, fmt);\n\t\tshow->showfn(show, fmt, args);\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_newline",
          "args": [
            "show"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_newline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1003-1006",
          "snippet": "static const char *btf_show_newline(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : \"\\n\";\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_show_newline(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : \"\\n\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_name",
          "args": [
            "show"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "830-986",
          "snippet": "static const char *btf_show_name(struct btf_show *show)\n{\n\t/* BTF_MAX_ITER array suffixes \"[]\" */\n\tconst char *array_suffixes = \"[][][][][][][][][][]\";\n\tconst char *array_suffix = &array_suffixes[strlen(array_suffixes)];\n\t/* BTF_MAX_ITER pointer suffixes \"*\" */\n\tconst char *ptr_suffixes = \"**********\";\n\tconst char *ptr_suffix = &ptr_suffixes[strlen(ptr_suffixes)];\n\tconst char *name = NULL, *prefix = \"\", *parens = \"\";\n\tconst struct btf_member *m = show->state.member;\n\tconst struct btf_type *t;\n\tconst struct btf_array *array;\n\tu32 id = show->state.type_id;\n\tconst char *member = NULL;\n\tbool show_member = false;\n\tu64 kinds = 0;\n\tint i;\n\n\tshow->state.name[0] = '\\0';\n\n\t/*\n\t * Don't show type name if we're showing an array member;\n\t * in that case we show the array type so don't need to repeat\n\t * ourselves for each member.\n\t */\n\tif (show->state.array_member)\n\t\treturn \"\";\n\n\t/* Retrieve member name, if any. */\n\tif (m) {\n\t\tmember = btf_name_by_offset(show->btf, m->name_off);\n\t\tshow_member = strlen(member) > 0;\n\t\tid = m->type;\n\t}\n\n\t/*\n\t * Start with type_id, as we have resolved the struct btf_type *\n\t * via btf_modifier_show() past the parent typedef to the child\n\t * struct, int etc it is defined as.  In such cases, the type_id\n\t * still represents the starting type while the struct btf_type *\n\t * in our show->state points at the resolved type of the typedef.\n\t */\n\tt = btf_type_by_id(show->btf, id);\n\tif (!t)\n\t\treturn \"\";\n\n\t/*\n\t * The goal here is to build up the right number of pointer and\n\t * array suffixes while ensuring the type name for a typedef\n\t * is represented.  Along the way we accumulate a list of\n\t * BTF kinds we have encountered, since these will inform later\n\t * display; for example, pointer types will not require an\n\t * opening \"{\" for struct, we will just display the pointer value.\n\t *\n\t * We also want to accumulate the right number of pointer or array\n\t * indices in the format string while iterating until we get to\n\t * the typedef/pointee/array member target type.\n\t *\n\t * We start by pointing at the end of pointer and array suffix\n\t * strings; as we accumulate pointers and arrays we move the pointer\n\t * or array string backwards so it will show the expected number of\n\t * '*' or '[]' for the type.  BTF_SHOW_MAX_ITER of nesting of pointers\n\t * and/or arrays and typedefs are supported as a precaution.\n\t *\n\t * We also want to get typedef name while proceeding to resolve\n\t * type it points to so that we can add parentheses if it is a\n\t * \"typedef struct\" etc.\n\t */\n\tfor (i = 0; i < BTF_SHOW_MAX_ITER; i++) {\n\n\t\tswitch (BTF_INFO_KIND(t->info)) {\n\t\tcase BTF_KIND_TYPEDEF:\n\t\t\tif (!name)\n\t\t\t\tname = btf_name_by_offset(show->btf,\n\t\t\t\t\t\t\t       t->name_off);\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_TYPEDEF);\n\t\t\tid = t->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_ARRAY);\n\t\t\tparens = \"[\";\n\t\t\tif (!t)\n\t\t\t\treturn \"\";\n\t\t\tarray = btf_type_array(t);\n\t\t\tif (array_suffix > array_suffixes)\n\t\t\t\tarray_suffix -= 2;\n\t\t\tid = array->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_PTR:\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_PTR);\n\t\t\tif (ptr_suffix > ptr_suffixes)\n\t\t\t\tptr_suffix -= 1;\n\t\t\tid = t->type;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tid = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!id)\n\t\t\tbreak;\n\t\tt = btf_type_skip_qualifiers(show->btf, id);\n\t}\n\t/* We may not be able to represent this type; bail to be safe */\n\tif (i == BTF_SHOW_MAX_ITER)\n\t\treturn \"\";\n\n\tif (!name)\n\t\tname = btf_name_by_offset(show->btf, t->name_off);\n\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\tprefix = BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT ?\n\t\t\t \"struct\" : \"union\";\n\t\t/* if it's an array of struct/union, parens is already set */\n\t\tif (!(kinds & (BTF_KIND_BIT(BTF_KIND_ARRAY))))\n\t\t\tparens = \"{\";\n\t\tbreak;\n\tcase BTF_KIND_ENUM:\n\t\tprefix = \"enum\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* pointer does not require parens */\n\tif (kinds & BTF_KIND_BIT(BTF_KIND_PTR))\n\t\tparens = \"\";\n\t/* typedef does not require struct/union/enum prefix */\n\tif (kinds & BTF_KIND_BIT(BTF_KIND_TYPEDEF))\n\t\tprefix = \"\";\n\n\tif (!name)\n\t\tname = \"\";\n\n\t/* Even if we don't want type name info, we want parentheses etc */\n\tif (show->flags & BTF_SHOW_NONAME)\n\t\tsnprintf(show->state.name, sizeof(show->state.name), \"%s\",\n\t\t\t parens);\n\telse\n\t\tsnprintf(show->state.name, sizeof(show->state.name),\n\t\t\t \"%s%s%s(%s%s%s%s%s%s)%s\",\n\t\t\t /* first 3 strings comprise \".member = \" */\n\t\t\t show_member ? \".\" : \"\",\n\t\t\t show_member ? member : \"\",\n\t\t\t show_member ? \" = \" : \"\",\n\t\t\t /* ...next is our prefix (struct, enum, etc) */\n\t\t\t prefix,\n\t\t\t strlen(prefix) > 0 && strlen(name) > 0 ? \" \" : \"\",\n\t\t\t /* ...this is the type name itself */\n\t\t\t name,\n\t\t\t /* ...suffixed by the appropriate '*', '[]' suffixes */\n\t\t\t strlen(ptr_suffix) > 0 ? \" \" : \"\", ptr_suffix,\n\t\t\t array_suffix, parens);\n\n\treturn show->state.name;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define BTF_SHOW_MAX_ITER\t10"
          ],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_SHOW_MAX_ITER\t10\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const char *btf_show_name(struct btf_show *show)\n{\n\t/* BTF_MAX_ITER array suffixes \"[]\" */\n\tconst char *array_suffixes = \"[][][][][][][][][][]\";\n\tconst char *array_suffix = &array_suffixes[strlen(array_suffixes)];\n\t/* BTF_MAX_ITER pointer suffixes \"*\" */\n\tconst char *ptr_suffixes = \"**********\";\n\tconst char *ptr_suffix = &ptr_suffixes[strlen(ptr_suffixes)];\n\tconst char *name = NULL, *prefix = \"\", *parens = \"\";\n\tconst struct btf_member *m = show->state.member;\n\tconst struct btf_type *t;\n\tconst struct btf_array *array;\n\tu32 id = show->state.type_id;\n\tconst char *member = NULL;\n\tbool show_member = false;\n\tu64 kinds = 0;\n\tint i;\n\n\tshow->state.name[0] = '\\0';\n\n\t/*\n\t * Don't show type name if we're showing an array member;\n\t * in that case we show the array type so don't need to repeat\n\t * ourselves for each member.\n\t */\n\tif (show->state.array_member)\n\t\treturn \"\";\n\n\t/* Retrieve member name, if any. */\n\tif (m) {\n\t\tmember = btf_name_by_offset(show->btf, m->name_off);\n\t\tshow_member = strlen(member) > 0;\n\t\tid = m->type;\n\t}\n\n\t/*\n\t * Start with type_id, as we have resolved the struct btf_type *\n\t * via btf_modifier_show() past the parent typedef to the child\n\t * struct, int etc it is defined as.  In such cases, the type_id\n\t * still represents the starting type while the struct btf_type *\n\t * in our show->state points at the resolved type of the typedef.\n\t */\n\tt = btf_type_by_id(show->btf, id);\n\tif (!t)\n\t\treturn \"\";\n\n\t/*\n\t * The goal here is to build up the right number of pointer and\n\t * array suffixes while ensuring the type name for a typedef\n\t * is represented.  Along the way we accumulate a list of\n\t * BTF kinds we have encountered, since these will inform later\n\t * display; for example, pointer types will not require an\n\t * opening \"{\" for struct, we will just display the pointer value.\n\t *\n\t * We also want to accumulate the right number of pointer or array\n\t * indices in the format string while iterating until we get to\n\t * the typedef/pointee/array member target type.\n\t *\n\t * We start by pointing at the end of pointer and array suffix\n\t * strings; as we accumulate pointers and arrays we move the pointer\n\t * or array string backwards so it will show the expected number of\n\t * '*' or '[]' for the type.  BTF_SHOW_MAX_ITER of nesting of pointers\n\t * and/or arrays and typedefs are supported as a precaution.\n\t *\n\t * We also want to get typedef name while proceeding to resolve\n\t * type it points to so that we can add parentheses if it is a\n\t * \"typedef struct\" etc.\n\t */\n\tfor (i = 0; i < BTF_SHOW_MAX_ITER; i++) {\n\n\t\tswitch (BTF_INFO_KIND(t->info)) {\n\t\tcase BTF_KIND_TYPEDEF:\n\t\t\tif (!name)\n\t\t\t\tname = btf_name_by_offset(show->btf,\n\t\t\t\t\t\t\t       t->name_off);\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_TYPEDEF);\n\t\t\tid = t->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_ARRAY);\n\t\t\tparens = \"[\";\n\t\t\tif (!t)\n\t\t\t\treturn \"\";\n\t\t\tarray = btf_type_array(t);\n\t\t\tif (array_suffix > array_suffixes)\n\t\t\t\tarray_suffix -= 2;\n\t\t\tid = array->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_PTR:\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_PTR);\n\t\t\tif (ptr_suffix > ptr_suffixes)\n\t\t\t\tptr_suffix -= 1;\n\t\t\tid = t->type;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tid = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!id)\n\t\t\tbreak;\n\t\tt = btf_type_skip_qualifiers(show->btf, id);\n\t}\n\t/* We may not be able to represent this type; bail to be safe */\n\tif (i == BTF_SHOW_MAX_ITER)\n\t\treturn \"\";\n\n\tif (!name)\n\t\tname = btf_name_by_offset(show->btf, t->name_off);\n\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\tprefix = BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT ?\n\t\t\t \"struct\" : \"union\";\n\t\t/* if it's an array of struct/union, parens is already set */\n\t\tif (!(kinds & (BTF_KIND_BIT(BTF_KIND_ARRAY))))\n\t\t\tparens = \"{\";\n\t\tbreak;\n\tcase BTF_KIND_ENUM:\n\t\tprefix = \"enum\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* pointer does not require parens */\n\tif (kinds & BTF_KIND_BIT(BTF_KIND_PTR))\n\t\tparens = \"\";\n\t/* typedef does not require struct/union/enum prefix */\n\tif (kinds & BTF_KIND_BIT(BTF_KIND_TYPEDEF))\n\t\tprefix = \"\";\n\n\tif (!name)\n\t\tname = \"\";\n\n\t/* Even if we don't want type name info, we want parentheses etc */\n\tif (show->flags & BTF_SHOW_NONAME)\n\t\tsnprintf(show->state.name, sizeof(show->state.name), \"%s\",\n\t\t\t parens);\n\telse\n\t\tsnprintf(show->state.name, sizeof(show->state.name),\n\t\t\t \"%s%s%s(%s%s%s%s%s%s)%s\",\n\t\t\t /* first 3 strings comprise \".member = \" */\n\t\t\t show_member ? \".\" : \"\",\n\t\t\t show_member ? member : \"\",\n\t\t\t show_member ? \" = \" : \"\",\n\t\t\t /* ...next is our prefix (struct, enum, etc) */\n\t\t\t prefix,\n\t\t\t strlen(prefix) > 0 && strlen(name) > 0 ? \" \" : \"\",\n\t\t\t /* ...this is the type name itself */\n\t\t\t name,\n\t\t\t /* ...suffixed by the appropriate '*', '[]' suffixes */\n\t\t\t strlen(ptr_suffix) > 0 ? \" \" : \"\", ptr_suffix,\n\t\t\t array_suffix, parens);\n\n\treturn show->state.name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_indent",
          "args": [
            "show"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_indent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "998-1001",
          "snippet": "static const char *btf_show_indent(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : __btf_show_indent(show);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_show_indent(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : __btf_show_indent(show);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_show_start_type",
          "args": [
            "show",
            "t",
            "type_id",
            "data"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_start_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1190-1199",
          "snippet": "static void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_aggr_type(struct btf_show *show,\n\t\t\t\t      const struct btf_type *t,\n\t\t\t\t      u32 type_id, void *data)\n{\n\tvoid *safe_data = btf_show_start_type(show, t, type_id, data);\n\n\tif (!safe_data)\n\t\treturn safe_data;\n\n\tbtf_show(show, \"%s%s%s\", btf_show_indent(show),\n\t\t btf_show_name(show),\n\t\t btf_show_newline(show));\n\tshow->state.depth++;\n\treturn safe_data;\n}"
  },
  {
    "function_name": "btf_show_end_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1201-1206",
    "snippet": "static void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}"
  },
  {
    "function_name": "btf_show_start_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1190-1199",
    "snippet": "static void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_obj_safe",
          "args": [
            "show",
            "t",
            "data"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_obj_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1114-1184",
          "snippet": "static void *btf_show_obj_safe(struct btf_show *show,\n\t\t\t       const struct btf_type *t,\n\t\t\t       void *data)\n{\n\tconst struct btf_type *rt;\n\tint size_left, size;\n\tvoid *safe = NULL;\n\n\tif (show->flags & BTF_SHOW_UNSAFE)\n\t\treturn data;\n\n\trt = btf_resolve_size(show->btf, t, &size);\n\tif (IS_ERR(rt)) {\n\t\tshow->state.status = PTR_ERR(rt);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Is this toplevel object? If so, set total object size and\n\t * initialize pointers.  Otherwise check if we still fall within\n\t * our safe object data.\n\t */\n\tif (show->state.depth == 0) {\n\t\tshow->obj.size = size;\n\t\tshow->obj.head = data;\n\t} else {\n\t\t/*\n\t\t * If the size of the current object is > our remaining\n\t\t * safe buffer we _may_ need to do a new copy.  However\n\t\t * consider the case of a nested struct; it's size pushes\n\t\t * us over the safe buffer limit, but showing any individual\n\t\t * struct members does not.  In such cases, we don't need\n\t\t * to initiate a fresh copy yet; however we definitely need\n\t\t * at least BTF_SHOW_OBJ_BASE_TYPE_SIZE bytes left\n\t\t * in our buffer, regardless of the current object size.\n\t\t * The logic here is that as we resolve types we will\n\t\t * hit a base type at some point, and we need to be sure\n\t\t * the next chunk of data is safely available to display\n\t\t * that type info safely.  We cannot rely on the size of\n\t\t * the current object here because it may be much larger\n\t\t * than our current buffer (e.g. task_struct is 8k).\n\t\t * All we want to do here is ensure that we can print the\n\t\t * next basic type, which we can if either\n\t\t * - the current type size is within the safe buffer; or\n\t\t * - at least BTF_SHOW_OBJ_BASE_TYPE_SIZE bytes are left in\n\t\t *   the safe buffer.\n\t\t */\n\t\tsafe = __btf_show_obj_safe(show, data,\n\t\t\t\t\t   min(size,\n\t\t\t\t\t       BTF_SHOW_OBJ_BASE_TYPE_SIZE));\n\t}\n\n\t/*\n\t * We need a new copy to our safe object, either because we haven't\n\t * yet copied and are initializing safe data, or because the data\n\t * we want falls outside the boundaries of the safe object.\n\t */\n\tif (!safe) {\n\t\tsize_left = btf_show_obj_size_left(show, data);\n\t\tif (size_left > BTF_SHOW_OBJ_SAFE_SIZE)\n\t\t\tsize_left = BTF_SHOW_OBJ_SAFE_SIZE;\n\t\tshow->state.status = copy_from_kernel_nofault(show->obj.safe,\n\t\t\t\t\t\t\t      data, size_left);\n\t\tif (!show->state.status) {\n\t\t\tshow->obj.data = data;\n\t\t\tsafe = show->obj.safe;\n\t\t}\n\t}\n\n\treturn safe;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define BTF_SHOW_OBJ_BASE_TYPE_SIZE\t16",
            "#define BTF_SHOW_OBJ_SAFE_SIZE\t\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_SHOW_OBJ_BASE_TYPE_SIZE\t16\n#define BTF_SHOW_OBJ_SAFE_SIZE\t\t32\n\nstatic void *btf_show_obj_safe(struct btf_show *show,\n\t\t\t       const struct btf_type *t,\n\t\t\t       void *data)\n{\n\tconst struct btf_type *rt;\n\tint size_left, size;\n\tvoid *safe = NULL;\n\n\tif (show->flags & BTF_SHOW_UNSAFE)\n\t\treturn data;\n\n\trt = btf_resolve_size(show->btf, t, &size);\n\tif (IS_ERR(rt)) {\n\t\tshow->state.status = PTR_ERR(rt);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Is this toplevel object? If so, set total object size and\n\t * initialize pointers.  Otherwise check if we still fall within\n\t * our safe object data.\n\t */\n\tif (show->state.depth == 0) {\n\t\tshow->obj.size = size;\n\t\tshow->obj.head = data;\n\t} else {\n\t\t/*\n\t\t * If the size of the current object is > our remaining\n\t\t * safe buffer we _may_ need to do a new copy.  However\n\t\t * consider the case of a nested struct; it's size pushes\n\t\t * us over the safe buffer limit, but showing any individual\n\t\t * struct members does not.  In such cases, we don't need\n\t\t * to initiate a fresh copy yet; however we definitely need\n\t\t * at least BTF_SHOW_OBJ_BASE_TYPE_SIZE bytes left\n\t\t * in our buffer, regardless of the current object size.\n\t\t * The logic here is that as we resolve types we will\n\t\t * hit a base type at some point, and we need to be sure\n\t\t * the next chunk of data is safely available to display\n\t\t * that type info safely.  We cannot rely on the size of\n\t\t * the current object here because it may be much larger\n\t\t * than our current buffer (e.g. task_struct is 8k).\n\t\t * All we want to do here is ensure that we can print the\n\t\t * next basic type, which we can if either\n\t\t * - the current type size is within the safe buffer; or\n\t\t * - at least BTF_SHOW_OBJ_BASE_TYPE_SIZE bytes are left in\n\t\t *   the safe buffer.\n\t\t */\n\t\tsafe = __btf_show_obj_safe(show, data,\n\t\t\t\t\t   min(size,\n\t\t\t\t\t       BTF_SHOW_OBJ_BASE_TYPE_SIZE));\n\t}\n\n\t/*\n\t * We need a new copy to our safe object, either because we haven't\n\t * yet copied and are initializing safe data, or because the data\n\t * we want falls outside the boundaries of the safe object.\n\t */\n\tif (!safe) {\n\t\tsize_left = btf_show_obj_size_left(show, data);\n\t\tif (size_left > BTF_SHOW_OBJ_SAFE_SIZE)\n\t\t\tsize_left = BTF_SHOW_OBJ_SAFE_SIZE;\n\t\tshow->state.status = copy_from_kernel_nofault(show->obj.safe,\n\t\t\t\t\t\t\t      data, size_left);\n\t\tif (!show->state.status) {\n\t\t\tshow->obj.data = data;\n\t\t\tsafe = show->obj.safe;\n\t\t}\n\t}\n\n\treturn safe;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}"
  },
  {
    "function_name": "btf_show_obj_safe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1114-1184",
    "snippet": "static void *btf_show_obj_safe(struct btf_show *show,\n\t\t\t       const struct btf_type *t,\n\t\t\t       void *data)\n{\n\tconst struct btf_type *rt;\n\tint size_left, size;\n\tvoid *safe = NULL;\n\n\tif (show->flags & BTF_SHOW_UNSAFE)\n\t\treturn data;\n\n\trt = btf_resolve_size(show->btf, t, &size);\n\tif (IS_ERR(rt)) {\n\t\tshow->state.status = PTR_ERR(rt);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Is this toplevel object? If so, set total object size and\n\t * initialize pointers.  Otherwise check if we still fall within\n\t * our safe object data.\n\t */\n\tif (show->state.depth == 0) {\n\t\tshow->obj.size = size;\n\t\tshow->obj.head = data;\n\t} else {\n\t\t/*\n\t\t * If the size of the current object is > our remaining\n\t\t * safe buffer we _may_ need to do a new copy.  However\n\t\t * consider the case of a nested struct; it's size pushes\n\t\t * us over the safe buffer limit, but showing any individual\n\t\t * struct members does not.  In such cases, we don't need\n\t\t * to initiate a fresh copy yet; however we definitely need\n\t\t * at least BTF_SHOW_OBJ_BASE_TYPE_SIZE bytes left\n\t\t * in our buffer, regardless of the current object size.\n\t\t * The logic here is that as we resolve types we will\n\t\t * hit a base type at some point, and we need to be sure\n\t\t * the next chunk of data is safely available to display\n\t\t * that type info safely.  We cannot rely on the size of\n\t\t * the current object here because it may be much larger\n\t\t * than our current buffer (e.g. task_struct is 8k).\n\t\t * All we want to do here is ensure that we can print the\n\t\t * next basic type, which we can if either\n\t\t * - the current type size is within the safe buffer; or\n\t\t * - at least BTF_SHOW_OBJ_BASE_TYPE_SIZE bytes are left in\n\t\t *   the safe buffer.\n\t\t */\n\t\tsafe = __btf_show_obj_safe(show, data,\n\t\t\t\t\t   min(size,\n\t\t\t\t\t       BTF_SHOW_OBJ_BASE_TYPE_SIZE));\n\t}\n\n\t/*\n\t * We need a new copy to our safe object, either because we haven't\n\t * yet copied and are initializing safe data, or because the data\n\t * we want falls outside the boundaries of the safe object.\n\t */\n\tif (!safe) {\n\t\tsize_left = btf_show_obj_size_left(show, data);\n\t\tif (size_left > BTF_SHOW_OBJ_SAFE_SIZE)\n\t\t\tsize_left = BTF_SHOW_OBJ_SAFE_SIZE;\n\t\tshow->state.status = copy_from_kernel_nofault(show->obj.safe,\n\t\t\t\t\t\t\t      data, size_left);\n\t\tif (!show->state.status) {\n\t\t\tshow->obj.data = data;\n\t\t\tsafe = show->obj.safe;\n\t\t}\n\t}\n\n\treturn safe;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BTF_SHOW_OBJ_BASE_TYPE_SIZE\t16",
      "#define BTF_SHOW_OBJ_SAFE_SIZE\t\t32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "show->obj.safe",
            "data",
            "size_left"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_show_obj_size_left",
          "args": [
            "show",
            "data"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_obj_size_left",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1061-1064",
          "snippet": "static int btf_show_obj_size_left(struct btf_show *show, void *data)\n{\n\treturn show->obj.head + show->obj.size - data;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_show_obj_size_left(struct btf_show *show, void *data)\n{\n\treturn show->obj.head + show->obj.size - data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_show_obj_safe",
          "args": [
            "show",
            "data",
            "min(size,\n\t\t\t\t\t       BTF_SHOW_OBJ_BASE_TYPE_SIZE)"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_show_obj_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1079-1084",
          "snippet": "static void *__btf_show_obj_safe(struct btf_show *show, void *data, int size)\n{\n\tif (btf_show_obj_is_safe(show, data, size))\n\t\treturn show->obj.safe + (data - show->obj.data);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void *__btf_show_obj_safe(struct btf_show *show, void *data, int size)\n{\n\tif (btf_show_obj_is_safe(show, data, size))\n\t\treturn show->obj.safe + (data - show->obj.data);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size",
            "BTF_SHOW_OBJ_BASE_TYPE_SIZE"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "__reg_combine_min_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "9059-9087",
          "snippet": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rt"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rt"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_resolve_size",
          "args": [
            "show->btf",
            "t",
            "&size"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolve_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1783-1788",
          "snippet": "const struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_SHOW_OBJ_BASE_TYPE_SIZE\t16\n#define BTF_SHOW_OBJ_SAFE_SIZE\t\t32\n\nstatic void *btf_show_obj_safe(struct btf_show *show,\n\t\t\t       const struct btf_type *t,\n\t\t\t       void *data)\n{\n\tconst struct btf_type *rt;\n\tint size_left, size;\n\tvoid *safe = NULL;\n\n\tif (show->flags & BTF_SHOW_UNSAFE)\n\t\treturn data;\n\n\trt = btf_resolve_size(show->btf, t, &size);\n\tif (IS_ERR(rt)) {\n\t\tshow->state.status = PTR_ERR(rt);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Is this toplevel object? If so, set total object size and\n\t * initialize pointers.  Otherwise check if we still fall within\n\t * our safe object data.\n\t */\n\tif (show->state.depth == 0) {\n\t\tshow->obj.size = size;\n\t\tshow->obj.head = data;\n\t} else {\n\t\t/*\n\t\t * If the size of the current object is > our remaining\n\t\t * safe buffer we _may_ need to do a new copy.  However\n\t\t * consider the case of a nested struct; it's size pushes\n\t\t * us over the safe buffer limit, but showing any individual\n\t\t * struct members does not.  In such cases, we don't need\n\t\t * to initiate a fresh copy yet; however we definitely need\n\t\t * at least BTF_SHOW_OBJ_BASE_TYPE_SIZE bytes left\n\t\t * in our buffer, regardless of the current object size.\n\t\t * The logic here is that as we resolve types we will\n\t\t * hit a base type at some point, and we need to be sure\n\t\t * the next chunk of data is safely available to display\n\t\t * that type info safely.  We cannot rely on the size of\n\t\t * the current object here because it may be much larger\n\t\t * than our current buffer (e.g. task_struct is 8k).\n\t\t * All we want to do here is ensure that we can print the\n\t\t * next basic type, which we can if either\n\t\t * - the current type size is within the safe buffer; or\n\t\t * - at least BTF_SHOW_OBJ_BASE_TYPE_SIZE bytes are left in\n\t\t *   the safe buffer.\n\t\t */\n\t\tsafe = __btf_show_obj_safe(show, data,\n\t\t\t\t\t   min(size,\n\t\t\t\t\t       BTF_SHOW_OBJ_BASE_TYPE_SIZE));\n\t}\n\n\t/*\n\t * We need a new copy to our safe object, either because we haven't\n\t * yet copied and are initializing safe data, or because the data\n\t * we want falls outside the boundaries of the safe object.\n\t */\n\tif (!safe) {\n\t\tsize_left = btf_show_obj_size_left(show, data);\n\t\tif (size_left > BTF_SHOW_OBJ_SAFE_SIZE)\n\t\t\tsize_left = BTF_SHOW_OBJ_SAFE_SIZE;\n\t\tshow->state.status = copy_from_kernel_nofault(show->obj.safe,\n\t\t\t\t\t\t\t      data, size_left);\n\t\tif (!show->state.status) {\n\t\t\tshow->obj.data = data;\n\t\t\tsafe = show->obj.safe;\n\t\t}\n\t}\n\n\treturn safe;\n}"
  },
  {
    "function_name": "__btf_show_obj_safe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1079-1084",
    "snippet": "static void *__btf_show_obj_safe(struct btf_show *show, void *data, int size)\n{\n\tif (btf_show_obj_is_safe(show, data, size))\n\t\treturn show->obj.safe + (data - show->obj.data);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_show_obj_is_safe",
          "args": [
            "show",
            "data",
            "size"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "btf_show_obj_is_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1067-1071",
          "snippet": "static bool btf_show_obj_is_safe(struct btf_show *show, void *data, int size)\n{\n\treturn data >= show->obj.data &&\n\t       (data + size) < (show->obj.data + BTF_SHOW_OBJ_SAFE_SIZE);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define BTF_SHOW_OBJ_SAFE_SIZE\t\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_SHOW_OBJ_SAFE_SIZE\t\t32\n\nstatic bool btf_show_obj_is_safe(struct btf_show *show, void *data, int size)\n{\n\treturn data >= show->obj.data &&\n\t       (data + size) < (show->obj.data + BTF_SHOW_OBJ_SAFE_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void *__btf_show_obj_safe(struct btf_show *show, void *data, int size)\n{\n\tif (btf_show_obj_is_safe(show, data, size))\n\t\treturn show->obj.safe + (data - show->obj.data);\n\treturn NULL;\n}"
  },
  {
    "function_name": "btf_show_obj_is_safe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1067-1071",
    "snippet": "static bool btf_show_obj_is_safe(struct btf_show *show, void *data, int size)\n{\n\treturn data >= show->obj.data &&\n\t       (data + size) < (show->obj.data + BTF_SHOW_OBJ_SAFE_SIZE);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BTF_SHOW_OBJ_SAFE_SIZE\t\t32"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_SHOW_OBJ_SAFE_SIZE\t\t32\n\nstatic bool btf_show_obj_is_safe(struct btf_show *show, void *data, int size)\n{\n\treturn data >= show->obj.data &&\n\t       (data + size) < (show->obj.data + BTF_SHOW_OBJ_SAFE_SIZE);\n}"
  },
  {
    "function_name": "btf_show_obj_size_left",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1061-1064",
    "snippet": "static int btf_show_obj_size_left(struct btf_show *show, void *data)\n{\n\treturn show->obj.head + show->obj.size - data;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_show_obj_size_left(struct btf_show *show, void *data)\n{\n\treturn show->obj.head + show->obj.size - data;\n}"
  },
  {
    "function_name": "btf_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1020-1029",
    "snippet": "static void btf_show(struct btf_show *show, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!show->state.depth_check) {\n\t\tva_start(args, fmt);\n\t\tshow->showfn(show, fmt, args);\n\t\tva_end(args);\n\t}\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show->showfn",
          "args": [
            "show",
            "fmt",
            "args"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_show(struct btf_show *show, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!show->state.depth_check) {\n\t\tva_start(args, fmt);\n\t\tshow->showfn(show, fmt, args);\n\t\tva_end(args);\n\t}\n}"
  },
  {
    "function_name": "btf_show_delim",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1008-1018",
    "snippet": "static const char *btf_show_delim(struct btf_show *show)\n{\n\tif (show->state.depth == 0)\n\t\treturn \"\";\n\n\tif ((show->flags & BTF_SHOW_COMPACT) && show->state.type &&\n\t\tBTF_INFO_KIND(show->state.type->info) == BTF_KIND_UNION)\n\t\treturn \"|\";\n\n\treturn \",\";\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "show->state.type->info"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_show_delim(struct btf_show *show)\n{\n\tif (show->state.depth == 0)\n\t\treturn \"\";\n\n\tif ((show->flags & BTF_SHOW_COMPACT) && show->state.type &&\n\t\tBTF_INFO_KIND(show->state.type->info) == BTF_KIND_UNION)\n\t\treturn \"|\";\n\n\treturn \",\";\n}"
  },
  {
    "function_name": "btf_show_newline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "1003-1006",
    "snippet": "static const char *btf_show_newline(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : \"\\n\";\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_show_newline(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : \"\\n\";\n}"
  },
  {
    "function_name": "btf_show_indent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "998-1001",
    "snippet": "static const char *btf_show_indent(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : __btf_show_indent(show);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_show_indent",
          "args": [
            "show"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_show_indent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "988-996",
          "snippet": "static const char *__btf_show_indent(struct btf_show *show)\n{\n\tconst char *indents = \"                                \";\n\tconst char *indent = &indents[strlen(indents)];\n\n\tif ((indent - show->state.depth) >= indents)\n\t\treturn indent - show->state.depth;\n\treturn indents;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_show_indent(struct btf_show *show)\n{\n\tconst char *indents = \"                                \";\n\tconst char *indent = &indents[strlen(indents)];\n\n\tif ((indent - show->state.depth) >= indents)\n\t\treturn indent - show->state.depth;\n\treturn indents;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_show_indent(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : __btf_show_indent(show);\n}"
  },
  {
    "function_name": "__btf_show_indent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "988-996",
    "snippet": "static const char *__btf_show_indent(struct btf_show *show)\n{\n\tconst char *indents = \"                                \";\n\tconst char *indent = &indents[strlen(indents)];\n\n\tif ((indent - show->state.depth) >= indents)\n\t\treturn indent - show->state.depth;\n\treturn indents;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "indents"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_show_indent(struct btf_show *show)\n{\n\tconst char *indents = \"                                \";\n\tconst char *indent = &indents[strlen(indents)];\n\n\tif ((indent - show->state.depth) >= indents)\n\t\treturn indent - show->state.depth;\n\treturn indents;\n}"
  },
  {
    "function_name": "btf_show_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "830-986",
    "snippet": "static const char *btf_show_name(struct btf_show *show)\n{\n\t/* BTF_MAX_ITER array suffixes \"[]\" */\n\tconst char *array_suffixes = \"[][][][][][][][][][]\";\n\tconst char *array_suffix = &array_suffixes[strlen(array_suffixes)];\n\t/* BTF_MAX_ITER pointer suffixes \"*\" */\n\tconst char *ptr_suffixes = \"**********\";\n\tconst char *ptr_suffix = &ptr_suffixes[strlen(ptr_suffixes)];\n\tconst char *name = NULL, *prefix = \"\", *parens = \"\";\n\tconst struct btf_member *m = show->state.member;\n\tconst struct btf_type *t;\n\tconst struct btf_array *array;\n\tu32 id = show->state.type_id;\n\tconst char *member = NULL;\n\tbool show_member = false;\n\tu64 kinds = 0;\n\tint i;\n\n\tshow->state.name[0] = '\\0';\n\n\t/*\n\t * Don't show type name if we're showing an array member;\n\t * in that case we show the array type so don't need to repeat\n\t * ourselves for each member.\n\t */\n\tif (show->state.array_member)\n\t\treturn \"\";\n\n\t/* Retrieve member name, if any. */\n\tif (m) {\n\t\tmember = btf_name_by_offset(show->btf, m->name_off);\n\t\tshow_member = strlen(member) > 0;\n\t\tid = m->type;\n\t}\n\n\t/*\n\t * Start with type_id, as we have resolved the struct btf_type *\n\t * via btf_modifier_show() past the parent typedef to the child\n\t * struct, int etc it is defined as.  In such cases, the type_id\n\t * still represents the starting type while the struct btf_type *\n\t * in our show->state points at the resolved type of the typedef.\n\t */\n\tt = btf_type_by_id(show->btf, id);\n\tif (!t)\n\t\treturn \"\";\n\n\t/*\n\t * The goal here is to build up the right number of pointer and\n\t * array suffixes while ensuring the type name for a typedef\n\t * is represented.  Along the way we accumulate a list of\n\t * BTF kinds we have encountered, since these will inform later\n\t * display; for example, pointer types will not require an\n\t * opening \"{\" for struct, we will just display the pointer value.\n\t *\n\t * We also want to accumulate the right number of pointer or array\n\t * indices in the format string while iterating until we get to\n\t * the typedef/pointee/array member target type.\n\t *\n\t * We start by pointing at the end of pointer and array suffix\n\t * strings; as we accumulate pointers and arrays we move the pointer\n\t * or array string backwards so it will show the expected number of\n\t * '*' or '[]' for the type.  BTF_SHOW_MAX_ITER of nesting of pointers\n\t * and/or arrays and typedefs are supported as a precaution.\n\t *\n\t * We also want to get typedef name while proceeding to resolve\n\t * type it points to so that we can add parentheses if it is a\n\t * \"typedef struct\" etc.\n\t */\n\tfor (i = 0; i < BTF_SHOW_MAX_ITER; i++) {\n\n\t\tswitch (BTF_INFO_KIND(t->info)) {\n\t\tcase BTF_KIND_TYPEDEF:\n\t\t\tif (!name)\n\t\t\t\tname = btf_name_by_offset(show->btf,\n\t\t\t\t\t\t\t       t->name_off);\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_TYPEDEF);\n\t\t\tid = t->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_ARRAY);\n\t\t\tparens = \"[\";\n\t\t\tif (!t)\n\t\t\t\treturn \"\";\n\t\t\tarray = btf_type_array(t);\n\t\t\tif (array_suffix > array_suffixes)\n\t\t\t\tarray_suffix -= 2;\n\t\t\tid = array->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_PTR:\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_PTR);\n\t\t\tif (ptr_suffix > ptr_suffixes)\n\t\t\t\tptr_suffix -= 1;\n\t\t\tid = t->type;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tid = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!id)\n\t\t\tbreak;\n\t\tt = btf_type_skip_qualifiers(show->btf, id);\n\t}\n\t/* We may not be able to represent this type; bail to be safe */\n\tif (i == BTF_SHOW_MAX_ITER)\n\t\treturn \"\";\n\n\tif (!name)\n\t\tname = btf_name_by_offset(show->btf, t->name_off);\n\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\tprefix = BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT ?\n\t\t\t \"struct\" : \"union\";\n\t\t/* if it's an array of struct/union, parens is already set */\n\t\tif (!(kinds & (BTF_KIND_BIT(BTF_KIND_ARRAY))))\n\t\t\tparens = \"{\";\n\t\tbreak;\n\tcase BTF_KIND_ENUM:\n\t\tprefix = \"enum\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* pointer does not require parens */\n\tif (kinds & BTF_KIND_BIT(BTF_KIND_PTR))\n\t\tparens = \"\";\n\t/* typedef does not require struct/union/enum prefix */\n\tif (kinds & BTF_KIND_BIT(BTF_KIND_TYPEDEF))\n\t\tprefix = \"\";\n\n\tif (!name)\n\t\tname = \"\";\n\n\t/* Even if we don't want type name info, we want parentheses etc */\n\tif (show->flags & BTF_SHOW_NONAME)\n\t\tsnprintf(show->state.name, sizeof(show->state.name), \"%s\",\n\t\t\t parens);\n\telse\n\t\tsnprintf(show->state.name, sizeof(show->state.name),\n\t\t\t \"%s%s%s(%s%s%s%s%s%s)%s\",\n\t\t\t /* first 3 strings comprise \".member = \" */\n\t\t\t show_member ? \".\" : \"\",\n\t\t\t show_member ? member : \"\",\n\t\t\t show_member ? \" = \" : \"\",\n\t\t\t /* ...next is our prefix (struct, enum, etc) */\n\t\t\t prefix,\n\t\t\t strlen(prefix) > 0 && strlen(name) > 0 ? \" \" : \"\",\n\t\t\t /* ...this is the type name itself */\n\t\t\t name,\n\t\t\t /* ...suffixed by the appropriate '*', '[]' suffixes */\n\t\t\t strlen(ptr_suffix) > 0 ? \" \" : \"\", ptr_suffix,\n\t\t\t array_suffix, parens);\n\n\treturn show->state.name;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BTF_SHOW_MAX_ITER\t10"
    ],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "show->state.name",
            "sizeof(show->state.name)",
            "\"%s%s%s(%s%s%s%s%s%s)%s\"",
            "/* first 3 strings comprise \".member = \" */show_member ? \".\" : \"\"",
            "show_member ? member : \"\"",
            "show_member ? \" = \" : \"\"",
            "/* ...next is our prefix (struct, enum, etc) */prefix",
            "strlen(prefix) > 0 && strlen(name) > 0 ? \" \" : \"\"",
            "/* ...this is the type name itself */name",
            "/* ...suffixed by the appropriate '*', '[]' suffixes */strlen(ptr_suffix) > 0 ? \" \" : \"\"",
            "ptr_suffix",
            "array_suffix",
            "parens"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr_suffix"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "show->state.name",
            "sizeof(show->state.name)",
            "\"%s\"",
            "parens"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_KIND_BIT",
          "args": [
            "BTF_KIND_TYPEDEF"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_KIND_BIT",
          "args": [
            "BTF_KIND_PTR"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_KIND_BIT",
          "args": [
            "BTF_KIND_ARRAY"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "show->btf",
            "t->name_off"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "726-729",
          "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_skip_qualifiers",
          "args": [
            "show->btf",
            "id"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_skip_qualifiers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "807-818",
          "snippet": "static const struct btf_type *btf_type_skip_qualifiers(const struct btf *btf,\n\t\t\t\t\t\t       u32 id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t) &&\n\t       BTF_INFO_KIND(t->info) != BTF_KIND_TYPEDEF) {\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_skip_qualifiers(const struct btf *btf,\n\t\t\t\t\t\t       u32 id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t) &&\n\t       BTF_INFO_KIND(t->info) != BTF_KIND_TYPEDEF) {\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_KIND_BIT",
          "args": [
            "BTF_KIND_PTR"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "t"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "621-624",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_KIND_BIT",
          "args": [
            "BTF_KIND_ARRAY"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_KIND_BIT",
          "args": [
            "BTF_KIND_TYPEDEF"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "show->btf",
            "id"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_SHOW_MAX_ITER\t10\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic const char *btf_show_name(struct btf_show *show)\n{\n\t/* BTF_MAX_ITER array suffixes \"[]\" */\n\tconst char *array_suffixes = \"[][][][][][][][][][]\";\n\tconst char *array_suffix = &array_suffixes[strlen(array_suffixes)];\n\t/* BTF_MAX_ITER pointer suffixes \"*\" */\n\tconst char *ptr_suffixes = \"**********\";\n\tconst char *ptr_suffix = &ptr_suffixes[strlen(ptr_suffixes)];\n\tconst char *name = NULL, *prefix = \"\", *parens = \"\";\n\tconst struct btf_member *m = show->state.member;\n\tconst struct btf_type *t;\n\tconst struct btf_array *array;\n\tu32 id = show->state.type_id;\n\tconst char *member = NULL;\n\tbool show_member = false;\n\tu64 kinds = 0;\n\tint i;\n\n\tshow->state.name[0] = '\\0';\n\n\t/*\n\t * Don't show type name if we're showing an array member;\n\t * in that case we show the array type so don't need to repeat\n\t * ourselves for each member.\n\t */\n\tif (show->state.array_member)\n\t\treturn \"\";\n\n\t/* Retrieve member name, if any. */\n\tif (m) {\n\t\tmember = btf_name_by_offset(show->btf, m->name_off);\n\t\tshow_member = strlen(member) > 0;\n\t\tid = m->type;\n\t}\n\n\t/*\n\t * Start with type_id, as we have resolved the struct btf_type *\n\t * via btf_modifier_show() past the parent typedef to the child\n\t * struct, int etc it is defined as.  In such cases, the type_id\n\t * still represents the starting type while the struct btf_type *\n\t * in our show->state points at the resolved type of the typedef.\n\t */\n\tt = btf_type_by_id(show->btf, id);\n\tif (!t)\n\t\treturn \"\";\n\n\t/*\n\t * The goal here is to build up the right number of pointer and\n\t * array suffixes while ensuring the type name for a typedef\n\t * is represented.  Along the way we accumulate a list of\n\t * BTF kinds we have encountered, since these will inform later\n\t * display; for example, pointer types will not require an\n\t * opening \"{\" for struct, we will just display the pointer value.\n\t *\n\t * We also want to accumulate the right number of pointer or array\n\t * indices in the format string while iterating until we get to\n\t * the typedef/pointee/array member target type.\n\t *\n\t * We start by pointing at the end of pointer and array suffix\n\t * strings; as we accumulate pointers and arrays we move the pointer\n\t * or array string backwards so it will show the expected number of\n\t * '*' or '[]' for the type.  BTF_SHOW_MAX_ITER of nesting of pointers\n\t * and/or arrays and typedefs are supported as a precaution.\n\t *\n\t * We also want to get typedef name while proceeding to resolve\n\t * type it points to so that we can add parentheses if it is a\n\t * \"typedef struct\" etc.\n\t */\n\tfor (i = 0; i < BTF_SHOW_MAX_ITER; i++) {\n\n\t\tswitch (BTF_INFO_KIND(t->info)) {\n\t\tcase BTF_KIND_TYPEDEF:\n\t\t\tif (!name)\n\t\t\t\tname = btf_name_by_offset(show->btf,\n\t\t\t\t\t\t\t       t->name_off);\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_TYPEDEF);\n\t\t\tid = t->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_ARRAY);\n\t\t\tparens = \"[\";\n\t\t\tif (!t)\n\t\t\t\treturn \"\";\n\t\t\tarray = btf_type_array(t);\n\t\t\tif (array_suffix > array_suffixes)\n\t\t\t\tarray_suffix -= 2;\n\t\t\tid = array->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_PTR:\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_PTR);\n\t\t\tif (ptr_suffix > ptr_suffixes)\n\t\t\t\tptr_suffix -= 1;\n\t\t\tid = t->type;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tid = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!id)\n\t\t\tbreak;\n\t\tt = btf_type_skip_qualifiers(show->btf, id);\n\t}\n\t/* We may not be able to represent this type; bail to be safe */\n\tif (i == BTF_SHOW_MAX_ITER)\n\t\treturn \"\";\n\n\tif (!name)\n\t\tname = btf_name_by_offset(show->btf, t->name_off);\n\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\tprefix = BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT ?\n\t\t\t \"struct\" : \"union\";\n\t\t/* if it's an array of struct/union, parens is already set */\n\t\tif (!(kinds & (BTF_KIND_BIT(BTF_KIND_ARRAY))))\n\t\t\tparens = \"{\";\n\t\tbreak;\n\tcase BTF_KIND_ENUM:\n\t\tprefix = \"enum\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* pointer does not require parens */\n\tif (kinds & BTF_KIND_BIT(BTF_KIND_PTR))\n\t\tparens = \"\";\n\t/* typedef does not require struct/union/enum prefix */\n\tif (kinds & BTF_KIND_BIT(BTF_KIND_TYPEDEF))\n\t\tprefix = \"\";\n\n\tif (!name)\n\t\tname = \"\";\n\n\t/* Even if we don't want type name info, we want parentheses etc */\n\tif (show->flags & BTF_SHOW_NONAME)\n\t\tsnprintf(show->state.name, sizeof(show->state.name), \"%s\",\n\t\t\t parens);\n\telse\n\t\tsnprintf(show->state.name, sizeof(show->state.name),\n\t\t\t \"%s%s%s(%s%s%s%s%s%s)%s\",\n\t\t\t /* first 3 strings comprise \".member = \" */\n\t\t\t show_member ? \".\" : \"\",\n\t\t\t show_member ? member : \"\",\n\t\t\t show_member ? \" = \" : \"\",\n\t\t\t /* ...next is our prefix (struct, enum, etc) */\n\t\t\t prefix,\n\t\t\t strlen(prefix) > 0 && strlen(name) > 0 ? \" \" : \"\",\n\t\t\t /* ...this is the type name itself */\n\t\t\t name,\n\t\t\t /* ...suffixed by the appropriate '*', '[]' suffixes */\n\t\t\t strlen(ptr_suffix) > 0 ? \" \" : \"\", ptr_suffix,\n\t\t\t array_suffix, parens);\n\n\treturn show->state.name;\n}"
  },
  {
    "function_name": "btf_type_skip_qualifiers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "807-818",
    "snippet": "static const struct btf_type *btf_type_skip_qualifiers(const struct btf *btf,\n\t\t\t\t\t\t       u32 id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t) &&\n\t       BTF_INFO_KIND(t->info) != BTF_KIND_TYPEDEF) {\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\treturn t;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "t->type"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "t"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_skip_qualifiers(const struct btf *btf,\n\t\t\t\t\t\t       u32 id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t) &&\n\t       BTF_INFO_KIND(t->info) != BTF_KIND_TYPEDEF) {\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\treturn t;\n}"
  },
  {
    "function_name": "btf_member_is_reg_int",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "769-804",
    "snippet": "bool btf_member_is_reg_int(const struct btf *btf, const struct btf_type *s,\n\t\t\t   const struct btf_member *m,\n\t\t\t   u32 expected_offset, u32 expected_size)\n{\n\tconst struct btf_type *t;\n\tu32 id, int_data;\n\tu8 nr_bits;\n\n\tid = m->type;\n\tt = btf_type_id_size(btf, &id, NULL);\n\tif (!t || !btf_type_is_int(t))\n\t\treturn false;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tif (btf_type_kflag(s)) {\n\t\tu32 bitfield_size = BTF_MEMBER_BITFIELD_SIZE(m->offset);\n\t\tu32 bit_offset = BTF_MEMBER_BIT_OFFSET(m->offset);\n\n\t\t/* if kflag set, int should be a regular int and\n\t\t * bit offset should be at byte boundary.\n\t\t */\n\t\treturn !bitfield_size &&\n\t\t       BITS_ROUNDUP_BYTES(bit_offset) == expected_offset &&\n\t\t       BITS_ROUNDUP_BYTES(nr_bits) == expected_size;\n\t}\n\n\tif (BTF_INT_OFFSET(int_data) ||\n\t    BITS_PER_BYTE_MASKED(m->offset) ||\n\t    BITS_ROUNDUP_BYTES(m->offset) != expected_offset ||\n\t    BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BITS_ROUNDUP_BYTES(nr_bits) != expected_size)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "nr_bits"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "nr_bits"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "m->offset"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "m->offset"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "nr_bits"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "bit_offset"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_MEMBER_BIT_OFFSET",
          "args": [
            "m->offset"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_MEMBER_BITFIELD_SIZE",
          "args": [
            "m->offset"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_kflag",
          "args": [
            "s"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "t"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "746-763",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_int",
          "args": [
            "t"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&id",
            "NULL"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "1814-1855",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nbool btf_member_is_reg_int(const struct btf *btf, const struct btf_type *s,\n\t\t\t   const struct btf_member *m,\n\t\t\t   u32 expected_offset, u32 expected_size)\n{\n\tconst struct btf_type *t;\n\tu32 id, int_data;\n\tu8 nr_bits;\n\n\tid = m->type;\n\tt = btf_type_id_size(btf, &id, NULL);\n\tif (!t || !btf_type_is_int(t))\n\t\treturn false;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tif (btf_type_kflag(s)) {\n\t\tu32 bitfield_size = BTF_MEMBER_BITFIELD_SIZE(m->offset);\n\t\tu32 bit_offset = BTF_MEMBER_BIT_OFFSET(m->offset);\n\n\t\t/* if kflag set, int should be a regular int and\n\t\t * bit offset should be at byte boundary.\n\t\t */\n\t\treturn !bitfield_size &&\n\t\t       BITS_ROUNDUP_BYTES(bit_offset) == expected_offset &&\n\t\t       BITS_ROUNDUP_BYTES(nr_bits) == expected_size;\n\t}\n\n\tif (BTF_INT_OFFSET(int_data) ||\n\t    BITS_PER_BYTE_MASKED(m->offset) ||\n\t    BITS_ROUNDUP_BYTES(m->offset) != expected_offset ||\n\t    BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BITS_ROUNDUP_BYTES(nr_bits) != expected_size)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "btf_type_int_is_regular",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "746-763",
    "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "nr_bits"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "nr_bits"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "t"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "746-763",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "btf_type_by_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "731-740",
    "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
  },
  {
    "function_name": "btf_name_by_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "726-729",
    "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_str_by_offset",
          "args": [
            "btf",
            "offset"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "btf_str_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "669-679",
          "snippet": "static const char *btf_str_by_offset(const struct btf *btf, u32 offset)\n{\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\tif (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_str_by_offset(const struct btf *btf, u32 offset)\n{\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\tif (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
  },
  {
    "function_name": "__btf_name_by_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "715-724",
    "snippet": "static const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_str_by_offset",
          "args": [
            "btf",
            "offset"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "btf_str_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "669-679",
          "snippet": "static const char *btf_str_by_offset(const struct btf *btf, u32 offset)\n{\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\tif (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_str_by_offset(const struct btf *btf, u32 offset)\n{\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\tif (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}"
  },
  {
    "function_name": "btf_name_valid_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "710-713",
    "snippet": "static bool btf_name_valid_section(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, true);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_name_valid",
          "args": [
            "btf",
            "offset",
            "true"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "681-700",
          "snippet": "static bool __btf_name_valid(const struct btf *btf, u32 offset, bool dot_ok)\n{\n\t/* offset must be valid */\n\tconst char *src = btf_str_by_offset(btf, offset);\n\tconst char *src_limit;\n\n\tif (!__btf_name_char_ok(*src, true, dot_ok))\n\t\treturn false;\n\n\t/* set a limit on identifier length */\n\tsrc_limit = src + KSYM_NAME_LEN;\n\tsrc++;\n\twhile (*src && src < src_limit) {\n\t\tif (!__btf_name_char_ok(*src, false, dot_ok))\n\t\t\treturn false;\n\t\tsrc++;\n\t}\n\n\treturn !*src;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_name_valid(const struct btf *btf, u32 offset, bool dot_ok)\n{\n\t/* offset must be valid */\n\tconst char *src = btf_str_by_offset(btf, offset);\n\tconst char *src_limit;\n\n\tif (!__btf_name_char_ok(*src, true, dot_ok))\n\t\treturn false;\n\n\t/* set a limit on identifier length */\n\tsrc_limit = src + KSYM_NAME_LEN;\n\tsrc++;\n\twhile (*src && src < src_limit) {\n\t\tif (!__btf_name_char_ok(*src, false, dot_ok))\n\t\t\treturn false;\n\t\tsrc++;\n\t}\n\n\treturn !*src;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_valid_section(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, true);\n}"
  },
  {
    "function_name": "btf_name_valid_identifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "705-708",
    "snippet": "static bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_name_valid",
          "args": [
            "btf",
            "offset",
            "false"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "681-700",
          "snippet": "static bool __btf_name_valid(const struct btf *btf, u32 offset, bool dot_ok)\n{\n\t/* offset must be valid */\n\tconst char *src = btf_str_by_offset(btf, offset);\n\tconst char *src_limit;\n\n\tif (!__btf_name_char_ok(*src, true, dot_ok))\n\t\treturn false;\n\n\t/* set a limit on identifier length */\n\tsrc_limit = src + KSYM_NAME_LEN;\n\tsrc++;\n\twhile (*src && src < src_limit) {\n\t\tif (!__btf_name_char_ok(*src, false, dot_ok))\n\t\t\treturn false;\n\t\tsrc++;\n\t}\n\n\treturn !*src;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_name_valid(const struct btf *btf, u32 offset, bool dot_ok)\n{\n\t/* offset must be valid */\n\tconst char *src = btf_str_by_offset(btf, offset);\n\tconst char *src_limit;\n\n\tif (!__btf_name_char_ok(*src, true, dot_ok))\n\t\treturn false;\n\n\t/* set a limit on identifier length */\n\tsrc_limit = src + KSYM_NAME_LEN;\n\tsrc++;\n\twhile (*src && src < src_limit) {\n\t\tif (!__btf_name_char_ok(*src, false, dot_ok))\n\t\t\treturn false;\n\t\tsrc++;\n\t}\n\n\treturn !*src;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}"
  },
  {
    "function_name": "__btf_name_valid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "681-700",
    "snippet": "static bool __btf_name_valid(const struct btf *btf, u32 offset, bool dot_ok)\n{\n\t/* offset must be valid */\n\tconst char *src = btf_str_by_offset(btf, offset);\n\tconst char *src_limit;\n\n\tif (!__btf_name_char_ok(*src, true, dot_ok))\n\t\treturn false;\n\n\t/* set a limit on identifier length */\n\tsrc_limit = src + KSYM_NAME_LEN;\n\tsrc++;\n\twhile (*src && src < src_limit) {\n\t\tif (!__btf_name_char_ok(*src, false, dot_ok))\n\t\t\treturn false;\n\t\tsrc++;\n\t}\n\n\treturn !*src;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_name_char_ok",
          "args": [
            "*src",
            "false",
            "dot_ok"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_name_char_ok",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "658-667",
          "snippet": "static bool __btf_name_char_ok(char c, bool first, bool dot_ok)\n{\n\tif ((first ? !isalpha(c) :\n\t\t     !isalnum(c)) &&\n\t    c != '_' &&\n\t    ((c == '.' && !dot_ok) ||\n\t      c != '.'))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_name_char_ok(char c, bool first, bool dot_ok)\n{\n\tif ((first ? !isalpha(c) :\n\t\t     !isalnum(c)) &&\n\t    c != '_' &&\n\t    ((c == '.' && !dot_ok) ||\n\t      c != '.'))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_str_by_offset",
          "args": [
            "btf",
            "offset"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "btf_str_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "669-679",
          "snippet": "static const char *btf_str_by_offset(const struct btf *btf, u32 offset)\n{\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\tif (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_str_by_offset(const struct btf *btf, u32 offset)\n{\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\tif (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_name_valid(const struct btf *btf, u32 offset, bool dot_ok)\n{\n\t/* offset must be valid */\n\tconst char *src = btf_str_by_offset(btf, offset);\n\tconst char *src_limit;\n\n\tif (!__btf_name_char_ok(*src, true, dot_ok))\n\t\treturn false;\n\n\t/* set a limit on identifier length */\n\tsrc_limit = src + KSYM_NAME_LEN;\n\tsrc++;\n\twhile (*src && src < src_limit) {\n\t\tif (!__btf_name_char_ok(*src, false, dot_ok))\n\t\t\treturn false;\n\t\tsrc++;\n\t}\n\n\treturn !*src;\n}"
  },
  {
    "function_name": "btf_str_by_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "669-679",
    "snippet": "static const char *btf_str_by_offset(const struct btf *btf, u32 offset)\n{\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\tif (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_str_by_offset(const struct btf *btf, u32 offset)\n{\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\tif (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "__btf_name_char_ok",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "658-667",
    "snippet": "static bool __btf_name_char_ok(char c, bool first, bool dot_ok)\n{\n\tif ((first ? !isalpha(c) :\n\t\t     !isalnum(c)) &&\n\t    c != '_' &&\n\t    ((c == '.' && !dot_ok) ||\n\t      c != '.'))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "c"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "c"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_name_char_ok(char c, bool first, bool dot_ok)\n{\n\tif ((first ? !isalpha(c) :\n\t\t     !isalnum(c)) &&\n\t    c != '_' &&\n\t    ((c == '.' && !dot_ok) ||\n\t      c != '.'))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "btf_name_offset_valid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "646-656",
    "snippet": "static bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\tif (!BTF_STR_OFFSET_VALID(offset))\n\t\treturn false;\n\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\treturn offset < btf->hdr.str_len;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_STR_OFFSET_VALID",
          "args": [
            "offset"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\tif (!BTF_STR_OFFSET_VALID(offset))\n\t\treturn false;\n\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\treturn offset < btf->hdr.str_len;\n}"
  },
  {
    "function_name": "btf_type_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "641-644",
    "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
      "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n\t[BTF_KIND_FLOAT] = &float_ops,\n\t[BTF_KIND_DECL_TAG] = &decl_tag_ops,\n\t[BTF_KIND_TYPE_TAG] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
  },
  {
    "function_name": "btf_type_decl_tag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "636-639",
    "snippet": "static const struct btf_decl_tag *btf_type_decl_tag(const struct btf_type *t)\n{\n\treturn (const struct btf_decl_tag *)(t + 1);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_decl_tag *btf_type_decl_tag(const struct btf_type *t)\n{\n\treturn (const struct btf_decl_tag *)(t + 1);\n}"
  },
  {
    "function_name": "btf_type_var",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "631-634",
    "snippet": "static const struct btf_var *btf_type_var(const struct btf_type *t)\n{\n\treturn (const struct btf_var *)(t + 1);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_var *btf_type_var(const struct btf_type *t)\n{\n\treturn (const struct btf_var *)(t + 1);\n}"
  },
  {
    "function_name": "btf_type_enum",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "626-629",
    "snippet": "static const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}"
  },
  {
    "function_name": "btf_type_array",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "621-624",
    "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
  },
  {
    "function_name": "btf_type_int",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "616-619",
    "snippet": "static u32 btf_type_int(const struct btf_type *t)\n{\n\treturn *(u32 *)(t + 1);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic u32 btf_type_int(const struct btf_type *t)\n{\n\treturn *(u32 *)(t + 1);\n}"
  },
  {
    "function_name": "btf_int_encoding_str",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "602-614",
    "snippet": "static const char *btf_int_encoding_str(u8 encoding)\n{\n\tif (encoding == 0)\n\t\treturn \"(none)\";\n\telse if (encoding == BTF_INT_SIGNED)\n\t\treturn \"SIGNED\";\n\telse if (encoding == BTF_INT_CHAR)\n\t\treturn \"CHAR\";\n\telse if (encoding == BTF_INT_BOOL)\n\t\treturn \"BOOL\";\n\telse\n\t\treturn \"UNKN\";\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_int_encoding_str(u8 encoding)\n{\n\tif (encoding == 0)\n\t\treturn \"(none)\";\n\telse if (encoding == BTF_INT_SIGNED)\n\t\treturn \"SIGNED\";\n\telse if (encoding == BTF_INT_CHAR)\n\t\treturn \"CHAR\";\n\telse if (encoding == BTF_INT_BOOL)\n\t\treturn \"BOOL\";\n\telse\n\t\treturn \"UNKN\";\n}"
  },
  {
    "function_name": "btf_type_has_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "587-600",
    "snippet": "static bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_DATASEC:\n\tcase BTF_KIND_FLOAT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_DATASEC:\n\tcase BTF_KIND_FLOAT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "btf_type_needs_resolve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "575-584",
    "snippet": "static bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t       btf_type_is_ptr(t) ||\n\t       btf_type_is_struct(t) ||\n\t       btf_type_is_array(t) ||\n\t       btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_datasec",
          "args": [
            "t"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_datasec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "461-464",
          "snippet": "static bool btf_type_is_datasec(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DATASEC;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_datasec(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DATASEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_decl_tag",
          "args": [
            "t"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_decl_tag_target",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "471-475",
          "snippet": "static bool btf_type_is_decl_tag_target(const struct btf_type *t)\n{\n\treturn btf_type_is_func(t) || btf_type_is_struct(t) ||\n\t       btf_type_is_var(t) || btf_type_is_typedef(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_decl_tag_target(const struct btf_type *t)\n{\n\treturn btf_type_is_func(t) || btf_type_is_struct(t) ||\n\t       btf_type_is_var(t) || btf_type_is_typedef(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_var",
          "args": [
            "t"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "t"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "456-459",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "t"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "t"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t       btf_type_is_ptr(t) ||\n\t       btf_type_is_struct(t) ||\n\t       btf_type_is_array(t) ||\n\t       btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}"
  },
  {
    "function_name": "btf_type_is_resolve_source_only",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "552-557",
    "snippet": "static bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_datasec",
          "args": [
            "t"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_datasec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "461-464",
          "snippet": "static bool btf_type_is_datasec(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DATASEC;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_datasec(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DATASEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_decl_tag",
          "args": [
            "t"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_decl_tag_target",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "471-475",
          "snippet": "static bool btf_type_is_decl_tag_target(const struct btf_type *t)\n{\n\treturn btf_type_is_func(t) || btf_type_is_struct(t) ||\n\t       btf_type_is_var(t) || btf_type_is_typedef(t);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_decl_tag_target(const struct btf_type *t)\n{\n\treturn btf_type_is_func(t) || btf_type_is_struct(t) ||\n\t       btf_type_is_var(t) || btf_type_is_typedef(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_var",
          "args": [
            "t"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_decl_tag(t) ||\n\t       btf_type_is_datasec(t);\n}"
  },
  {
    "function_name": "btf_type_resolve_func_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "537-547",
    "snippet": "const struct btf_type *btf_type_resolve_func_ptr(const struct btf *btf,\n\t\t\t\t\t\t u32 id, u32 *res_id)\n{\n\tconst struct btf_type *ptype;\n\n\tptype = btf_type_resolve_ptr(btf, id, res_id);\n\tif (ptype && btf_type_is_func_proto(ptype))\n\t\treturn ptype;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_func_proto",
          "args": [
            "ptype"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_resolve_ptr",
          "args": [
            "btf",
            "id",
            "res_id"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_resolve_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "525-535",
          "snippet": "const struct btf_type *btf_type_resolve_ptr(const struct btf *btf,\n\t\t\t\t\t    u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t;\n\n\tt = btf_type_skip_modifiers(btf, id, NULL);\n\tif (!btf_type_is_ptr(t))\n\t\treturn NULL;\n\n\treturn btf_type_skip_modifiers(btf, t->type, res_id);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_resolve_ptr(const struct btf *btf,\n\t\t\t\t\t    u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t;\n\n\tt = btf_type_skip_modifiers(btf, id, NULL);\n\tif (!btf_type_is_ptr(t))\n\t\treturn NULL;\n\n\treturn btf_type_skip_modifiers(btf, t->type, res_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_resolve_func_ptr(const struct btf *btf,\n\t\t\t\t\t\t u32 id, u32 *res_id)\n{\n\tconst struct btf_type *ptype;\n\n\tptype = btf_type_resolve_ptr(btf, id, res_id);\n\tif (ptype && btf_type_is_func_proto(ptype))\n\t\treturn ptype;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "btf_type_resolve_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "525-535",
    "snippet": "const struct btf_type *btf_type_resolve_ptr(const struct btf *btf,\n\t\t\t\t\t    u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t;\n\n\tt = btf_type_skip_modifiers(btf, id, NULL);\n\tif (!btf_type_is_ptr(t))\n\t\treturn NULL;\n\n\treturn btf_type_skip_modifiers(btf, t->type, res_id);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_skip_modifiers",
          "args": [
            "btf",
            "t->type",
            "res_id"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_skip_modifiers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "509-523",
          "snippet": "const struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_resolve_ptr(const struct btf *btf,\n\t\t\t\t\t    u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t;\n\n\tt = btf_type_skip_modifiers(btf, id, NULL);\n\tif (!btf_type_is_ptr(t))\n\t\treturn NULL;\n\n\treturn btf_type_skip_modifiers(btf, t->type, res_id);\n}"
  },
  {
    "function_name": "btf_type_skip_modifiers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "509-523",
    "snippet": "const struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "t->type"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "t"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "406-428",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}"
  },
  {
    "function_name": "btf_find_by_name_kind",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "489-507",
    "snippet": "s32 btf_find_by_name_kind(const struct btf *btf, const char *name, u8 kind)\n{\n\tconst struct btf_type *t;\n\tconst char *tname;\n\tu32 i, total;\n\n\ttotal = btf_nr_types(btf);\n\tfor (i = 1; i < total; i++) {\n\t\tt = btf_type_by_id(btf, i);\n\t\tif (BTF_INFO_KIND(t->info) != kind)\n\t\t\tcontinue;\n\n\t\ttname = btf_name_by_offset(btf, t->name_off);\n\t\tif (!strcmp(tname, name))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tname",
            "name"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "btf",
            "t->name_off"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "726-729",
          "snippet": "const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "i"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "731-740",
          "snippet": "const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_nr_types",
          "args": [
            "btf"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "btf_nr_types",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "477-487",
          "snippet": "u32 btf_nr_types(const struct btf *btf)\n{\n\tu32 total = 0;\n\n\twhile (btf) {\n\t\ttotal += btf->nr_types;\n\t\tbtf = btf->base_btf;\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nu32 btf_nr_types(const struct btf *btf)\n{\n\tu32 total = 0;\n\n\twhile (btf) {\n\t\ttotal += btf->nr_types;\n\t\tbtf = btf->base_btf;\n\t}\n\n\treturn total;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\ns32 btf_find_by_name_kind(const struct btf *btf, const char *name, u8 kind)\n{\n\tconst struct btf_type *t;\n\tconst char *tname;\n\tu32 i, total;\n\n\ttotal = btf_nr_types(btf);\n\tfor (i = 1; i < total; i++) {\n\t\tt = btf_type_by_id(btf, i);\n\t\tif (BTF_INFO_KIND(t->info) != kind)\n\t\t\tcontinue;\n\n\t\ttname = btf_name_by_offset(btf, t->name_off);\n\t\tif (!strcmp(tname, name))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "btf_nr_types",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "477-487",
    "snippet": "u32 btf_nr_types(const struct btf *btf)\n{\n\tu32 total = 0;\n\n\twhile (btf) {\n\t\ttotal += btf->nr_types;\n\t\tbtf = btf->base_btf;\n\t}\n\n\treturn total;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nu32 btf_nr_types(const struct btf *btf)\n{\n\tu32 total = 0;\n\n\twhile (btf) {\n\t\ttotal += btf->nr_types;\n\t\tbtf = btf->base_btf;\n\t}\n\n\treturn total;\n}"
  },
  {
    "function_name": "btf_type_is_decl_tag_target",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "471-475",
    "snippet": "static bool btf_type_is_decl_tag_target(const struct btf_type *t)\n{\n\treturn btf_type_is_func(t) || btf_type_is_struct(t) ||\n\t       btf_type_is_var(t) || btf_type_is_typedef(t);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_typedef",
          "args": [
            "t"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_var",
          "args": [
            "t"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "t"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_type_is_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "451-454",
          "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_func",
          "args": [
            "t"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_decl_tag_target(const struct btf_type *t)\n{\n\treturn btf_type_is_func(t) || btf_type_is_struct(t) ||\n\t       btf_type_is_var(t) || btf_type_is_typedef(t);\n}"
  },
  {
    "function_name": "btf_type_is_decl_tag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "466-469",
    "snippet": "static bool btf_type_is_decl_tag(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DECL_TAG;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_decl_tag(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DECL_TAG;\n}"
  },
  {
    "function_name": "btf_type_is_datasec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "461-464",
    "snippet": "static bool btf_type_is_datasec(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DATASEC;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_datasec(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DATASEC;\n}"
  },
  {
    "function_name": "btf_type_is_array",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "456-459",
    "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
  },
  {
    "function_name": "__btf_type_is_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "451-454",
    "snippet": "static bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}"
  },
  {
    "function_name": "btf_type_nosize_or_null",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "446-449",
    "snippet": "static bool btf_type_nosize_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_nosize(t);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_nosize",
          "args": [
            "t"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_nosize_or_null",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "446-449",
          "snippet": "static bool btf_type_nosize_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_nosize(t);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_nosize_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_nosize(t);\n}"
  },
  {
    "function_name": "btf_type_nosize",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "440-444",
    "snippet": "static bool btf_type_nosize(const struct btf_type *t)\n{\n\treturn btf_type_is_void(t) || btf_type_is_fwd(t) ||\n\t       btf_type_is_func(t) || btf_type_is_func_proto(t);\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_func_proto",
          "args": [
            "t"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_func",
          "args": [
            "t"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_fwd",
          "args": [
            "t"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_fwd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "435-438",
          "snippet": "static bool btf_type_is_fwd(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_FWD;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_fwd(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_FWD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_void",
          "args": [
            "t"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_void",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "430-433",
          "snippet": "bool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btf_type btf_void;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nbool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_nosize(const struct btf_type *t)\n{\n\treturn btf_type_is_void(t) || btf_type_is_fwd(t) ||\n\t       btf_type_is_func(t) || btf_type_is_func_proto(t);\n}"
  },
  {
    "function_name": "btf_type_is_fwd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "435-438",
    "snippet": "static bool btf_type_is_fwd(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_FWD;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_fwd(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_FWD;\n}"
  },
  {
    "function_name": "btf_type_is_void",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "430-433",
    "snippet": "bool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct btf_type btf_void;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nbool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}"
  },
  {
    "function_name": "btf_type_is_modifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "406-428",
    "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\tcase BTF_KIND_TYPE_TAG:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "btf_type_str",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
    "lines": "289-292",
    "snippet": "const char *btf_type_str(const struct btf_type *t)\n{\n\treturn btf_kind_str[BTF_INFO_KIND(t->info)];\n}",
    "includes": [
      "#include <linux/bpf_types.h>",
      "#include \"../tools/lib/bpf/relo_core.h\"",
      "#include <net/sock.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/skmsg.h>",
      "#include <linux/btf_ids.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/bpf_perf_event.h>",
      "#include <uapi/linux/bpf.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n\t[BTF_KIND_FLOAT]\t= \"FLOAT\",\n\t[BTF_KIND_DECL_TAG]\t= \"DECL_TAG\",\n\t[BTF_KIND_TYPE_TAG]\t= \"TYPE_TAG\",\n};\n\nconst char *btf_type_str(const struct btf_type *t)\n{\n\treturn btf_kind_str[BTF_INFO_KIND(t->info)];\n}"
  }
]