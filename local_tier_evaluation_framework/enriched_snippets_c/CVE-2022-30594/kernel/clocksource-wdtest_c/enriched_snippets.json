[
  {
    "function_name": "clocksource_wdtest_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource-wdtest.c",
    "lines": "182-198",
    "snippet": "static int __init clocksource_wdtest_init(void)\n{\n\tint ret = 0;\n\n\twdtest_print_module_parms();\n\n\t/* Create watchdog-test task. */\n\twdtest_task = kthread_run(wdtest_func, NULL, \"wdtest\");\n\tif (IS_ERR(wdtest_task)) {\n\t\tret = PTR_ERR(wdtest_task);\n\t\tpr_warn(\"%s: Failed to create wdtest kthread.\\n\", __func__);\n\t\twdtest_task = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *wdtest_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failed to create wdtest kthread.\\n\"",
            "__func__"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "wdtest_task"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "wdtest_task"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "wdtest_func",
            "NULL",
            "\"wdtest\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdtest_print_module_parms",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "wdtest_print_module_parms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource-wdtest.c",
          "lines": "172-175",
          "snippet": "static void wdtest_print_module_parms(void)\n{\n\tpr_alert(\"--- holdoff=%d\\n\", holdoff);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int holdoff = IS_BUILTIN(CONFIG_TEST_CLOCKSOURCE_WATCHDOG) ? 10 : 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int holdoff = IS_BUILTIN(CONFIG_TEST_CLOCKSOURCE_WATCHDOG) ? 10 : 0;\n\nstatic void wdtest_print_module_parms(void)\n{\n\tpr_alert(\"--- holdoff=%d\\n\", holdoff);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct task_struct *wdtest_task;\n\nstatic int __init clocksource_wdtest_init(void)\n{\n\tint ret = 0;\n\n\twdtest_print_module_parms();\n\n\t/* Create watchdog-test task. */\n\twdtest_task = kthread_run(wdtest_func, NULL, \"wdtest\");\n\tif (IS_ERR(wdtest_task)) {\n\t\tret = PTR_ERR(wdtest_task);\n\t\tpr_warn(\"%s: Failed to create wdtest kthread.\\n\", __func__);\n\t\twdtest_task = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "clocksource_wdtest_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource-wdtest.c",
    "lines": "178-180",
    "snippet": "static void clocksource_wdtest_cleanup(void)\n{\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_wdtest_cleanup(void)\n{\n}"
  },
  {
    "function_name": "wdtest_print_module_parms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource-wdtest.c",
    "lines": "172-175",
    "snippet": "static void wdtest_print_module_parms(void)\n{\n\tpr_alert(\"--- holdoff=%d\\n\", holdoff);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int holdoff = IS_BUILTIN(CONFIG_TEST_CLOCKSOURCE_WATCHDOG) ? 10 : 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"--- holdoff=%d\\n\"",
            "holdoff"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int holdoff = IS_BUILTIN(CONFIG_TEST_CLOCKSOURCE_WATCHDOG) ? 10 : 0;\n\nstatic void wdtest_print_module_parms(void)\n{\n\tpr_alert(\"--- holdoff=%d\\n\", holdoff);\n}"
  },
  {
    "function_name": "wdtest_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource-wdtest.c",
    "lines": "104-170",
    "snippet": "static int wdtest_func(void *arg)\n{\n\tunsigned long j1, j2;\n\tchar *s;\n\tint i;\n\n\tschedule_timeout_uninterruptible(holdoff * HZ);\n\n\t/*\n\t * Verify that jiffies-like clocksources get the manually\n\t * specified uncertainty margin.\n\t */\n\tpr_info(\"--- Verify jiffies-like uncertainty margin.\\n\");\n\t__clocksource_register(&clocksource_wdtest_jiffies);\n\tWARN_ON_ONCE(clocksource_wdtest_jiffies.uncertainty_margin != TICK_NSEC);\n\n\tj1 = clocksource_wdtest_jiffies.read(&clocksource_wdtest_jiffies);\n\tschedule_timeout_uninterruptible(HZ);\n\tj2 = clocksource_wdtest_jiffies.read(&clocksource_wdtest_jiffies);\n\tWARN_ON_ONCE(j1 == j2);\n\n\tclocksource_unregister(&clocksource_wdtest_jiffies);\n\n\t/*\n\t * Verify that tsc-like clocksources are assigned a reasonable\n\t * uncertainty margin.\n\t */\n\tpr_info(\"--- Verify tsc-like uncertainty margin.\\n\");\n\tclocksource_register_khz(&clocksource_wdtest_ktime, 1000 * 1000);\n\tWARN_ON_ONCE(clocksource_wdtest_ktime.uncertainty_margin < NSEC_PER_USEC);\n\n\tj1 = clocksource_wdtest_ktime.read(&clocksource_wdtest_ktime);\n\tudelay(1);\n\tj2 = clocksource_wdtest_ktime.read(&clocksource_wdtest_ktime);\n\tpr_info(\"--- tsc-like times: %lu - %lu = %lu.\\n\", j2, j1, j2 - j1);\n\tWARN_ON_ONCE(time_before(j2, j1 + NSEC_PER_USEC));\n\n\t/* Verify tsc-like stability with various numbers of errors injected. */\n\tfor (i = 0; i <= max_cswd_read_retries + 1; i++) {\n\t\tif (i <= 1 && i < max_cswd_read_retries)\n\t\t\ts = \"\";\n\t\telse if (i <= max_cswd_read_retries)\n\t\t\ts = \", expect message\";\n\t\telse\n\t\t\ts = \", expect clock skew\";\n\t\tpr_info(\"--- Watchdog with %dx error injection, %lu retries%s.\\n\", i, max_cswd_read_retries, s);\n\t\tWRITE_ONCE(wdtest_ktime_read_ndelays, i);\n\t\tschedule_timeout_uninterruptible(2 * HZ);\n\t\tWARN_ON_ONCE(READ_ONCE(wdtest_ktime_read_ndelays));\n\t\tWARN_ON_ONCE((i <= max_cswd_read_retries) !=\n\t\t\t     !(clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE));\n\t\twdtest_ktime_clocksource_reset();\n\t}\n\n\t/* Verify tsc-like stability with clock-value-fuzz error injection. */\n\tpr_info(\"--- Watchdog clock-value-fuzz error injection, expect clock skew and per-CPU mismatches.\\n\");\n\tWRITE_ONCE(wdtest_ktime_read_fuzz, true);\n\tschedule_timeout_uninterruptible(2 * HZ);\n\tWARN_ON_ONCE(!(clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE));\n\tclocksource_verify_percpu(&clocksource_wdtest_ktime);\n\tWRITE_ONCE(wdtest_ktime_read_fuzz, false);\n\n\tclocksource_unregister(&clocksource_wdtest_ktime);\n\n\tpr_info(\"--- Done with test.\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int holdoff = IS_BUILTIN(CONFIG_TEST_CLOCKSOURCE_WATCHDOG) ? 10 : 0;",
      "static struct clocksource clocksource_wdtest_jiffies = {\n\t.name\t\t\t= \"wdtest-jiffies\",\n\t.rating\t\t\t= 1, /* lowest valid rating*/\n\t.uncertainty_margin\t= TICK_NSEC,\n\t.read\t\t\t= wdtest_jiffies_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(32),\n\t.flags\t\t\t= CLOCK_SOURCE_MUST_VERIFY,\n\t.mult\t\t\t= TICK_NSEC << JIFFIES_SHIFT, /* details above */\n\t.shift\t\t\t= JIFFIES_SHIFT,\n\t.max_cycles\t\t= 10,\n};",
      "static int wdtest_ktime_read_ndelays;",
      "static bool wdtest_ktime_read_fuzz;",
      "static struct clocksource clocksource_wdtest_ktime = {\n\t.name\t\t\t= \"wdtest-ktime\",\n\t.rating\t\t\t= 300,\n\t.read\t\t\t= wdtest_ktime_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(64),\n\t.flags\t\t\t= KTIME_FLAGS,\n\t.mark_unstable\t\t= wdtest_ktime_cs_mark_unstable,\n\t.list\t\t\t= LIST_HEAD_INIT(clocksource_wdtest_ktime.list),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"--- Done with test.\\n\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_unregister",
          "args": [
            "&clocksource_wdtest_ktime"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1254-1263",
          "snippet": "int clocksource_unregister(struct clocksource *cs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tif (!list_empty(&cs->list))\n\t\tret = clocksource_unbind(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(clocksource_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nint clocksource_unregister(struct clocksource *cs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tif (!list_empty(&cs->list))\n\t\tret = clocksource_unbind(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "wdtest_ktime_read_fuzz",
            "false"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_verify_percpu",
          "args": [
            "&clocksource_wdtest_ktime"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_verify_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "326-378",
          "snippet": "void clocksource_verify_percpu(struct clocksource *cs)\n{\n\tint64_t cs_nsec, cs_nsec_max = 0, cs_nsec_min = LLONG_MAX;\n\tu64 csnow_begin, csnow_end;\n\tint cpu, testcpu;\n\ts64 delta;\n\n\tif (verify_n_cpus == 0)\n\t\treturn;\n\tcpumask_clear(&cpus_ahead);\n\tcpumask_clear(&cpus_behind);\n\tcpus_read_lock();\n\tpreempt_disable();\n\tclocksource_verify_choose_cpus();\n\tif (cpumask_weight(&cpus_chosen) == 0) {\n\t\tpreempt_enable();\n\t\tcpus_read_unlock();\n\t\tpr_warn(\"Not enough CPUs to check clocksource '%s'.\\n\", cs->name);\n\t\treturn;\n\t}\n\ttestcpu = smp_processor_id();\n\tpr_warn(\"Checking clocksource %s synchronization from CPU %d to CPUs %*pbl.\\n\", cs->name, testcpu, cpumask_pr_args(&cpus_chosen));\n\tfor_each_cpu(cpu, &cpus_chosen) {\n\t\tif (cpu == testcpu)\n\t\t\tcontinue;\n\t\tcsnow_begin = cs->read(cs);\n\t\tsmp_call_function_single(cpu, clocksource_verify_one_cpu, cs, 1);\n\t\tcsnow_end = cs->read(cs);\n\t\tdelta = (s64)((csnow_mid - csnow_begin) & cs->mask);\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_behind);\n\t\tdelta = (csnow_end - csnow_mid) & cs->mask;\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_ahead);\n\t\tdelta = clocksource_delta(csnow_end, csnow_begin, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\tif (cs_nsec > cs_nsec_max)\n\t\t\tcs_nsec_max = cs_nsec;\n\t\tif (cs_nsec < cs_nsec_min)\n\t\t\tcs_nsec_min = cs_nsec;\n\t}\n\tpreempt_enable();\n\tcpus_read_unlock();\n\tif (!cpumask_empty(&cpus_ahead))\n\t\tpr_warn(\"        CPUs %*pbl ahead of CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_ahead), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPUs %*pbl behind CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_behind), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_ahead) || !cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPU %d check durations %lldns - %lldns for clocksource %s.\\n\",\n\t\t\ttestcpu, cs_nsec_min, cs_nsec_max, cs->name);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid clocksource_verify_percpu(struct clocksource *cs)\n{\n\tint64_t cs_nsec, cs_nsec_max = 0, cs_nsec_min = LLONG_MAX;\n\tu64 csnow_begin, csnow_end;\n\tint cpu, testcpu;\n\ts64 delta;\n\n\tif (verify_n_cpus == 0)\n\t\treturn;\n\tcpumask_clear(&cpus_ahead);\n\tcpumask_clear(&cpus_behind);\n\tcpus_read_lock();\n\tpreempt_disable();\n\tclocksource_verify_choose_cpus();\n\tif (cpumask_weight(&cpus_chosen) == 0) {\n\t\tpreempt_enable();\n\t\tcpus_read_unlock();\n\t\tpr_warn(\"Not enough CPUs to check clocksource '%s'.\\n\", cs->name);\n\t\treturn;\n\t}\n\ttestcpu = smp_processor_id();\n\tpr_warn(\"Checking clocksource %s synchronization from CPU %d to CPUs %*pbl.\\n\", cs->name, testcpu, cpumask_pr_args(&cpus_chosen));\n\tfor_each_cpu(cpu, &cpus_chosen) {\n\t\tif (cpu == testcpu)\n\t\t\tcontinue;\n\t\tcsnow_begin = cs->read(cs);\n\t\tsmp_call_function_single(cpu, clocksource_verify_one_cpu, cs, 1);\n\t\tcsnow_end = cs->read(cs);\n\t\tdelta = (s64)((csnow_mid - csnow_begin) & cs->mask);\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_behind);\n\t\tdelta = (csnow_end - csnow_mid) & cs->mask;\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_ahead);\n\t\tdelta = clocksource_delta(csnow_end, csnow_begin, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\tif (cs_nsec > cs_nsec_max)\n\t\t\tcs_nsec_max = cs_nsec;\n\t\tif (cs_nsec < cs_nsec_min)\n\t\t\tcs_nsec_min = cs_nsec;\n\t}\n\tpreempt_enable();\n\tcpus_read_unlock();\n\tif (!cpumask_empty(&cpus_ahead))\n\t\tpr_warn(\"        CPUs %*pbl ahead of CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_ahead), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPUs %*pbl behind CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_behind), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_ahead) || !cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPU %d check durations %lldns - %lldns for clocksource %s.\\n\",\n\t\t\ttestcpu, cs_nsec_min, cs_nsec_max, cs->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "2 * HZ"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "wdtest_ktime_read_fuzz",
            "true"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"--- Watchdog clock-value-fuzz error injection, expect clock skew and per-CPU mismatches.\\n\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdtest_ktime_clocksource_reset",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "wdtest_ktime_clocksource_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource-wdtest.c",
          "lines": "93-101",
          "snippet": "static void wdtest_ktime_clocksource_reset(void)\n{\n\tif (clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE) {\n\t\tclocksource_unregister(&clocksource_wdtest_ktime);\n\t\tclocksource_wdtest_ktime.flags = KTIME_FLAGS;\n\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t\tclocksource_register_khz(&clocksource_wdtest_ktime, 1000 * 1000);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [
            "#define KTIME_FLAGS (CLOCK_SOURCE_IS_CONTINUOUS | \\\n\t\t     CLOCK_SOURCE_VALID_FOR_HRES | \\\n\t\t     CLOCK_SOURCE_MUST_VERIFY | \\\n\t\t     CLOCK_SOURCE_VERIFY_PERCPU)"
          ],
          "globals_used": [
            "static struct clocksource clocksource_wdtest_ktime = {\n\t.name\t\t\t= \"wdtest-ktime\",\n\t.rating\t\t\t= 300,\n\t.read\t\t\t= wdtest_ktime_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(64),\n\t.flags\t\t\t= KTIME_FLAGS,\n\t.mark_unstable\t\t= wdtest_ktime_cs_mark_unstable,\n\t.list\t\t\t= LIST_HEAD_INIT(clocksource_wdtest_ktime.list),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define KTIME_FLAGS (CLOCK_SOURCE_IS_CONTINUOUS | \\\n\t\t     CLOCK_SOURCE_VALID_FOR_HRES | \\\n\t\t     CLOCK_SOURCE_MUST_VERIFY | \\\n\t\t     CLOCK_SOURCE_VERIFY_PERCPU)\n\nstatic struct clocksource clocksource_wdtest_ktime = {\n\t.name\t\t\t= \"wdtest-ktime\",\n\t.rating\t\t\t= 300,\n\t.read\t\t\t= wdtest_ktime_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(64),\n\t.flags\t\t\t= KTIME_FLAGS,\n\t.mark_unstable\t\t= wdtest_ktime_cs_mark_unstable,\n\t.list\t\t\t= LIST_HEAD_INIT(clocksource_wdtest_ktime.list),\n};\n\nstatic void wdtest_ktime_clocksource_reset(void)\n{\n\tif (clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE) {\n\t\tclocksource_unregister(&clocksource_wdtest_ktime);\n\t\tclocksource_wdtest_ktime.flags = KTIME_FLAGS;\n\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t\tclocksource_register_khz(&clocksource_wdtest_ktime, 1000 * 1000);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(i <= max_cswd_read_retries) !=\n\t\t\t     !(clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE)"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "READ_ONCE(wdtest_ktime_read_ndelays)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "wdtest_ktime_read_ndelays"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "wdtest_ktime_read_ndelays",
            "i"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"--- Watchdog with %dx error injection, %lu retries%s.\\n\"",
            "i",
            "max_cswd_read_retries",
            "s"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "time_before(j2, j1 + NSEC_PER_USEC)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j2",
            "j1 + NSEC_PER_USEC"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"--- tsc-like times: %lu - %lu = %lu.\\n\"",
            "j2",
            "j1",
            "j2 - j1"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_wdtest_ktime.read",
          "args": [
            "&clocksource_wdtest_ktime"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_wdtest_ktime.read",
          "args": [
            "&clocksource_wdtest_ktime"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "clocksource_wdtest_ktime.uncertainty_margin < NSEC_PER_USEC"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_register_khz",
          "args": [
            "&clocksource_wdtest_ktime",
            "1000 * 1000"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"--- Verify tsc-like uncertainty margin.\\n\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "j1 == j2"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_wdtest_jiffies.read",
          "args": [
            "&clocksource_wdtest_jiffies"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_wdtest_jiffies.read",
          "args": [
            "&clocksource_wdtest_jiffies"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "clocksource_wdtest_jiffies.uncertainty_margin != TICK_NSEC"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clocksource_register",
          "args": [
            "&clocksource_wdtest_jiffies"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"--- Verify jiffies-like uncertainty margin.\\n\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int holdoff = IS_BUILTIN(CONFIG_TEST_CLOCKSOURCE_WATCHDOG) ? 10 : 0;\nstatic struct clocksource clocksource_wdtest_jiffies = {\n\t.name\t\t\t= \"wdtest-jiffies\",\n\t.rating\t\t\t= 1, /* lowest valid rating*/\n\t.uncertainty_margin\t= TICK_NSEC,\n\t.read\t\t\t= wdtest_jiffies_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(32),\n\t.flags\t\t\t= CLOCK_SOURCE_MUST_VERIFY,\n\t.mult\t\t\t= TICK_NSEC << JIFFIES_SHIFT, /* details above */\n\t.shift\t\t\t= JIFFIES_SHIFT,\n\t.max_cycles\t\t= 10,\n};\nstatic int wdtest_ktime_read_ndelays;\nstatic bool wdtest_ktime_read_fuzz;\nstatic struct clocksource clocksource_wdtest_ktime = {\n\t.name\t\t\t= \"wdtest-ktime\",\n\t.rating\t\t\t= 300,\n\t.read\t\t\t= wdtest_ktime_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(64),\n\t.flags\t\t\t= KTIME_FLAGS,\n\t.mark_unstable\t\t= wdtest_ktime_cs_mark_unstable,\n\t.list\t\t\t= LIST_HEAD_INIT(clocksource_wdtest_ktime.list),\n};\n\nstatic int wdtest_func(void *arg)\n{\n\tunsigned long j1, j2;\n\tchar *s;\n\tint i;\n\n\tschedule_timeout_uninterruptible(holdoff * HZ);\n\n\t/*\n\t * Verify that jiffies-like clocksources get the manually\n\t * specified uncertainty margin.\n\t */\n\tpr_info(\"--- Verify jiffies-like uncertainty margin.\\n\");\n\t__clocksource_register(&clocksource_wdtest_jiffies);\n\tWARN_ON_ONCE(clocksource_wdtest_jiffies.uncertainty_margin != TICK_NSEC);\n\n\tj1 = clocksource_wdtest_jiffies.read(&clocksource_wdtest_jiffies);\n\tschedule_timeout_uninterruptible(HZ);\n\tj2 = clocksource_wdtest_jiffies.read(&clocksource_wdtest_jiffies);\n\tWARN_ON_ONCE(j1 == j2);\n\n\tclocksource_unregister(&clocksource_wdtest_jiffies);\n\n\t/*\n\t * Verify that tsc-like clocksources are assigned a reasonable\n\t * uncertainty margin.\n\t */\n\tpr_info(\"--- Verify tsc-like uncertainty margin.\\n\");\n\tclocksource_register_khz(&clocksource_wdtest_ktime, 1000 * 1000);\n\tWARN_ON_ONCE(clocksource_wdtest_ktime.uncertainty_margin < NSEC_PER_USEC);\n\n\tj1 = clocksource_wdtest_ktime.read(&clocksource_wdtest_ktime);\n\tudelay(1);\n\tj2 = clocksource_wdtest_ktime.read(&clocksource_wdtest_ktime);\n\tpr_info(\"--- tsc-like times: %lu - %lu = %lu.\\n\", j2, j1, j2 - j1);\n\tWARN_ON_ONCE(time_before(j2, j1 + NSEC_PER_USEC));\n\n\t/* Verify tsc-like stability with various numbers of errors injected. */\n\tfor (i = 0; i <= max_cswd_read_retries + 1; i++) {\n\t\tif (i <= 1 && i < max_cswd_read_retries)\n\t\t\ts = \"\";\n\t\telse if (i <= max_cswd_read_retries)\n\t\t\ts = \", expect message\";\n\t\telse\n\t\t\ts = \", expect clock skew\";\n\t\tpr_info(\"--- Watchdog with %dx error injection, %lu retries%s.\\n\", i, max_cswd_read_retries, s);\n\t\tWRITE_ONCE(wdtest_ktime_read_ndelays, i);\n\t\tschedule_timeout_uninterruptible(2 * HZ);\n\t\tWARN_ON_ONCE(READ_ONCE(wdtest_ktime_read_ndelays));\n\t\tWARN_ON_ONCE((i <= max_cswd_read_retries) !=\n\t\t\t     !(clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE));\n\t\twdtest_ktime_clocksource_reset();\n\t}\n\n\t/* Verify tsc-like stability with clock-value-fuzz error injection. */\n\tpr_info(\"--- Watchdog clock-value-fuzz error injection, expect clock skew and per-CPU mismatches.\\n\");\n\tWRITE_ONCE(wdtest_ktime_read_fuzz, true);\n\tschedule_timeout_uninterruptible(2 * HZ);\n\tWARN_ON_ONCE(!(clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE));\n\tclocksource_verify_percpu(&clocksource_wdtest_ktime);\n\tWRITE_ONCE(wdtest_ktime_read_fuzz, false);\n\n\tclocksource_unregister(&clocksource_wdtest_ktime);\n\n\tpr_info(\"--- Done with test.\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "wdtest_ktime_clocksource_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource-wdtest.c",
    "lines": "93-101",
    "snippet": "static void wdtest_ktime_clocksource_reset(void)\n{\n\tif (clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE) {\n\t\tclocksource_unregister(&clocksource_wdtest_ktime);\n\t\tclocksource_wdtest_ktime.flags = KTIME_FLAGS;\n\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t\tclocksource_register_khz(&clocksource_wdtest_ktime, 1000 * 1000);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define KTIME_FLAGS (CLOCK_SOURCE_IS_CONTINUOUS | \\\n\t\t     CLOCK_SOURCE_VALID_FOR_HRES | \\\n\t\t     CLOCK_SOURCE_MUST_VERIFY | \\\n\t\t     CLOCK_SOURCE_VERIFY_PERCPU)"
    ],
    "globals_used": [
      "static struct clocksource clocksource_wdtest_ktime = {\n\t.name\t\t\t= \"wdtest-ktime\",\n\t.rating\t\t\t= 300,\n\t.read\t\t\t= wdtest_ktime_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(64),\n\t.flags\t\t\t= KTIME_FLAGS,\n\t.mark_unstable\t\t= wdtest_ktime_cs_mark_unstable,\n\t.list\t\t\t= LIST_HEAD_INIT(clocksource_wdtest_ktime.list),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_register_khz",
          "args": [
            "&clocksource_wdtest_ktime",
            "1000 * 1000"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "HZ / 10"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_unregister",
          "args": [
            "&clocksource_wdtest_ktime"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1254-1263",
          "snippet": "int clocksource_unregister(struct clocksource *cs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tif (!list_empty(&cs->list))\n\t\tret = clocksource_unbind(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(clocksource_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nint clocksource_unregister(struct clocksource *cs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tif (!list_empty(&cs->list))\n\t\tret = clocksource_unbind(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define KTIME_FLAGS (CLOCK_SOURCE_IS_CONTINUOUS | \\\n\t\t     CLOCK_SOURCE_VALID_FOR_HRES | \\\n\t\t     CLOCK_SOURCE_MUST_VERIFY | \\\n\t\t     CLOCK_SOURCE_VERIFY_PERCPU)\n\nstatic struct clocksource clocksource_wdtest_ktime = {\n\t.name\t\t\t= \"wdtest-ktime\",\n\t.rating\t\t\t= 300,\n\t.read\t\t\t= wdtest_ktime_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(64),\n\t.flags\t\t\t= KTIME_FLAGS,\n\t.mark_unstable\t\t= wdtest_ktime_cs_mark_unstable,\n\t.list\t\t\t= LIST_HEAD_INIT(clocksource_wdtest_ktime.list),\n};\n\nstatic void wdtest_ktime_clocksource_reset(void)\n{\n\tif (clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE) {\n\t\tclocksource_unregister(&clocksource_wdtest_ktime);\n\t\tclocksource_wdtest_ktime.flags = KTIME_FLAGS;\n\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t\tclocksource_register_khz(&clocksource_wdtest_ktime, 1000 * 1000);\n\t}\n}"
  },
  {
    "function_name": "wdtest_ktime_cs_mark_unstable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource-wdtest.c",
    "lines": "72-75",
    "snippet": "static void wdtest_ktime_cs_mark_unstable(struct clocksource *cs)\n{\n\tpr_info(\"--- Marking %s unstable due to clocksource watchdog.\\n\", cs->name);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"--- Marking %s unstable due to clocksource watchdog.\\n\"",
            "cs->name"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void wdtest_ktime_cs_mark_unstable(struct clocksource *cs)\n{\n\tpr_info(\"--- Marking %s unstable due to clocksource watchdog.\\n\", cs->name);\n}"
  },
  {
    "function_name": "wdtest_ktime_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource-wdtest.c",
    "lines": "54-70",
    "snippet": "static u64 wdtest_ktime_read(struct clocksource *cs)\n{\n\tint wkrn = READ_ONCE(wdtest_ktime_read_ndelays);\n\tstatic int sign = 1;\n\tu64 ret;\n\n\tif (wkrn) {\n\t\tudelay(cs->uncertainty_margin / 250);\n\t\tWRITE_ONCE(wdtest_ktime_read_ndelays, wkrn - 1);\n\t}\n\tret = ktime_get_real_fast_ns();\n\tif (READ_ONCE(wdtest_ktime_read_fuzz)) {\n\t\tsign = -sign;\n\t\tret = ret + sign * 100 * NSEC_PER_MSEC;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wdtest_ktime_read_ndelays;",
      "static bool wdtest_ktime_read_fuzz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "wdtest_ktime_read_fuzz"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_fast_ns",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "562-565",
          "snippet": "u64 ktime_get_real_fast_ns(void)\n{\n\treturn __ktime_get_real_fast(&tk_fast_mono, NULL);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_real_fast_ns(void)\n{\n\treturn __ktime_get_real_fast(&tk_fast_mono, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "wdtest_ktime_read_ndelays",
            "wkrn - 1"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "cs->uncertainty_margin / 250"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "wdtest_ktime_read_ndelays"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int wdtest_ktime_read_ndelays;\nstatic bool wdtest_ktime_read_fuzz;\n\nstatic u64 wdtest_ktime_read(struct clocksource *cs)\n{\n\tint wkrn = READ_ONCE(wdtest_ktime_read_ndelays);\n\tstatic int sign = 1;\n\tu64 ret;\n\n\tif (wkrn) {\n\t\tudelay(cs->uncertainty_margin / 250);\n\t\tWRITE_ONCE(wdtest_ktime_read_ndelays, wkrn - 1);\n\t}\n\tret = ktime_get_real_fast_ns();\n\tif (READ_ONCE(wdtest_ktime_read_fuzz)) {\n\t\tsign = -sign;\n\t\tret = ret + sign * 100 * NSEC_PER_MSEC;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "wdtest_jiffies_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource-wdtest.c",
    "lines": "34-37",
    "snippet": "static u64 wdtest_jiffies_read(struct clocksource *cs)\n{\n\treturn (u64)jiffies;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic u64 wdtest_jiffies_read(struct clocksource *cs)\n{\n\treturn (u64)jiffies;\n}"
  }
]