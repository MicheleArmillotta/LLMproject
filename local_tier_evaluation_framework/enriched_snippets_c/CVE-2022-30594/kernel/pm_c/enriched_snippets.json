[
  {
    "function_name": "resume_device_irqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
    "lines": "258-261",
    "snippet": "void resume_device_irqs(void)\n{\n\tresume_irqs(false);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/syscore_ops.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resume_irqs",
          "args": [
            "false"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "resume_irqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
          "lines": "184-203",
          "snippet": "static void resume_irqs(bool want_early)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tunsigned long flags;\n\t\tbool is_early = desc->action &&\n\t\t\tdesc->action->flags & IRQF_EARLY_RESUME;\n\n\t\tif (!is_early && want_early)\n\t\t\tcontinue;\n\t\tif (irq_settings_is_nested_thread(desc))\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tresume_irq(desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void resume_irqs(bool want_early)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tunsigned long flags;\n\t\tbool is_early = desc->action &&\n\t\t\tdesc->action->flags & IRQF_EARLY_RESUME;\n\n\t\tif (!is_early && want_early)\n\t\t\tcontinue;\n\t\tif (irq_settings_is_nested_thread(desc))\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tresume_irq(desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nvoid resume_device_irqs(void)\n{\n\tresume_irqs(false);\n}"
  },
  {
    "function_name": "irq_pm_init_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
    "lines": "243-247",
    "snippet": "static int __init irq_pm_init_ops(void)\n{\n\tregister_syscore_ops(&irq_pm_syscore_ops);\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/syscore_ops.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct syscore_ops irq_pm_syscore_ops = {\n\t.resume\t\t= irq_pm_syscore_resume,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_syscore_ops",
          "args": [
            "&irq_pm_syscore_ops"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic struct syscore_ops irq_pm_syscore_ops = {\n\t.resume\t\t= irq_pm_syscore_resume,\n};\n\nstatic int __init irq_pm_init_ops(void)\n{\n\tregister_syscore_ops(&irq_pm_syscore_ops);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_pm_syscore_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
    "lines": "234-237",
    "snippet": "static void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/syscore_ops.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resume_irqs",
          "args": [
            "true"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "resume_irqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
          "lines": "184-203",
          "snippet": "static void resume_irqs(bool want_early)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tunsigned long flags;\n\t\tbool is_early = desc->action &&\n\t\t\tdesc->action->flags & IRQF_EARLY_RESUME;\n\n\t\tif (!is_early && want_early)\n\t\t\tcontinue;\n\t\tif (irq_settings_is_nested_thread(desc))\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tresume_irq(desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void resume_irqs(bool want_early)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tunsigned long flags;\n\t\tbool is_early = desc->action &&\n\t\t\tdesc->action->flags & IRQF_EARLY_RESUME;\n\n\t\tif (!is_early && want_early)\n\t\t\tcontinue;\n\t\tif (irq_settings_is_nested_thread(desc))\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tresume_irq(desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}"
  },
  {
    "function_name": "rearm_wake_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
    "lines": "209-227",
    "snippet": "void rearm_wake_irq(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn;\n\n\tif (!(desc->istate & IRQS_SUSPENDED) ||\n\t    !irqd_is_wakeup_set(&desc->irq_data))\n\t\tgoto unlock;\n\n\tdesc->istate &= ~IRQS_SUSPENDED;\n\tirqd_set(&desc->irq_data, IRQD_WAKEUP_ARMED);\n\t__enable_irq(desc);\n\nunlock:\n\tirq_put_desc_busunlock(desc, flags);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/syscore_ops.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_put_desc_busunlock",
          "args": [
            "desc",
            "flags"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "irq_put_desc_busunlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "175-179",
          "snippet": "static inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__enable_irq",
          "args": [
            "desc"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__enable_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "769-795",
          "snippet": "void __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "&desc->irq_data",
            "IRQD_WAKEUP_ARMED"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_wakeup_set",
          "args": [
            "&desc->irq_data"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_desc_buslock",
          "args": [
            "irq",
            "&flags",
            "IRQ_GET_DESC_CHECK_GLOBAL"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_desc_buslock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "169-173",
          "snippet": "static inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);",
            "extern bool irq_can_set_affinity_usr(unsigned int irq);",
            "struct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern bool irq_can_set_affinity_usr(unsigned int irq);\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nvoid rearm_wake_irq(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn;\n\n\tif (!(desc->istate & IRQS_SUSPENDED) ||\n\t    !irqd_is_wakeup_set(&desc->irq_data))\n\t\tgoto unlock;\n\n\tdesc->istate &= ~IRQS_SUSPENDED;\n\tirqd_set(&desc->irq_data, IRQD_WAKEUP_ARMED);\n\t__enable_irq(desc);\n\nunlock:\n\tirq_put_desc_busunlock(desc, flags);\n}"
  },
  {
    "function_name": "resume_irqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
    "lines": "184-203",
    "snippet": "static void resume_irqs(bool want_early)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tunsigned long flags;\n\t\tbool is_early = desc->action &&\n\t\t\tdesc->action->flags & IRQF_EARLY_RESUME;\n\n\t\tif (!is_early && want_early)\n\t\t\tcontinue;\n\t\tif (irq_settings_is_nested_thread(desc))\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tresume_irq(desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/syscore_ops.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resume_irq",
          "args": [
            "desc"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "resume_irqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
          "lines": "184-203",
          "snippet": "static void resume_irqs(bool want_early)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tunsigned long flags;\n\t\tbool is_early = desc->action &&\n\t\t\tdesc->action->flags & IRQF_EARLY_RESUME;\n\n\t\tif (!is_early && want_early)\n\t\t\tcontinue;\n\t\tif (irq_settings_is_nested_thread(desc))\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tresume_irq(desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_nested_thread",
          "args": [
            "desc"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_nested_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "155-158",
          "snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc",
          "args": [
            "irq",
            "desc"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void resume_irqs(bool want_early)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tunsigned long flags;\n\t\tbool is_early = desc->action &&\n\t\t\tdesc->action->flags & IRQF_EARLY_RESUME;\n\n\t\tif (!is_early && want_early)\n\t\t\tcontinue;\n\t\tif (irq_settings_is_nested_thread(desc))\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tresume_irq(desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}"
  },
  {
    "function_name": "resume_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
    "lines": "152-182",
    "snippet": "static void resume_irq(struct irq_desc *desc)\n{\n\tstruct irq_data *irqd = &desc->irq_data;\n\n\tirqd_clear(irqd, IRQD_WAKEUP_ARMED);\n\n\tif (irqd_is_enabled_on_suspend(irqd)) {\n\t\t/*\n\t\t * Interrupt marked for wakeup was enabled during suspend\n\t\t * entry. Disable such interrupts to restore them back to\n\t\t * original state.\n\t\t */\n\t\t__disable_irq(desc);\n\t\tirqd_clear(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);\n\t}\n\n\tif (desc->istate & IRQS_SUSPENDED)\n\t\tgoto resume;\n\n\t/* Force resume the interrupt? */\n\tif (!desc->force_resume_depth)\n\t\treturn;\n\n\t/* Pretend that it got disabled ! */\n\tdesc->depth++;\n\tirq_state_set_disabled(desc);\n\tirq_state_set_masked(desc);\nresume:\n\tdesc->istate &= ~IRQS_SUSPENDED;\n\t__enable_irq(desc);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/syscore_ops.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__enable_irq",
          "args": [
            "desc"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__enable_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "769-795",
          "snippet": "void __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_state_set_masked",
          "args": [
            "desc"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_set_masked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "243-246",
          "snippet": "static inline void irq_state_set_masked(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_state_set_masked(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_state_set_disabled",
          "args": [
            "desc"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "irq_state_set_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "238-241",
          "snippet": "static inline void irq_state_set_disabled(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_state_set_disabled(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "irqd",
            "IRQD_IRQ_ENABLED_ON_SUSPEND"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__disable_irq",
          "args": [
            "desc"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_irq_nosync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "680-690",
          "snippet": "static int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_enabled_on_suspend",
          "args": [
            "irqd"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void resume_irq(struct irq_desc *desc)\n{\n\tstruct irq_data *irqd = &desc->irq_data;\n\n\tirqd_clear(irqd, IRQD_WAKEUP_ARMED);\n\n\tif (irqd_is_enabled_on_suspend(irqd)) {\n\t\t/*\n\t\t * Interrupt marked for wakeup was enabled during suspend\n\t\t * entry. Disable such interrupts to restore them back to\n\t\t * original state.\n\t\t */\n\t\t__disable_irq(desc);\n\t\tirqd_clear(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);\n\t}\n\n\tif (desc->istate & IRQS_SUSPENDED)\n\t\tgoto resume;\n\n\t/* Force resume the interrupt? */\n\tif (!desc->force_resume_depth)\n\t\treturn;\n\n\t/* Pretend that it got disabled ! */\n\tdesc->depth++;\n\tirq_state_set_disabled(desc);\n\tirq_state_set_masked(desc);\nresume:\n\tdesc->istate &= ~IRQS_SUSPENDED;\n\t__enable_irq(desc);\n}"
  },
  {
    "function_name": "suspend_device_irqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
    "lines": "131-149",
    "snippet": "void suspend_device_irqs(void)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tunsigned long flags;\n\t\tbool sync;\n\n\t\tif (irq_settings_is_nested_thread(desc))\n\t\t\tcontinue;\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tsync = suspend_device_irq(desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\tif (sync)\n\t\t\tsynchronize_irq(irq);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/syscore_ops.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_irq",
          "args": [
            "irq"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "126-140",
          "snippet": "void synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, true);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc, true);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "suspend_device_irq",
          "args": [
            "desc"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_device_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
          "lines": "70-113",
          "snippet": "static bool suspend_device_irq(struct irq_desc *desc)\n{\n\tunsigned long chipflags = irq_desc_get_chip(desc)->flags;\n\tstruct irq_data *irqd = &desc->irq_data;\n\n\tif (!desc->action || irq_desc_is_chained(desc) ||\n\t    desc->no_suspend_depth)\n\t\treturn false;\n\n\tif (irqd_is_wakeup_set(irqd)) {\n\t\tirqd_set(irqd, IRQD_WAKEUP_ARMED);\n\n\t\tif ((chipflags & IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND) &&\n\t\t     irqd_irq_disabled(irqd)) {\n\t\t\t/*\n\t\t\t * Interrupt marked for wakeup is in disabled state.\n\t\t\t * Enable interrupt here to unmask/enable in irqchip\n\t\t\t * to be able to resume with such interrupts.\n\t\t\t */\n\t\t\t__enable_irq(desc);\n\t\t\tirqd_set(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);\n\t\t}\n\t\t/*\n\t\t * We return true here to force the caller to issue\n\t\t * synchronize_irq(). We need to make sure that the\n\t\t * IRQD_WAKEUP_ARMED is visible before we return from\n\t\t * suspend_device_irqs().\n\t\t */\n\t\treturn true;\n\t}\n\n\tdesc->istate |= IRQS_SUSPENDED;\n\t__disable_irq(desc);\n\n\t/*\n\t * Hardware which has no wakeup source configuration facility\n\t * requires that the non wakeup interrupts are masked at the\n\t * chip level. The chip implementation indicates that with\n\t * IRQCHIP_MASK_ON_SUSPEND.\n\t */\n\tif (chipflags & IRQCHIP_MASK_ON_SUSPEND)\n\t\tmask_irq(desc);\n\treturn true;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic bool suspend_device_irq(struct irq_desc *desc)\n{\n\tunsigned long chipflags = irq_desc_get_chip(desc)->flags;\n\tstruct irq_data *irqd = &desc->irq_data;\n\n\tif (!desc->action || irq_desc_is_chained(desc) ||\n\t    desc->no_suspend_depth)\n\t\treturn false;\n\n\tif (irqd_is_wakeup_set(irqd)) {\n\t\tirqd_set(irqd, IRQD_WAKEUP_ARMED);\n\n\t\tif ((chipflags & IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND) &&\n\t\t     irqd_irq_disabled(irqd)) {\n\t\t\t/*\n\t\t\t * Interrupt marked for wakeup is in disabled state.\n\t\t\t * Enable interrupt here to unmask/enable in irqchip\n\t\t\t * to be able to resume with such interrupts.\n\t\t\t */\n\t\t\t__enable_irq(desc);\n\t\t\tirqd_set(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);\n\t\t}\n\t\t/*\n\t\t * We return true here to force the caller to issue\n\t\t * synchronize_irq(). We need to make sure that the\n\t\t * IRQD_WAKEUP_ARMED is visible before we return from\n\t\t * suspend_device_irqs().\n\t\t */\n\t\treturn true;\n\t}\n\n\tdesc->istate |= IRQS_SUSPENDED;\n\t__disable_irq(desc);\n\n\t/*\n\t * Hardware which has no wakeup source configuration facility\n\t * requires that the non wakeup interrupts are masked at the\n\t * chip level. The chip implementation indicates that with\n\t * IRQCHIP_MASK_ON_SUSPEND.\n\t */\n\tif (chipflags & IRQCHIP_MASK_ON_SUSPEND)\n\t\tmask_irq(desc);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_nested_thread",
          "args": [
            "desc"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_nested_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "155-158",
          "snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc",
          "args": [
            "irq",
            "desc"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nvoid suspend_device_irqs(void)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tunsigned long flags;\n\t\tbool sync;\n\n\t\tif (irq_settings_is_nested_thread(desc))\n\t\t\tcontinue;\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tsync = suspend_device_irq(desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\tif (sync)\n\t\t\tsynchronize_irq(irq);\n\t}\n}"
  },
  {
    "function_name": "suspend_device_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
    "lines": "70-113",
    "snippet": "static bool suspend_device_irq(struct irq_desc *desc)\n{\n\tunsigned long chipflags = irq_desc_get_chip(desc)->flags;\n\tstruct irq_data *irqd = &desc->irq_data;\n\n\tif (!desc->action || irq_desc_is_chained(desc) ||\n\t    desc->no_suspend_depth)\n\t\treturn false;\n\n\tif (irqd_is_wakeup_set(irqd)) {\n\t\tirqd_set(irqd, IRQD_WAKEUP_ARMED);\n\n\t\tif ((chipflags & IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND) &&\n\t\t     irqd_irq_disabled(irqd)) {\n\t\t\t/*\n\t\t\t * Interrupt marked for wakeup is in disabled state.\n\t\t\t * Enable interrupt here to unmask/enable in irqchip\n\t\t\t * to be able to resume with such interrupts.\n\t\t\t */\n\t\t\t__enable_irq(desc);\n\t\t\tirqd_set(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);\n\t\t}\n\t\t/*\n\t\t * We return true here to force the caller to issue\n\t\t * synchronize_irq(). We need to make sure that the\n\t\t * IRQD_WAKEUP_ARMED is visible before we return from\n\t\t * suspend_device_irqs().\n\t\t */\n\t\treturn true;\n\t}\n\n\tdesc->istate |= IRQS_SUSPENDED;\n\t__disable_irq(desc);\n\n\t/*\n\t * Hardware which has no wakeup source configuration facility\n\t * requires that the non wakeup interrupts are masked at the\n\t * chip level. The chip implementation indicates that with\n\t * IRQCHIP_MASK_ON_SUSPEND.\n\t */\n\tif (chipflags & IRQCHIP_MASK_ON_SUSPEND)\n\t\tmask_irq(desc);\n\treturn true;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/syscore_ops.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mask_irq",
          "args": [
            "desc"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "handle_fasteoi_mask_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "1249-1285",
          "snippet": "void handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __irq_disable(struct irq_desc *desc, bool mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t/*\n\t * If its disabled or no action available\n\t * then mask it and get out of here:\n\t */\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__disable_irq",
          "args": [
            "desc"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_irq_nosync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "680-690",
          "snippet": "static int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nstatic int __disable_irq_nosync(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\t__disable_irq(desc);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_set",
          "args": [
            "irqd",
            "IRQD_IRQ_ENABLED_ON_SUSPEND"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "228-231",
          "snippet": "static inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__enable_irq",
          "args": [
            "desc"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "__enable_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "769-795",
          "snippet": "void __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid __enable_irq(struct irq_desc *desc)\n{\n\tswitch (desc->depth) {\n\tcase 0:\n err_out:\n\t\tWARN(1, KERN_WARNING \"Unbalanced enable for IRQ %d\\n\",\n\t\t     irq_desc_get_irq(desc));\n\t\tbreak;\n\tcase 1: {\n\t\tif (desc->istate & IRQS_SUSPENDED)\n\t\t\tgoto err_out;\n\t\t/* Prevent probing on this irq: */\n\t\tirq_settings_set_noprobe(desc);\n\t\t/*\n\t\t * Call irq_startup() not irq_enable() here because the\n\t\t * interrupt might be marked NOAUTOEN. So irq_startup()\n\t\t * needs to be invoked when it gets enabled the first\n\t\t * time. If it was already started up, then irq_startup()\n\t\t * will invoke irq_enable() under the hood.\n\t\t */\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdesc->depth--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "irqd"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_is_wakeup_set",
          "args": [
            "irqd"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_is_chained",
          "args": [
            "desc"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "irq_desc_is_chained",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "267-270",
          "snippet": "static inline int irq_desc_is_chained(struct irq_desc *desc)\n{\n\treturn (desc->action && desc->action == &chained_action);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct irqaction chained_action;",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern struct irqaction chained_action;\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline int irq_desc_is_chained(struct irq_desc *desc)\n{\n\treturn (desc->action && desc->action == &chained_action);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_chip",
          "args": [
            "desc"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic bool suspend_device_irq(struct irq_desc *desc)\n{\n\tunsigned long chipflags = irq_desc_get_chip(desc)->flags;\n\tstruct irq_data *irqd = &desc->irq_data;\n\n\tif (!desc->action || irq_desc_is_chained(desc) ||\n\t    desc->no_suspend_depth)\n\t\treturn false;\n\n\tif (irqd_is_wakeup_set(irqd)) {\n\t\tirqd_set(irqd, IRQD_WAKEUP_ARMED);\n\n\t\tif ((chipflags & IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND) &&\n\t\t     irqd_irq_disabled(irqd)) {\n\t\t\t/*\n\t\t\t * Interrupt marked for wakeup is in disabled state.\n\t\t\t * Enable interrupt here to unmask/enable in irqchip\n\t\t\t * to be able to resume with such interrupts.\n\t\t\t */\n\t\t\t__enable_irq(desc);\n\t\t\tirqd_set(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);\n\t\t}\n\t\t/*\n\t\t * We return true here to force the caller to issue\n\t\t * synchronize_irq(). We need to make sure that the\n\t\t * IRQD_WAKEUP_ARMED is visible before we return from\n\t\t * suspend_device_irqs().\n\t\t */\n\t\treturn true;\n\t}\n\n\tdesc->istate |= IRQS_SUSPENDED;\n\t__disable_irq(desc);\n\n\t/*\n\t * Hardware which has no wakeup source configuration facility\n\t * requires that the non wakeup interrupts are masked at the\n\t * chip level. The chip implementation indicates that with\n\t * IRQCHIP_MASK_ON_SUSPEND.\n\t */\n\tif (chipflags & IRQCHIP_MASK_ON_SUSPEND)\n\t\tmask_irq(desc);\n\treturn true;\n}"
  },
  {
    "function_name": "irq_pm_remove_action",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
    "lines": "57-68",
    "snippet": "void irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action)\n{\n\tdesc->nr_actions--;\n\n\tif (action->flags & IRQF_FORCE_RESUME)\n\t\tdesc->force_resume_depth--;\n\n\tif (action->flags & IRQF_NO_SUSPEND)\n\t\tdesc->no_suspend_depth--;\n\telse if (action->flags & IRQF_COND_SUSPEND)\n\t\tdesc->cond_suspend_depth--;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/syscore_ops.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nvoid irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action)\n{\n\tdesc->nr_actions--;\n\n\tif (action->flags & IRQF_FORCE_RESUME)\n\t\tdesc->force_resume_depth--;\n\n\tif (action->flags & IRQF_NO_SUSPEND)\n\t\tdesc->no_suspend_depth--;\n\telse if (action->flags & IRQF_COND_SUSPEND)\n\t\tdesc->cond_suspend_depth--;\n}"
  },
  {
    "function_name": "irq_pm_install_action",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
    "lines": "33-51",
    "snippet": "void irq_pm_install_action(struct irq_desc *desc, struct irqaction *action)\n{\n\tdesc->nr_actions++;\n\n\tif (action->flags & IRQF_FORCE_RESUME)\n\t\tdesc->force_resume_depth++;\n\n\tWARN_ON_ONCE(desc->force_resume_depth &&\n\t\t     desc->force_resume_depth != desc->nr_actions);\n\n\tif (action->flags & IRQF_NO_SUSPEND)\n\t\tdesc->no_suspend_depth++;\n\telse if (action->flags & IRQF_COND_SUSPEND)\n\t\tdesc->cond_suspend_depth++;\n\n\tWARN_ON_ONCE(desc->no_suspend_depth &&\n\t\t     (desc->no_suspend_depth +\n\t\t\tdesc->cond_suspend_depth) != desc->nr_actions);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/syscore_ops.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "desc->no_suspend_depth &&\n\t\t     (desc->no_suspend_depth +\n\t\t\tdesc->cond_suspend_depth) != desc->nr_actions"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "desc->force_resume_depth &&\n\t\t     desc->force_resume_depth != desc->nr_actions"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nvoid irq_pm_install_action(struct irq_desc *desc, struct irqaction *action)\n{\n\tdesc->nr_actions++;\n\n\tif (action->flags & IRQF_FORCE_RESUME)\n\t\tdesc->force_resume_depth++;\n\n\tWARN_ON_ONCE(desc->force_resume_depth &&\n\t\t     desc->force_resume_depth != desc->nr_actions);\n\n\tif (action->flags & IRQF_NO_SUSPEND)\n\t\tdesc->no_suspend_depth++;\n\telse if (action->flags & IRQF_COND_SUSPEND)\n\t\tdesc->cond_suspend_depth++;\n\n\tWARN_ON_ONCE(desc->no_suspend_depth &&\n\t\t     (desc->no_suspend_depth +\n\t\t\tdesc->cond_suspend_depth) != desc->nr_actions);\n}"
  },
  {
    "function_name": "irq_pm_check_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
    "lines": "16-27",
    "snippet": "bool irq_pm_check_wakeup(struct irq_desc *desc)\n{\n\tif (irqd_is_wakeup_armed(&desc->irq_data)) {\n\t\tirqd_clear(&desc->irq_data, IRQD_WAKEUP_ARMED);\n\t\tdesc->istate |= IRQS_SUSPENDED | IRQS_PENDING;\n\t\tdesc->depth++;\n\t\tirq_disable(desc);\n\t\tpm_system_irq_wakeup(irq_desc_get_irq(desc));\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/syscore_ops.h>",
      "#include <linux/suspend.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_system_irq_wakeup",
          "args": [
            "irq_desc_get_irq(desc)"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_disable",
          "args": [
            "desc"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "irq_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "386-389",
          "snippet": "void irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_clear",
          "args": [
            "&desc->irq_data",
            "IRQD_WAKEUP_ARMED"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "irqd_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "223-226",
          "snippet": "static inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_wakeup_armed",
          "args": [
            "&desc->irq_data"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nbool irq_pm_check_wakeup(struct irq_desc *desc)\n{\n\tif (irqd_is_wakeup_armed(&desc->irq_data)) {\n\t\tirqd_clear(&desc->irq_data, IRQD_WAKEUP_ARMED);\n\t\tdesc->istate |= IRQS_SUSPENDED | IRQS_PENDING;\n\t\tdesc->depth++;\n\t\tirq_disable(desc);\n\t\tpm_system_irq_wakeup(irq_desc_get_irq(desc));\n\t\treturn true;\n\t}\n\treturn false;\n}"
  }
]