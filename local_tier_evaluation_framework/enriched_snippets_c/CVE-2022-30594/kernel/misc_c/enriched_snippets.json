[
  {
    "function_name": "misc_cg_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "413-416",
    "snippet": "static void misc_cg_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_misc(css));\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "css_misc(css)"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_misc",
          "args": [
            "css"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic void misc_cg_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_misc(css));\n}"
  },
  {
    "function_name": "misc_cg_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "385-405",
    "snippet": "static struct cgroup_subsys_state *\nmisc_cg_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tenum misc_res_type i;\n\tstruct misc_cg *cg;\n\n\tif (!parent_css) {\n\t\tcg = &root_cg;\n\t} else {\n\t\tcg = kzalloc(sizeof(*cg), GFP_KERNEL);\n\t\tif (!cg)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tWRITE_ONCE(cg->res[i].max, MAX_NUM);\n\t\tatomic_long_set(&cg->res[i].usage, 0);\n\t}\n\n\treturn &cg->css;\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [
      "#define MAX_NUM ULONG_MAX"
    ],
    "globals_used": [
      "static struct misc_cg root_cg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&cg->res[i].usage",
            "0"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "cg->res[i].max",
            "MAX_NUM"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cg)",
            "GFP_KERNEL"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\n#define MAX_NUM ULONG_MAX\n\nstatic struct misc_cg root_cg;\n\nstatic struct cgroup_subsys_state *\nmisc_cg_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tenum misc_res_type i;\n\tstruct misc_cg *cg;\n\n\tif (!parent_css) {\n\t\tcg = &root_cg;\n\t} else {\n\t\tcg = kzalloc(sizeof(*cg), GFP_KERNEL);\n\t\tif (!cg)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tWRITE_ONCE(cg->res[i].max, MAX_NUM);\n\t\tatomic_long_set(&cg->res[i].usage, 0);\n\t}\n\n\treturn &cg->css;\n}"
  },
  {
    "function_name": "misc_events_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "336-347",
    "snippet": "static int misc_events_show(struct seq_file *sf, void *v)\n{\n\tstruct misc_cg *cg = css_misc(seq_css(sf));\n\tunsigned long events, i;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tevents = atomic_long_read(&cg->res[i].events);\n\t\tif (READ_ONCE(misc_res_capacity[i]) || events)\n\t\t\tseq_printf(sf, \"%s.max %lu\\n\", misc_res_name[i], events);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};",
      "static unsigned long misc_res_capacity[MISC_CG_RES_TYPES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"%s.max %lu\\n\"",
            "misc_res_name[i]",
            "events"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "misc_res_capacity[i]"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&cg->res[i].events"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_misc",
          "args": [
            "seq_css(sf)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};\nstatic unsigned long misc_res_capacity[MISC_CG_RES_TYPES];\n\nstatic int misc_events_show(struct seq_file *sf, void *v)\n{\n\tstruct misc_cg *cg = css_misc(seq_css(sf));\n\tunsigned long events, i;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tevents = atomic_long_read(&cg->res[i].events);\n\t\tif (READ_ONCE(misc_res_capacity[i]) || events)\n\t\t\tseq_printf(sf, \"%s.max %lu\\n\", misc_res_name[i], events);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "misc_cg_capacity_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "322-334",
    "snippet": "static int misc_cg_capacity_show(struct seq_file *sf, void *v)\n{\n\tint i;\n\tunsigned long cap;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tcap = READ_ONCE(misc_res_capacity[i]);\n\t\tif (cap)\n\t\t\tseq_printf(sf, \"%s %lu\\n\", misc_res_name[i], cap);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};",
      "static unsigned long misc_res_capacity[MISC_CG_RES_TYPES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"%s %lu\\n\"",
            "misc_res_name[i]",
            "cap"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "misc_res_capacity[i]"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};\nstatic unsigned long misc_res_capacity[MISC_CG_RES_TYPES];\n\nstatic int misc_cg_capacity_show(struct seq_file *sf, void *v)\n{\n\tint i;\n\tunsigned long cap;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tcap = READ_ONCE(misc_res_capacity[i]);\n\t\tif (cap)\n\t\t\tseq_printf(sf, \"%s %lu\\n\", misc_res_name[i], cap);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "misc_cg_current_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "297-310",
    "snippet": "static int misc_cg_current_show(struct seq_file *sf, void *v)\n{\n\tint i;\n\tunsigned long usage;\n\tstruct misc_cg *cg = css_misc(seq_css(sf));\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tusage = atomic_long_read(&cg->res[i].usage);\n\t\tif (READ_ONCE(misc_res_capacity[i]) || usage)\n\t\t\tseq_printf(sf, \"%s %lu\\n\", misc_res_name[i], usage);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};",
      "static unsigned long misc_res_capacity[MISC_CG_RES_TYPES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"%s %lu\\n\"",
            "misc_res_name[i]",
            "usage"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "misc_res_capacity[i]"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&cg->res[i].usage"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_misc",
          "args": [
            "seq_css(sf)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};\nstatic unsigned long misc_res_capacity[MISC_CG_RES_TYPES];\n\nstatic int misc_cg_current_show(struct seq_file *sf, void *v)\n{\n\tint i;\n\tunsigned long usage;\n\tstruct misc_cg *cg = css_misc(seq_css(sf));\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tusage = atomic_long_read(&cg->res[i].usage);\n\t\tif (READ_ONCE(misc_res_capacity[i]) || usage)\n\t\t\tseq_printf(sf, \"%s %lu\\n\", misc_res_name[i], usage);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "misc_cg_max_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "246-287",
    "snippet": "static ssize_t misc_cg_max_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct misc_cg *cg;\n\tunsigned long max;\n\tint ret = 0, i;\n\tenum misc_res_type type = MISC_CG_RES_TYPES;\n\tchar *token;\n\n\tbuf = strstrip(buf);\n\ttoken = strsep(&buf, \" \");\n\n\tif (!token || !buf)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tif (!strcmp(misc_res_name[i], token)) {\n\t\t\ttype = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (type == MISC_CG_RES_TYPES)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(MAX_STR, buf)) {\n\t\tmax = MAX_NUM;\n\t} else {\n\t\tret = kstrtoul(buf, 0, &max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcg = css_misc(of_css(of));\n\n\tif (READ_ONCE(misc_res_capacity[type]))\n\t\tWRITE_ONCE(cg->res[type].max, max);\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret ? ret : nbytes;\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [
      "#define MAX_NUM ULONG_MAX",
      "#define MAX_STR \"max\""
    ],
    "globals_used": [
      "static const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};",
      "static unsigned long misc_res_capacity[MISC_CG_RES_TYPES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "cg->res[type].max",
            "max"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "misc_res_capacity[type]"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_misc",
          "args": [
            "of_css(of)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "of_css",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "652-669",
          "snippet": "struct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "0",
            "&max"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "MAX_STR",
            "buf"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&buf",
            "\" \""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\n#define MAX_NUM ULONG_MAX\n#define MAX_STR \"max\"\n\nstatic const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};\nstatic unsigned long misc_res_capacity[MISC_CG_RES_TYPES];\n\nstatic ssize_t misc_cg_max_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct misc_cg *cg;\n\tunsigned long max;\n\tint ret = 0, i;\n\tenum misc_res_type type = MISC_CG_RES_TYPES;\n\tchar *token;\n\n\tbuf = strstrip(buf);\n\ttoken = strsep(&buf, \" \");\n\n\tif (!token || !buf)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tif (!strcmp(misc_res_name[i], token)) {\n\t\t\ttype = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (type == MISC_CG_RES_TYPES)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(MAX_STR, buf)) {\n\t\tmax = MAX_NUM;\n\t} else {\n\t\tret = kstrtoul(buf, 0, &max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcg = css_misc(of_css(of));\n\n\tif (READ_ONCE(misc_res_capacity[type]))\n\t\tWRITE_ONCE(cg->res[type].max, max);\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret ? ret : nbytes;\n}"
  },
  {
    "function_name": "misc_cg_max_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "208-226",
    "snippet": "static int misc_cg_max_show(struct seq_file *sf, void *v)\n{\n\tint i;\n\tstruct misc_cg *cg = css_misc(seq_css(sf));\n\tunsigned long max;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tif (READ_ONCE(misc_res_capacity[i])) {\n\t\t\tmax = READ_ONCE(cg->res[i].max);\n\t\t\tif (max == MAX_NUM)\n\t\t\t\tseq_printf(sf, \"%s max\\n\", misc_res_name[i]);\n\t\t\telse\n\t\t\t\tseq_printf(sf, \"%s %lu\\n\", misc_res_name[i],\n\t\t\t\t\t   max);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [
      "#define MAX_NUM ULONG_MAX"
    ],
    "globals_used": [
      "static const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};",
      "static unsigned long misc_res_capacity[MISC_CG_RES_TYPES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"%s %lu\\n\"",
            "misc_res_name[i]",
            "max"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cg->res[i].max"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "misc_res_capacity[i]"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_misc",
          "args": [
            "seq_css(sf)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\n#define MAX_NUM ULONG_MAX\n\nstatic const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};\nstatic unsigned long misc_res_capacity[MISC_CG_RES_TYPES];\n\nstatic int misc_cg_max_show(struct seq_file *sf, void *v)\n{\n\tint i;\n\tstruct misc_cg *cg = css_misc(seq_css(sf));\n\tunsigned long max;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tif (READ_ONCE(misc_res_capacity[i])) {\n\t\t\tmax = READ_ONCE(cg->res[i].max);\n\t\t\tif (max == MAX_NUM)\n\t\t\t\tseq_printf(sf, \"%s max\\n\", misc_res_name[i]);\n\t\t\telse\n\t\t\t\tseq_printf(sf, \"%s %lu\\n\", misc_res_name[i],\n\t\t\t\t\t   max);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "misc_cg_uncharge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "187-197",
    "snippet": "void misc_cg_uncharge(enum misc_res_type type, struct misc_cg *cg,\n\t\t      unsigned long amount)\n{\n\tstruct misc_cg *i;\n\n\tif (!(amount && valid_type(type) && cg))\n\t\treturn;\n\n\tfor (i = cg; i; i = parent_misc(i))\n\t\tmisc_cg_cancel_charge(type, i, amount);\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "misc_cg_cancel_charge",
          "args": [
            "type",
            "i",
            "amount"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "misc_cg_cancel_charge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
          "lines": "116-122",
          "snippet": "static void misc_cg_cancel_charge(enum misc_res_type type, struct misc_cg *cg,\n\t\t\t\t  unsigned long amount)\n{\n\tWARN_ONCE(atomic_long_add_negative(-amount, &cg->res[type].usage),\n\t\t  \"misc cgroup resource %s became less than 0\",\n\t\t  misc_res_name[type]);\n}",
          "includes": [
            "#include <linux/misc_cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/atomic.h>",
            "#include <linux/errno.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/limits.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};\n\nstatic void misc_cg_cancel_charge(enum misc_res_type type, struct misc_cg *cg,\n\t\t\t\t  unsigned long amount)\n{\n\tWARN_ONCE(atomic_long_add_negative(-amount, &cg->res[type].usage),\n\t\t  \"misc cgroup resource %s became less than 0\",\n\t\t  misc_res_name[type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_misc",
          "args": [
            "i"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "parent_misc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
          "lines": "51-54",
          "snippet": "static struct misc_cg *parent_misc(struct misc_cg *cgroup)\n{\n\treturn cgroup ? css_misc(cgroup->css.parent) : NULL;\n}",
          "includes": [
            "#include <linux/misc_cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/atomic.h>",
            "#include <linux/errno.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/limits.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic struct misc_cg *parent_misc(struct misc_cg *cgroup)\n{\n\treturn cgroup ? css_misc(cgroup->css.parent) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_type",
          "args": [
            "type"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "valid_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
          "lines": "65-68",
          "snippet": "static inline bool valid_type(enum misc_res_type type)\n{\n\treturn type >= 0 && type < MISC_CG_RES_TYPES;\n}",
          "includes": [
            "#include <linux/misc_cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/atomic.h>",
            "#include <linux/errno.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/limits.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic inline bool valid_type(enum misc_res_type type)\n{\n\treturn type >= 0 && type < MISC_CG_RES_TYPES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nvoid misc_cg_uncharge(enum misc_res_type type, struct misc_cg *cg,\n\t\t      unsigned long amount)\n{\n\tstruct misc_cg *i;\n\n\tif (!(amount && valid_type(type) && cg))\n\t\treturn;\n\n\tfor (i = cg; i; i = parent_misc(i))\n\t\tmisc_cg_cancel_charge(type, i, amount);\n}"
  },
  {
    "function_name": "misc_cg_try_charge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "140-176",
    "snippet": "int misc_cg_try_charge(enum misc_res_type type, struct misc_cg *cg,\n\t\t       unsigned long amount)\n{\n\tstruct misc_cg *i, *j;\n\tint ret;\n\tstruct misc_res *res;\n\tint new_usage;\n\n\tif (!(valid_type(type) && cg && READ_ONCE(misc_res_capacity[type])))\n\t\treturn -EINVAL;\n\n\tif (!amount)\n\t\treturn 0;\n\n\tfor (i = cg; i; i = parent_misc(i)) {\n\t\tres = &i->res[type];\n\n\t\tnew_usage = atomic_long_add_return(amount, &res->usage);\n\t\tif (new_usage > READ_ONCE(res->max) ||\n\t\t    new_usage > READ_ONCE(misc_res_capacity[type])) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_charge;\n\t\t}\n\t}\n\treturn 0;\n\nerr_charge:\n\tfor (j = i; j; j = parent_misc(j)) {\n\t\tatomic_long_inc(&j->res[type].events);\n\t\tcgroup_file_notify(&j->events_file);\n\t}\n\n\tfor (j = cg; j != i; j = parent_misc(j))\n\t\tmisc_cg_cancel_charge(type, j, amount);\n\tmisc_cg_cancel_charge(type, i, amount);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long misc_res_capacity[MISC_CG_RES_TYPES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "misc_cg_cancel_charge",
          "args": [
            "type",
            "i",
            "amount"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "misc_cg_cancel_charge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
          "lines": "116-122",
          "snippet": "static void misc_cg_cancel_charge(enum misc_res_type type, struct misc_cg *cg,\n\t\t\t\t  unsigned long amount)\n{\n\tWARN_ONCE(atomic_long_add_negative(-amount, &cg->res[type].usage),\n\t\t  \"misc cgroup resource %s became less than 0\",\n\t\t  misc_res_name[type]);\n}",
          "includes": [
            "#include <linux/misc_cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/atomic.h>",
            "#include <linux/errno.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/limits.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};\n\nstatic void misc_cg_cancel_charge(enum misc_res_type type, struct misc_cg *cg,\n\t\t\t\t  unsigned long amount)\n{\n\tWARN_ONCE(atomic_long_add_negative(-amount, &cg->res[type].usage),\n\t\t  \"misc cgroup resource %s became less than 0\",\n\t\t  misc_res_name[type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_misc",
          "args": [
            "j"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "parent_misc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
          "lines": "51-54",
          "snippet": "static struct misc_cg *parent_misc(struct misc_cg *cgroup)\n{\n\treturn cgroup ? css_misc(cgroup->css.parent) : NULL;\n}",
          "includes": [
            "#include <linux/misc_cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/atomic.h>",
            "#include <linux/errno.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/limits.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic struct misc_cg *parent_misc(struct misc_cg *cgroup)\n{\n\treturn cgroup ? css_misc(cgroup->css.parent) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&j->events_file"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&j->res[type].events"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "misc_res_capacity[type]"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "res->max"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add_return",
          "args": [
            "amount",
            "&res->usage"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "misc_res_capacity[type]"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_type",
          "args": [
            "type"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "valid_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
          "lines": "65-68",
          "snippet": "static inline bool valid_type(enum misc_res_type type)\n{\n\treturn type >= 0 && type < MISC_CG_RES_TYPES;\n}",
          "includes": [
            "#include <linux/misc_cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/atomic.h>",
            "#include <linux/errno.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/limits.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic inline bool valid_type(enum misc_res_type type)\n{\n\treturn type >= 0 && type < MISC_CG_RES_TYPES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic unsigned long misc_res_capacity[MISC_CG_RES_TYPES];\n\nint misc_cg_try_charge(enum misc_res_type type, struct misc_cg *cg,\n\t\t       unsigned long amount)\n{\n\tstruct misc_cg *i, *j;\n\tint ret;\n\tstruct misc_res *res;\n\tint new_usage;\n\n\tif (!(valid_type(type) && cg && READ_ONCE(misc_res_capacity[type])))\n\t\treturn -EINVAL;\n\n\tif (!amount)\n\t\treturn 0;\n\n\tfor (i = cg; i; i = parent_misc(i)) {\n\t\tres = &i->res[type];\n\n\t\tnew_usage = atomic_long_add_return(amount, &res->usage);\n\t\tif (new_usage > READ_ONCE(res->max) ||\n\t\t    new_usage > READ_ONCE(misc_res_capacity[type])) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_charge;\n\t\t}\n\t}\n\treturn 0;\n\nerr_charge:\n\tfor (j = i; j; j = parent_misc(j)) {\n\t\tatomic_long_inc(&j->res[type].events);\n\t\tcgroup_file_notify(&j->events_file);\n\t}\n\n\tfor (j = cg; j != i; j = parent_misc(j))\n\t\tmisc_cg_cancel_charge(type, j, amount);\n\tmisc_cg_cancel_charge(type, i, amount);\n\treturn ret;\n}"
  },
  {
    "function_name": "misc_cg_cancel_charge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "116-122",
    "snippet": "static void misc_cg_cancel_charge(enum misc_res_type type, struct misc_cg *cg,\n\t\t\t\t  unsigned long amount)\n{\n\tWARN_ONCE(atomic_long_add_negative(-amount, &cg->res[type].usage),\n\t\t  \"misc cgroup resource %s became less than 0\",\n\t\t  misc_res_name[type]);\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "atomic_long_add_negative(-amount, &cg->res[type].usage)",
            "\"misc cgroup resource %s became less than 0\"",
            "misc_res_name[type]"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add_negative",
          "args": [
            "-amount",
            "&cg->res[type].usage"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t/* AMD SEV ASIDs resource */\n\t\"sev\",\n\t/* AMD SEV-ES ASIDs resource */\n\t\"sev_es\",\n#endif\n};\n\nstatic void misc_cg_cancel_charge(enum misc_res_type type, struct misc_cg *cg,\n\t\t\t\t  unsigned long amount)\n{\n\tWARN_ONCE(atomic_long_add_negative(-amount, &cg->res[type].usage),\n\t\t  \"misc cgroup resource %s became less than 0\",\n\t\t  misc_res_name[type]);\n}"
  },
  {
    "function_name": "misc_cg_set_capacity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "98-105",
    "snippet": "int misc_cg_set_capacity(enum misc_res_type type, unsigned long capacity)\n{\n\tif (!valid_type(type))\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(misc_res_capacity[type], capacity);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long misc_res_capacity[MISC_CG_RES_TYPES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "misc_res_capacity[type]",
            "capacity"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_type",
          "args": [
            "type"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "valid_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
          "lines": "65-68",
          "snippet": "static inline bool valid_type(enum misc_res_type type)\n{\n\treturn type >= 0 && type < MISC_CG_RES_TYPES;\n}",
          "includes": [
            "#include <linux/misc_cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/atomic.h>",
            "#include <linux/errno.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/limits.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic inline bool valid_type(enum misc_res_type type)\n{\n\treturn type >= 0 && type < MISC_CG_RES_TYPES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic unsigned long misc_res_capacity[MISC_CG_RES_TYPES];\n\nint misc_cg_set_capacity(enum misc_res_type type, unsigned long capacity)\n{\n\tif (!valid_type(type))\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(misc_res_capacity[type], capacity);\n\treturn 0;\n}"
  },
  {
    "function_name": "misc_cg_res_total_usage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "77-83",
    "snippet": "unsigned long misc_cg_res_total_usage(enum misc_res_type type)\n{\n\tif (valid_type(type))\n\t\treturn atomic_long_read(&root_cg.res[type].usage);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct misc_cg root_cg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&root_cg.res[type].usage"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_type",
          "args": [
            "type"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "valid_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
          "lines": "65-68",
          "snippet": "static inline bool valid_type(enum misc_res_type type)\n{\n\treturn type >= 0 && type < MISC_CG_RES_TYPES;\n}",
          "includes": [
            "#include <linux/misc_cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/atomic.h>",
            "#include <linux/errno.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/limits.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic inline bool valid_type(enum misc_res_type type)\n{\n\treturn type >= 0 && type < MISC_CG_RES_TYPES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic struct misc_cg root_cg;\n\nunsigned long misc_cg_res_total_usage(enum misc_res_type type)\n{\n\tif (valid_type(type))\n\t\treturn atomic_long_read(&root_cg.res[type].usage);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "valid_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "65-68",
    "snippet": "static inline bool valid_type(enum misc_res_type type)\n{\n\treturn type >= 0 && type < MISC_CG_RES_TYPES;\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic inline bool valid_type(enum misc_res_type type)\n{\n\treturn type >= 0 && type < MISC_CG_RES_TYPES;\n}"
  },
  {
    "function_name": "parent_misc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/misc.c",
    "lines": "51-54",
    "snippet": "static struct misc_cg *parent_misc(struct misc_cg *cgroup)\n{\n\treturn cgroup ? css_misc(cgroup->css.parent) : NULL;\n}",
    "includes": [
      "#include <linux/misc_cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/atomic.h>",
      "#include <linux/errno.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/limits.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_misc",
          "args": [
            "cgroup->css.parent"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/misc_cgroup.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/cgroup.h>\n#include <linux/limits.h>\n\nstatic struct misc_cg *parent_misc(struct misc_cg *cgroup)\n{\n\treturn cgroup ? css_misc(cgroup->css.parent) : NULL;\n}"
  }
]