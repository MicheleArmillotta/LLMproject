[
  {
    "function_name": "xfer_to_guest_mode_handle_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/kvm.c",
    "lines": "37-54",
    "snippet": "int xfer_to_guest_mode_handle_work(struct kvm_vcpu *vcpu)\n{\n\tunsigned long ti_work;\n\n\t/*\n\t * This is invoked from the outer guest loop with interrupts and\n\t * preemption enabled.\n\t *\n\t * KVM invokes xfer_to_guest_mode_work_pending() with interrupts\n\t * disabled in the inner loop before going into guest mode. No need\n\t * to disable interrupts here.\n\t */\n\tti_work = read_thread_flags();\n\tif (!(ti_work & XFER_TO_GUEST_MODE_WORK))\n\t\treturn 0;\n\n\treturn xfer_to_guest_mode_work(vcpu, ti_work);\n}",
    "includes": [
      "#include <linux/kvm_host.h>",
      "#include <linux/entry-kvm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfer_to_guest_mode_work",
          "args": [
            "vcpu",
            "ti_work"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "xfer_to_guest_mode_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/kvm.c",
          "lines": "6-35",
          "snippet": "static int xfer_to_guest_mode_work(struct kvm_vcpu *vcpu, unsigned long ti_work)\n{\n\tdo {\n\t\tint ret;\n\n\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL)) {\n\t\t\tclear_notify_signal();\n\t\t\tif (task_work_pending(current))\n\t\t\t\ttask_work_run();\n\t\t}\n\n\t\tif (ti_work & _TIF_SIGPENDING) {\n\t\t\tkvm_handle_signal_exit(vcpu);\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tif (ti_work & _TIF_NEED_RESCHED)\n\t\t\tschedule();\n\n\t\tif (ti_work & _TIF_NOTIFY_RESUME)\n\t\t\tresume_user_mode_work(NULL);\n\n\t\tret = arch_xfer_to_guest_mode_handle_work(vcpu, ti_work);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tti_work = read_thread_flags();\n\t} while (ti_work & XFER_TO_GUEST_MODE_WORK || need_resched());\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <linux/entry-kvm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <linux/entry-kvm.h>\n\nstatic int xfer_to_guest_mode_work(struct kvm_vcpu *vcpu, unsigned long ti_work)\n{\n\tdo {\n\t\tint ret;\n\n\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL)) {\n\t\t\tclear_notify_signal();\n\t\t\tif (task_work_pending(current))\n\t\t\t\ttask_work_run();\n\t\t}\n\n\t\tif (ti_work & _TIF_SIGPENDING) {\n\t\t\tkvm_handle_signal_exit(vcpu);\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tif (ti_work & _TIF_NEED_RESCHED)\n\t\t\tschedule();\n\n\t\tif (ti_work & _TIF_NOTIFY_RESUME)\n\t\t\tresume_user_mode_work(NULL);\n\n\t\tret = arch_xfer_to_guest_mode_handle_work(vcpu, ti_work);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tti_work = read_thread_flags();\n\t} while (ti_work & XFER_TO_GUEST_MODE_WORK || need_resched());\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_thread_flags",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_host.h>\n#include <linux/entry-kvm.h>\n\nint xfer_to_guest_mode_handle_work(struct kvm_vcpu *vcpu)\n{\n\tunsigned long ti_work;\n\n\t/*\n\t * This is invoked from the outer guest loop with interrupts and\n\t * preemption enabled.\n\t *\n\t * KVM invokes xfer_to_guest_mode_work_pending() with interrupts\n\t * disabled in the inner loop before going into guest mode. No need\n\t * to disable interrupts here.\n\t */\n\tti_work = read_thread_flags();\n\tif (!(ti_work & XFER_TO_GUEST_MODE_WORK))\n\t\treturn 0;\n\n\treturn xfer_to_guest_mode_work(vcpu, ti_work);\n}"
  },
  {
    "function_name": "xfer_to_guest_mode_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/entry/kvm.c",
    "lines": "6-35",
    "snippet": "static int xfer_to_guest_mode_work(struct kvm_vcpu *vcpu, unsigned long ti_work)\n{\n\tdo {\n\t\tint ret;\n\n\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL)) {\n\t\t\tclear_notify_signal();\n\t\t\tif (task_work_pending(current))\n\t\t\t\ttask_work_run();\n\t\t}\n\n\t\tif (ti_work & _TIF_SIGPENDING) {\n\t\t\tkvm_handle_signal_exit(vcpu);\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tif (ti_work & _TIF_NEED_RESCHED)\n\t\t\tschedule();\n\n\t\tif (ti_work & _TIF_NOTIFY_RESUME)\n\t\t\tresume_user_mode_work(NULL);\n\n\t\tret = arch_xfer_to_guest_mode_handle_work(vcpu, ti_work);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tti_work = read_thread_flags();\n\t} while (ti_work & XFER_TO_GUEST_MODE_WORK || need_resched());\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_host.h>",
      "#include <linux/entry-kvm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_thread_flags",
          "args": [],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_xfer_to_guest_mode_handle_work",
          "args": [
            "vcpu",
            "ti_work"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resume_user_mode_work",
          "args": [
            "NULL"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_handle_signal_exit",
          "args": [
            "vcpu"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_work_run",
          "args": [],
          "line": 14
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/task_work.c",
          "lines": "131-169",
          "snippet": "void task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\tdo {\n\t\t\thead = NULL;\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\tif (!work) {\n\t\t\t\tif (task->flags & PF_EXITING)\n\t\t\t\t\thead = &work_exited;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\n\t\tif (!work)\n\t\t\tbreak;\n\t\t/*\n\t\t * Synchronize with task_work_cancel(). It can not remove\n\t\t * the first entry == work, cmpxchg(task_works) must fail.\n\t\t * But it can remove another entry from the ->next list.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}",
          "includes": [
            "#include <linux/resume_user_mode.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_head work_exited;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/resume_user_mode.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nvoid task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\tdo {\n\t\t\thead = NULL;\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\tif (!work) {\n\t\t\t\tif (task->flags & PF_EXITING)\n\t\t\t\t\thead = &work_exited;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\n\t\tif (!work)\n\t\t\tbreak;\n\t\t/*\n\t\t * Synchronize with task_work_cancel(). It can not remove\n\t\t * the first entry == work, cmpxchg(task_works) must fail.\n\t\t * But it can remove another entry from the ->next list.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_work_pending",
          "args": [
            "current"
          ],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_notify_signal",
          "args": [],
          "line": 12
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_host.h>\n#include <linux/entry-kvm.h>\n\nstatic int xfer_to_guest_mode_work(struct kvm_vcpu *vcpu, unsigned long ti_work)\n{\n\tdo {\n\t\tint ret;\n\n\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL)) {\n\t\t\tclear_notify_signal();\n\t\t\tif (task_work_pending(current))\n\t\t\t\ttask_work_run();\n\t\t}\n\n\t\tif (ti_work & _TIF_SIGPENDING) {\n\t\t\tkvm_handle_signal_exit(vcpu);\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tif (ti_work & _TIF_NEED_RESCHED)\n\t\t\tschedule();\n\n\t\tif (ti_work & _TIF_NOTIFY_RESUME)\n\t\t\tresume_user_mode_work(NULL);\n\n\t\tret = arch_xfer_to_guest_mode_handle_work(vcpu, ti_work);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tti_work = read_thread_flags();\n\t} while (ti_work & XFER_TO_GUEST_MODE_WORK || need_resched());\n\treturn 0;\n}"
  }
]