[
  {
    "function_name": "mmio_trace_printk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "359-362",
    "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_vprintk",
          "args": [
            "0",
            "fmt",
            "args"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "trace_vprintk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3535-3538",
          "snippet": "int trace_vprintk(unsigned long ip, const char *fmt, va_list args)\n{\n\treturn trace_array_vprintk(&global_trace, ip, fmt, args);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint trace_vprintk(unsigned long ip, const char *fmt, va_list args)\n{\n\treturn trace_array_vprintk(&global_trace, ip, fmt, args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
  },
  {
    "function_name": "mmio_trace_mapping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "348-357",
    "snippet": "void mmio_trace_mapping(struct mmiotrace_map *map)\n{\n\tstruct trace_array *tr = mmio_trace_array;\n\tstruct trace_array_cpu *data;\n\n\tpreempt_disable();\n\tdata = per_cpu_ptr(tr->array_buffer.data, smp_processor_id());\n\t__trace_mmiotrace_map(tr, data, map);\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *mmio_trace_array;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_mmiotrace_map",
          "args": [
            "tr",
            "data",
            "map"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_mmiotrace_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "324-346",
          "snippet": "static void __trace_mmiotrace_map(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_map *map)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_map;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_map *entry;\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx_flags(0);\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_MAP,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->map\t\t\t= *map;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t dropped_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic atomic_t dropped_count;\n\nstatic void __trace_mmiotrace_map(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_map *map)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_map;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_map *entry;\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx_flags(0);\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_MAP,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->map\t\t\t= *map;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "smp_processor_id()"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic struct trace_array *mmio_trace_array;\n\nvoid mmio_trace_mapping(struct mmiotrace_map *map)\n{\n\tstruct trace_array *tr = mmio_trace_array;\n\tstruct trace_array_cpu *data;\n\n\tpreempt_disable();\n\tdata = per_cpu_ptr(tr->array_buffer.data, smp_processor_id());\n\t__trace_mmiotrace_map(tr, data, map);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "__trace_mmiotrace_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "324-346",
    "snippet": "static void __trace_mmiotrace_map(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_map *map)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_map;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_map *entry;\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx_flags(0);\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_MAP,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->map\t\t\t= *map;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t dropped_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "tr",
            "buffer",
            "event",
            "trace_ctx"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1322-1328",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "502-513",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dropped_count"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_MMIO_MAP",
            "sizeof(*entry)",
            "trace_ctx"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic atomic_t dropped_count;\n\nstatic void __trace_mmiotrace_map(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_map *map)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_map;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_map *entry;\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx_flags(0);\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_MAP,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->map\t\t\t= *map;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}"
  },
  {
    "function_name": "mmio_trace_rw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "317-322",
    "snippet": "void mmio_trace_rw(struct mmiotrace_rw *rw)\n{\n\tstruct trace_array *tr = mmio_trace_array;\n\tstruct trace_array_cpu *data = per_cpu_ptr(tr->array_buffer.data, smp_processor_id());\n\t__trace_mmiotrace_rw(tr, data, rw);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *mmio_trace_array;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_mmiotrace_rw",
          "args": [
            "tr",
            "data",
            "rw"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_mmiotrace_rw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "293-315",
          "snippet": "static void __trace_mmiotrace_rw(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_rw *rw)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_rw;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_rw *entry;\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx_flags(0);\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_RW,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->rw\t\t\t= *rw;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t dropped_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic atomic_t dropped_count;\n\nstatic void __trace_mmiotrace_rw(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_rw *rw)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_rw;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_rw *entry;\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx_flags(0);\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_RW,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->rw\t\t\t= *rw;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "smp_processor_id()"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic struct trace_array *mmio_trace_array;\n\nvoid mmio_trace_rw(struct mmiotrace_rw *rw)\n{\n\tstruct trace_array *tr = mmio_trace_array;\n\tstruct trace_array_cpu *data = per_cpu_ptr(tr->array_buffer.data, smp_processor_id());\n\t__trace_mmiotrace_rw(tr, data, rw);\n}"
  },
  {
    "function_name": "__trace_mmiotrace_rw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "293-315",
    "snippet": "static void __trace_mmiotrace_rw(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_rw *rw)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_rw;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_rw *entry;\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx_flags(0);\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_RW,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->rw\t\t\t= *rw;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t dropped_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit",
          "args": [
            "tr",
            "buffer",
            "event",
            "trace_ctx"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1322-1328",
          "snippet": "static inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void trace_buffer_unlock_commit(struct trace_array *tr,\n\t\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t\t      struct ring_buffer_event *event,\n\t\t\t\t\t      unsigned int trace_ctx)\n{\n\ttrace_buffer_unlock_commit_regs(tr, buffer, event, trace_ctx, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "502-513",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dropped_count"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_MMIO_RW",
            "sizeof(*entry)",
            "trace_ctx"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "0"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic atomic_t dropped_count;\n\nstatic void __trace_mmiotrace_rw(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_rw *rw)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_rw;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_rw *entry;\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx_flags(0);\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_RW,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->rw\t\t\t= *rw;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}"
  },
  {
    "function_name": "init_mmio_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "287-290",
    "snippet": "__init static int init_mmio_trace(void)\n{\n\treturn register_tracer(&mmio_tracer);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&mmio_tracer"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2037-2120",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\n__init static int init_mmio_trace(void)\n{\n\treturn register_tracer(&mmio_tracer);\n}"
  },
  {
    "function_name": "mmio_print_line",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "260-272",
    "snippet": "static enum print_line_t mmio_print_line(struct trace_iterator *iter)\n{\n\tswitch (iter->ent->type) {\n\tcase TRACE_MMIO_RW:\n\t\treturn mmio_print_rw(iter);\n\tcase TRACE_MMIO_MAP:\n\t\treturn mmio_print_map(iter);\n\tcase TRACE_PRINT:\n\t\treturn mmio_print_mark(iter);\n\tdefault:\n\t\treturn TRACE_TYPE_HANDLED; /* ignore unknown entries */\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmio_print_mark",
          "args": [
            "iter"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_print_mark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "244-258",
          "snippet": "static enum print_line_t mmio_print_mark(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *print = (struct print_entry *)entry;\n\tconst char *msg\t\t= print->buf;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\t/* The trailing newline must be in the message. */\n\ttrace_seq_printf(s, \"MARK %u.%06lu %s\", secs, usec_rem, msg);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_mark(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *print = (struct print_entry *)entry;\n\tconst char *msg\t\t= print->buf;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\t/* The trailing newline must be in the message. */\n\ttrace_seq_printf(s, \"MARK %u.%06lu %s\", secs, usec_rem, msg);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmio_print_map",
          "args": [
            "iter"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_print_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "210-242",
          "snippet": "static enum print_line_t mmio_print_map(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_map *field;\n\tstruct mmiotrace_map *m;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\tm = &field->map;\n\n\tswitch (m->opcode) {\n\tcase MMIO_PROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"MAP %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id,\n\t\t\t(unsigned long long)m->phys, m->virt, m->len,\n\t\t\t0UL, 0);\n\t\tbreak;\n\tcase MMIO_UNPROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNMAP %u.%06lu %d 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id, 0UL, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"map what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_map(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_map *field;\n\tstruct mmiotrace_map *m;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\tm = &field->map;\n\n\tswitch (m->opcode) {\n\tcase MMIO_PROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"MAP %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id,\n\t\t\t(unsigned long long)m->phys, m->virt, m->len,\n\t\t\t0UL, 0);\n\t\tbreak;\n\tcase MMIO_UNPROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNMAP %u.%06lu %d 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id, 0UL, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"map what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmio_print_rw",
          "args": [
            "iter"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_print_rw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "165-208",
          "snippet": "static enum print_line_t mmio_print_rw(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_rw *field;\n\tstruct mmiotrace_rw *rw;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\trw = &field->rw;\n\n\tswitch (rw->opcode) {\n\tcase MMIO_READ:\n\t\ttrace_seq_printf(s,\n\t\t\t\"R %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_WRITE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"W %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_UNKNOWN_OP:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,\"\n\t\t\t\"%02lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\t(rw->value >> 16) & 0xff, (rw->value >> 8) & 0xff,\n\t\t\t(rw->value >> 0) & 0xff, rw->pc, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"rw what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_rw(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_rw *field;\n\tstruct mmiotrace_rw *rw;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\trw = &field->rw;\n\n\tswitch (rw->opcode) {\n\tcase MMIO_READ:\n\t\ttrace_seq_printf(s,\n\t\t\t\"R %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_WRITE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"W %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_UNKNOWN_OP:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,\"\n\t\t\t\"%02lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\t(rw->value >> 16) & 0xff, (rw->value >> 8) & 0xff,\n\t\t\t(rw->value >> 0) & 0xff, rw->pc, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"rw what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_line(struct trace_iterator *iter)\n{\n\tswitch (iter->ent->type) {\n\tcase TRACE_MMIO_RW:\n\t\treturn mmio_print_rw(iter);\n\tcase TRACE_MMIO_MAP:\n\t\treturn mmio_print_map(iter);\n\tcase TRACE_PRINT:\n\t\treturn mmio_print_mark(iter);\n\tdefault:\n\t\treturn TRACE_TYPE_HANDLED; /* ignore unknown entries */\n\t}\n}"
  },
  {
    "function_name": "mmio_print_mark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "244-258",
    "snippet": "static enum print_line_t mmio_print_mark(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *print = (struct print_entry *)entry;\n\tconst char *msg\t\t= print->buf;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\t/* The trailing newline must be in the message. */\n\ttrace_seq_printf(s, \"MARK %u.%06lu %s\", secs, usec_rem, msg);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"MARK %u.%06lu %s\"",
            "secs",
            "usec_rem",
            "msg"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "t",
            "USEC_PER_SEC"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns2usecs",
          "args": [
            "iter->ts"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ns2usecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "268-273",
          "snippet": "unsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_mark(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *print = (struct print_entry *)entry;\n\tconst char *msg\t\t= print->buf;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\t/* The trailing newline must be in the message. */\n\ttrace_seq_printf(s, \"MARK %u.%06lu %s\", secs, usec_rem, msg);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "mmio_print_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "210-242",
    "snippet": "static enum print_line_t mmio_print_map(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_map *field;\n\tstruct mmiotrace_map *m;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\tm = &field->map;\n\n\tswitch (m->opcode) {\n\tcase MMIO_PROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"MAP %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id,\n\t\t\t(unsigned long long)m->phys, m->virt, m->len,\n\t\t\t0UL, 0);\n\t\tbreak;\n\tcase MMIO_UNPROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNMAP %u.%06lu %d 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id, 0UL, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"map what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"map what?\\n\""
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"UNMAP %u.%06lu %d 0x%lx %d\\n\"",
            "secs",
            "usec_rem",
            "m->map_id",
            "0UL",
            "0"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "t",
            "USEC_PER_SEC"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns2usecs",
          "args": [
            "iter->ts"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "ns2usecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "268-273",
          "snippet": "unsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_map(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_map *field;\n\tstruct mmiotrace_map *m;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\tm = &field->map;\n\n\tswitch (m->opcode) {\n\tcase MMIO_PROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"MAP %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id,\n\t\t\t(unsigned long long)m->phys, m->virt, m->len,\n\t\t\t0UL, 0);\n\t\tbreak;\n\tcase MMIO_UNPROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNMAP %u.%06lu %d 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id, 0UL, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"map what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "mmio_print_rw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "165-208",
    "snippet": "static enum print_line_t mmio_print_rw(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_rw *field;\n\tstruct mmiotrace_rw *rw;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\trw = &field->rw;\n\n\tswitch (rw->opcode) {\n\tcase MMIO_READ:\n\t\ttrace_seq_printf(s,\n\t\t\t\"R %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_WRITE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"W %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_UNKNOWN_OP:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,\"\n\t\t\t\"%02lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\t(rw->value >> 16) & 0xff, (rw->value >> 8) & 0xff,\n\t\t\t(rw->value >> 0) & 0xff, rw->pc, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"rw what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"rw what?\\n\""
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,\"\n\t\t\t\"%02lx 0x%lx %d\\n\"",
            "secs",
            "usec_rem",
            "rw->map_id",
            "(unsigned long long)rw->phys",
            "(rw->value >> 16) & 0xff",
            "(rw->value >> 8) & 0xff",
            "(rw->value >> 0) & 0xff",
            "rw->pc",
            "0"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "t",
            "USEC_PER_SEC"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns2usecs",
          "args": [
            "iter->ts"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "ns2usecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "268-273",
          "snippet": "unsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic enum print_line_t mmio_print_rw(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_rw *field;\n\tstruct mmiotrace_rw *rw;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\trw = &field->rw;\n\n\tswitch (rw->opcode) {\n\tcase MMIO_READ:\n\t\ttrace_seq_printf(s,\n\t\t\t\"R %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_WRITE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"W %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_UNKNOWN_OP:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,\"\n\t\t\t\"%02lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\t(rw->value >> 16) & 0xff, (rw->value >> 8) & 0xff,\n\t\t\t(rw->value >> 0) & 0xff, rw->pc, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"rw what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "mmio_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "131-163",
    "snippet": "static ssize_t mmio_read(struct trace_iterator *iter, struct file *filp,\n\t\t\t\tchar __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tssize_t ret;\n\tstruct header_iter *hiter = iter->private;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long n;\n\n\tn = count_overruns(iter);\n\tif (n) {\n\t\t/* XXX: This is later than where events were lost. */\n\t\ttrace_seq_printf(s, \"MARK 0.000000 Lost %lu events.\\n\", n);\n\t\tif (!overrun_detected)\n\t\t\tpr_warn(\"mmiotrace has lost events\\n\");\n\t\toverrun_detected = true;\n\t\tgoto print_out;\n\t}\n\n\tif (!hiter)\n\t\treturn 0;\n\n\tmmio_print_pcidev(s, hiter->dev);\n\thiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, hiter->dev);\n\n\tif (!hiter->dev) {\n\t\tdestroy_header_iter(hiter);\n\t\titer->private = NULL;\n\t}\n\nprint_out:\n\tret = trace_seq_to_user(s, ubuf, cnt);\n\treturn (ret == -EBUSY) ? 0 : ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool overrun_detected;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_to_user",
          "args": [
            "s",
            "ubuf",
            "cnt"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "370-374",
          "snippet": "int trace_seq_to_user(struct trace_seq *s, char __user *ubuf, int cnt)\n{\n\t__trace_seq_init(s);\n\treturn seq_buf_to_user(&s->seq, ubuf, cnt);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nint trace_seq_to_user(struct trace_seq *s, char __user *ubuf, int cnt)\n{\n\t__trace_seq_init(s);\n\treturn seq_buf_to_user(&s->seq, ubuf, cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_header_iter",
          "args": [
            "hiter"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_header_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "89-95",
          "snippet": "static void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_get_device",
          "args": [
            "PCI_ANY_ID",
            "PCI_ANY_ID",
            "hiter->dev"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmio_print_pcidev",
          "args": [
            "s",
            "hiter->dev"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_print_pcidev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "61-87",
          "snippet": "static void mmio_print_pcidev(struct trace_seq *s, const struct pci_dev *dev)\n{\n\tint i;\n\tresource_size_t start, end;\n\tconst struct pci_driver *drv = pci_dev_driver(dev);\n\n\ttrace_seq_printf(s, \"PCIDEV %02x%02x %04x%04x %x\",\n\t\t\t dev->bus->number, dev->devfn,\n\t\t\t dev->vendor, dev->device, dev->irq);\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\t(unsigned long long)(start |\n\t\t\t(dev->resource[i].flags & PCI_REGION_FLAG_MASK)));\n\t}\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\tend = dev->resource[i].end;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\tdev->resource[i].start < dev->resource[i].end ?\n\t\t\t(unsigned long long)(end - start) + 1 : 0);\n\t}\n\tif (drv)\n\t\ttrace_seq_printf(s, \" %s\\n\", drv->name);\n\telse\n\t\ttrace_seq_puts(s, \" \\n\");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void mmio_print_pcidev(struct trace_seq *s, const struct pci_dev *dev)\n{\n\tint i;\n\tresource_size_t start, end;\n\tconst struct pci_driver *drv = pci_dev_driver(dev);\n\n\ttrace_seq_printf(s, \"PCIDEV %02x%02x %04x%04x %x\",\n\t\t\t dev->bus->number, dev->devfn,\n\t\t\t dev->vendor, dev->device, dev->irq);\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\t(unsigned long long)(start |\n\t\t\t(dev->resource[i].flags & PCI_REGION_FLAG_MASK)));\n\t}\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\tend = dev->resource[i].end;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\tdev->resource[i].start < dev->resource[i].end ?\n\t\t\t(unsigned long long)(end - start) + 1 : 0);\n\t}\n\tif (drv)\n\t\ttrace_seq_printf(s, \" %s\\n\", drv->name);\n\telse\n\t\ttrace_seq_puts(s, \" \\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"mmiotrace has lost events\\n\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"MARK 0.000000 Lost %lu events.\\n\"",
            "n"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_overruns",
          "args": [
            "iter"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "count_overruns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "120-129",
          "snippet": "static unsigned long count_overruns(struct trace_iterator *iter)\n{\n\tunsigned long cnt = atomic_xchg(&dropped_count, 0);\n\tunsigned long over = ring_buffer_overruns(iter->array_buffer->buffer);\n\n\tif (over > prev_overruns)\n\t\tcnt += over - prev_overruns;\n\tprev_overruns = over;\n\treturn cnt;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long prev_overruns;",
            "static atomic_t dropped_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic unsigned long prev_overruns;\nstatic atomic_t dropped_count;\n\nstatic unsigned long count_overruns(struct trace_iterator *iter)\n{\n\tunsigned long cnt = atomic_xchg(&dropped_count, 0);\n\tunsigned long over = ring_buffer_overruns(iter->array_buffer->buffer);\n\n\tif (over > prev_overruns)\n\t\tcnt += over - prev_overruns;\n\tprev_overruns = over;\n\treturn cnt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic bool overrun_detected;\n\nstatic ssize_t mmio_read(struct trace_iterator *iter, struct file *filp,\n\t\t\t\tchar __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tssize_t ret;\n\tstruct header_iter *hiter = iter->private;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long n;\n\n\tn = count_overruns(iter);\n\tif (n) {\n\t\t/* XXX: This is later than where events were lost. */\n\t\ttrace_seq_printf(s, \"MARK 0.000000 Lost %lu events.\\n\", n);\n\t\tif (!overrun_detected)\n\t\t\tpr_warn(\"mmiotrace has lost events\\n\");\n\t\toverrun_detected = true;\n\t\tgoto print_out;\n\t}\n\n\tif (!hiter)\n\t\treturn 0;\n\n\tmmio_print_pcidev(s, hiter->dev);\n\thiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, hiter->dev);\n\n\tif (!hiter->dev) {\n\t\tdestroy_header_iter(hiter);\n\t\titer->private = NULL;\n\t}\n\nprint_out:\n\tret = trace_seq_to_user(s, ubuf, cnt);\n\treturn (ret == -EBUSY) ? 0 : ret;\n}"
  },
  {
    "function_name": "count_overruns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "120-129",
    "snippet": "static unsigned long count_overruns(struct trace_iterator *iter)\n{\n\tunsigned long cnt = atomic_xchg(&dropped_count, 0);\n\tunsigned long over = ring_buffer_overruns(iter->array_buffer->buffer);\n\n\tif (over > prev_overruns)\n\t\tcnt += over - prev_overruns;\n\tprev_overruns = over;\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long prev_overruns;",
      "static atomic_t dropped_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_overruns",
          "args": [
            "iter->array_buffer->buffer"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_overruns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "4245-4258",
          "snippet": "unsigned long ring_buffer_overruns(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long overruns = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\toverruns += local_read(&cpu_buffer->overrun);\n\t}\n\n\treturn overruns;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nunsigned long ring_buffer_overruns(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long overruns = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\toverruns += local_read(&cpu_buffer->overrun);\n\t}\n\n\treturn overruns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&dropped_count",
            "0"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic unsigned long prev_overruns;\nstatic atomic_t dropped_count;\n\nstatic unsigned long count_overruns(struct trace_iterator *iter)\n{\n\tunsigned long cnt = atomic_xchg(&dropped_count, 0);\n\tunsigned long over = ring_buffer_overruns(iter->array_buffer->buffer);\n\n\tif (over > prev_overruns)\n\t\tcnt += over - prev_overruns;\n\tprev_overruns = over;\n\treturn cnt;\n}"
  },
  {
    "function_name": "mmio_close",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "113-118",
    "snippet": "static void mmio_close(struct trace_iterator *iter)\n{\n\tstruct header_iter *hiter = iter->private;\n\tdestroy_header_iter(hiter);\n\titer->private = NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_header_iter",
          "args": [
            "hiter"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_header_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "89-95",
          "snippet": "static void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void mmio_close(struct trace_iterator *iter)\n{\n\tstruct header_iter *hiter = iter->private;\n\tdestroy_header_iter(hiter);\n\titer->private = NULL;\n}"
  },
  {
    "function_name": "mmio_pipe_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "97-110",
    "snippet": "static void mmio_pipe_open(struct trace_iterator *iter)\n{\n\tstruct header_iter *hiter;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_seq_puts(s, \"VERSION 20070824\\n\");\n\n\thiter = kzalloc(sizeof(*hiter), GFP_KERNEL);\n\tif (!hiter)\n\t\treturn;\n\n\thiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);\n\titer->private = hiter;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_get_device",
          "args": [
            "PCI_ANY_ID",
            "PCI_ANY_ID",
            "NULL"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*hiter)",
            "GFP_KERNEL"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"VERSION 20070824\\n\""
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void mmio_pipe_open(struct trace_iterator *iter)\n{\n\tstruct header_iter *hiter;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_seq_puts(s, \"VERSION 20070824\\n\");\n\n\thiter = kzalloc(sizeof(*hiter), GFP_KERNEL);\n\tif (!hiter)\n\t\treturn;\n\n\thiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);\n\titer->private = hiter;\n}"
  },
  {
    "function_name": "destroy_header_iter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "89-95",
    "snippet": "static void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hiter"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "hiter->dev"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}"
  },
  {
    "function_name": "mmio_print_pcidev",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "61-87",
    "snippet": "static void mmio_print_pcidev(struct trace_seq *s, const struct pci_dev *dev)\n{\n\tint i;\n\tresource_size_t start, end;\n\tconst struct pci_driver *drv = pci_dev_driver(dev);\n\n\ttrace_seq_printf(s, \"PCIDEV %02x%02x %04x%04x %x\",\n\t\t\t dev->bus->number, dev->devfn,\n\t\t\t dev->vendor, dev->device, dev->irq);\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\t(unsigned long long)(start |\n\t\t\t(dev->resource[i].flags & PCI_REGION_FLAG_MASK)));\n\t}\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\tend = dev->resource[i].end;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\tdev->resource[i].start < dev->resource[i].end ?\n\t\t\t(unsigned long long)(end - start) + 1 : 0);\n\t}\n\tif (drv)\n\t\ttrace_seq_printf(s, \" %s\\n\", drv->name);\n\telse\n\t\ttrace_seq_puts(s, \" \\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" \\n\""
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" %s\\n\"",
            "drv->name"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_driver",
          "args": [
            "dev"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void mmio_print_pcidev(struct trace_seq *s, const struct pci_dev *dev)\n{\n\tint i;\n\tresource_size_t start, end;\n\tconst struct pci_driver *drv = pci_dev_driver(dev);\n\n\ttrace_seq_printf(s, \"PCIDEV %02x%02x %04x%04x %x\",\n\t\t\t dev->bus->number, dev->devfn,\n\t\t\t dev->vendor, dev->device, dev->irq);\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\t(unsigned long long)(start |\n\t\t\t(dev->resource[i].flags & PCI_REGION_FLAG_MASK)));\n\t}\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\tend = dev->resource[i].end;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\tdev->resource[i].start < dev->resource[i].end ?\n\t\t\t(unsigned long long)(end - start) + 1 : 0);\n\t}\n\tif (drv)\n\t\ttrace_seq_printf(s, \" %s\\n\", drv->name);\n\telse\n\t\ttrace_seq_puts(s, \" \\n\");\n}"
  },
  {
    "function_name": "mmio_trace_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "55-59",
    "snippet": "static void mmio_trace_start(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\tmmio_reset_data(tr);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmio_reset_data",
          "args": [
            "tr"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_reset_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "28-34",
          "snippet": "static void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool overrun_detected;",
            "static unsigned long prev_overruns;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic bool overrun_detected;\nstatic unsigned long prev_overruns;\n\nstatic void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"in %s\\n\"",
            "__func__"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic void mmio_trace_start(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\tmmio_reset_data(tr);\n}"
  },
  {
    "function_name": "mmio_trace_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "46-53",
    "snippet": "static void mmio_trace_reset(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\n\tdisable_mmiotrace();\n\tmmio_reset_data(tr);\n\tmmio_trace_array = NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *mmio_trace_array;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmio_reset_data",
          "args": [
            "tr"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_reset_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "28-34",
          "snippet": "static void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool overrun_detected;",
            "static unsigned long prev_overruns;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic bool overrun_detected;\nstatic unsigned long prev_overruns;\n\nstatic void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_mmiotrace",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"in %s\\n\"",
            "__func__"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic struct trace_array *mmio_trace_array;\n\nstatic void mmio_trace_reset(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\n\tdisable_mmiotrace();\n\tmmio_reset_data(tr);\n\tmmio_trace_array = NULL;\n}"
  },
  {
    "function_name": "mmio_trace_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "36-44",
    "snippet": "static int mmio_trace_init(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\tmmio_trace_array = tr;\n\n\tmmio_reset_data(tr);\n\tenable_mmiotrace();\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *mmio_trace_array;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_mmiotrace",
          "args": [],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmio_reset_data",
          "args": [
            "tr"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_reset_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "28-34",
          "snippet": "static void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool overrun_detected;",
            "static unsigned long prev_overruns;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic bool overrun_detected;\nstatic unsigned long prev_overruns;\n\nstatic void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"in %s\\n\"",
            "__func__"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic struct trace_array *mmio_trace_array;\n\nstatic int mmio_trace_init(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\tmmio_trace_array = tr;\n\n\tmmio_reset_data(tr);\n\tenable_mmiotrace();\n\treturn 0;\n}"
  },
  {
    "function_name": "mmio_reset_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
    "lines": "28-34",
    "snippet": "static void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/mmiotrace.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool overrun_detected;",
      "static unsigned long prev_overruns;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_reset_online_cpus",
          "args": [
            "&tr->array_buffer"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2138-2155",
          "snippet": "void tracing_reset_online_cpus(struct array_buffer *buf)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tring_buffer_reset_online_cpus(buffer);\n\n\tring_buffer_record_enable(buffer);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nvoid tracing_reset_online_cpus(struct array_buffer *buf)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tring_buffer_reset_online_cpus(buffer);\n\n\tring_buffer_record_enable(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nstatic bool overrun_detected;\nstatic unsigned long prev_overruns;\n\nstatic void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n}"
  }
]