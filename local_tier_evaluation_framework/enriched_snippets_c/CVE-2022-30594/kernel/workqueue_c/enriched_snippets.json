[
  {
    "function_name": "workqueue_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "6084-6131",
    "snippet": "void __init workqueue_init(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tint cpu, bkt;\n\n\t/*\n\t * It'd be simpler to initialize NUMA in workqueue_init_early() but\n\t * CPU to node mapping may not be available that early on some\n\t * archs such as power and arm64.  As per-cpu pools created\n\t * previously could be missing node hint and unbound pools NUMA\n\t * affinity, fix them up.\n\t *\n\t * Also, while iterating workqueues, create rescuers if requested.\n\t */\n\twq_numa_init();\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tpool->node = cpu_to_node(cpu);\n\t\t}\n\t}\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\twq_update_unbound_numa(wq, smp_processor_id(), true);\n\t\tWARN(init_rescuer(wq),\n\t\t     \"workqueue: failed to create early rescuer for %s\",\n\t\t     wq->name);\n\t}\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\t/* create the initial workers */\n\tfor_each_online_cpu(cpu) {\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tpool->flags &= ~POOL_DISASSOCIATED;\n\t\t\tBUG_ON(!create_worker(pool));\n\t\t}\n\t}\n\n\thash_for_each(unbound_pool_hash, bkt, pool, hash_node)\n\t\tBUG_ON(!create_worker(pool));\n\n\twq_online = true;\n\twq_watchdog_init();\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_online;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wq_watchdog_init",
          "args": [],
          "line": 6130
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5948-5948",
          "snippet": "static inline void wq_watchdog_init(void) { }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void wq_watchdog_init(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!create_worker(pool)"
          ],
          "line": 6127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_worker",
          "args": [
            "pool"
          ],
          "line": 6127
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2114-2143",
          "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\traw_spin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\traw_spin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "unbound_pool_hash",
            "bkt",
            "pool",
            "hash_node"
          ],
          "line": 6126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!create_worker(pool)"
          ],
          "line": 6122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu_worker_pool",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 6120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 6116
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "init_rescuer(wq)",
            "\"workqueue: failed to create early rescuer for %s\"",
            "wq->name"
          ],
          "line": 6111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rescuer",
          "args": [
            "wq"
          ],
          "line": 6111
        },
        "resolved": true,
        "details": {
          "function_name": "init_rescuer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4270-4295",
          "snippet": "static int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tif (IS_ERR(rescuer->task)) {\n\t\tret = PTR_ERR(rescuer->task);\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tif (IS_ERR(rescuer->task)) {\n\t\tret = PTR_ERR(rescuer->task);\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_update_unbound_numa",
          "args": [
            "wq",
            "smp_processor_id()",
            "true"
          ],
          "line": 6110
        },
        "resolved": true,
        "details": {
          "function_name": "wq_update_unbound_numa",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4151-4212",
          "snippet": "static void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\traw_spin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\traw_spin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_numa_enabled;",
            "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\traw_spin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\traw_spin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 6110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 6109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 6105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu_worker_pool",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 6104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 6101
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_numa_init",
          "args": [],
          "line": 6099
        },
        "resolved": true,
        "details": {
          "function_name": "wq_numa_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5952-5994",
          "snippet": "static void __init wq_numa_init(void)\n{\n\tcpumask_var_t *tbl;\n\tint node, cpu;\n\n\tif (num_possible_nodes() <= 1)\n\t\treturn;\n\n\tif (wq_disable_numa) {\n\t\tpr_info(\"workqueue: NUMA affinity support disabled\\n\");\n\t\treturn;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (WARN_ON(cpu_to_node(cpu) == NUMA_NO_NODE)) {\n\t\t\tpr_warn(\"workqueue: NUMA node mapping not available for cpu%d, disabling NUMA support\\n\", cpu);\n\t\t\treturn;\n\t\t}\n\t}\n\n\twq_update_unbound_numa_attrs_buf = alloc_workqueue_attrs();\n\tBUG_ON(!wq_update_unbound_numa_attrs_buf);\n\n\t/*\n\t * We want masks of possible CPUs of each node which isn't readily\n\t * available.  Build one from cpu_to_node() which should have been\n\t * fully initialized by now.\n\t */\n\ttbl = kcalloc(nr_node_ids, sizeof(tbl[0]), GFP_KERNEL);\n\tBUG_ON(!tbl);\n\n\tfor_each_node(node)\n\t\tBUG_ON(!zalloc_cpumask_var_node(&tbl[node], GFP_KERNEL,\n\t\t\t\tnode_online(node) ? node : NUMA_NO_NODE));\n\n\tfor_each_possible_cpu(cpu) {\n\t\tnode = cpu_to_node(cpu);\n\t\tcpumask_set_cpu(cpu, tbl[node]);\n\t}\n\n\twq_numa_possible_cpumask = tbl;\n\twq_numa_enabled = true;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t *wq_numa_possible_cpumask;",
            "static bool wq_disable_numa;",
            "static bool wq_numa_enabled;",
            "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_disable_numa;\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\n\nstatic void __init wq_numa_init(void)\n{\n\tcpumask_var_t *tbl;\n\tint node, cpu;\n\n\tif (num_possible_nodes() <= 1)\n\t\treturn;\n\n\tif (wq_disable_numa) {\n\t\tpr_info(\"workqueue: NUMA affinity support disabled\\n\");\n\t\treturn;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (WARN_ON(cpu_to_node(cpu) == NUMA_NO_NODE)) {\n\t\t\tpr_warn(\"workqueue: NUMA node mapping not available for cpu%d, disabling NUMA support\\n\", cpu);\n\t\t\treturn;\n\t\t}\n\t}\n\n\twq_update_unbound_numa_attrs_buf = alloc_workqueue_attrs();\n\tBUG_ON(!wq_update_unbound_numa_attrs_buf);\n\n\t/*\n\t * We want masks of possible CPUs of each node which isn't readily\n\t * available.  Build one from cpu_to_node() which should have been\n\t * fully initialized by now.\n\t */\n\ttbl = kcalloc(nr_node_ids, sizeof(tbl[0]), GFP_KERNEL);\n\tBUG_ON(!tbl);\n\n\tfor_each_node(node)\n\t\tBUG_ON(!zalloc_cpumask_var_node(&tbl[node], GFP_KERNEL,\n\t\t\t\tnode_online(node) ? node : NUMA_NO_NODE));\n\n\tfor_each_possible_cpu(cpu) {\n\t\tnode = cpu_to_node(cpu);\n\t\tcpumask_set_cpu(cpu, tbl[node]);\n\t}\n\n\twq_numa_possible_cpumask = tbl;\n\twq_numa_enabled = true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid __init workqueue_init(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tint cpu, bkt;\n\n\t/*\n\t * It'd be simpler to initialize NUMA in workqueue_init_early() but\n\t * CPU to node mapping may not be available that early on some\n\t * archs such as power and arm64.  As per-cpu pools created\n\t * previously could be missing node hint and unbound pools NUMA\n\t * affinity, fix them up.\n\t *\n\t * Also, while iterating workqueues, create rescuers if requested.\n\t */\n\twq_numa_init();\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tpool->node = cpu_to_node(cpu);\n\t\t}\n\t}\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\twq_update_unbound_numa(wq, smp_processor_id(), true);\n\t\tWARN(init_rescuer(wq),\n\t\t     \"workqueue: failed to create early rescuer for %s\",\n\t\t     wq->name);\n\t}\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\t/* create the initial workers */\n\tfor_each_online_cpu(cpu) {\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tpool->flags &= ~POOL_DISASSOCIATED;\n\t\t\tBUG_ON(!create_worker(pool));\n\t\t}\n\t}\n\n\thash_for_each(unbound_pool_hash, bkt, pool, hash_node)\n\t\tBUG_ON(!create_worker(pool));\n\n\twq_online = true;\n\twq_watchdog_init();\n}"
  },
  {
    "function_name": "workqueue_init_early",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "6006-6073",
    "snippet": "void __init workqueue_init_early(void)\n{\n\tint std_nice[NR_STD_WORKER_POOLS] = { 0, HIGHPRI_NICE_LEVEL };\n\tint hk_flags = HK_FLAG_DOMAIN | HK_FLAG_WQ;\n\tint i, cpu;\n\n\tBUILD_BUG_ON(__alignof__(struct pool_workqueue) < __alignof__(long long));\n\n\tBUG_ON(!alloc_cpumask_var(&wq_unbound_cpumask, GFP_KERNEL));\n\tcpumask_copy(wq_unbound_cpumask, housekeeping_cpumask(hk_flags));\n\n\tpwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);\n\n\t/* initialize CPU pools */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct worker_pool *pool;\n\n\t\ti = 0;\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tBUG_ON(init_worker_pool(pool));\n\t\t\tpool->cpu = cpu;\n\t\t\tcpumask_copy(pool->attrs->cpumask, cpumask_of(cpu));\n\t\t\tpool->attrs->nice = std_nice[i++];\n\t\t\tpool->node = cpu_to_node(cpu);\n\n\t\t\t/* alloc pool ID */\n\t\t\tmutex_lock(&wq_pool_mutex);\n\t\t\tBUG_ON(worker_pool_assign_id(pool));\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t}\n\t}\n\n\t/* create default unbound and ordered wq attrs */\n\tfor (i = 0; i < NR_STD_WORKER_POOLS; i++) {\n\t\tstruct workqueue_attrs *attrs;\n\n\t\tBUG_ON(!(attrs = alloc_workqueue_attrs()));\n\t\tattrs->nice = std_nice[i];\n\t\tunbound_std_wq_attrs[i] = attrs;\n\n\t\t/*\n\t\t * An ordered wq should have only one pwq as ordering is\n\t\t * guaranteed by max_active which is enforced by pwqs.\n\t\t * Turn off NUMA so that dfl_pwq is used for all nodes.\n\t\t */\n\t\tBUG_ON(!(attrs = alloc_workqueue_attrs()));\n\t\tattrs->nice = std_nice[i];\n\t\tattrs->no_numa = true;\n\t\tordered_wq_attrs[i] = attrs;\n\t}\n\n\tsystem_wq = alloc_workqueue(\"events\", 0, 0);\n\tsystem_highpri_wq = alloc_workqueue(\"events_highpri\", WQ_HIGHPRI, 0);\n\tsystem_long_wq = alloc_workqueue(\"events_long\", 0, 0);\n\tsystem_unbound_wq = alloc_workqueue(\"events_unbound\", WQ_UNBOUND,\n\t\t\t\t\t    WQ_UNBOUND_MAX_ACTIVE);\n\tsystem_freezable_wq = alloc_workqueue(\"events_freezable\",\n\t\t\t\t\t      WQ_FREEZABLE, 0);\n\tsystem_power_efficient_wq = alloc_workqueue(\"events_power_efficient\",\n\t\t\t\t\t      WQ_POWER_EFFICIENT, 0);\n\tsystem_freezable_power_efficient_wq = alloc_workqueue(\"events_freezable_power_efficient\",\n\t\t\t\t\t      WQ_FREEZABLE | WQ_POWER_EFFICIENT,\n\t\t\t\t\t      0);\n\tBUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||\n\t       !system_unbound_wq || !system_freezable_wq ||\n\t       !system_power_efficient_wq ||\n\t       !system_freezable_power_efficient_wq);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pwq_cache;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static cpumask_var_t wq_unbound_cpumask;",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];",
      "static struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];",
      "struct workqueue_struct *system_highpri_wq",
      "struct workqueue_struct *system_long_wq",
      "struct workqueue_struct *system_unbound_wq",
      "struct workqueue_struct *system_freezable_wq",
      "struct workqueue_struct *system_power_efficient_wq",
      "struct workqueue_struct *system_freezable_power_efficient_wq",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!system_wq || !system_highpri_wq || !system_long_wq ||\n\t       !system_unbound_wq || !system_freezable_wq ||\n\t       !system_power_efficient_wq ||\n\t       !system_freezable_power_efficient_wq"
          ],
          "line": 6069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"events_freezable_power_efficient\"",
            "WQ_FREEZABLE | WQ_POWER_EFFICIENT",
            "0"
          ],
          "line": 6066
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4298-4392",
          "snippet": "struct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);",
            "static bool wq_online;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);\nstatic bool wq_online;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstruct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(attrs = alloc_workqueue_attrs())"
          ],
          "line": 6051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [],
          "line": 6051
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3401-3416",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(attrs = alloc_workqueue_attrs())"
          ],
          "line": 6042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 6034
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "worker_pool_assign_id(pool)"
          ],
          "line": 6033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_pool_assign_id",
          "args": [
            "pool"
          ],
          "line": 6033
        },
        "resolved": true,
        "details": {
          "function_name": "worker_pool_assign_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "547-560",
          "snippet": "static int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static DEFINE_IDR(worker_pool_idr);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 6032
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 6029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "pool->attrs->cpumask",
            "cpumask_of(cpu)"
          ],
          "line": 6027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 6027
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "init_worker_pool(pool)"
          ],
          "line": 6025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_worker_pool",
          "args": [
            "pool"
          ],
          "line": 6025
        },
        "resolved": true,
        "details": {
          "function_name": "init_worker_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3463-3490",
          "snippet": "static int init_worker_pool(struct worker_pool *pool)\n{\n\traw_spin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs();\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int init_worker_pool(struct worker_pool *pool)\n{\n\traw_spin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs();\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_worker_pool",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 6024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "pool_workqueue",
            "SLAB_PANIC"
          ],
          "line": 6017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "wq_unbound_cpumask",
            "housekeeping_cpumask(hk_flags)"
          ],
          "line": 6015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "hk_flags"
          ],
          "line": 6015
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/isolation.c",
          "lines": "40-46",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!alloc_cpumask_var(&wq_unbound_cpumask, GFP_KERNEL)"
          ],
          "line": 6014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&wq_unbound_cpumask",
            "GFP_KERNEL"
          ],
          "line": 6014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "__alignof__(struct pool_workqueue) < __alignof__(long long)"
          ],
          "line": 6012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *pwq_cache;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];\nstatic struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];\nstruct workqueue_struct *system_highpri_wq;\nstruct workqueue_struct *system_long_wq;\nstruct workqueue_struct *system_unbound_wq;\nstruct workqueue_struct *system_freezable_wq;\nstruct workqueue_struct *system_power_efficient_wq;\nstruct workqueue_struct *system_freezable_power_efficient_wq;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid __init workqueue_init_early(void)\n{\n\tint std_nice[NR_STD_WORKER_POOLS] = { 0, HIGHPRI_NICE_LEVEL };\n\tint hk_flags = HK_FLAG_DOMAIN | HK_FLAG_WQ;\n\tint i, cpu;\n\n\tBUILD_BUG_ON(__alignof__(struct pool_workqueue) < __alignof__(long long));\n\n\tBUG_ON(!alloc_cpumask_var(&wq_unbound_cpumask, GFP_KERNEL));\n\tcpumask_copy(wq_unbound_cpumask, housekeeping_cpumask(hk_flags));\n\n\tpwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);\n\n\t/* initialize CPU pools */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct worker_pool *pool;\n\n\t\ti = 0;\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tBUG_ON(init_worker_pool(pool));\n\t\t\tpool->cpu = cpu;\n\t\t\tcpumask_copy(pool->attrs->cpumask, cpumask_of(cpu));\n\t\t\tpool->attrs->nice = std_nice[i++];\n\t\t\tpool->node = cpu_to_node(cpu);\n\n\t\t\t/* alloc pool ID */\n\t\t\tmutex_lock(&wq_pool_mutex);\n\t\t\tBUG_ON(worker_pool_assign_id(pool));\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t}\n\t}\n\n\t/* create default unbound and ordered wq attrs */\n\tfor (i = 0; i < NR_STD_WORKER_POOLS; i++) {\n\t\tstruct workqueue_attrs *attrs;\n\n\t\tBUG_ON(!(attrs = alloc_workqueue_attrs()));\n\t\tattrs->nice = std_nice[i];\n\t\tunbound_std_wq_attrs[i] = attrs;\n\n\t\t/*\n\t\t * An ordered wq should have only one pwq as ordering is\n\t\t * guaranteed by max_active which is enforced by pwqs.\n\t\t * Turn off NUMA so that dfl_pwq is used for all nodes.\n\t\t */\n\t\tBUG_ON(!(attrs = alloc_workqueue_attrs()));\n\t\tattrs->nice = std_nice[i];\n\t\tattrs->no_numa = true;\n\t\tordered_wq_attrs[i] = attrs;\n\t}\n\n\tsystem_wq = alloc_workqueue(\"events\", 0, 0);\n\tsystem_highpri_wq = alloc_workqueue(\"events_highpri\", WQ_HIGHPRI, 0);\n\tsystem_long_wq = alloc_workqueue(\"events_long\", 0, 0);\n\tsystem_unbound_wq = alloc_workqueue(\"events_unbound\", WQ_UNBOUND,\n\t\t\t\t\t    WQ_UNBOUND_MAX_ACTIVE);\n\tsystem_freezable_wq = alloc_workqueue(\"events_freezable\",\n\t\t\t\t\t      WQ_FREEZABLE, 0);\n\tsystem_power_efficient_wq = alloc_workqueue(\"events_power_efficient\",\n\t\t\t\t\t      WQ_POWER_EFFICIENT, 0);\n\tsystem_freezable_power_efficient_wq = alloc_workqueue(\"events_freezable_power_efficient\",\n\t\t\t\t\t      WQ_FREEZABLE | WQ_POWER_EFFICIENT,\n\t\t\t\t\t      0);\n\tBUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||\n\t       !system_unbound_wq || !system_freezable_wq ||\n\t       !system_power_efficient_wq ||\n\t       !system_freezable_power_efficient_wq);\n}"
  },
  {
    "function_name": "wq_numa_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5952-5994",
    "snippet": "static void __init wq_numa_init(void)\n{\n\tcpumask_var_t *tbl;\n\tint node, cpu;\n\n\tif (num_possible_nodes() <= 1)\n\t\treturn;\n\n\tif (wq_disable_numa) {\n\t\tpr_info(\"workqueue: NUMA affinity support disabled\\n\");\n\t\treturn;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (WARN_ON(cpu_to_node(cpu) == NUMA_NO_NODE)) {\n\t\t\tpr_warn(\"workqueue: NUMA node mapping not available for cpu%d, disabling NUMA support\\n\", cpu);\n\t\t\treturn;\n\t\t}\n\t}\n\n\twq_update_unbound_numa_attrs_buf = alloc_workqueue_attrs();\n\tBUG_ON(!wq_update_unbound_numa_attrs_buf);\n\n\t/*\n\t * We want masks of possible CPUs of each node which isn't readily\n\t * available.  Build one from cpu_to_node() which should have been\n\t * fully initialized by now.\n\t */\n\ttbl = kcalloc(nr_node_ids, sizeof(tbl[0]), GFP_KERNEL);\n\tBUG_ON(!tbl);\n\n\tfor_each_node(node)\n\t\tBUG_ON(!zalloc_cpumask_var_node(&tbl[node], GFP_KERNEL,\n\t\t\t\tnode_online(node) ? node : NUMA_NO_NODE));\n\n\tfor_each_possible_cpu(cpu) {\n\t\tnode = cpu_to_node(cpu);\n\t\tcpumask_set_cpu(cpu, tbl[node]);\n\t}\n\n\twq_numa_possible_cpumask = tbl;\n\twq_numa_enabled = true;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t *wq_numa_possible_cpumask;",
      "static bool wq_disable_numa;",
      "static bool wq_numa_enabled;",
      "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tbl[node]"
          ],
          "line": 5989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 5988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var_node",
          "args": [
            "&tbl[node]",
            "GFP_KERNEL",
            "node_online(node) ? node : NUMA_NO_NODE"
          ],
          "line": 5984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "node"
          ],
          "line": 5985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tbl"
          ],
          "line": 5981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_node_ids",
            "sizeof(tbl[0])",
            "GFP_KERNEL"
          ],
          "line": 5980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!wq_update_unbound_numa_attrs_buf"
          ],
          "line": 5973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [],
          "line": 5972
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3401-3416",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"workqueue: NUMA node mapping not available for cpu%d, disabling NUMA support\\n\"",
            "cpu"
          ],
          "line": 5967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cpu_to_node(cpu) == NUMA_NO_NODE"
          ],
          "line": 5966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 5966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"workqueue: NUMA affinity support disabled\\n\""
          ],
          "line": 5961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_nodes",
          "args": [],
          "line": 5957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_disable_numa;\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\n\nstatic void __init wq_numa_init(void)\n{\n\tcpumask_var_t *tbl;\n\tint node, cpu;\n\n\tif (num_possible_nodes() <= 1)\n\t\treturn;\n\n\tif (wq_disable_numa) {\n\t\tpr_info(\"workqueue: NUMA affinity support disabled\\n\");\n\t\treturn;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (WARN_ON(cpu_to_node(cpu) == NUMA_NO_NODE)) {\n\t\t\tpr_warn(\"workqueue: NUMA node mapping not available for cpu%d, disabling NUMA support\\n\", cpu);\n\t\t\treturn;\n\t\t}\n\t}\n\n\twq_update_unbound_numa_attrs_buf = alloc_workqueue_attrs();\n\tBUG_ON(!wq_update_unbound_numa_attrs_buf);\n\n\t/*\n\t * We want masks of possible CPUs of each node which isn't readily\n\t * available.  Build one from cpu_to_node() which should have been\n\t * fully initialized by now.\n\t */\n\ttbl = kcalloc(nr_node_ids, sizeof(tbl[0]), GFP_KERNEL);\n\tBUG_ON(!tbl);\n\n\tfor_each_node(node)\n\t\tBUG_ON(!zalloc_cpumask_var_node(&tbl[node], GFP_KERNEL,\n\t\t\t\tnode_online(node) ? node : NUMA_NO_NODE));\n\n\tfor_each_possible_cpu(cpu) {\n\t\tnode = cpu_to_node(cpu);\n\t\tcpumask_set_cpu(cpu, tbl[node]);\n\t}\n\n\twq_numa_possible_cpumask = tbl;\n\twq_numa_enabled = true;\n}"
  },
  {
    "function_name": "wq_watchdog_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5948-5948",
    "snippet": "static inline void wq_watchdog_init(void) { }",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void wq_watchdog_init(void) { }"
  },
  {
    "function_name": "wq_watchdog_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5940-5944",
    "snippet": "static void wq_watchdog_init(void)\n{\n\ttimer_setup(&wq_watchdog_timer, wq_watchdog_timer_fn, TIMER_DEFERRABLE);\n\twq_watchdog_set_thresh(wq_watchdog_thresh);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wq_watchdog_set_thresh",
          "args": [
            "wq_watchdog_thresh"
          ],
          "line": 5943
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_set_thresh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5902-5912",
          "snippet": "static void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&wq_watchdog_timer",
            "wq_watchdog_timer_fn",
            "TIMER_DEFERRABLE"
          ],
          "line": 5942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_init(void)\n{\n\ttimer_setup(&wq_watchdog_timer, wq_watchdog_timer_fn, TIMER_DEFERRABLE);\n\twq_watchdog_set_thresh(wq_watchdog_thresh);\n}"
  },
  {
    "function_name": "wq_watchdog_param_set_thresh",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5914-5930",
    "snippet": "static int wq_watchdog_param_set_thresh(const char *val,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\tunsigned long thresh;\n\tint ret;\n\n\tret = kstrtoul(val, 0, &thresh);\n\tif (ret)\n\t\treturn ret;\n\n\tif (system_wq)\n\t\twq_watchdog_set_thresh(thresh);\n\telse\n\t\twq_watchdog_thresh = thresh;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wq_watchdog_set_thresh",
          "args": [
            "thresh"
          ],
          "line": 5925
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_set_thresh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5902-5912",
          "snippet": "static void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "val",
            "0",
            "&thresh"
          ],
          "line": 5920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_watchdog_param_set_thresh(const char *val,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\tunsigned long thresh;\n\tint ret;\n\n\tret = kstrtoul(val, 0, &thresh);\n\tif (ret)\n\t\treturn ret;\n\n\tif (system_wq)\n\t\twq_watchdog_set_thresh(thresh);\n\telse\n\t\twq_watchdog_thresh = thresh;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wq_watchdog_set_thresh",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5902-5912",
    "snippet": "static void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&wq_watchdog_timer",
            "jiffies + thresh * HZ"
          ],
          "line": 5910
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_watchdog_reset_touched",
          "args": [],
          "line": 5909
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_reset_touched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5829-5836",
          "snippet": "static void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&wq_watchdog_timer"
          ],
          "line": 5905
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}"
  },
  {
    "function_name": "wq_watchdog_touch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5894-5900",
    "snippet": "notrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\n\twq_watchdog_touched = jiffies;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wq_watchdog_touched_cpu",
            "cpu"
          ],
          "line": 5897
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nnotrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\n\twq_watchdog_touched = jiffies;\n}"
  },
  {
    "function_name": "wq_watchdog_timer_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5838-5892",
    "snippet": "static void wq_watchdog_timer_fn(struct timer_list *unused)\n{\n\tunsigned long thresh = READ_ONCE(wq_watchdog_thresh) * HZ;\n\tbool lockup_detected = false;\n\tunsigned long now = jiffies;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\tif (!thresh)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tfor_each_pool(pool, pi) {\n\t\tunsigned long pool_ts, touched, ts;\n\n\t\tif (list_empty(&pool->worklist))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like a stall.\n\t\t */\n\t\tkvm_check_and_clear_guest_paused();\n\n\t\t/* get the latest of pool and touched timestamps */\n\t\tif (pool->cpu >= 0)\n\t\t\ttouched = READ_ONCE(per_cpu(wq_watchdog_touched_cpu, pool->cpu));\n\t\telse\n\t\t\ttouched = READ_ONCE(wq_watchdog_touched);\n\t\tpool_ts = READ_ONCE(pool->watchdog_ts);\n\n\t\tif (time_after(pool_ts, touched))\n\t\t\tts = pool_ts;\n\t\telse\n\t\t\tts = touched;\n\n\t\t/* did we stall? */\n\t\tif (time_after(now, ts + thresh)) {\n\t\t\tlockup_detected = true;\n\t\t\tpr_emerg(\"BUG: workqueue lockup - pool\");\n\t\t\tpr_cont_pool_info(pool);\n\t\t\tpr_cont(\" stuck for %us!\\n\",\n\t\t\t\tjiffies_to_msecs(now - pool_ts) / 1000);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (lockup_detected)\n\t\tshow_all_workqueues();\n\n\twq_watchdog_reset_touched();\n\tmod_timer(&wq_watchdog_timer, jiffies + thresh);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&wq_watchdog_timer",
            "jiffies + thresh"
          ],
          "line": 5891
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_watchdog_reset_touched",
          "args": [],
          "line": 5890
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_reset_touched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5829-5836",
          "snippet": "static void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_all_workqueues",
          "args": [],
          "line": 5888
        },
        "resolved": true,
        "details": {
          "function_name": "show_all_workqueues",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4904-4921",
          "snippet": "void show_all_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\trcu_read_lock();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list)\n\t\tshow_one_workqueue(wq);\n\n\tfor_each_pool(pool, pi)\n\t\tshow_one_worker_pool(pool);\n\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid show_all_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\trcu_read_lock();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list)\n\t\tshow_one_workqueue(wq);\n\n\tfor_each_pool(pool, pi)\n\t\tshow_one_worker_pool(pool);\n\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5885
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" stuck for %us!\\n\"",
            "jiffies_to_msecs(now - pool_ts) / 1000"
          ],
          "line": 5880
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "now - pool_ts"
          ],
          "line": 5881
        },
        "resolved": true,
        "details": {
          "function_name": "jiffies_to_msecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "374-388",
          "snippet": "unsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont_pool_info",
          "args": [
            "pool"
          ],
          "line": 5879
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"BUG: workqueue lockup - pool\""
          ],
          "line": 5878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "now",
            "ts + thresh"
          ],
          "line": 5876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "pool_ts",
            "touched"
          ],
          "line": 5870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pool->watchdog_ts"
          ],
          "line": 5868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "wq_watchdog_touched"
          ],
          "line": 5867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "per_cpu(wq_watchdog_touched_cpu, pool->cpu)"
          ],
          "line": 5865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wq_watchdog_touched_cpu",
            "pool->cpu"
          ],
          "line": 5865
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_and_clear_guest_paused",
          "args": [],
          "line": 5861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->worklist"
          ],
          "line": 5854
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool",
          "args": [
            "pool",
            "pi"
          ],
          "line": 5851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5849
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "wq_watchdog_thresh"
          ],
          "line": 5840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wq_watchdog_timer_fn(struct timer_list *unused)\n{\n\tunsigned long thresh = READ_ONCE(wq_watchdog_thresh) * HZ;\n\tbool lockup_detected = false;\n\tunsigned long now = jiffies;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\tif (!thresh)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tfor_each_pool(pool, pi) {\n\t\tunsigned long pool_ts, touched, ts;\n\n\t\tif (list_empty(&pool->worklist))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like a stall.\n\t\t */\n\t\tkvm_check_and_clear_guest_paused();\n\n\t\t/* get the latest of pool and touched timestamps */\n\t\tif (pool->cpu >= 0)\n\t\t\ttouched = READ_ONCE(per_cpu(wq_watchdog_touched_cpu, pool->cpu));\n\t\telse\n\t\t\ttouched = READ_ONCE(wq_watchdog_touched);\n\t\tpool_ts = READ_ONCE(pool->watchdog_ts);\n\n\t\tif (time_after(pool_ts, touched))\n\t\t\tts = pool_ts;\n\t\telse\n\t\t\tts = touched;\n\n\t\t/* did we stall? */\n\t\tif (time_after(now, ts + thresh)) {\n\t\t\tlockup_detected = true;\n\t\t\tpr_emerg(\"BUG: workqueue lockup - pool\");\n\t\t\tpr_cont_pool_info(pool);\n\t\t\tpr_cont(\" stuck for %us!\\n\",\n\t\t\t\tjiffies_to_msecs(now - pool_ts) / 1000);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (lockup_detected)\n\t\tshow_all_workqueues();\n\n\twq_watchdog_reset_touched();\n\tmod_timer(&wq_watchdog_timer, jiffies + thresh);\n}"
  },
  {
    "function_name": "wq_watchdog_reset_touched",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5829-5836",
    "snippet": "static void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}"
  },
  {
    "function_name": "workqueue_sysfs_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5801-5801",
    "snippet": "static void workqueue_sysfs_unregister(struct workqueue_struct *wq)\t{ }",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq)\t{ }"
  },
  {
    "function_name": "workqueue_sysfs_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5790-5799",
    "snippet": "static void workqueue_sysfs_unregister(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev = wq->wq_dev;\n\n\tif (!wq->wq_dev)\n\t\treturn;\n\n\twq->wq_dev = NULL;\n\tdevice_unregister(&wq_dev->dev);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_unregister",
          "args": [
            "&wq_dev->dev"
          ],
          "line": 5798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev = wq->wq_dev;\n\n\tif (!wq->wq_dev)\n\t\treturn;\n\n\twq->wq_dev = NULL;\n\tdevice_unregister(&wq_dev->dev);\n}"
  },
  {
    "function_name": "workqueue_sysfs_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5731-5782",
    "snippet": "int workqueue_sysfs_register(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev;\n\tint ret;\n\n\t/*\n\t * Adjusting max_active or creating new pwqs by applying\n\t * attributes breaks ordering guarantee.  Disallow exposing ordered\n\t * workqueues.\n\t */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn -EINVAL;\n\n\twq->wq_dev = wq_dev = kzalloc(sizeof(*wq_dev), GFP_KERNEL);\n\tif (!wq_dev)\n\t\treturn -ENOMEM;\n\n\twq_dev->wq = wq;\n\twq_dev->dev.bus = &wq_subsys;\n\twq_dev->dev.release = wq_device_release;\n\tdev_set_name(&wq_dev->dev, \"%s\", wq->name);\n\n\t/*\n\t * unbound_attrs are created separately.  Suppress uevent until\n\t * everything is ready.\n\t */\n\tdev_set_uevent_suppress(&wq_dev->dev, true);\n\n\tret = device_register(&wq_dev->dev);\n\tif (ret) {\n\t\tput_device(&wq_dev->dev);\n\t\twq->wq_dev = NULL;\n\t\treturn ret;\n\t}\n\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tstruct device_attribute *attr;\n\n\t\tfor (attr = wq_sysfs_unbound_attrs; attr->attr.name; attr++) {\n\t\t\tret = device_create_file(&wq_dev->dev, attr);\n\t\t\tif (ret) {\n\t\t\t\tdevice_unregister(&wq_dev->dev);\n\t\t\t\twq->wq_dev = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_set_uevent_suppress(&wq_dev->dev, false);\n\tkobject_uevent(&wq_dev->dev.kobj, KOBJ_ADD);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&wq_dev->dev.kobj",
            "KOBJ_ADD"
          ],
          "line": 5780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_uevent_suppress",
          "args": [
            "&wq_dev->dev",
            "false"
          ],
          "line": 5779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_unregister",
          "args": [
            "&wq_dev->dev"
          ],
          "line": 5772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "&wq_dev->dev",
            "attr"
          ],
          "line": 5770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_device",
          "args": [
            "&wq_dev->dev"
          ],
          "line": 5761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_register",
          "args": [
            "&wq_dev->dev"
          ],
          "line": 5759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_uevent_suppress",
          "args": [
            "&wq_dev->dev",
            "true"
          ],
          "line": 5757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_name",
          "args": [
            "&wq_dev->dev",
            "\"%s\"",
            "wq->name"
          ],
          "line": 5751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*wq_dev)",
            "GFP_KERNEL"
          ],
          "line": 5744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "wq->flags & __WQ_ORDERED_EXPLICIT"
          ],
          "line": 5741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint workqueue_sysfs_register(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev;\n\tint ret;\n\n\t/*\n\t * Adjusting max_active or creating new pwqs by applying\n\t * attributes breaks ordering guarantee.  Disallow exposing ordered\n\t * workqueues.\n\t */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn -EINVAL;\n\n\twq->wq_dev = wq_dev = kzalloc(sizeof(*wq_dev), GFP_KERNEL);\n\tif (!wq_dev)\n\t\treturn -ENOMEM;\n\n\twq_dev->wq = wq;\n\twq_dev->dev.bus = &wq_subsys;\n\twq_dev->dev.release = wq_device_release;\n\tdev_set_name(&wq_dev->dev, \"%s\", wq->name);\n\n\t/*\n\t * unbound_attrs are created separately.  Suppress uevent until\n\t * everything is ready.\n\t */\n\tdev_set_uevent_suppress(&wq_dev->dev, true);\n\n\tret = device_register(&wq_dev->dev);\n\tif (ret) {\n\t\tput_device(&wq_dev->dev);\n\t\twq->wq_dev = NULL;\n\t\treturn ret;\n\t}\n\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tstruct device_attribute *attr;\n\n\t\tfor (attr = wq_sysfs_unbound_attrs; attr->attr.name; attr++) {\n\t\t\tret = device_create_file(&wq_dev->dev, attr);\n\t\t\tif (ret) {\n\t\t\t\tdevice_unregister(&wq_dev->dev);\n\t\t\t\twq->wq_dev = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_set_uevent_suppress(&wq_dev->dev, false);\n\tkobject_uevent(&wq_dev->dev.kobj, KOBJ_ADD);\n\treturn 0;\n}"
  },
  {
    "function_name": "wq_device_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5709-5714",
    "snippet": "static void wq_device_release(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\tkfree(wq_dev);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq_dev"
          ],
          "line": 5713
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structwq_device",
            "dev"
          ],
          "line": 5711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_device_release(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\tkfree(wq_dev);\n}"
  },
  {
    "function_name": "wq_sysfs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5697-5706",
    "snippet": "static int __init wq_sysfs_init(void)\n{\n\tint err;\n\n\terr = subsys_virtual_register(&wq_subsys, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn device_create_file(wq_subsys.dev_root, &wq_sysfs_cpumask_attr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "wq_subsys.dev_root",
            "&wq_sysfs_cpumask_attr"
          ],
          "line": 5705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subsys_virtual_register",
          "args": [
            "&wq_subsys",
            "NULL"
          ],
          "line": 5701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int __init wq_sysfs_init(void)\n{\n\tint err;\n\n\terr = subsys_virtual_register(&wq_subsys, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn device_create_file(wq_subsys.dev_root, &wq_sysfs_cpumask_attr);\n}"
  },
  {
    "function_name": "wq_unbound_cpumask_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5676-5691",
    "snippet": "static ssize_t wq_unbound_cpumask_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tcpumask_var_t cpumask;\n\tint ret;\n\n\tif (!zalloc_cpumask_var(&cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = cpumask_parse(buf, cpumask);\n\tif (!ret)\n\t\tret = workqueue_set_unbound_cpumask(cpumask);\n\n\tfree_cpumask_var(cpumask);\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cpumask"
          ],
          "line": 5689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "workqueue_set_unbound_cpumask",
          "args": [
            "cpumask"
          ],
          "line": 5687
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_unbound_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5391-5430",
          "snippet": "int workqueue_set_unbound_cpumask(cpumask_var_t cpumask)\n{\n\tint ret = -EINVAL;\n\tcpumask_var_t saved_cpumask;\n\n\t/*\n\t * Not excluding isolated cpus on purpose.\n\t * If the user wishes to include them, we allow that.\n\t */\n\tcpumask_and(cpumask, cpumask, cpu_possible_mask);\n\tif (!cpumask_empty(cpumask)) {\n\t\tapply_wqattrs_lock();\n\t\tif (cpumask_equal(cpumask, wq_unbound_cpumask)) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!zalloc_cpumask_var(&saved_cpumask, GFP_KERNEL)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* save the old wq_unbound_cpumask. */\n\t\tcpumask_copy(saved_cpumask, wq_unbound_cpumask);\n\n\t\t/* update wq_unbound_cpumask at first and apply it to wqs. */\n\t\tcpumask_copy(wq_unbound_cpumask, cpumask);\n\t\tret = workqueue_apply_unbound_cpumask();\n\n\t\t/* restore the wq_unbound_cpumask when failed. */\n\t\tif (ret < 0)\n\t\t\tcpumask_copy(wq_unbound_cpumask, saved_cpumask);\n\n\t\tfree_cpumask_var(saved_cpumask);\nout_unlock:\n\t\tapply_wqattrs_unlock();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t wq_unbound_cpumask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t wq_unbound_cpumask;\n\nint workqueue_set_unbound_cpumask(cpumask_var_t cpumask)\n{\n\tint ret = -EINVAL;\n\tcpumask_var_t saved_cpumask;\n\n\t/*\n\t * Not excluding isolated cpus on purpose.\n\t * If the user wishes to include them, we allow that.\n\t */\n\tcpumask_and(cpumask, cpumask, cpu_possible_mask);\n\tif (!cpumask_empty(cpumask)) {\n\t\tapply_wqattrs_lock();\n\t\tif (cpumask_equal(cpumask, wq_unbound_cpumask)) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!zalloc_cpumask_var(&saved_cpumask, GFP_KERNEL)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* save the old wq_unbound_cpumask. */\n\t\tcpumask_copy(saved_cpumask, wq_unbound_cpumask);\n\n\t\t/* update wq_unbound_cpumask at first and apply it to wqs. */\n\t\tcpumask_copy(wq_unbound_cpumask, cpumask);\n\t\tret = workqueue_apply_unbound_cpumask();\n\n\t\t/* restore the wq_unbound_cpumask when failed. */\n\t\tif (ret < 0)\n\t\t\tcpumask_copy(wq_unbound_cpumask, saved_cpumask);\n\n\t\tfree_cpumask_var(saved_cpumask);\nout_unlock:\n\t\tapply_wqattrs_unlock();\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_parse",
          "args": [
            "buf",
            "cpumask"
          ],
          "line": 5685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&cpumask",
            "GFP_KERNEL"
          ],
          "line": 5682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic ssize_t wq_unbound_cpumask_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tcpumask_var_t cpumask;\n\tint ret;\n\n\tif (!zalloc_cpumask_var(&cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = cpumask_parse(buf, cpumask);\n\tif (!ret)\n\t\tret = workqueue_set_unbound_cpumask(cpumask);\n\n\tfree_cpumask_var(cpumask);\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "wq_unbound_cpumask_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5663-5674",
    "snippet": "static ssize_t wq_unbound_cpumask_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tint written;\n\n\tmutex_lock(&wq_pool_mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t\t    cpumask_pr_args(wq_unbound_cpumask));\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn written;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static cpumask_var_t wq_unbound_cpumask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5671
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%*pb\\n\"",
            "cpumask_pr_args(wq_unbound_cpumask)"
          ],
          "line": 5669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "wq_unbound_cpumask"
          ],
          "line": 5670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5668
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic cpumask_var_t wq_unbound_cpumask;\n\nstatic ssize_t wq_unbound_cpumask_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tint written;\n\n\tmutex_lock(&wq_pool_mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t\t    cpumask_pr_args(wq_unbound_cpumask));\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn written;\n}"
  },
  {
    "function_name": "wq_numa_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5625-5648",
    "snippet": "static ssize_t wq_numa_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint v, ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tif (sscanf(buf, \"%d\", &v) == 1) {\n\t\tattrs->no_numa = !v;\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\t}\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "attrs"
          ],
          "line": 5646
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3385-3391",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_unlock",
          "args": [],
          "line": 5645
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4063-4067",
          "snippet": "static void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_workqueue_attrs_locked",
          "args": [
            "wq",
            "attrs"
          ],
          "line": 5641
        },
        "resolved": true,
        "details": {
          "function_name": "apply_workqueue_attrs_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4069-4095",
          "snippet": "static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%d\"",
            "&v"
          ],
          "line": 5639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_sysfs_prep_attrs",
          "args": [
            "wq"
          ],
          "line": 5634
        },
        "resolved": true,
        "details": {
          "function_name": "wq_sysfs_prep_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5535-5547",
          "snippet": "static struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_lock",
          "args": [],
          "line": 5632
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4056-4061",
          "snippet": "static void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tcpus_read_lock();\n\tmutex_lock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tcpus_read_lock();\n\tmutex_lock(&wq_pool_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5628
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5453-5458",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_numa_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint v, ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tif (sscanf(buf, \"%d\", &v) == 1) {\n\t\tattrs->no_numa = !v;\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\t}\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}"
  },
  {
    "function_name": "wq_numa_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5611-5623",
    "snippet": "static ssize_t wq_numa_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t    !wq->unbound_attrs->no_numa);\n\tmutex_unlock(&wq->mutex);\n\n\treturn written;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5620
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%d\\n\"",
            "!wq->unbound_attrs->no_numa"
          ],
          "line": 5618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5617
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5614
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5453-5458",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_numa_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t    !wq->unbound_attrs->no_numa);\n\tmutex_unlock(&wq->mutex);\n\n\treturn written;\n}"
  },
  {
    "function_name": "wq_cpumask_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5587-5609",
    "snippet": "static ssize_t wq_cpumask_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tret = cpumask_parse(buf, attrs->cpumask);\n\tif (!ret)\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "attrs"
          ],
          "line": 5607
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3385-3391",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_unlock",
          "args": [],
          "line": 5606
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4063-4067",
          "snippet": "static void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_workqueue_attrs_locked",
          "args": [
            "wq",
            "attrs"
          ],
          "line": 5603
        },
        "resolved": true,
        "details": {
          "function_name": "apply_workqueue_attrs_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4069-4095",
          "snippet": "static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_parse",
          "args": [
            "buf",
            "attrs->cpumask"
          ],
          "line": 5601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_sysfs_prep_attrs",
          "args": [
            "wq"
          ],
          "line": 5597
        },
        "resolved": true,
        "details": {
          "function_name": "wq_sysfs_prep_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5535-5547",
          "snippet": "static struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_lock",
          "args": [],
          "line": 5595
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4056-4061",
          "snippet": "static void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tcpus_read_lock();\n\tmutex_lock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tcpus_read_lock();\n\tmutex_lock(&wq_pool_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5591
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5453-5458",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_cpumask_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tret = cpumask_parse(buf, attrs->cpumask);\n\tif (!ret)\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}"
  },
  {
    "function_name": "wq_cpumask_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5574-5585",
    "snippet": "static ssize_t wq_cpumask_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t\t    cpumask_pr_args(wq->unbound_attrs->cpumask));\n\tmutex_unlock(&wq->mutex);\n\treturn written;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5583
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%*pb\\n\"",
            "cpumask_pr_args(wq->unbound_attrs->cpumask)"
          ],
          "line": 5581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "wq->unbound_attrs->cpumask"
          ],
          "line": 5582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5580
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5577
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5453-5458",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_cpumask_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t\t    cpumask_pr_args(wq->unbound_attrs->cpumask));\n\tmutex_unlock(&wq->mutex);\n\treturn written;\n}"
  },
  {
    "function_name": "wq_nice_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5549-5572",
    "snippet": "static ssize_t wq_nice_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tif (sscanf(buf, \"%d\", &attrs->nice) == 1 &&\n\t    attrs->nice >= MIN_NICE && attrs->nice <= MAX_NICE)\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\telse\n\t\tret = -EINVAL;\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "attrs"
          ],
          "line": 5570
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3385-3391",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_unlock",
          "args": [],
          "line": 5569
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4063-4067",
          "snippet": "static void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_workqueue_attrs_locked",
          "args": [
            "wq",
            "attrs"
          ],
          "line": 5564
        },
        "resolved": true,
        "details": {
          "function_name": "apply_workqueue_attrs_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4069-4095",
          "snippet": "static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%d\"",
            "&attrs->nice"
          ],
          "line": 5562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_sysfs_prep_attrs",
          "args": [
            "wq"
          ],
          "line": 5558
        },
        "resolved": true,
        "details": {
          "function_name": "wq_sysfs_prep_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5535-5547",
          "snippet": "static struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_lock",
          "args": [],
          "line": 5556
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4056-4061",
          "snippet": "static void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tcpus_read_lock();\n\tmutex_lock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tcpus_read_lock();\n\tmutex_lock(&wq_pool_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5552
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5453-5458",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_nice_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tif (sscanf(buf, \"%d\", &attrs->nice) == 1 &&\n\t    attrs->nice >= MIN_NICE && attrs->nice <= MAX_NICE)\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\telse\n\t\tret = -EINVAL;\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}"
  },
  {
    "function_name": "wq_sysfs_prep_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5535-5547",
    "snippet": "static struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_workqueue_attrs",
          "args": [
            "attrs",
            "wq->unbound_attrs"
          ],
          "line": 5545
        },
        "resolved": true,
        "details": {
          "function_name": "copy_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3418-3429",
          "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [],
          "line": 5541
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3401-3416",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}"
  },
  {
    "function_name": "wq_nice_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5521-5532",
    "snippet": "static ssize_t wq_nice_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%d\\n\", wq->unbound_attrs->nice);\n\tmutex_unlock(&wq->mutex);\n\n\treturn written;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5529
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%d\\n\"",
            "wq->unbound_attrs->nice"
          ],
          "line": 5528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5527
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5524
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5453-5458",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_nice_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%d\\n\", wq->unbound_attrs->nice);\n\tmutex_unlock(&wq->mutex);\n\n\treturn written;\n}"
  },
  {
    "function_name": "wq_pool_ids_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5499-5519",
    "snippet": "static ssize_t wq_pool_ids_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tconst char *delim = \"\";\n\tint node, written = 0;\n\n\tcpus_read_lock();\n\trcu_read_lock();\n\tfor_each_node(node) {\n\t\twritten += scnprintf(buf + written, PAGE_SIZE - written,\n\t\t\t\t     \"%s%d:%d\", delim, node,\n\t\t\t\t     unbound_pwq_by_node(wq, node)->pool->id);\n\t\tdelim = \" \";\n\t}\n\twritten += scnprintf(buf + written, PAGE_SIZE - written, \"\\n\");\n\trcu_read_unlock();\n\tcpus_read_unlock();\n\n\treturn written;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 5516
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5515
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf + written",
            "PAGE_SIZE - written",
            "\"\\n\""
          ],
          "line": 5514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf + written",
            "PAGE_SIZE - written",
            "\"%s%d:%d\"",
            "delim",
            "node",
            "unbound_pwq_by_node(wq, node)->pool->id"
          ],
          "line": 5509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unbound_pwq_by_node",
          "args": [
            "wq",
            "node"
          ],
          "line": 5511
        },
        "resolved": true,
        "details": {
          "function_name": "unbound_pwq_by_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "574-589",
          "snippet": "static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5507
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 5506
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5502
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5453-5458",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic ssize_t wq_pool_ids_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tconst char *delim = \"\";\n\tint node, written = 0;\n\n\tcpus_read_lock();\n\trcu_read_lock();\n\tfor_each_node(node) {\n\t\twritten += scnprintf(buf + written, PAGE_SIZE - written,\n\t\t\t\t     \"%s%d:%d\", delim, node,\n\t\t\t\t     unbound_pwq_by_node(wq, node)->pool->id);\n\t\tdelim = \" \";\n\t}\n\twritten += scnprintf(buf + written, PAGE_SIZE - written, \"\\n\");\n\trcu_read_unlock();\n\tcpus_read_unlock();\n\n\treturn written;\n}"
  },
  {
    "function_name": "max_active_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5477-5489",
    "snippet": "static ssize_t max_active_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint val;\n\n\tif (sscanf(buf, \"%d\", &val) != 1 || val <= 0)\n\t\treturn -EINVAL;\n\n\tworkqueue_set_max_active(wq, val);\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "workqueue_set_max_active",
          "args": [
            "wq",
            "val"
          ],
          "line": 5487
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4514-4533",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%d\"",
            "&val"
          ],
          "line": 5484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5481
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5453-5458",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t max_active_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint val;\n\n\tif (sscanf(buf, \"%d\", &val) != 1 || val <= 0)\n\t\treturn -EINVAL;\n\n\tworkqueue_set_max_active(wq, val);\n\treturn count;\n}"
  },
  {
    "function_name": "max_active_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5469-5475",
    "snippet": "static ssize_t max_active_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", wq->saved_max_active);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%d\\n\"",
            "wq->saved_max_active"
          ],
          "line": 5474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5472
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5453-5458",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t max_active_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", wq->saved_max_active);\n}"
  },
  {
    "function_name": "per_cpu_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5460-5466",
    "snippet": "static ssize_t per_cpu_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (bool)!(wq->flags & WQ_UNBOUND));\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%d\\n\"",
            "(bool)!(wq->flags & WQ_UNBOUND)"
          ],
          "line": 5465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5463
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5453-5458",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t per_cpu_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (bool)!(wq->flags & WQ_UNBOUND));\n}"
  },
  {
    "function_name": "dev_to_wq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5453-5458",
    "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structwq_device",
            "dev"
          ],
          "line": 5455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
  },
  {
    "function_name": "workqueue_set_unbound_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5391-5430",
    "snippet": "int workqueue_set_unbound_cpumask(cpumask_var_t cpumask)\n{\n\tint ret = -EINVAL;\n\tcpumask_var_t saved_cpumask;\n\n\t/*\n\t * Not excluding isolated cpus on purpose.\n\t * If the user wishes to include them, we allow that.\n\t */\n\tcpumask_and(cpumask, cpumask, cpu_possible_mask);\n\tif (!cpumask_empty(cpumask)) {\n\t\tapply_wqattrs_lock();\n\t\tif (cpumask_equal(cpumask, wq_unbound_cpumask)) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!zalloc_cpumask_var(&saved_cpumask, GFP_KERNEL)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* save the old wq_unbound_cpumask. */\n\t\tcpumask_copy(saved_cpumask, wq_unbound_cpumask);\n\n\t\t/* update wq_unbound_cpumask at first and apply it to wqs. */\n\t\tcpumask_copy(wq_unbound_cpumask, cpumask);\n\t\tret = workqueue_apply_unbound_cpumask();\n\n\t\t/* restore the wq_unbound_cpumask when failed. */\n\t\tif (ret < 0)\n\t\t\tcpumask_copy(wq_unbound_cpumask, saved_cpumask);\n\n\t\tfree_cpumask_var(saved_cpumask);\nout_unlock:\n\t\tapply_wqattrs_unlock();\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t wq_unbound_cpumask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_wqattrs_unlock",
          "args": [],
          "line": 5426
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4063-4067",
          "snippet": "static void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "saved_cpumask"
          ],
          "line": 5424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "wq_unbound_cpumask",
            "saved_cpumask"
          ],
          "line": 5422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "workqueue_apply_unbound_cpumask",
          "args": [],
          "line": 5418
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_apply_unbound_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5345-5377",
          "snippet": "static int workqueue_apply_unbound_cpumask(void)\n{\n\tLIST_HEAD(ctxs);\n\tint ret = 0;\n\tstruct workqueue_struct *wq;\n\tstruct apply_wqattrs_ctx *ctx, *n;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_UNBOUND))\n\t\t\tcontinue;\n\t\t/* creating multiple pwqs breaks ordering guarantee */\n\t\tif (wq->flags & __WQ_ORDERED)\n\t\t\tcontinue;\n\n\t\tctx = apply_wqattrs_prepare(wq, wq->unbound_attrs);\n\t\tif (!ctx) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&ctx->list, &ctxs);\n\t}\n\n\tlist_for_each_entry_safe(ctx, n, &ctxs, list) {\n\t\tif (!ret)\n\t\t\tapply_wqattrs_commit(ctx);\n\t\tapply_wqattrs_cleanup(ctx);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int workqueue_apply_unbound_cpumask(void)\n{\n\tLIST_HEAD(ctxs);\n\tint ret = 0;\n\tstruct workqueue_struct *wq;\n\tstruct apply_wqattrs_ctx *ctx, *n;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_UNBOUND))\n\t\t\tcontinue;\n\t\t/* creating multiple pwqs breaks ordering guarantee */\n\t\tif (wq->flags & __WQ_ORDERED)\n\t\t\tcontinue;\n\n\t\tctx = apply_wqattrs_prepare(wq, wq->unbound_attrs);\n\t\tif (!ctx) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&ctx->list, &ctxs);\n\t}\n\n\tlist_for_each_entry_safe(ctx, n, &ctxs, list) {\n\t\tif (!ret)\n\t\t\tapply_wqattrs_commit(ctx);\n\t\tapply_wqattrs_cleanup(ctx);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "wq_unbound_cpumask",
            "cpumask"
          ],
          "line": 5417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "saved_cpumask",
            "wq_unbound_cpumask"
          ],
          "line": 5414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&saved_cpumask",
            "GFP_KERNEL"
          ],
          "line": 5408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "cpumask",
            "wq_unbound_cpumask"
          ],
          "line": 5403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_lock",
          "args": [],
          "line": 5402
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4056-4061",
          "snippet": "static void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tcpus_read_lock();\n\tmutex_lock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tcpus_read_lock();\n\tmutex_lock(&wq_pool_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpumask"
          ],
          "line": 5401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "cpumask",
            "cpumask",
            "cpu_possible_mask"
          ],
          "line": 5400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t wq_unbound_cpumask;\n\nint workqueue_set_unbound_cpumask(cpumask_var_t cpumask)\n{\n\tint ret = -EINVAL;\n\tcpumask_var_t saved_cpumask;\n\n\t/*\n\t * Not excluding isolated cpus on purpose.\n\t * If the user wishes to include them, we allow that.\n\t */\n\tcpumask_and(cpumask, cpumask, cpu_possible_mask);\n\tif (!cpumask_empty(cpumask)) {\n\t\tapply_wqattrs_lock();\n\t\tif (cpumask_equal(cpumask, wq_unbound_cpumask)) {\n\t\t\tret = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!zalloc_cpumask_var(&saved_cpumask, GFP_KERNEL)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* save the old wq_unbound_cpumask. */\n\t\tcpumask_copy(saved_cpumask, wq_unbound_cpumask);\n\n\t\t/* update wq_unbound_cpumask at first and apply it to wqs. */\n\t\tcpumask_copy(wq_unbound_cpumask, cpumask);\n\t\tret = workqueue_apply_unbound_cpumask();\n\n\t\t/* restore the wq_unbound_cpumask when failed. */\n\t\tif (ret < 0)\n\t\t\tcpumask_copy(wq_unbound_cpumask, saved_cpumask);\n\n\t\tfree_cpumask_var(saved_cpumask);\nout_unlock:\n\t\tapply_wqattrs_unlock();\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "workqueue_apply_unbound_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5345-5377",
    "snippet": "static int workqueue_apply_unbound_cpumask(void)\n{\n\tLIST_HEAD(ctxs);\n\tint ret = 0;\n\tstruct workqueue_struct *wq;\n\tstruct apply_wqattrs_ctx *ctx, *n;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_UNBOUND))\n\t\t\tcontinue;\n\t\t/* creating multiple pwqs breaks ordering guarantee */\n\t\tif (wq->flags & __WQ_ORDERED)\n\t\t\tcontinue;\n\n\t\tctx = apply_wqattrs_prepare(wq, wq->unbound_attrs);\n\t\tif (!ctx) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&ctx->list, &ctxs);\n\t}\n\n\tlist_for_each_entry_safe(ctx, n, &ctxs, list) {\n\t\tif (!ret)\n\t\t\tapply_wqattrs_commit(ctx);\n\t\tapply_wqattrs_cleanup(ctx);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_wqattrs_cleanup",
          "args": [
            "ctx"
          ],
          "line": 5373
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3948-3961",
          "snippet": "static void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_commit",
          "args": [
            "ctx"
          ],
          "line": 5372
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4035-4054",
          "snippet": "static void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ctx",
            "n",
            "&ctxs",
            "list"
          ],
          "line": 5370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ctx->list",
            "&ctxs"
          ],
          "line": 5367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_prepare",
          "args": [
            "wq",
            "wq->unbound_attrs"
          ],
          "line": 5361
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3964-4032",
          "snippet": "static struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs();\n\ttmp_attrs = alloc_workqueue_attrs();\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static cpumask_var_t wq_unbound_cpumask;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs();\n\ttmp_attrs = alloc_workqueue_attrs();\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 5354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "ctxs"
          ],
          "line": 5347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int workqueue_apply_unbound_cpumask(void)\n{\n\tLIST_HEAD(ctxs);\n\tint ret = 0;\n\tstruct workqueue_struct *wq;\n\tstruct apply_wqattrs_ctx *ctx, *n;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_UNBOUND))\n\t\t\tcontinue;\n\t\t/* creating multiple pwqs breaks ordering guarantee */\n\t\tif (wq->flags & __WQ_ORDERED)\n\t\t\tcontinue;\n\n\t\tctx = apply_wqattrs_prepare(wq, wq->unbound_attrs);\n\t\tif (!ctx) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&ctx->list, &ctxs);\n\t}\n\n\tlist_for_each_entry_safe(ctx, n, &ctxs, list) {\n\t\tif (!ret)\n\t\t\tapply_wqattrs_commit(ctx);\n\t\tapply_wqattrs_cleanup(ctx);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "thaw_workqueues",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5320-5342",
    "snippet": "void thaw_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tif (!workqueue_freezing)\n\t\tgoto out_unlock;\n\n\tworkqueue_freezing = false;\n\n\t/* restore max_active and repopulate worklist */\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static bool workqueue_freezing;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5341
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwq_adjust_max_active",
          "args": [
            "pwq"
          ],
          "line": 5336
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_adjust_max_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3759-3804",
          "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 5335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5334
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 5333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nvoid thaw_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tif (!workqueue_freezing)\n\t\tgoto out_unlock;\n\n\tworkqueue_freezing = false;\n\n\t/* restore max_active and repopulate worklist */\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n}"
  },
  {
    "function_name": "freeze_workqueues_busy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5278-5309",
    "snippet": "bool freeze_workqueues_busy(void)\n{\n\tbool busy = false;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(!workqueue_freezing);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_FREEZABLE))\n\t\t\tcontinue;\n\t\t/*\n\t\t * nr_active is monotonically decreasing.  It's safe\n\t\t * to peek without lock.\n\t\t */\n\t\trcu_read_lock();\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tWARN_ON_ONCE(pwq->nr_active < 0);\n\t\t\tif (pwq->nr_active) {\n\t\t\t\tbusy = true;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n\treturn busy;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static bool workqueue_freezing;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5307
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5304
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pwq->nr_active < 0"
          ],
          "line": 5297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 5296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5295
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 5288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!workqueue_freezing"
          ],
          "line": 5286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5284
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nbool freeze_workqueues_busy(void)\n{\n\tbool busy = false;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(!workqueue_freezing);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_FREEZABLE))\n\t\t\tcontinue;\n\t\t/*\n\t\t * nr_active is monotonically decreasing.  It's safe\n\t\t * to peek without lock.\n\t\t */\n\t\trcu_read_lock();\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tWARN_ON_ONCE(pwq->nr_active < 0);\n\t\t\tif (pwq->nr_active) {\n\t\t\t\tbusy = true;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n\treturn busy;\n}"
  },
  {
    "function_name": "freeze_workqueues_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5245-5263",
    "snippet": "void freeze_workqueues_begin(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(workqueue_freezing);\n\tworkqueue_freezing = true;\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\n\tmutex_unlock(&wq_pool_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static bool workqueue_freezing;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5262
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwq_adjust_max_active",
          "args": [
            "pwq"
          ],
          "line": 5258
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_adjust_max_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3759-3804",
          "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 5257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5256
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 5255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "workqueue_freezing"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nvoid freeze_workqueues_begin(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(workqueue_freezing);\n\tworkqueue_freezing = true;\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\n\tmutex_unlock(&wq_pool_mutex);\n}"
  },
  {
    "function_name": "work_on_cpu_safe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5220-5229",
    "snippet": "long work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg)\n{\n\tlong ret = -ENODEV;\n\n\tcpus_read_lock();\n\tif (cpu_online(cpu))\n\t\tret = work_on_cpu(cpu, fn, arg);\n\tcpus_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 5227
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_on_cpu",
          "args": [
            "cpu",
            "fn",
            "arg"
          ],
          "line": 5226
        },
        "resolved": true,
        "details": {
          "function_name": "work_on_cpu_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5220-5229",
          "snippet": "long work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg)\n{\n\tlong ret = -ENODEV;\n\n\tcpus_read_lock();\n\tif (cpu_online(cpu))\n\t\tret = work_on_cpu(cpu, fn, arg);\n\tcpus_read_unlock();\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 5225
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 5224
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nlong work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg)\n{\n\tlong ret = -ENODEV;\n\n\tcpus_read_lock();\n\tif (cpu_online(cpu))\n\t\tret = work_on_cpu(cpu, fn, arg);\n\tcpus_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "work_on_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5197-5206",
    "snippet": "long work_on_cpu(int cpu, long (*fn)(void *), void *arg)\n{\n\tstruct work_for_cpu wfc = { .fn = fn, .arg = arg };\n\n\tINIT_WORK_ONSTACK(&wfc.work, work_for_cpu_fn);\n\tschedule_work_on(cpu, &wfc.work);\n\tflush_work(&wfc.work);\n\tdestroy_work_on_stack(&wfc.work);\n\treturn wfc.ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_work_on_stack",
          "args": [
            "&wfc.work"
          ],
          "line": 5204
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_work_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "522-525",
          "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&wfc.work"
          ],
          "line": 5203
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3112-3115",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work_on",
          "args": [
            "cpu",
            "&wfc.work"
          ],
          "line": 5202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&wfc.work",
            "work_for_cpu_fn"
          ],
          "line": 5201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nlong work_on_cpu(int cpu, long (*fn)(void *), void *arg)\n{\n\tstruct work_for_cpu wfc = { .fn = fn, .arg = arg };\n\n\tINIT_WORK_ONSTACK(&wfc.work, work_for_cpu_fn);\n\tschedule_work_on(cpu, &wfc.work);\n\tflush_work(&wfc.work);\n\tdestroy_work_on_stack(&wfc.work);\n\treturn wfc.ret;\n}"
  },
  {
    "function_name": "work_for_cpu_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5179-5184",
    "snippet": "static void work_for_cpu_fn(struct work_struct *work)\n{\n\tstruct work_for_cpu *wfc = container_of(work, struct work_for_cpu, work);\n\n\twfc->ret = wfc->fn(wfc->arg);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wfc->fn",
          "args": [
            "wfc->arg"
          ],
          "line": 5183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structwork_for_cpu",
            "work"
          ],
          "line": 5181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void work_for_cpu_fn(struct work_struct *work)\n{\n\tstruct work_for_cpu *wfc = container_of(work, struct work_for_cpu, work);\n\n\twfc->ret = wfc->fn(wfc->arg);\n}"
  },
  {
    "function_name": "workqueue_offline_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5153-5170",
    "snippet": "int workqueue_offline_cpu(unsigned int cpu)\n{\n\tstruct workqueue_struct *wq;\n\n\t/* unbinding per-cpu workers should happen on the local CPU */\n\tif (WARN_ON(cpu != smp_processor_id()))\n\t\treturn -1;\n\n\tunbind_workers(cpu);\n\n\t/* update NUMA affinity of unbound workqueues */\n\tmutex_lock(&wq_pool_mutex);\n\tlist_for_each_entry(wq, &workqueues, list)\n\t\twq_update_unbound_numa(wq, cpu, false);\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5167
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_update_unbound_numa",
          "args": [
            "wq",
            "cpu",
            "false"
          ],
          "line": 5166
        },
        "resolved": true,
        "details": {
          "function_name": "wq_update_unbound_numa",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4151-4212",
          "snippet": "static void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\traw_spin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\traw_spin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_numa_enabled;",
            "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\traw_spin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\traw_spin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 5165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5164
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unbind_workers",
          "args": [
            "cpu"
          ],
          "line": 5161
        },
        "resolved": true,
        "details": {
          "function_name": "unbind_workers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4979-5027",
          "snippet": "static void unbind_workers(int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct worker *worker;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\t\traw_spin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * We've blocked all attach/detach operations. Make all workers\n\t\t * unbound and set DISASSOCIATED.  Before this, all workers\n\t\t * must be on the cpu.  After this, they may become diasporas.\n\t\t * And the preemption disabled section in their sched callbacks\n\t\t * are guaranteed to see WORKER_UNBOUND since the code here\n\t\t * is on the same cpu.\n\t\t */\n\t\tfor_each_pool_worker(worker, pool)\n\t\t\tworker->flags |= WORKER_UNBOUND;\n\n\t\tpool->flags |= POOL_DISASSOCIATED;\n\n\t\t/*\n\t\t * The handling of nr_running in sched callbacks are disabled\n\t\t * now.  Zap nr_running.  After this, nr_running stays zero and\n\t\t * need_more_worker() and keep_working() are always true as\n\t\t * long as the worklist is not empty.  This pool now behaves as\n\t\t * an unbound (in terms of concurrency management) pool which\n\t\t * are served by workers tied to the pool.\n\t\t */\n\t\tatomic_set(&pool->nr_running, 0);\n\n\t\t/*\n\t\t * With concurrency management just turned off, a busy\n\t\t * worker blocking could lead to lengthy stalls.  Kick off\n\t\t * unbound chain execution of currently pending work items.\n\t\t */\n\t\twake_up_worker(pool);\n\n\t\traw_spin_unlock_irq(&pool->lock);\n\n\t\tfor_each_pool_worker(worker, pool) {\n\t\t\tkthread_set_per_cpu(worker->task, -1);\n\t\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, cpu_possible_mask) < 0);\n\t\t}\n\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void unbind_workers(int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct worker *worker;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\t\traw_spin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * We've blocked all attach/detach operations. Make all workers\n\t\t * unbound and set DISASSOCIATED.  Before this, all workers\n\t\t * must be on the cpu.  After this, they may become diasporas.\n\t\t * And the preemption disabled section in their sched callbacks\n\t\t * are guaranteed to see WORKER_UNBOUND since the code here\n\t\t * is on the same cpu.\n\t\t */\n\t\tfor_each_pool_worker(worker, pool)\n\t\t\tworker->flags |= WORKER_UNBOUND;\n\n\t\tpool->flags |= POOL_DISASSOCIATED;\n\n\t\t/*\n\t\t * The handling of nr_running in sched callbacks are disabled\n\t\t * now.  Zap nr_running.  After this, nr_running stays zero and\n\t\t * need_more_worker() and keep_working() are always true as\n\t\t * long as the worklist is not empty.  This pool now behaves as\n\t\t * an unbound (in terms of concurrency management) pool which\n\t\t * are served by workers tied to the pool.\n\t\t */\n\t\tatomic_set(&pool->nr_running, 0);\n\n\t\t/*\n\t\t * With concurrency management just turned off, a busy\n\t\t * worker blocking could lead to lengthy stalls.  Kick off\n\t\t * unbound chain execution of currently pending work items.\n\t\t */\n\t\twake_up_worker(pool);\n\n\t\traw_spin_unlock_irq(&pool->lock);\n\n\t\tfor_each_pool_worker(worker, pool) {\n\t\t\tkthread_set_per_cpu(worker->task, -1);\n\t\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, cpu_possible_mask) < 0);\n\t\t}\n\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cpu != smp_processor_id()"
          ],
          "line": 5158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 5158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint workqueue_offline_cpu(unsigned int cpu)\n{\n\tstruct workqueue_struct *wq;\n\n\t/* unbinding per-cpu workers should happen on the local CPU */\n\tif (WARN_ON(cpu != smp_processor_id()))\n\t\treturn -1;\n\n\tunbind_workers(cpu);\n\n\t/* update NUMA affinity of unbound workqueues */\n\tmutex_lock(&wq_pool_mutex);\n\tlist_for_each_entry(wq, &workqueues, list)\n\t\twq_update_unbound_numa(wq, cpu, false);\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "workqueue_online_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5126-5151",
    "snippet": "int workqueue_online_cpu(unsigned int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct workqueue_struct *wq;\n\tint pi;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tfor_each_pool(pool, pi) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\n\t\tif (pool->cpu == cpu)\n\t\t\trebind_workers(pool);\n\t\telse if (pool->cpu < 0)\n\t\t\trestore_unbound_workers_cpumask(pool, cpu);\n\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\t}\n\n\t/* update NUMA affinity of unbound workqueues */\n\tlist_for_each_entry(wq, &workqueues, list)\n\t\twq_update_unbound_numa(wq, cpu, true);\n\n\tmutex_unlock(&wq_pool_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static LIST_HEAD(workqueues);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5149
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_update_unbound_numa",
          "args": [
            "wq",
            "cpu",
            "true"
          ],
          "line": 5147
        },
        "resolved": true,
        "details": {
          "function_name": "wq_update_unbound_numa",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4151-4212",
          "snippet": "static void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\traw_spin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\traw_spin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_numa_enabled;",
            "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\traw_spin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\traw_spin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 5146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_unbound_workers_cpumask",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 5140
        },
        "resolved": true,
        "details": {
          "function_name": "restore_unbound_workers_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5095-5111",
          "snippet": "static void restore_unbound_workers_cpumask(struct worker_pool *pool, int cpu)\n{\n\tstatic cpumask_t cpumask;\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/* is @cpu allowed for @pool? */\n\tif (!cpumask_test_cpu(cpu, pool->attrs->cpumask))\n\t\treturn;\n\n\tcpumask_and(&cpumask, pool->attrs->cpumask, cpu_online_mask);\n\n\t/* as we're called from CPU_ONLINE, the following shouldn't fail */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, &cpumask) < 0);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void restore_unbound_workers_cpumask(struct worker_pool *pool, int cpu)\n{\n\tstatic cpumask_t cpumask;\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/* is @cpu allowed for @pool? */\n\tif (!cpumask_test_cpu(cpu, pool->attrs->cpumask))\n\t\treturn;\n\n\tcpumask_and(&cpumask, pool->attrs->cpumask, cpu_online_mask);\n\n\t/* as we're called from CPU_ONLINE, the following shouldn't fail */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, &cpumask) < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebind_workers",
          "args": [
            "pool"
          ],
          "line": 5138
        },
        "resolved": true,
        "details": {
          "function_name": "rebind_workers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5035-5083",
          "snippet": "static void rebind_workers(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/*\n\t * Restore CPU affinity of all workers.  As all idle workers should\n\t * be on the run-queue of the associated CPU before any local\n\t * wake-ups for concurrency management happen, restore CPU affinity\n\t * of all workers first and then clear UNBOUND.  As we're called\n\t * from CPU_ONLINE, the following shouldn't fail.\n\t */\n\tfor_each_pool_worker(worker, pool) {\n\t\tkthread_set_per_cpu(worker->task, pool->cpu);\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task,\n\t\t\t\t\t\t  pool->attrs->cpumask) < 0);\n\t}\n\n\traw_spin_lock_irq(&pool->lock);\n\n\tpool->flags &= ~POOL_DISASSOCIATED;\n\n\tfor_each_pool_worker(worker, pool) {\n\t\tunsigned int worker_flags = worker->flags;\n\n\t\t/*\n\t\t * We want to clear UNBOUND but can't directly call\n\t\t * worker_clr_flags() or adjust nr_running.  Atomically\n\t\t * replace UNBOUND with another NOT_RUNNING flag REBOUND.\n\t\t * @worker will clear REBOUND using worker_clr_flags() when\n\t\t * it initiates the next execution cycle thus restoring\n\t\t * concurrency management.  Note that when or whether\n\t\t * @worker clears REBOUND doesn't affect correctness.\n\t\t *\n\t\t * WRITE_ONCE() is necessary because @worker->flags may be\n\t\t * tested without holding any lock in\n\t\t * wq_worker_running().  Without it, NOT_RUNNING test may\n\t\t * fail incorrectly leading to premature concurrency\n\t\t * management operations.\n\t\t */\n\t\tWARN_ON_ONCE(!(worker_flags & WORKER_UNBOUND));\n\t\tworker_flags |= WORKER_REBOUND;\n\t\tworker_flags &= ~WORKER_UNBOUND;\n\t\tWRITE_ONCE(worker->flags, worker_flags);\n\t}\n\n\traw_spin_unlock_irq(&pool->lock);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void rebind_workers(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/*\n\t * Restore CPU affinity of all workers.  As all idle workers should\n\t * be on the run-queue of the associated CPU before any local\n\t * wake-ups for concurrency management happen, restore CPU affinity\n\t * of all workers first and then clear UNBOUND.  As we're called\n\t * from CPU_ONLINE, the following shouldn't fail.\n\t */\n\tfor_each_pool_worker(worker, pool) {\n\t\tkthread_set_per_cpu(worker->task, pool->cpu);\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task,\n\t\t\t\t\t\t  pool->attrs->cpumask) < 0);\n\t}\n\n\traw_spin_lock_irq(&pool->lock);\n\n\tpool->flags &= ~POOL_DISASSOCIATED;\n\n\tfor_each_pool_worker(worker, pool) {\n\t\tunsigned int worker_flags = worker->flags;\n\n\t\t/*\n\t\t * We want to clear UNBOUND but can't directly call\n\t\t * worker_clr_flags() or adjust nr_running.  Atomically\n\t\t * replace UNBOUND with another NOT_RUNNING flag REBOUND.\n\t\t * @worker will clear REBOUND using worker_clr_flags() when\n\t\t * it initiates the next execution cycle thus restoring\n\t\t * concurrency management.  Note that when or whether\n\t\t * @worker clears REBOUND doesn't affect correctness.\n\t\t *\n\t\t * WRITE_ONCE() is necessary because @worker->flags may be\n\t\t * tested without holding any lock in\n\t\t * wq_worker_running().  Without it, NOT_RUNNING test may\n\t\t * fail incorrectly leading to premature concurrency\n\t\t * management operations.\n\t\t */\n\t\tWARN_ON_ONCE(!(worker_flags & WORKER_UNBOUND));\n\t\tworker_flags |= WORKER_REBOUND;\n\t\tworker_flags &= ~WORKER_UNBOUND;\n\t\tWRITE_ONCE(worker->flags, worker_flags);\n\t}\n\n\traw_spin_unlock_irq(&pool->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 5135
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool",
          "args": [
            "pool",
            "pi"
          ],
          "line": 5134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nint workqueue_online_cpu(unsigned int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct workqueue_struct *wq;\n\tint pi;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tfor_each_pool(pool, pi) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\n\t\tif (pool->cpu == cpu)\n\t\t\trebind_workers(pool);\n\t\telse if (pool->cpu < 0)\n\t\t\trestore_unbound_workers_cpumask(pool, cpu);\n\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\t}\n\n\t/* update NUMA affinity of unbound workqueues */\n\tlist_for_each_entry(wq, &workqueues, list)\n\t\twq_update_unbound_numa(wq, cpu, true);\n\n\tmutex_unlock(&wq_pool_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "workqueue_prepare_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5113-5124",
    "snippet": "int workqueue_prepare_cpu(unsigned int cpu)\n{\n\tstruct worker_pool *pool;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tif (pool->nr_workers)\n\t\t\tcontinue;\n\t\tif (!create_worker(pool))\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_worker",
          "args": [
            "pool"
          ],
          "line": 5120
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2114-2143",
          "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\traw_spin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\traw_spin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_worker_pool",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 5117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nint workqueue_prepare_cpu(unsigned int cpu)\n{\n\tstruct worker_pool *pool;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tif (pool->nr_workers)\n\t\t\tcontinue;\n\t\tif (!create_worker(pool))\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "restore_unbound_workers_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5095-5111",
    "snippet": "static void restore_unbound_workers_cpumask(struct worker_pool *pool, int cpu)\n{\n\tstatic cpumask_t cpumask;\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/* is @cpu allowed for @pool? */\n\tif (!cpumask_test_cpu(cpu, pool->attrs->cpumask))\n\t\treturn;\n\n\tcpumask_and(&cpumask, pool->attrs->cpumask, cpu_online_mask);\n\n\t/* as we're called from CPU_ONLINE, the following shouldn't fail */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, &cpumask) < 0);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "set_cpus_allowed_ptr(worker->task, &cpumask) < 0"
          ],
          "line": 5110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "worker->task",
            "&cpumask"
          ],
          "line": 5110
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool_worker",
          "args": [
            "worker",
            "pool"
          ],
          "line": 5109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "&cpumask",
            "pool->attrs->cpumask",
            "cpu_online_mask"
          ],
          "line": 5106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "pool->attrs->cpumask"
          ],
          "line": 5103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 5100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void restore_unbound_workers_cpumask(struct worker_pool *pool, int cpu)\n{\n\tstatic cpumask_t cpumask;\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/* is @cpu allowed for @pool? */\n\tif (!cpumask_test_cpu(cpu, pool->attrs->cpumask))\n\t\treturn;\n\n\tcpumask_and(&cpumask, pool->attrs->cpumask, cpu_online_mask);\n\n\t/* as we're called from CPU_ONLINE, the following shouldn't fail */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, &cpumask) < 0);\n}"
  },
  {
    "function_name": "rebind_workers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "5035-5083",
    "snippet": "static void rebind_workers(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/*\n\t * Restore CPU affinity of all workers.  As all idle workers should\n\t * be on the run-queue of the associated CPU before any local\n\t * wake-ups for concurrency management happen, restore CPU affinity\n\t * of all workers first and then clear UNBOUND.  As we're called\n\t * from CPU_ONLINE, the following shouldn't fail.\n\t */\n\tfor_each_pool_worker(worker, pool) {\n\t\tkthread_set_per_cpu(worker->task, pool->cpu);\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task,\n\t\t\t\t\t\t  pool->attrs->cpumask) < 0);\n\t}\n\n\traw_spin_lock_irq(&pool->lock);\n\n\tpool->flags &= ~POOL_DISASSOCIATED;\n\n\tfor_each_pool_worker(worker, pool) {\n\t\tunsigned int worker_flags = worker->flags;\n\n\t\t/*\n\t\t * We want to clear UNBOUND but can't directly call\n\t\t * worker_clr_flags() or adjust nr_running.  Atomically\n\t\t * replace UNBOUND with another NOT_RUNNING flag REBOUND.\n\t\t * @worker will clear REBOUND using worker_clr_flags() when\n\t\t * it initiates the next execution cycle thus restoring\n\t\t * concurrency management.  Note that when or whether\n\t\t * @worker clears REBOUND doesn't affect correctness.\n\t\t *\n\t\t * WRITE_ONCE() is necessary because @worker->flags may be\n\t\t * tested without holding any lock in\n\t\t * wq_worker_running().  Without it, NOT_RUNNING test may\n\t\t * fail incorrectly leading to premature concurrency\n\t\t * management operations.\n\t\t */\n\t\tWARN_ON_ONCE(!(worker_flags & WORKER_UNBOUND));\n\t\tworker_flags |= WORKER_REBOUND;\n\t\tworker_flags &= ~WORKER_UNBOUND;\n\t\tWRITE_ONCE(worker->flags, worker_flags);\n\t}\n\n\traw_spin_unlock_irq(&pool->lock);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 5082
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "worker->flags",
            "worker_flags"
          ],
          "line": 5079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(worker_flags & WORKER_UNBOUND)"
          ],
          "line": 5076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_pool_worker",
          "args": [
            "worker",
            "pool"
          ],
          "line": 5058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 5054
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "set_cpus_allowed_ptr(worker->task,\n\t\t\t\t\t\t  pool->attrs->cpumask) < 0"
          ],
          "line": 5050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "worker->task",
            "pool->attrs->cpumask"
          ],
          "line": 5050
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_set_per_cpu",
          "args": [
            "worker->task",
            "pool->cpu"
          ],
          "line": 5049
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool_worker",
          "args": [
            "worker",
            "pool"
          ],
          "line": 5048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 5039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void rebind_workers(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/*\n\t * Restore CPU affinity of all workers.  As all idle workers should\n\t * be on the run-queue of the associated CPU before any local\n\t * wake-ups for concurrency management happen, restore CPU affinity\n\t * of all workers first and then clear UNBOUND.  As we're called\n\t * from CPU_ONLINE, the following shouldn't fail.\n\t */\n\tfor_each_pool_worker(worker, pool) {\n\t\tkthread_set_per_cpu(worker->task, pool->cpu);\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task,\n\t\t\t\t\t\t  pool->attrs->cpumask) < 0);\n\t}\n\n\traw_spin_lock_irq(&pool->lock);\n\n\tpool->flags &= ~POOL_DISASSOCIATED;\n\n\tfor_each_pool_worker(worker, pool) {\n\t\tunsigned int worker_flags = worker->flags;\n\n\t\t/*\n\t\t * We want to clear UNBOUND but can't directly call\n\t\t * worker_clr_flags() or adjust nr_running.  Atomically\n\t\t * replace UNBOUND with another NOT_RUNNING flag REBOUND.\n\t\t * @worker will clear REBOUND using worker_clr_flags() when\n\t\t * it initiates the next execution cycle thus restoring\n\t\t * concurrency management.  Note that when or whether\n\t\t * @worker clears REBOUND doesn't affect correctness.\n\t\t *\n\t\t * WRITE_ONCE() is necessary because @worker->flags may be\n\t\t * tested without holding any lock in\n\t\t * wq_worker_running().  Without it, NOT_RUNNING test may\n\t\t * fail incorrectly leading to premature concurrency\n\t\t * management operations.\n\t\t */\n\t\tWARN_ON_ONCE(!(worker_flags & WORKER_UNBOUND));\n\t\tworker_flags |= WORKER_REBOUND;\n\t\tworker_flags &= ~WORKER_UNBOUND;\n\t\tWRITE_ONCE(worker->flags, worker_flags);\n\t}\n\n\traw_spin_unlock_irq(&pool->lock);\n}"
  },
  {
    "function_name": "unbind_workers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4979-5027",
    "snippet": "static void unbind_workers(int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct worker *worker;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\t\traw_spin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * We've blocked all attach/detach operations. Make all workers\n\t\t * unbound and set DISASSOCIATED.  Before this, all workers\n\t\t * must be on the cpu.  After this, they may become diasporas.\n\t\t * And the preemption disabled section in their sched callbacks\n\t\t * are guaranteed to see WORKER_UNBOUND since the code here\n\t\t * is on the same cpu.\n\t\t */\n\t\tfor_each_pool_worker(worker, pool)\n\t\t\tworker->flags |= WORKER_UNBOUND;\n\n\t\tpool->flags |= POOL_DISASSOCIATED;\n\n\t\t/*\n\t\t * The handling of nr_running in sched callbacks are disabled\n\t\t * now.  Zap nr_running.  After this, nr_running stays zero and\n\t\t * need_more_worker() and keep_working() are always true as\n\t\t * long as the worklist is not empty.  This pool now behaves as\n\t\t * an unbound (in terms of concurrency management) pool which\n\t\t * are served by workers tied to the pool.\n\t\t */\n\t\tatomic_set(&pool->nr_running, 0);\n\n\t\t/*\n\t\t * With concurrency management just turned off, a busy\n\t\t * worker blocking could lead to lengthy stalls.  Kick off\n\t\t * unbound chain execution of currently pending work items.\n\t\t */\n\t\twake_up_worker(pool);\n\n\t\traw_spin_unlock_irq(&pool->lock);\n\n\t\tfor_each_pool_worker(worker, pool) {\n\t\t\tkthread_set_per_cpu(worker->task, -1);\n\t\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, cpu_possible_mask) < 0);\n\t\t}\n\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 5025
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "set_cpus_allowed_ptr(worker->task, cpu_possible_mask) < 0"
          ],
          "line": 5022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "worker->task",
            "cpu_possible_mask"
          ],
          "line": 5022
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_set_per_cpu",
          "args": [
            "worker->task",
            "-1"
          ],
          "line": 5021
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool_worker",
          "args": [
            "worker",
            "pool"
          ],
          "line": 5020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 5018
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_worker",
          "args": [
            "pool"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pool->nr_running",
            "0"
          ],
          "line": 5009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_pool_worker",
          "args": [
            "worker",
            "pool"
          ],
          "line": 4996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 4986
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 4985
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_worker_pool",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 4984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void unbind_workers(int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct worker *worker;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\t\traw_spin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * We've blocked all attach/detach operations. Make all workers\n\t\t * unbound and set DISASSOCIATED.  Before this, all workers\n\t\t * must be on the cpu.  After this, they may become diasporas.\n\t\t * And the preemption disabled section in their sched callbacks\n\t\t * are guaranteed to see WORKER_UNBOUND since the code here\n\t\t * is on the same cpu.\n\t\t */\n\t\tfor_each_pool_worker(worker, pool)\n\t\t\tworker->flags |= WORKER_UNBOUND;\n\n\t\tpool->flags |= POOL_DISASSOCIATED;\n\n\t\t/*\n\t\t * The handling of nr_running in sched callbacks are disabled\n\t\t * now.  Zap nr_running.  After this, nr_running stays zero and\n\t\t * need_more_worker() and keep_working() are always true as\n\t\t * long as the worklist is not empty.  This pool now behaves as\n\t\t * an unbound (in terms of concurrency management) pool which\n\t\t * are served by workers tied to the pool.\n\t\t */\n\t\tatomic_set(&pool->nr_running, 0);\n\n\t\t/*\n\t\t * With concurrency management just turned off, a busy\n\t\t * worker blocking could lead to lengthy stalls.  Kick off\n\t\t * unbound chain execution of currently pending work items.\n\t\t */\n\t\twake_up_worker(pool);\n\n\t\traw_spin_unlock_irq(&pool->lock);\n\n\t\tfor_each_pool_worker(worker, pool) {\n\t\t\tkthread_set_per_cpu(worker->task, -1);\n\t\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, cpu_possible_mask) < 0);\n\t\t}\n\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\t}\n}"
  },
  {
    "function_name": "wq_worker_comm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4924-4960",
    "snippet": "void wq_worker_comm(char *buf, size_t size, struct task_struct *task)\n{\n\tint off;\n\n\t/* always show the actual comm */\n\toff = strscpy(buf, task->comm, size);\n\tif (off < 0)\n\t\treturn;\n\n\t/* stabilize PF_WQ_WORKER and worker pool association */\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tif (task->flags & PF_WQ_WORKER) {\n\t\tstruct worker *worker = kthread_data(task);\n\t\tstruct worker_pool *pool = worker->pool;\n\n\t\tif (pool) {\n\t\t\traw_spin_lock_irq(&pool->lock);\n\t\t\t/*\n\t\t\t * ->desc tracks information (wq name or\n\t\t\t * set_worker_desc()) for the latest execution.  If\n\t\t\t * current, prepend '+', otherwise '-'.\n\t\t\t */\n\t\t\tif (worker->desc[0] != '\\0') {\n\t\t\t\tif (worker->current_work)\n\t\t\t\t\tscnprintf(buf + off, size - off, \"+%s\",\n\t\t\t\t\t\t  worker->desc);\n\t\t\t\telse\n\t\t\t\t\tscnprintf(buf + off, size - off, \"-%s\",\n\t\t\t\t\t\t  worker->desc);\n\t\t\t}\n\t\t\traw_spin_unlock_irq(&pool->lock);\n\t\t}\n\t}\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 4959
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 4955
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf + off",
            "size - off",
            "\"-%s\"",
            "worker->desc"
          ],
          "line": 4952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf + off",
            "size - off",
            "\"+%s\"",
            "worker->desc"
          ],
          "line": 4949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 4941
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_data",
          "args": [
            "task"
          ],
          "line": 4937
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "233-236",
          "snippet": "void *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 4934
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "buf",
            "task->comm",
            "size"
          ],
          "line": 4929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid wq_worker_comm(char *buf, size_t size, struct task_struct *task)\n{\n\tint off;\n\n\t/* always show the actual comm */\n\toff = strscpy(buf, task->comm, size);\n\tif (off < 0)\n\t\treturn;\n\n\t/* stabilize PF_WQ_WORKER and worker pool association */\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tif (task->flags & PF_WQ_WORKER) {\n\t\tstruct worker *worker = kthread_data(task);\n\t\tstruct worker_pool *pool = worker->pool;\n\n\t\tif (pool) {\n\t\t\traw_spin_lock_irq(&pool->lock);\n\t\t\t/*\n\t\t\t * ->desc tracks information (wq name or\n\t\t\t * set_worker_desc()) for the latest execution.  If\n\t\t\t * current, prepend '+', otherwise '-'.\n\t\t\t */\n\t\t\tif (worker->desc[0] != '\\0') {\n\t\t\t\tif (worker->current_work)\n\t\t\t\t\tscnprintf(buf + off, size - off, \"+%s\",\n\t\t\t\t\t\t  worker->desc);\n\t\t\t\telse\n\t\t\t\t\tscnprintf(buf + off, size - off, \"-%s\",\n\t\t\t\t\t\t  worker->desc);\n\t\t\t}\n\t\t\traw_spin_unlock_irq(&pool->lock);\n\t\t}\n\t}\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
  },
  {
    "function_name": "show_all_workqueues",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4904-4921",
    "snippet": "void show_all_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\trcu_read_lock();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list)\n\t\tshow_one_workqueue(wq);\n\n\tfor_each_pool(pool, pi)\n\t\tshow_one_worker_pool(pool);\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4920
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_one_worker_pool",
          "args": [
            "pool"
          ],
          "line": 4918
        },
        "resolved": true,
        "details": {
          "function_name": "show_one_worker_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4857-4896",
          "snippet": "static void show_one_worker_pool(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\tbool first = true;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pool->lock, flags);\n\tif (pool->nr_workers == pool->nr_idle)\n\t\tgoto next_pool;\n\t/*\n\t * Defer printing to avoid deadlocks in console drivers that\n\t * queue work while holding locks also taken in their write\n\t * paths.\n\t */\n\tprintk_deferred_enter();\n\tpr_info(\"pool %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\tpr_cont(\" hung=%us workers=%d\",\n\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\tpool->nr_workers);\n\tif (pool->manager)\n\t\tpr_cont(\" manager: %d\",\n\t\t\ttask_pid_nr(pool->manager->task));\n\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\ttask_pid_nr(worker->task));\n\t\tfirst = false;\n\t}\n\tpr_cont(\"\\n\");\n\tprintk_deferred_exit();\nnext_pool:\n\traw_spin_unlock_irqrestore(&pool->lock, flags);\n\t/*\n\t * We could be printing a lot from atomic context, e.g.\n\t * sysrq-t -> show_all_workqueues(). Avoid triggering\n\t * hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void show_one_worker_pool(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\tbool first = true;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pool->lock, flags);\n\tif (pool->nr_workers == pool->nr_idle)\n\t\tgoto next_pool;\n\t/*\n\t * Defer printing to avoid deadlocks in console drivers that\n\t * queue work while holding locks also taken in their write\n\t * paths.\n\t */\n\tprintk_deferred_enter();\n\tpr_info(\"pool %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\tpr_cont(\" hung=%us workers=%d\",\n\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\tpool->nr_workers);\n\tif (pool->manager)\n\t\tpr_cont(\" manager: %d\",\n\t\t\ttask_pid_nr(pool->manager->task));\n\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\ttask_pid_nr(worker->task));\n\t\tfirst = false;\n\t}\n\tpr_cont(\"\\n\");\n\tprintk_deferred_exit();\nnext_pool:\n\traw_spin_unlock_irqrestore(&pool->lock, flags);\n\t/*\n\t * We could be printing a lot from atomic context, e.g.\n\t * sysrq-t -> show_all_workqueues(). Avoid triggering\n\t * hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool",
          "args": [
            "pool",
            "pi"
          ],
          "line": 4917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_one_workqueue",
          "args": [
            "wq"
          ],
          "line": 4915
        },
        "resolved": true,
        "details": {
          "function_name": "show_one_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4813-4851",
          "snippet": "void show_one_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tbool idle = true;\n\tunsigned long flags;\n\n\tfor_each_pwq(pwq, wq) {\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\tidle = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (idle) /* Nothing to print for idle workqueue */\n\t\treturn;\n\n\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\t/*\n\t\t\t * Defer printing to avoid deadlocks in console\n\t\t\t * drivers that queue work while holding locks\n\t\t\t * also taken in their write paths.\n\t\t\t */\n\t\t\tprintk_deferred_enter();\n\t\t\tshow_pwq(pwq);\n\t\t\tprintk_deferred_exit();\n\t\t}\n\t\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_all_workqueues(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid show_one_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tbool idle = true;\n\tunsigned long flags;\n\n\tfor_each_pwq(pwq, wq) {\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\tidle = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (idle) /* Nothing to print for idle workqueue */\n\t\treturn;\n\n\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\t/*\n\t\t\t * Defer printing to avoid deadlocks in console\n\t\t\t * drivers that queue work while holding locks\n\t\t\t * also taken in their write paths.\n\t\t\t */\n\t\t\tprintk_deferred_enter();\n\t\t\tshow_pwq(pwq);\n\t\t\tprintk_deferred_exit();\n\t\t}\n\t\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_all_workqueues(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 4914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Showing busy workqueues and worker pools:\\n\""
          ],
          "line": 4912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4910
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid show_all_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\trcu_read_lock();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list)\n\t\tshow_one_workqueue(wq);\n\n\tfor_each_pool(pool, pi)\n\t\tshow_one_worker_pool(pool);\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "show_one_worker_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4857-4896",
    "snippet": "static void show_one_worker_pool(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\tbool first = true;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pool->lock, flags);\n\tif (pool->nr_workers == pool->nr_idle)\n\t\tgoto next_pool;\n\t/*\n\t * Defer printing to avoid deadlocks in console drivers that\n\t * queue work while holding locks also taken in their write\n\t * paths.\n\t */\n\tprintk_deferred_enter();\n\tpr_info(\"pool %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\tpr_cont(\" hung=%us workers=%d\",\n\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\tpool->nr_workers);\n\tif (pool->manager)\n\t\tpr_cont(\" manager: %d\",\n\t\t\ttask_pid_nr(pool->manager->task));\n\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\ttask_pid_nr(worker->task));\n\t\tfirst = false;\n\t}\n\tpr_cont(\"\\n\");\n\tprintk_deferred_exit();\nnext_pool:\n\traw_spin_unlock_irqrestore(&pool->lock, flags);\n\t/*\n\t * We could be printing a lot from atomic context, e.g.\n\t * sysrq-t -> show_all_workqueues(). Avoid triggering\n\t * hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 4894
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 4888
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred_exit",
          "args": [],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 4885
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %s%d\"",
            "first ? \"idle: \" : \"\"",
            "task_pid_nr(worker->task)"
          ],
          "line": 4881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "worker->task"
          ],
          "line": 4882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "worker",
            "&pool->idle_list",
            "entry"
          ],
          "line": 4880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" manager: %d\"",
            "task_pid_nr(pool->manager->task)"
          ],
          "line": 4878
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "pool->manager->task"
          ],
          "line": 4879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" hung=%us workers=%d\"",
            "jiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000",
            "pool->nr_workers"
          ],
          "line": 4874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "jiffies - pool->watchdog_ts"
          ],
          "line": 4875
        },
        "resolved": true,
        "details": {
          "function_name": "jiffies_to_msecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "374-388",
          "snippet": "unsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"pool %d:\"",
            "pool->id"
          ],
          "line": 4872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_deferred_enter",
          "args": [],
          "line": 4871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 4863
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void show_one_worker_pool(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\tbool first = true;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pool->lock, flags);\n\tif (pool->nr_workers == pool->nr_idle)\n\t\tgoto next_pool;\n\t/*\n\t * Defer printing to avoid deadlocks in console drivers that\n\t * queue work while holding locks also taken in their write\n\t * paths.\n\t */\n\tprintk_deferred_enter();\n\tpr_info(\"pool %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\tpr_cont(\" hung=%us workers=%d\",\n\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\tpool->nr_workers);\n\tif (pool->manager)\n\t\tpr_cont(\" manager: %d\",\n\t\t\ttask_pid_nr(pool->manager->task));\n\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\ttask_pid_nr(worker->task));\n\t\tfirst = false;\n\t}\n\tpr_cont(\"\\n\");\n\tprintk_deferred_exit();\nnext_pool:\n\traw_spin_unlock_irqrestore(&pool->lock, flags);\n\t/*\n\t * We could be printing a lot from atomic context, e.g.\n\t * sysrq-t -> show_all_workqueues(). Avoid triggering\n\t * hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n}"
  },
  {
    "function_name": "show_one_workqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4813-4851",
    "snippet": "void show_one_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tbool idle = true;\n\tunsigned long flags;\n\n\tfor_each_pwq(pwq, wq) {\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\tidle = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (idle) /* Nothing to print for idle workqueue */\n\t\treturn;\n\n\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\t/*\n\t\t\t * Defer printing to avoid deadlocks in console\n\t\t\t * drivers that queue work while holding locks\n\t\t\t * also taken in their write paths.\n\t\t\t */\n\t\t\tprintk_deferred_enter();\n\t\t\tshow_pwq(pwq);\n\t\t\tprintk_deferred_exit();\n\t\t}\n\t\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_all_workqueues(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 4848
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&pwq->pool->lock",
            "flags"
          ],
          "line": 4842
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred_exit",
          "args": [],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_pwq",
          "args": [
            "pwq"
          ],
          "line": 4839
        },
        "resolved": true,
        "details": {
          "function_name": "show_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4737-4807",
          "snippet": "static void show_pwq(struct pool_workqueue *pwq)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\tstruct work_struct *work;\n\tstruct worker *worker;\n\tbool has_in_flight = false, has_pending = false;\n\tint bkt;\n\n\tpr_info(\"  pwq %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\n\tpr_cont(\" active=%d/%d refcnt=%d%s\\n\",\n\t\tpwq->nr_active, pwq->max_active, pwq->refcnt,\n\t\t!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\");\n\n\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\tif (worker->current_pwq == pwq) {\n\t\t\thas_in_flight = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_in_flight) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    in-flight:\");\n\t\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\t\tif (worker->current_pwq != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont(\"%s %d%s:%ps\", comma ? \",\" : \"\",\n\t\t\t\ttask_pid_nr(worker->task),\n\t\t\t\tworker->rescue_wq ? \"(RESCUER)\" : \"\",\n\t\t\t\tworker->current_func);\n\t\t\tlist_for_each_entry(work, &worker->scheduled, entry)\n\t\t\t\tpr_cont_work(false, work);\n\t\t\tcomma = true;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\tif (get_work_pwq(work) == pwq) {\n\t\t\thas_pending = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_pending) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    pending:\");\n\t\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (!list_empty(&pwq->inactive_works)) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    inactive:\");\n\t\tlist_for_each_entry(work, &pwq->inactive_works, entry) {\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void show_pwq(struct pool_workqueue *pwq)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\tstruct work_struct *work;\n\tstruct worker *worker;\n\tbool has_in_flight = false, has_pending = false;\n\tint bkt;\n\n\tpr_info(\"  pwq %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\n\tpr_cont(\" active=%d/%d refcnt=%d%s\\n\",\n\t\tpwq->nr_active, pwq->max_active, pwq->refcnt,\n\t\t!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\");\n\n\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\tif (worker->current_pwq == pwq) {\n\t\t\thas_in_flight = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_in_flight) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    in-flight:\");\n\t\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\t\tif (worker->current_pwq != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont(\"%s %d%s:%ps\", comma ? \",\" : \"\",\n\t\t\t\ttask_pid_nr(worker->task),\n\t\t\t\tworker->rescue_wq ? \"(RESCUER)\" : \"\",\n\t\t\t\tworker->current_func);\n\t\t\tlist_for_each_entry(work, &worker->scheduled, entry)\n\t\t\t\tpr_cont_work(false, work);\n\t\t\tcomma = true;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\tif (get_work_pwq(work) == pwq) {\n\t\t\thas_pending = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_pending) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    pending:\");\n\t\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (!list_empty(&pwq->inactive_works)) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    inactive:\");\n\t\tlist_for_each_entry(work, &pwq->inactive_works, entry) {\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred_enter",
          "args": [],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->inactive_works"
          ],
          "line": 4832
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&pwq->pool->lock",
            "flags"
          ],
          "line": 4831
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"workqueue %s: flags=0x%x\\n\"",
            "wq->name",
            "wq->flags"
          ],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid show_one_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tbool idle = true;\n\tunsigned long flags;\n\n\tfor_each_pwq(pwq, wq) {\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\tidle = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (idle) /* Nothing to print for idle workqueue */\n\t\treturn;\n\n\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\t/*\n\t\t\t * Defer printing to avoid deadlocks in console\n\t\t\t * drivers that queue work while holding locks\n\t\t\t * also taken in their write paths.\n\t\t\t */\n\t\t\tprintk_deferred_enter();\n\t\t\tshow_pwq(pwq);\n\t\t\tprintk_deferred_exit();\n\t\t}\n\t\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_all_workqueues(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n}"
  },
  {
    "function_name": "show_pwq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4737-4807",
    "snippet": "static void show_pwq(struct pool_workqueue *pwq)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\tstruct work_struct *work;\n\tstruct worker *worker;\n\tbool has_in_flight = false, has_pending = false;\n\tint bkt;\n\n\tpr_info(\"  pwq %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\n\tpr_cont(\" active=%d/%d refcnt=%d%s\\n\",\n\t\tpwq->nr_active, pwq->max_active, pwq->refcnt,\n\t\t!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\");\n\n\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\tif (worker->current_pwq == pwq) {\n\t\t\thas_in_flight = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_in_flight) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    in-flight:\");\n\t\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\t\tif (worker->current_pwq != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont(\"%s %d%s:%ps\", comma ? \",\" : \"\",\n\t\t\t\ttask_pid_nr(worker->task),\n\t\t\t\tworker->rescue_wq ? \"(RESCUER)\" : \"\",\n\t\t\t\tworker->current_func);\n\t\t\tlist_for_each_entry(work, &worker->scheduled, entry)\n\t\t\t\tpr_cont_work(false, work);\n\t\t\tcomma = true;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\tif (get_work_pwq(work) == pwq) {\n\t\t\thas_pending = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_pending) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    pending:\");\n\t\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (!list_empty(&pwq->inactive_works)) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    inactive:\");\n\t\tlist_for_each_entry(work, &pwq->inactive_works, entry) {\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 4805
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 4803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont_work",
          "args": [
            "comma",
            "work"
          ],
          "line": 4802
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "work",
            "&pwq->inactive_works",
            "entry"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"    inactive:\""
          ],
          "line": 4800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->inactive_works"
          ],
          "line": 4797
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 4792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 4788
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "696-704",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "work",
            "&pool->worklist",
            "entry"
          ],
          "line": 4787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"    pending:\""
          ],
          "line": 4786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "work",
            "&pool->worklist",
            "entry"
          ],
          "line": 4777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "work",
            "&worker->scheduled",
            "entry"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s %d%s:%ps\"",
            "comma ? \",\" : \"\"",
            "task_pid_nr(worker->task)",
            "worker->rescue_wq ? \"(RESCUER)\" : \"\"",
            "worker->current_func"
          ],
          "line": 4766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "worker->task"
          ],
          "line": 4767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "pool->busy_hash",
            "bkt",
            "worker",
            "hentry"
          ],
          "line": 4762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"    in-flight:\""
          ],
          "line": 4761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "pool->busy_hash",
            "bkt",
            "worker",
            "hentry"
          ],
          "line": 4752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" active=%d/%d refcnt=%d%s\\n\"",
            "pwq->nr_active",
            "pwq->max_active",
            "pwq->refcnt",
            "!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\""
          ],
          "line": 4748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"  pwq %d:\"",
            "pool->id"
          ],
          "line": 4745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void show_pwq(struct pool_workqueue *pwq)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\tstruct work_struct *work;\n\tstruct worker *worker;\n\tbool has_in_flight = false, has_pending = false;\n\tint bkt;\n\n\tpr_info(\"  pwq %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\n\tpr_cont(\" active=%d/%d refcnt=%d%s\\n\",\n\t\tpwq->nr_active, pwq->max_active, pwq->refcnt,\n\t\t!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\");\n\n\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\tif (worker->current_pwq == pwq) {\n\t\t\thas_in_flight = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_in_flight) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    in-flight:\");\n\t\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\t\tif (worker->current_pwq != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont(\"%s %d%s:%ps\", comma ? \",\" : \"\",\n\t\t\t\ttask_pid_nr(worker->task),\n\t\t\t\tworker->rescue_wq ? \"(RESCUER)\" : \"\",\n\t\t\t\tworker->current_func);\n\t\t\tlist_for_each_entry(work, &worker->scheduled, entry)\n\t\t\t\tpr_cont_work(false, work);\n\t\t\tcomma = true;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\tif (get_work_pwq(work) == pwq) {\n\t\t\thas_pending = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_pending) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    pending:\");\n\t\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (!list_empty(&pwq->inactive_works)) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    inactive:\");\n\t\tlist_for_each_entry(work, &pwq->inactive_works, entry) {\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "pr_cont_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4723-4735",
    "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s %ps\"",
            "comma ? \",\" : \"\"",
            "work->func"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s BAR(%d)\"",
            "comma ? \",\" : \"\"",
            "task_pid_nr(barr->task)"
          ],
          "line": 4730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "barr->task"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structwq_barrier",
            "work"
          ],
          "line": 4728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
  },
  {
    "function_name": "pr_cont_pool_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4715-4721",
    "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" flags=0x%x nice=%d\"",
            "pool->flags",
            "pool->attrs->nice"
          ],
          "line": 4720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" node=%d\"",
            "pool->node"
          ],
          "line": 4719
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" cpus=%*pbl\"",
            "nr_cpumask_bits",
            "pool->attrs->cpumask"
          ],
          "line": 4717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
  },
  {
    "function_name": "print_worker_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4679-4713",
    "snippet": "void print_worker_info(const char *log_lvl, struct task_struct *task)\n{\n\twork_func_t *fn = NULL;\n\tchar name[WQ_NAME_LEN] = { };\n\tchar desc[WORKER_DESC_LEN] = { };\n\tstruct pool_workqueue *pwq = NULL;\n\tstruct workqueue_struct *wq = NULL;\n\tstruct worker *worker;\n\n\tif (!(task->flags & PF_WQ_WORKER))\n\t\treturn;\n\n\t/*\n\t * This function is called without any synchronization and @task\n\t * could be in any state.  Be careful with dereferences.\n\t */\n\tworker = kthread_probe_data(task);\n\n\t/*\n\t * Carefully copy the associated workqueue's workfn, name and desc.\n\t * Keep the original last '\\0' in case the original is garbage.\n\t */\n\tcopy_from_kernel_nofault(&fn, &worker->current_func, sizeof(fn));\n\tcopy_from_kernel_nofault(&pwq, &worker->current_pwq, sizeof(pwq));\n\tcopy_from_kernel_nofault(&wq, &pwq->wq, sizeof(wq));\n\tcopy_from_kernel_nofault(name, wq->name, sizeof(name) - 1);\n\tcopy_from_kernel_nofault(desc, worker->desc, sizeof(desc) - 1);\n\n\tif (fn || name[0] || desc[0]) {\n\t\tprintk(\"%sWorkqueue: %s %ps\", log_lvl, name, fn);\n\t\tif (strcmp(name, desc))\n\t\t\tpr_cont(\" (%s)\", desc);\n\t\tpr_cont(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 4711
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" (%s)\"",
            "desc"
          ],
          "line": 4710
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "desc"
          ],
          "line": 4709
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sWorkqueue: %s %ps\"",
            "log_lvl",
            "name",
            "fn"
          ],
          "line": 4708
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "desc",
            "worker->desc",
            "sizeof(desc) - 1"
          ],
          "line": 4705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "name",
            "wq->name",
            "sizeof(name) - 1"
          ],
          "line": 4704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "&wq",
            "&pwq->wq",
            "sizeof(wq)"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "&pwq",
            "&worker->current_pwq",
            "sizeof(pwq)"
          ],
          "line": 4702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "&fn",
            "&worker->current_func",
            "sizeof(fn)"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_probe_data",
          "args": [
            "task"
          ],
          "line": 4695
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_probe_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "248-256",
          "snippet": "void *kthread_probe_data(struct task_struct *task)\n{\n\tstruct kthread *kthread = __to_kthread(task);\n\tvoid *data = NULL;\n\n\tif (kthread)\n\t\tcopy_from_kernel_nofault(&data, &kthread->data, sizeof(data));\n\treturn data;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_probe_data(struct task_struct *task)\n{\n\tstruct kthread *kthread = __to_kthread(task);\n\tvoid *data = NULL;\n\n\tif (kthread)\n\t\tcopy_from_kernel_nofault(&data, &kthread->data, sizeof(data));\n\treturn data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nvoid print_worker_info(const char *log_lvl, struct task_struct *task)\n{\n\twork_func_t *fn = NULL;\n\tchar name[WQ_NAME_LEN] = { };\n\tchar desc[WORKER_DESC_LEN] = { };\n\tstruct pool_workqueue *pwq = NULL;\n\tstruct workqueue_struct *wq = NULL;\n\tstruct worker *worker;\n\n\tif (!(task->flags & PF_WQ_WORKER))\n\t\treturn;\n\n\t/*\n\t * This function is called without any synchronization and @task\n\t * could be in any state.  Be careful with dereferences.\n\t */\n\tworker = kthread_probe_data(task);\n\n\t/*\n\t * Carefully copy the associated workqueue's workfn, name and desc.\n\t * Keep the original last '\\0' in case the original is garbage.\n\t */\n\tcopy_from_kernel_nofault(&fn, &worker->current_func, sizeof(fn));\n\tcopy_from_kernel_nofault(&pwq, &worker->current_pwq, sizeof(pwq));\n\tcopy_from_kernel_nofault(&wq, &pwq->wq, sizeof(wq));\n\tcopy_from_kernel_nofault(name, wq->name, sizeof(name) - 1);\n\tcopy_from_kernel_nofault(desc, worker->desc, sizeof(desc) - 1);\n\n\tif (fn || name[0] || desc[0]) {\n\t\tprintk(\"%sWorkqueue: %s %ps\", log_lvl, name, fn);\n\t\tif (strcmp(name, desc))\n\t\t\tpr_cont(\" (%s)\", desc);\n\t\tpr_cont(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "set_worker_desc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4653-4663",
    "snippet": "void set_worker_desc(const char *fmt, ...)\n{\n\tstruct worker *worker = current_wq_worker();\n\tva_list args;\n\n\tif (worker) {\n\t\tva_start(args, fmt);\n\t\tvsnprintf(worker->desc, sizeof(worker->desc), fmt, args);\n\t\tva_end(args);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 4661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "worker->desc",
            "sizeof(worker->desc)",
            "fmt",
            "args"
          ],
          "line": 4660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 4659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 4655
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue_internal.h",
          "lines": "66-71",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid set_worker_desc(const char *fmt, ...)\n{\n\tstruct worker *worker = current_wq_worker();\n\tva_list args;\n\n\tif (worker) {\n\t\tva_start(args, fmt);\n\t\tvsnprintf(worker->desc, sizeof(worker->desc), fmt, args);\n\t\tva_end(args);\n\t}\n}"
  },
  {
    "function_name": "work_busy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4620-4640",
    "snippet": "unsigned int work_busy(struct work_struct *work)\n{\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tunsigned int ret = 0;\n\n\tif (work_pending(work))\n\t\tret |= WORK_BUSY_PENDING;\n\n\trcu_read_lock();\n\tpool = get_work_pool(work);\n\tif (pool) {\n\t\traw_spin_lock_irqsave(&pool->lock, flags);\n\t\tif (find_worker_executing_work(pool, work))\n\t\t\tret |= WORK_BUSY_RUNNING;\n\t\traw_spin_unlock_irqrestore(&pool->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4637
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 4635
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_worker_executing_work",
          "args": [
            "pool",
            "work"
          ],
          "line": 4633
        },
        "resolved": true,
        "details": {
          "function_name": "find_worker_executing_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1058-1070",
          "snippet": "static struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 4632
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pool",
          "args": [
            "work"
          ],
          "line": 4630
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "746-755",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4629
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_pending",
          "args": [
            "work"
          ],
          "line": 4626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nunsigned int work_busy(struct work_struct *work)\n{\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tunsigned int ret = 0;\n\n\tif (work_pending(work))\n\t\tret |= WORK_BUSY_PENDING;\n\n\trcu_read_lock();\n\tpool = get_work_pool(work);\n\tif (pool) {\n\t\traw_spin_lock_irqsave(&pool->lock, flags);\n\t\tif (find_worker_executing_work(pool, work))\n\t\t\tret |= WORK_BUSY_RUNNING;\n\t\traw_spin_unlock_irqrestore(&pool->lock, flags);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "workqueue_congested",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4585-4606",
    "snippet": "bool workqueue_congested(int cpu, struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tbool ret;\n\n\trcu_read_lock();\n\tpreempt_disable();\n\n\tif (cpu == WORK_CPU_UNBOUND)\n\t\tcpu = smp_processor_id();\n\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\tret = !list_empty(&pwq->inactive_works);\n\tpreempt_enable();\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4603
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 4602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->inactive_works"
          ],
          "line": 4601
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unbound_pwq_by_node",
          "args": [
            "wq",
            "cpu_to_node(cpu)"
          ],
          "line": 4599
        },
        "resolved": true,
        "details": {
          "function_name": "unbound_pwq_by_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "574-589",
          "snippet": "static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 4599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wq->cpu_pwqs",
            "cpu"
          ],
          "line": 4597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 4594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 4591
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4590
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nbool workqueue_congested(int cpu, struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tbool ret;\n\n\trcu_read_lock();\n\tpreempt_disable();\n\n\tif (cpu == WORK_CPU_UNBOUND)\n\t\tcpu = smp_processor_id();\n\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\tret = !list_empty(&pwq->inactive_works);\n\tpreempt_enable();\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "current_is_workqueue_rescuer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4560-4565",
    "snippet": "bool current_is_workqueue_rescuer(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker && worker->rescue_wq;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 4562
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue_internal.h",
          "lines": "66-71",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool current_is_workqueue_rescuer(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker && worker->rescue_wq;\n}"
  },
  {
    "function_name": "current_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4544-4549",
    "snippet": "struct work_struct *current_work(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker ? worker->current_work : NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 4546
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue_internal.h",
          "lines": "66-71",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct work_struct *current_work(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker ? worker->current_work : NULL;\n}"
  },
  {
    "function_name": "workqueue_set_max_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4514-4533",
    "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4532
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwq_adjust_max_active",
          "args": [
            "pwq"
          ],
          "line": 4530
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_adjust_max_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3759-3804",
          "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4524
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_clamp_max_active",
          "args": [
            "max_active",
            "wq->flags",
            "wq->name"
          ],
          "line": 4522
        },
        "resolved": true,
        "details": {
          "function_name": "wq_clamp_max_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4254-4264",
          "snippet": "static int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "wq->flags & __WQ_ORDERED_EXPLICIT"
          ],
          "line": 4519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
  },
  {
    "function_name": "destroy_workqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4417-4501",
    "snippet": "void destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/*\n\t * Remove it from sysfs first so that sanity check failure doesn't\n\t * lead to sysfs name conflicts.\n\t */\n\tworkqueue_sysfs_unregister(wq);\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* kill rescuer, if sanity checks fail, leave it w/o rescuer */\n\tif (wq->rescuer) {\n\t\tstruct worker *rescuer = wq->rescuer;\n\n\t\t/* this prevents new queueing */\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t\twq->rescuer = NULL;\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\t/* rescuer will empty maydays list before exiting */\n\t\tkthread_stop(rescuer->task);\n\t\tkfree(rescuer);\n\t}\n\n\t/*\n\t * Sanity checks - grab all the locks so that we wait for all\n\t * in-flight operations which may do put_pwq().\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tif (WARN_ON(pwq_busy(pwq))) {\n\t\t\tpr_warn(\"%s: %s has the following busy pwq\\n\",\n\t\t\t\t__func__, wq->name);\n\t\t\tshow_pwq(pwq);\n\t\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t\tshow_one_workqueue(wq);\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq_unregister_lockdep(wq);\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_RAW_SPINLOCK(wq_mayday_lock);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pwq_unlocked",
          "args": [
            "pwq"
          ],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1158-1169",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "wq->numa_pwq_tbl[node]",
            "NULL"
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "wq->numa_pwq_tbl[node]"
          ],
          "line": 4488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&wq->rcu",
            "rcu_free_wq"
          ],
          "line": 4480
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_unregister_lockdep",
          "args": [
            "wq"
          ],
          "line": 4475
        },
        "resolved": true,
        "details": {
          "function_name": "wq_unregister_lockdep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3521-3523",
          "snippet": "static void wq_unregister_lockdep(struct workqueue_struct *wq)\n{\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_unregister_lockdep(struct workqueue_struct *wq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4472
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&wq->list"
          ],
          "line": 4471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 4463
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_one_workqueue",
          "args": [
            "wq"
          ],
          "line": 4460
        },
        "resolved": true,
        "details": {
          "function_name": "show_one_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4813-4851",
          "snippet": "void show_one_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tbool idle = true;\n\tunsigned long flags;\n\n\tfor_each_pwq(pwq, wq) {\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\tidle = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (idle) /* Nothing to print for idle workqueue */\n\t\treturn;\n\n\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\t/*\n\t\t\t * Defer printing to avoid deadlocks in console\n\t\t\t * drivers that queue work while holding locks\n\t\t\t * also taken in their write paths.\n\t\t\t */\n\t\t\tprintk_deferred_enter();\n\t\t\tshow_pwq(pwq);\n\t\t\tprintk_deferred_exit();\n\t\t}\n\t\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_all_workqueues(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid show_one_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tbool idle = true;\n\tunsigned long flags;\n\n\tfor_each_pwq(pwq, wq) {\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\tidle = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (idle) /* Nothing to print for idle workqueue */\n\t\treturn;\n\n\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\t\tif (pwq->nr_active || !list_empty(&pwq->inactive_works)) {\n\t\t\t/*\n\t\t\t * Defer printing to avoid deadlocks in console\n\t\t\t * drivers that queue work while holding locks\n\t\t\t * also taken in their write paths.\n\t\t\t */\n\t\t\tprintk_deferred_enter();\n\t\t\tshow_pwq(pwq);\n\t\t\tprintk_deferred_exit();\n\t\t}\n\t\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_all_workqueues(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_pwq",
          "args": [
            "pwq"
          ],
          "line": 4456
        },
        "resolved": true,
        "details": {
          "function_name": "show_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4737-4807",
          "snippet": "static void show_pwq(struct pool_workqueue *pwq)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\tstruct work_struct *work;\n\tstruct worker *worker;\n\tbool has_in_flight = false, has_pending = false;\n\tint bkt;\n\n\tpr_info(\"  pwq %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\n\tpr_cont(\" active=%d/%d refcnt=%d%s\\n\",\n\t\tpwq->nr_active, pwq->max_active, pwq->refcnt,\n\t\t!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\");\n\n\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\tif (worker->current_pwq == pwq) {\n\t\t\thas_in_flight = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_in_flight) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    in-flight:\");\n\t\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\t\tif (worker->current_pwq != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont(\"%s %d%s:%ps\", comma ? \",\" : \"\",\n\t\t\t\ttask_pid_nr(worker->task),\n\t\t\t\tworker->rescue_wq ? \"(RESCUER)\" : \"\",\n\t\t\t\tworker->current_func);\n\t\t\tlist_for_each_entry(work, &worker->scheduled, entry)\n\t\t\t\tpr_cont_work(false, work);\n\t\t\tcomma = true;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\tif (get_work_pwq(work) == pwq) {\n\t\t\thas_pending = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_pending) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    pending:\");\n\t\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (!list_empty(&pwq->inactive_works)) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    inactive:\");\n\t\tlist_for_each_entry(work, &pwq->inactive_works, entry) {\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void show_pwq(struct pool_workqueue *pwq)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\tstruct work_struct *work;\n\tstruct worker *worker;\n\tbool has_in_flight = false, has_pending = false;\n\tint bkt;\n\n\tpr_info(\"  pwq %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\n\tpr_cont(\" active=%d/%d refcnt=%d%s\\n\",\n\t\tpwq->nr_active, pwq->max_active, pwq->refcnt,\n\t\t!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\");\n\n\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\tif (worker->current_pwq == pwq) {\n\t\t\thas_in_flight = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_in_flight) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    in-flight:\");\n\t\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\t\tif (worker->current_pwq != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont(\"%s %d%s:%ps\", comma ? \",\" : \"\",\n\t\t\t\ttask_pid_nr(worker->task),\n\t\t\t\tworker->rescue_wq ? \"(RESCUER)\" : \"\",\n\t\t\t\tworker->current_func);\n\t\t\tlist_for_each_entry(work, &worker->scheduled, entry)\n\t\t\t\tpr_cont_work(false, work);\n\t\t\tcomma = true;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\tif (get_work_pwq(work) == pwq) {\n\t\t\thas_pending = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_pending) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    pending:\");\n\t\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (!list_empty(&pwq->inactive_works)) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    inactive:\");\n\t\tlist_for_each_entry(work, &pwq->inactive_works, entry) {\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: %s has the following busy pwq\\n\"",
            "__func__",
            "wq->name"
          ],
          "line": 4454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pwq_busy(pwq)"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwq_busy",
          "args": [
            "pwq"
          ],
          "line": 4453
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_busy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4395-4409",
          "snippet": "static bool pwq_busy(struct pool_workqueue *pwq)\n{\n\tint i;\n\n\tfor (i = 0; i < WORK_NR_COLORS; i++)\n\t\tif (pwq->nr_in_flight[i])\n\t\t\treturn true;\n\n\tif ((pwq != pwq->wq->dfl_pwq) && (pwq->refcnt > 1))\n\t\treturn true;\n\tif (pwq->nr_active || !list_empty(&pwq->inactive_works))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic bool pwq_busy(struct pool_workqueue *pwq)\n{\n\tint i;\n\n\tfor (i = 0; i < WORK_NR_COLORS; i++)\n\t\tif (pwq->nr_in_flight[i])\n\t\t\treturn true;\n\n\tif ((pwq != pwq->wq->dfl_pwq) && (pwq->refcnt > 1))\n\t\treturn true;\n\tif (pwq->nr_active || !list_empty(&pwq->inactive_works))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 4452
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4450
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rescuer"
          ],
          "line": 4442
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "rescuer->task"
          ],
          "line": 4441
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_workqueue",
          "args": [
            "wq"
          ],
          "line": 4429
        },
        "resolved": true,
        "details": {
          "function_name": "drain_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2977-3018",
          "snippet": "void drain_workqueue(struct workqueue_struct *wq)\n{\n\tunsigned int flush_cnt = 0;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * __queue_work() needs to test whether there are drainers, is much\n\t * hotter than drain_workqueue() and already looks at @wq->flags.\n\t * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.\n\t */\n\tmutex_lock(&wq->mutex);\n\tif (!wq->nr_drainers++)\n\t\twq->flags |= __WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\nreflush:\n\tflush_workqueue(wq);\n\n\tmutex_lock(&wq->mutex);\n\n\tfor_each_pwq(pwq, wq) {\n\t\tbool drained;\n\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tdrained = !pwq->nr_active && list_empty(&pwq->inactive_works);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\n\t\tif (drained)\n\t\t\tcontinue;\n\n\t\tif (++flush_cnt == 10 ||\n\t\t    (flush_cnt % 100 == 0 && flush_cnt <= 1000))\n\t\t\tpr_warn(\"workqueue %s: %s() isn't complete after %u tries\\n\",\n\t\t\t\twq->name, __func__, flush_cnt);\n\n\t\tmutex_unlock(&wq->mutex);\n\t\tgoto reflush;\n\t}\n\n\tif (!--wq->nr_drainers)\n\t\twq->flags &= ~__WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid drain_workqueue(struct workqueue_struct *wq)\n{\n\tunsigned int flush_cnt = 0;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * __queue_work() needs to test whether there are drainers, is much\n\t * hotter than drain_workqueue() and already looks at @wq->flags.\n\t * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.\n\t */\n\tmutex_lock(&wq->mutex);\n\tif (!wq->nr_drainers++)\n\t\twq->flags |= __WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\nreflush:\n\tflush_workqueue(wq);\n\n\tmutex_lock(&wq->mutex);\n\n\tfor_each_pwq(pwq, wq) {\n\t\tbool drained;\n\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tdrained = !pwq->nr_active && list_empty(&pwq->inactive_works);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\n\t\tif (drained)\n\t\t\tcontinue;\n\n\t\tif (++flush_cnt == 10 ||\n\t\t    (flush_cnt % 100 == 0 && flush_cnt <= 1000))\n\t\t\tpr_warn(\"workqueue %s: %s() isn't complete after %u tries\\n\",\n\t\t\t\twq->name, __func__, flush_cnt);\n\n\t\tmutex_unlock(&wq->mutex);\n\t\tgoto reflush;\n\t}\n\n\tif (!--wq->nr_drainers)\n\t\twq->flags &= ~__WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "workqueue_sysfs_unregister",
          "args": [
            "wq"
          ],
          "line": 4426
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_sysfs_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5801-5801",
          "snippet": "static void workqueue_sysfs_unregister(struct workqueue_struct *wq)\t{ }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq)\t{ }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_RAW_SPINLOCK(wq_mayday_lock);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/*\n\t * Remove it from sysfs first so that sanity check failure doesn't\n\t * lead to sysfs name conflicts.\n\t */\n\tworkqueue_sysfs_unregister(wq);\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* kill rescuer, if sanity checks fail, leave it w/o rescuer */\n\tif (wq->rescuer) {\n\t\tstruct worker *rescuer = wq->rescuer;\n\n\t\t/* this prevents new queueing */\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t\twq->rescuer = NULL;\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\t/* rescuer will empty maydays list before exiting */\n\t\tkthread_stop(rescuer->task);\n\t\tkfree(rescuer);\n\t}\n\n\t/*\n\t * Sanity checks - grab all the locks so that we wait for all\n\t * in-flight operations which may do put_pwq().\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tif (WARN_ON(pwq_busy(pwq))) {\n\t\t\tpr_warn(\"%s: %s has the following busy pwq\\n\",\n\t\t\t\t__func__, wq->name);\n\t\t\tshow_pwq(pwq);\n\t\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t\tshow_one_workqueue(wq);\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq_unregister_lockdep(wq);\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}"
  },
  {
    "function_name": "pwq_busy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4395-4409",
    "snippet": "static bool pwq_busy(struct pool_workqueue *pwq)\n{\n\tint i;\n\n\tfor (i = 0; i < WORK_NR_COLORS; i++)\n\t\tif (pwq->nr_in_flight[i])\n\t\t\treturn true;\n\n\tif ((pwq != pwq->wq->dfl_pwq) && (pwq->refcnt > 1))\n\t\treturn true;\n\tif (pwq->nr_active || !list_empty(&pwq->inactive_works))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->inactive_works"
          ],
          "line": 4405
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic bool pwq_busy(struct pool_workqueue *pwq)\n{\n\tint i;\n\n\tfor (i = 0; i < WORK_NR_COLORS; i++)\n\t\tif (pwq->nr_in_flight[i])\n\t\t\treturn true;\n\n\tif ((pwq != pwq->wq->dfl_pwq) && (pwq->refcnt > 1))\n\t\treturn true;\n\tif (pwq->nr_active || !list_empty(&pwq->inactive_works))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "alloc_workqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4298-4392",
    "snippet": "struct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);",
      "static bool wq_online;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "wq"
          ],
          "line": 4390
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4417-4501",
          "snippet": "void destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/*\n\t * Remove it from sysfs first so that sanity check failure doesn't\n\t * lead to sysfs name conflicts.\n\t */\n\tworkqueue_sysfs_unregister(wq);\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* kill rescuer, if sanity checks fail, leave it w/o rescuer */\n\tif (wq->rescuer) {\n\t\tstruct worker *rescuer = wq->rescuer;\n\n\t\t/* this prevents new queueing */\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t\twq->rescuer = NULL;\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\t/* rescuer will empty maydays list before exiting */\n\t\tkthread_stop(rescuer->task);\n\t\tkfree(rescuer);\n\t}\n\n\t/*\n\t * Sanity checks - grab all the locks so that we wait for all\n\t * in-flight operations which may do put_pwq().\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tif (WARN_ON(pwq_busy(pwq))) {\n\t\t\tpr_warn(\"%s: %s has the following busy pwq\\n\",\n\t\t\t\t__func__, wq->name);\n\t\t\tshow_pwq(pwq);\n\t\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t\tshow_one_workqueue(wq);\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq_unregister_lockdep(wq);\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_RAW_SPINLOCK(wq_mayday_lock);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_RAW_SPINLOCK(wq_mayday_lock);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/*\n\t * Remove it from sysfs first so that sanity check failure doesn't\n\t * lead to sysfs name conflicts.\n\t */\n\tworkqueue_sysfs_unregister(wq);\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* kill rescuer, if sanity checks fail, leave it w/o rescuer */\n\tif (wq->rescuer) {\n\t\tstruct worker *rescuer = wq->rescuer;\n\n\t\t/* this prevents new queueing */\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t\twq->rescuer = NULL;\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\t/* rescuer will empty maydays list before exiting */\n\t\tkthread_stop(rescuer->task);\n\t\tkfree(rescuer);\n\t}\n\n\t/*\n\t * Sanity checks - grab all the locks so that we wait for all\n\t * in-flight operations which may do put_pwq().\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tif (WARN_ON(pwq_busy(pwq))) {\n\t\t\tpr_warn(\"%s: %s has the following busy pwq\\n\",\n\t\t\t\t__func__, wq->name);\n\t\t\tshow_pwq(pwq);\n\t\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t\tshow_one_workqueue(wq);\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq_unregister_lockdep(wq);\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq"
          ],
          "line": 4387
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "wq->unbound_attrs"
          ],
          "line": 4386
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3385-3391",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_free_lockdep",
          "args": [
            "wq"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "wq_free_lockdep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3525-3527",
          "snippet": "static void wq_free_lockdep(struct workqueue_struct *wq)\n{\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_free_lockdep(struct workqueue_struct *wq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_unregister_lockdep",
          "args": [
            "wq"
          ],
          "line": 4383
        },
        "resolved": true,
        "details": {
          "function_name": "wq_unregister_lockdep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3521-3523",
          "snippet": "static void wq_unregister_lockdep(struct workqueue_struct *wq)\n{\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_unregister_lockdep(struct workqueue_struct *wq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4378
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&wq->list",
            "&workqueues"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwq_adjust_max_active",
          "args": [
            "pwq"
          ],
          "line": 4373
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_adjust_max_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3759-3804",
          "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "workqueue_sysfs_register",
          "args": [
            "wq"
          ],
          "line": 4361
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_sysfs_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5731-5782",
          "snippet": "int workqueue_sysfs_register(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev;\n\tint ret;\n\n\t/*\n\t * Adjusting max_active or creating new pwqs by applying\n\t * attributes breaks ordering guarantee.  Disallow exposing ordered\n\t * workqueues.\n\t */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn -EINVAL;\n\n\twq->wq_dev = wq_dev = kzalloc(sizeof(*wq_dev), GFP_KERNEL);\n\tif (!wq_dev)\n\t\treturn -ENOMEM;\n\n\twq_dev->wq = wq;\n\twq_dev->dev.bus = &wq_subsys;\n\twq_dev->dev.release = wq_device_release;\n\tdev_set_name(&wq_dev->dev, \"%s\", wq->name);\n\n\t/*\n\t * unbound_attrs are created separately.  Suppress uevent until\n\t * everything is ready.\n\t */\n\tdev_set_uevent_suppress(&wq_dev->dev, true);\n\n\tret = device_register(&wq_dev->dev);\n\tif (ret) {\n\t\tput_device(&wq_dev->dev);\n\t\twq->wq_dev = NULL;\n\t\treturn ret;\n\t}\n\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tstruct device_attribute *attr;\n\n\t\tfor (attr = wq_sysfs_unbound_attrs; attr->attr.name; attr++) {\n\t\t\tret = device_create_file(&wq_dev->dev, attr);\n\t\t\tif (ret) {\n\t\t\t\tdevice_unregister(&wq_dev->dev);\n\t\t\t\twq->wq_dev = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_set_uevent_suppress(&wq_dev->dev, false);\n\tkobject_uevent(&wq_dev->dev.kobj, KOBJ_ADD);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint workqueue_sysfs_register(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev;\n\tint ret;\n\n\t/*\n\t * Adjusting max_active or creating new pwqs by applying\n\t * attributes breaks ordering guarantee.  Disallow exposing ordered\n\t * workqueues.\n\t */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn -EINVAL;\n\n\twq->wq_dev = wq_dev = kzalloc(sizeof(*wq_dev), GFP_KERNEL);\n\tif (!wq_dev)\n\t\treturn -ENOMEM;\n\n\twq_dev->wq = wq;\n\twq_dev->dev.bus = &wq_subsys;\n\twq_dev->dev.release = wq_device_release;\n\tdev_set_name(&wq_dev->dev, \"%s\", wq->name);\n\n\t/*\n\t * unbound_attrs are created separately.  Suppress uevent until\n\t * everything is ready.\n\t */\n\tdev_set_uevent_suppress(&wq_dev->dev, true);\n\n\tret = device_register(&wq_dev->dev);\n\tif (ret) {\n\t\tput_device(&wq_dev->dev);\n\t\twq->wq_dev = NULL;\n\t\treturn ret;\n\t}\n\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tstruct device_attribute *attr;\n\n\t\tfor (attr = wq_sysfs_unbound_attrs; attr->attr.name; attr++) {\n\t\t\tret = device_create_file(&wq_dev->dev, attr);\n\t\t\tif (ret) {\n\t\t\t\tdevice_unregister(&wq_dev->dev);\n\t\t\t\twq->wq_dev = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_set_uevent_suppress(&wq_dev->dev, false);\n\tkobject_uevent(&wq_dev->dev.kobj, KOBJ_ADD);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rescuer",
          "args": [
            "wq"
          ],
          "line": 4358
        },
        "resolved": true,
        "details": {
          "function_name": "init_rescuer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4270-4295",
          "snippet": "static int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tif (IS_ERR(rescuer->task)) {\n\t\tret = PTR_ERR(rescuer->task);\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tif (IS_ERR(rescuer->task)) {\n\t\tret = PTR_ERR(rescuer->task);\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_and_link_pwqs",
          "args": [
            "wq"
          ],
          "line": 4355
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_link_pwqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4214-4252",
          "snippet": "static int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcpus_read_lock();\n\tif (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t} else {\n\t\tret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n\tcpus_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];",
            "static struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];\nstatic struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcpus_read_lock();\n\tif (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t} else {\n\t\tret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n\tcpus_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq->list"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_init_lockdep",
          "args": [
            "wq"
          ],
          "line": 4352
        },
        "resolved": true,
        "details": {
          "function_name": "wq_init_lockdep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3517-3519",
          "snippet": "static void wq_init_lockdep(struct workqueue_struct *wq)\n{\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_init_lockdep(struct workqueue_struct *wq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq->maydays"
          ],
          "line": 4350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq->flusher_overflow"
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq->flusher_queue"
          ],
          "line": 4348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq->pwqs"
          ],
          "line": 4347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&wq->nr_pwqs_to_flush",
            "0"
          ],
          "line": 4346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&wq->mutex"
          ],
          "line": 4345
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_clamp_max_active",
          "args": [
            "max_active",
            "flags",
            "wq->name"
          ],
          "line": 4340
        },
        "resolved": true,
        "details": {
          "function_name": "wq_clamp_max_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4254-4264",
          "snippet": "static int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 4337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "wq->name",
            "sizeof(wq->name)",
            "fmt",
            "args"
          ],
          "line": 4336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "max_active"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [],
          "line": 4330
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3401-3416",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*wq) + tbl_size",
            "GFP_KERNEL"
          ],
          "line": 4325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);\nstatic bool wq_online;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstruct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}"
  },
  {
    "function_name": "init_rescuer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4270-4295",
    "snippet": "static int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tif (IS_ERR(rescuer->task)) {\n\t\tret = PTR_ERR(rescuer->task);\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "rescuer->task"
          ],
          "line": 4292
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_bind_mask",
          "args": [
            "rescuer->task",
            "cpu_possible_mask"
          ],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_bind_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "541-544",
          "snippet": "void kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rescuer"
          ],
          "line": 4286
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rescuer->task"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rescuer->task"
          ],
          "line": 4284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "rescuer_thread",
            "rescuer",
            "\"%s\"",
            "wq->name"
          ],
          "line": 4283
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "882-893",
          "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_worker",
          "args": [
            "NUMA_NO_NODE"
          ],
          "line": 4278
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1854-1867",
          "snippet": "static struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tif (IS_ERR(rescuer->task)) {\n\t\tret = PTR_ERR(rescuer->task);\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wq_clamp_max_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4254-4264",
    "snippet": "static int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clamp_val",
          "args": [
            "max_active",
            "1",
            "lim"
          ],
          "line": 4263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\"",
            "max_active",
            "name",
            "1",
            "lim"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}"
  },
  {
    "function_name": "alloc_and_link_pwqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4214-4252",
    "snippet": "static int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcpus_read_lock();\n\tif (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t} else {\n\t\tret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n\tcpus_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];",
      "static struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 4249
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_workqueue_attrs",
          "args": [
            "wq",
            "unbound_std_wq_attrs[highpri]"
          ],
          "line": 4247
        },
        "resolved": true,
        "details": {
          "function_name": "apply_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4115-4127",
          "snippet": "int apply_workqueue_attrs(struct workqueue_struct *wq,\n\t\t\t  const struct workqueue_attrs *attrs)\n{\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&wq_pool_mutex);\n\tret = apply_workqueue_attrs_locked(wq, attrs);\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint apply_workqueue_attrs(struct workqueue_struct *wq,\n\t\t\t  const struct workqueue_attrs *attrs)\n{\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&wq_pool_mutex);\n\tret = apply_workqueue_attrs_locked(wq, attrs);\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node)",
            "\"ordering guarantee broken for workqueue %s\\n\"",
            "wq->name"
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 4239
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4234
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_pwq",
          "args": [
            "pwq"
          ],
          "line": 4233
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_link_pwqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4214-4252",
          "snippet": "static int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcpus_read_lock();\n\tif (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t} else {\n\t\tret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n\tcpus_read_unlock();\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4232
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_pwq",
          "args": [
            "pwq",
            "wq",
            "&cpu_pools[highpri]"
          ],
          "line": 4230
        },
        "resolved": true,
        "details": {
          "function_name": "init_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3807-3822",
          "snippet": "static void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->inactive_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->inactive_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_worker_pools",
            "cpu"
          ],
          "line": 4228
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wq->cpu_pwqs",
            "cpu"
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structpool_workqueue"
          ],
          "line": 4220
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];\nstatic struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcpus_read_lock();\n\tif (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t} else {\n\t\tret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n\tcpus_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wq_update_unbound_numa",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4151-4212",
    "snippet": "static void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\traw_spin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\traw_spin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_numa_enabled;",
      "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pwq_unlocked",
          "args": [
            "old_pwq"
          ],
          "line": 4211
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1158-1169",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4210
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_pwq_tbl_install",
          "args": [
            "wq",
            "node",
            "wq->dfl_pwq"
          ],
          "line": 4208
        },
        "resolved": true,
        "details": {
          "function_name": "numa_pwq_tbl_install",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3921-3936",
          "snippet": "static struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&wq->dfl_pwq->pool->lock"
          ],
          "line": 4207
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pwq",
          "args": [
            "wq->dfl_pwq"
          ],
          "line": 4206
        },
        "resolved": true,
        "details": {
          "function_name": "get_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1120-1125",
          "snippet": "static void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&wq->dfl_pwq->pool->lock"
          ],
          "line": 4205
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4204
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\"",
            "wq->name"
          ],
          "line": 4193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_unbound_pwq",
          "args": [
            "wq",
            "target_attrs"
          ],
          "line": 4191
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_unbound_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3846-3866",
          "snippet": "static struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pwq_cache;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *pwq_cache;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "cpumask",
            "pwq->pool->attrs->cpumask"
          ],
          "line": 4184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_calc_node_cpumask",
          "args": [
            "wq->dfl_pwq->pool->attrs",
            "node",
            "cpu_off",
            "cpumask"
          ],
          "line": 4183
        },
        "resolved": true,
        "details": {
          "function_name": "wq_calc_node_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3890-3918",
          "snippet": "static bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t *wq_numa_possible_cpumask;",
            "static bool wq_numa_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_numa_enabled;\n\nstatic bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unbound_pwq_by_node",
          "args": [
            "wq",
            "node"
          ],
          "line": 4175
        },
        "resolved": true,
        "details": {
          "function_name": "unbound_pwq_by_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "574-589",
          "snippet": "static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_workqueue_attrs",
          "args": [
            "target_attrs",
            "wq->unbound_attrs"
          ],
          "line": 4174
        },
        "resolved": true,
        "details": {
          "function_name": "copy_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3418-3429",
          "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 4154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\traw_spin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\traw_spin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}"
  },
  {
    "function_name": "apply_workqueue_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4115-4127",
    "snippet": "int apply_workqueue_attrs(struct workqueue_struct *wq,\n\t\t\t  const struct workqueue_attrs *attrs)\n{\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&wq_pool_mutex);\n\tret = apply_workqueue_attrs_locked(wq, attrs);\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4124
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_workqueue_attrs_locked",
          "args": [
            "wq",
            "attrs"
          ],
          "line": 4123
        },
        "resolved": true,
        "details": {
          "function_name": "apply_workqueue_attrs_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4069-4095",
          "snippet": "static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4122
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 4120
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "335-347",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint apply_workqueue_attrs(struct workqueue_struct *wq,\n\t\t\t  const struct workqueue_attrs *attrs)\n{\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&wq_pool_mutex);\n\tret = apply_workqueue_attrs_locked(wq, attrs);\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "apply_workqueue_attrs_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4069-4095",
    "snippet": "static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_wqattrs_cleanup",
          "args": [
            "ctx"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3948-3961",
          "snippet": "static void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_commit",
          "args": [
            "ctx"
          ],
          "line": 4091
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4035-4054",
          "snippet": "static void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_prepare",
          "args": [
            "wq",
            "attrs"
          ],
          "line": 4086
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3964-4032",
          "snippet": "static struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs();\n\ttmp_attrs = alloc_workqueue_attrs();\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static cpumask_var_t wq_unbound_cpumask;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs();\n\ttmp_attrs = alloc_workqueue_attrs();\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "wq->flags & __WQ_ORDERED_EXPLICIT"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq->pwqs"
          ],
          "line": 4079
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(wq->flags & WQ_UNBOUND)"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "apply_wqattrs_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4063-4067",
    "snippet": "static void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 4066
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4065
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "apply_wqattrs_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4056-4061",
    "snippet": "static void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tcpus_read_lock();\n\tmutex_lock(&wq_pool_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4060
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 4059
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tcpus_read_lock();\n\tmutex_lock(&wq_pool_mutex);\n}"
  },
  {
    "function_name": "apply_wqattrs_commit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "4035-4054",
    "snippet": "static void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctx->wq->mutex"
          ],
          "line": 4053
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "ctx->wq->dfl_pwq",
            "ctx->dfl_pwq"
          ],
          "line": 4051
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_reader",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/swap.c",
          "lines": "974-1018",
          "snippet": "static int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_pwq",
          "args": [
            "ctx->dfl_pwq"
          ],
          "line": 4050
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_link_pwqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4214-4252",
          "snippet": "static int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcpus_read_lock();\n\tif (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t} else {\n\t\tret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n\tcpus_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];",
            "static struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];\nstatic struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcpus_read_lock();\n\tif (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t} else {\n\t\tret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n\tcpus_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_pwq_tbl_install",
          "args": [
            "ctx->wq",
            "node",
            "ctx->pwq_tbl[node]"
          ],
          "line": 4046
        },
        "resolved": true,
        "details": {
          "function_name": "numa_pwq_tbl_install",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3921-3936",
          "snippet": "static struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_workqueue_attrs",
          "args": [
            "ctx->wq->unbound_attrs",
            "ctx->attrs"
          ],
          "line": 4042
        },
        "resolved": true,
        "details": {
          "function_name": "copy_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3418-3429",
          "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ctx->wq->mutex"
          ],
          "line": 4040
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}"
  },
  {
    "function_name": "apply_wqattrs_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3964-4032",
    "snippet": "static struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs();\n\ttmp_attrs = alloc_workqueue_attrs();\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static cpumask_var_t wq_unbound_cpumask;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_wqattrs_cleanup",
          "args": [
            "ctx"
          ],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3948-3961",
          "snippet": "static void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "new_attrs"
          ],
          "line": 4029
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3385-3391",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "new_attrs->cpumask",
            "new_attrs->cpumask",
            "cpu_possible_mask"
          ],
          "line": 4020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_workqueue_attrs",
          "args": [
            "new_attrs",
            "attrs"
          ],
          "line": 4019
        },
        "resolved": true,
        "details": {
          "function_name": "copy_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3418-3429",
          "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_unbound_pwq",
          "args": [
            "wq",
            "tmp_attrs"
          ],
          "line": 4009
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_unbound_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3846-3866",
          "snippet": "static struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pwq_cache;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *pwq_cache;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_calc_node_cpumask",
          "args": [
            "new_attrs",
            "node",
            "-1",
            "tmp_attrs->cpumask"
          ],
          "line": 4008
        },
        "resolved": true,
        "details": {
          "function_name": "wq_calc_node_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3890-3918",
          "snippet": "static bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t *wq_numa_possible_cpumask;",
            "static bool wq_numa_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_numa_enabled;\n\nstatic bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "new_attrs->cpumask",
            "wq_unbound_cpumask"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpumask_empty(new_attrs->cpumask)"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "new_attrs->cpumask"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "new_attrs->cpumask",
            "new_attrs->cpumask",
            "wq_unbound_cpumask"
          ],
          "line": 3987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [],
          "line": 3977
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3401-3416",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "struct_size(ctx, pwq_tbl, nr_node_ids)",
            "GFP_KERNEL"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "ctx",
            "pwq_tbl",
            "nr_node_ids"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs();\n\ttmp_attrs = alloc_workqueue_attrs();\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}"
  },
  {
    "function_name": "apply_wqattrs_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3948-3961",
    "snippet": "static void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 3959
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "ctx->attrs"
          ],
          "line": 3957
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3385-3391",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pwq_unlocked",
          "args": [
            "ctx->dfl_pwq"
          ],
          "line": 3955
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1158-1169",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}"
  },
  {
    "function_name": "numa_pwq_tbl_install",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3921-3936",
    "snippet": "static struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "wq->numa_pwq_tbl[node]",
            "pwq"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "wq->numa_pwq_tbl[node]"
          ],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_pwq",
          "args": [
            "pwq"
          ],
          "line": 3931
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_link_pwqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4214-4252",
          "snippet": "static int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcpus_read_lock();\n\tif (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t} else {\n\t\tret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n\tcpus_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];",
            "static struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];\nstatic struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tcpus_read_lock();\n\tif (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t} else {\n\t\tret = apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n\tcpus_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq->mutex"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}"
  },
  {
    "function_name": "wq_calc_node_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3890-3918",
    "snippet": "static bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t *wq_numa_possible_cpumask;",
      "static bool wq_numa_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cpumask",
            "attrs->cpumask"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "cpumask",
            "attrs->cpumask"
          ],
          "line": 3913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\""
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpumask"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "cpumask",
            "attrs->cpumask",
            "wq_numa_possible_cpumask[node]"
          ],
          "line": 3905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpumask"
          ],
          "line": 3901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu_going_down",
            "cpumask"
          ],
          "line": 3899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "cpumask",
            "cpumask_of_node(node)",
            "attrs->cpumask"
          ],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "node"
          ],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_numa_enabled;\n\nstatic bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}"
  },
  {
    "function_name": "alloc_unbound_pwq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3846-3866",
    "snippet": "static struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pwq_cache;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_pwq",
          "args": [
            "pwq",
            "wq",
            "pool"
          ],
          "line": 3864
        },
        "resolved": true,
        "details": {
          "function_name": "init_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3807-3822",
          "snippet": "static void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->inactive_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->inactive_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unbound_pool",
          "args": [
            "pool"
          ],
          "line": 3860
        },
        "resolved": true,
        "details": {
          "function_name": "put_unbound_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3577-3627",
          "snippet": "static void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t * Because of how wq_manager_inactive() works, we will hold the\n\t * spinlock after a successful wait.\n\t */\n\trcuwait_wait_event(&manager_wait, wq_manager_inactive(pool),\n\t\t\t   TASK_UNINTERRUPTIBLE);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\traw_spin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu(&pool->rcu, rcu_free_pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static DEFINE_IDR(worker_pool_idr);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t * Because of how wq_manager_inactive() works, we will hold the\n\t * spinlock after a successful wait.\n\t */\n\trcuwait_wait_event(&manager_wait, wq_manager_inactive(pool),\n\t\t\t   TASK_UNINTERRUPTIBLE);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\traw_spin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu(&pool->rcu, rcu_free_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc_node",
          "args": [
            "pwq_cache",
            "GFP_KERNEL",
            "pool->node"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unbound_pool",
          "args": [
            "attrs"
          ],
          "line": 3854
        },
        "resolved": true,
        "details": {
          "function_name": "get_unbound_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3643-3701",
          "snippet": "static struct worker_pool *get_unbound_pool(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = wqattrs_hash(attrs);\n\tstruct worker_pool *pool;\n\tint node;\n\tint target_node = NUMA_NO_NODE;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\t/* do we already have a matching pool? */\n\thash_for_each_possible(unbound_pool_hash, pool, hash_node, hash) {\n\t\tif (wqattrs_equal(pool->attrs, attrs)) {\n\t\t\tpool->refcnt++;\n\t\t\treturn pool;\n\t\t}\n\t}\n\n\t/* if cpumask is contained inside a NUMA node, we belong to that node */\n\tif (wq_numa_enabled) {\n\t\tfor_each_node(node) {\n\t\t\tif (cpumask_subset(attrs->cpumask,\n\t\t\t\t\t   wq_numa_possible_cpumask[node])) {\n\t\t\t\ttarget_node = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* nope, create a new one */\n\tpool = kzalloc_node(sizeof(*pool), GFP_KERNEL, target_node);\n\tif (!pool || init_worker_pool(pool) < 0)\n\t\tgoto fail;\n\n\tlockdep_set_subclass(&pool->lock, 1);\t/* see put_pwq() */\n\tcopy_workqueue_attrs(pool->attrs, attrs);\n\tpool->node = target_node;\n\n\t/*\n\t * no_numa isn't a worker_pool attribute, always clear it.  See\n\t * 'struct workqueue_attrs' comments for detail.\n\t */\n\tpool->attrs->no_numa = false;\n\n\tif (worker_pool_assign_id(pool) < 0)\n\t\tgoto fail;\n\n\t/* create and start the initial worker */\n\tif (wq_online && !create_worker(pool))\n\t\tgoto fail;\n\n\t/* install */\n\thash_add(unbound_pool_hash, &pool->hash_node, hash);\n\n\treturn pool;\nfail:\n\tif (pool)\n\t\tput_unbound_pool(pool);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t *wq_numa_possible_cpumask;",
            "static bool wq_online;",
            "static bool wq_numa_enabled;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_online;\nstatic bool wq_numa_enabled;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker_pool *get_unbound_pool(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = wqattrs_hash(attrs);\n\tstruct worker_pool *pool;\n\tint node;\n\tint target_node = NUMA_NO_NODE;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\t/* do we already have a matching pool? */\n\thash_for_each_possible(unbound_pool_hash, pool, hash_node, hash) {\n\t\tif (wqattrs_equal(pool->attrs, attrs)) {\n\t\t\tpool->refcnt++;\n\t\t\treturn pool;\n\t\t}\n\t}\n\n\t/* if cpumask is contained inside a NUMA node, we belong to that node */\n\tif (wq_numa_enabled) {\n\t\tfor_each_node(node) {\n\t\t\tif (cpumask_subset(attrs->cpumask,\n\t\t\t\t\t   wq_numa_possible_cpumask[node])) {\n\t\t\t\ttarget_node = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* nope, create a new one */\n\tpool = kzalloc_node(sizeof(*pool), GFP_KERNEL, target_node);\n\tif (!pool || init_worker_pool(pool) < 0)\n\t\tgoto fail;\n\n\tlockdep_set_subclass(&pool->lock, 1);\t/* see put_pwq() */\n\tcopy_workqueue_attrs(pool->attrs, attrs);\n\tpool->node = target_node;\n\n\t/*\n\t * no_numa isn't a worker_pool attribute, always clear it.  See\n\t * 'struct workqueue_attrs' comments for detail.\n\t */\n\tpool->attrs->no_numa = false;\n\n\tif (worker_pool_assign_id(pool) < 0)\n\t\tgoto fail;\n\n\t/* create and start the initial worker */\n\tif (wq_online && !create_worker(pool))\n\t\tgoto fail;\n\n\t/* install */\n\thash_add(unbound_pool_hash, &pool->hash_node, hash);\n\n\treturn pool;\nfail:\n\tif (pool)\n\t\tput_unbound_pool(pool);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *pwq_cache;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}"
  },
  {
    "function_name": "link_pwq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3825-3843",
    "snippet": "static void link_pwq(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* may be called multiple times, ignore if already linked */\n\tif (!list_empty(&pwq->pwqs_node))\n\t\treturn;\n\n\t/* set the matching work_color */\n\tpwq->work_color = wq->work_color;\n\n\t/* sync max_active to the current setting */\n\tpwq_adjust_max_active(pwq);\n\n\t/* link in @pwq */\n\tlist_add_rcu(&pwq->pwqs_node, &wq->pwqs);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&pwq->pwqs_node",
            "&wq->pwqs"
          ],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwq_adjust_max_active",
          "args": [
            "pwq"
          ],
          "line": 3839
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_adjust_max_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3759-3804",
          "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->pwqs_node"
          ],
          "line": 3832
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq->mutex"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void link_pwq(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* may be called multiple times, ignore if already linked */\n\tif (!list_empty(&pwq->pwqs_node))\n\t\treturn;\n\n\t/* set the matching work_color */\n\tpwq->work_color = wq->work_color;\n\n\t/* sync max_active to the current setting */\n\tpwq_adjust_max_active(pwq);\n\n\t/* link in @pwq */\n\tlist_add_rcu(&pwq->pwqs_node, &wq->pwqs);\n}"
  },
  {
    "function_name": "init_pwq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3807-3822",
    "snippet": "static void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->inactive_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&pwq->unbound_release_work",
            "pwq_unbound_release_workfn"
          ],
          "line": 3821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pwq->mayday_node"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pwq->pwqs_node"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pwq->inactive_works"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pwq",
            "0",
            "sizeof(*pwq)"
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(unsigned long)pwq & WORK_STRUCT_FLAG_MASK"
          ],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->inactive_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}"
  },
  {
    "function_name": "pwq_adjust_max_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3759-3804",
    "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool workqueue_freezing;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&pwq->pool->lock",
            "flags"
          ],
          "line": 3803
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_worker",
          "args": [
            "pwq->pool"
          ],
          "line": 3798
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwq_activate_first_inactive",
          "args": [
            "pwq"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_activate_first_inactive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1183-1189",
          "snippet": "static void pwq_activate_first_inactive(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->inactive_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_inactive_work(work);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void pwq_activate_first_inactive(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->inactive_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_inactive_work(work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->inactive_works"
          ],
          "line": 3785
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&pwq->pool->lock",
            "flags"
          ],
          "line": 3773
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq->mutex"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\traw_spin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tbool kick = false;\n\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->inactive_works) &&\n\t\t       pwq->nr_active < pwq->max_active) {\n\t\t\tpwq_activate_first_inactive(pwq);\n\t\t\tkick = true;\n\t\t}\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped. In realtime scenarios, always kicking a\n\t\t * worker will cause interference on the isolated cpu cores, so\n\t\t * let's kick iff work items were activated.\n\t\t */\n\t\tif (kick)\n\t\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
  },
  {
    "function_name": "pwq_unbound_release_workfn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3713-3749",
    "snippet": "static void pwq_unbound_release_workfn(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = container_of(work, struct pool_workqueue,\n\t\t\t\t\t\t  unbound_release_work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\tstruct worker_pool *pool = pwq->pool;\n\tbool is_last = false;\n\n\t/*\n\t * when @pwq is not linked, it doesn't hold any reference to the\n\t * @wq, and @wq is invalid to access.\n\t */\n\tif (!list_empty(&pwq->pwqs_node)) {\n\t\tif (WARN_ON_ONCE(!(wq->flags & WQ_UNBOUND)))\n\t\t\treturn;\n\n\t\tmutex_lock(&wq->mutex);\n\t\tlist_del_rcu(&pwq->pwqs_node);\n\t\tis_last = list_empty(&wq->pwqs);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\n\tmutex_lock(&wq_pool_mutex);\n\tput_unbound_pool(pool);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tcall_rcu(&pwq->rcu, rcu_free_pwq);\n\n\t/*\n\t * If we're the last pwq going away, @wq is already dead and no one\n\t * is gonna access it anymore.  Schedule RCU free.\n\t */\n\tif (is_last) {\n\t\twq_unregister_lockdep(wq);\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&wq->rcu",
            "rcu_free_wq"
          ],
          "line": 3747
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_unregister_lockdep",
          "args": [
            "wq"
          ],
          "line": 3746
        },
        "resolved": true,
        "details": {
          "function_name": "wq_unregister_lockdep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3521-3523",
          "snippet": "static void wq_unregister_lockdep(struct workqueue_struct *wq)\n{\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_unregister_lockdep(struct workqueue_struct *wq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3737
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unbound_pool",
          "args": [
            "pool"
          ],
          "line": 3736
        },
        "resolved": true,
        "details": {
          "function_name": "put_unbound_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3577-3627",
          "snippet": "static void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t * Because of how wq_manager_inactive() works, we will hold the\n\t * spinlock after a successful wait.\n\t */\n\trcuwait_wait_event(&manager_wait, wq_manager_inactive(pool),\n\t\t\t   TASK_UNINTERRUPTIBLE);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\traw_spin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu(&pool->rcu, rcu_free_pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static DEFINE_IDR(worker_pool_idr);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t * Because of how wq_manager_inactive() works, we will hold the\n\t * spinlock after a successful wait.\n\t */\n\trcuwait_wait_event(&manager_wait, wq_manager_inactive(pool),\n\t\t\t   TASK_UNINTERRUPTIBLE);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\traw_spin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu(&pool->rcu, rcu_free_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3735
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq->pwqs"
          ],
          "line": 3731
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&pwq->pwqs_node"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(wq->flags & WQ_UNBOUND)"
          ],
          "line": 3726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structpool_workqueue",
            "unbound_release_work"
          ],
          "line": 3715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pwq_unbound_release_workfn(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = container_of(work, struct pool_workqueue,\n\t\t\t\t\t\t  unbound_release_work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\tstruct worker_pool *pool = pwq->pool;\n\tbool is_last = false;\n\n\t/*\n\t * when @pwq is not linked, it doesn't hold any reference to the\n\t * @wq, and @wq is invalid to access.\n\t */\n\tif (!list_empty(&pwq->pwqs_node)) {\n\t\tif (WARN_ON_ONCE(!(wq->flags & WQ_UNBOUND)))\n\t\t\treturn;\n\n\t\tmutex_lock(&wq->mutex);\n\t\tlist_del_rcu(&pwq->pwqs_node);\n\t\tis_last = list_empty(&wq->pwqs);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\n\tmutex_lock(&wq_pool_mutex);\n\tput_unbound_pool(pool);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tcall_rcu(&pwq->rcu, rcu_free_pwq);\n\n\t/*\n\t * If we're the last pwq going away, @wq is already dead and no one\n\t * is gonna access it anymore.  Schedule RCU free.\n\t */\n\tif (is_last) {\n\t\twq_unregister_lockdep(wq);\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t}\n}"
  },
  {
    "function_name": "rcu_free_pwq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3703-3707",
    "snippet": "static void rcu_free_pwq(struct rcu_head *rcu)\n{\n\tkmem_cache_free(pwq_cache,\n\t\t\tcontainer_of(rcu, struct pool_workqueue, rcu));\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pwq_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "pwq_cache",
            "container_of(rcu, struct pool_workqueue, rcu)"
          ],
          "line": 3705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structpool_workqueue",
            "rcu"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *pwq_cache;\n\nstatic void rcu_free_pwq(struct rcu_head *rcu)\n{\n\tkmem_cache_free(pwq_cache,\n\t\t\tcontainer_of(rcu, struct pool_workqueue, rcu));\n}"
  },
  {
    "function_name": "get_unbound_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3643-3701",
    "snippet": "static struct worker_pool *get_unbound_pool(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = wqattrs_hash(attrs);\n\tstruct worker_pool *pool;\n\tint node;\n\tint target_node = NUMA_NO_NODE;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\t/* do we already have a matching pool? */\n\thash_for_each_possible(unbound_pool_hash, pool, hash_node, hash) {\n\t\tif (wqattrs_equal(pool->attrs, attrs)) {\n\t\t\tpool->refcnt++;\n\t\t\treturn pool;\n\t\t}\n\t}\n\n\t/* if cpumask is contained inside a NUMA node, we belong to that node */\n\tif (wq_numa_enabled) {\n\t\tfor_each_node(node) {\n\t\t\tif (cpumask_subset(attrs->cpumask,\n\t\t\t\t\t   wq_numa_possible_cpumask[node])) {\n\t\t\t\ttarget_node = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* nope, create a new one */\n\tpool = kzalloc_node(sizeof(*pool), GFP_KERNEL, target_node);\n\tif (!pool || init_worker_pool(pool) < 0)\n\t\tgoto fail;\n\n\tlockdep_set_subclass(&pool->lock, 1);\t/* see put_pwq() */\n\tcopy_workqueue_attrs(pool->attrs, attrs);\n\tpool->node = target_node;\n\n\t/*\n\t * no_numa isn't a worker_pool attribute, always clear it.  See\n\t * 'struct workqueue_attrs' comments for detail.\n\t */\n\tpool->attrs->no_numa = false;\n\n\tif (worker_pool_assign_id(pool) < 0)\n\t\tgoto fail;\n\n\t/* create and start the initial worker */\n\tif (wq_online && !create_worker(pool))\n\t\tgoto fail;\n\n\t/* install */\n\thash_add(unbound_pool_hash, &pool->hash_node, hash);\n\n\treturn pool;\nfail:\n\tif (pool)\n\t\tput_unbound_pool(pool);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t *wq_numa_possible_cpumask;",
      "static bool wq_online;",
      "static bool wq_numa_enabled;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unbound_pool",
          "args": [
            "pool"
          ],
          "line": 3699
        },
        "resolved": true,
        "details": {
          "function_name": "put_unbound_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3577-3627",
          "snippet": "static void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t * Because of how wq_manager_inactive() works, we will hold the\n\t * spinlock after a successful wait.\n\t */\n\trcuwait_wait_event(&manager_wait, wq_manager_inactive(pool),\n\t\t\t   TASK_UNINTERRUPTIBLE);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\traw_spin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu(&pool->rcu, rcu_free_pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static DEFINE_IDR(worker_pool_idr);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t * Because of how wq_manager_inactive() works, we will hold the\n\t * spinlock after a successful wait.\n\t */\n\trcuwait_wait_event(&manager_wait, wq_manager_inactive(pool),\n\t\t\t   TASK_UNINTERRUPTIBLE);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\traw_spin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu(&pool->rcu, rcu_free_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "unbound_pool_hash",
            "&pool->hash_node",
            "hash"
          ],
          "line": 3694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_worker",
          "args": [
            "pool"
          ],
          "line": 3690
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2114-2143",
          "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\traw_spin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\traw_spin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_pool_assign_id",
          "args": [
            "pool"
          ],
          "line": 3686
        },
        "resolved": true,
        "details": {
          "function_name": "worker_pool_assign_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "547-560",
          "snippet": "static int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static DEFINE_IDR(worker_pool_idr);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_workqueue_attrs",
          "args": [
            "pool->attrs",
            "attrs"
          ],
          "line": 3677
        },
        "resolved": true,
        "details": {
          "function_name": "copy_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3418-3429",
          "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_set_subclass",
          "args": [
            "&pool->lock",
            "1"
          ],
          "line": 3676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_worker_pool",
          "args": [
            "pool"
          ],
          "line": 3673
        },
        "resolved": true,
        "details": {
          "function_name": "init_worker_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3463-3490",
          "snippet": "static int init_worker_pool(struct worker_pool *pool)\n{\n\traw_spin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs();\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int init_worker_pool(struct worker_pool *pool)\n{\n\traw_spin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs();\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*pool)",
            "GFP_KERNEL",
            "target_node"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "attrs->cpumask",
            "wq_numa_possible_cpumask[node]"
          ],
          "line": 3663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wqattrs_equal",
          "args": [
            "pool->attrs",
            "attrs"
          ],
          "line": 3654
        },
        "resolved": true,
        "details": {
          "function_name": "wqattrs_equal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3443-3451",
          "snippet": "static bool wqattrs_equal(const struct workqueue_attrs *a,\n\t\t\t  const struct workqueue_attrs *b)\n{\n\tif (a->nice != b->nice)\n\t\treturn false;\n\tif (!cpumask_equal(a->cpumask, b->cpumask))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wqattrs_equal(const struct workqueue_attrs *a,\n\t\t\t  const struct workqueue_attrs *b)\n{\n\tif (a->nice != b->nice)\n\t\treturn false;\n\tif (!cpumask_equal(a->cpumask, b->cpumask))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "unbound_pool_hash",
            "pool",
            "hash_node",
            "hash"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wqattrs_hash",
          "args": [
            "attrs"
          ],
          "line": 3645
        },
        "resolved": true,
        "details": {
          "function_name": "wqattrs_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3432-3440",
          "snippet": "static u32 wqattrs_hash(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = 0;\n\n\thash = jhash_1word(attrs->nice, hash);\n\thash = jhash(cpumask_bits(attrs->cpumask),\n\t\t     BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long), hash);\n\treturn hash;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic u32 wqattrs_hash(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = 0;\n\n\thash = jhash_1word(attrs->nice, hash);\n\thash = jhash(cpumask_bits(attrs->cpumask),\n\t\t     BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long), hash);\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_online;\nstatic bool wq_numa_enabled;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker_pool *get_unbound_pool(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = wqattrs_hash(attrs);\n\tstruct worker_pool *pool;\n\tint node;\n\tint target_node = NUMA_NO_NODE;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\t/* do we already have a matching pool? */\n\thash_for_each_possible(unbound_pool_hash, pool, hash_node, hash) {\n\t\tif (wqattrs_equal(pool->attrs, attrs)) {\n\t\t\tpool->refcnt++;\n\t\t\treturn pool;\n\t\t}\n\t}\n\n\t/* if cpumask is contained inside a NUMA node, we belong to that node */\n\tif (wq_numa_enabled) {\n\t\tfor_each_node(node) {\n\t\t\tif (cpumask_subset(attrs->cpumask,\n\t\t\t\t\t   wq_numa_possible_cpumask[node])) {\n\t\t\t\ttarget_node = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* nope, create a new one */\n\tpool = kzalloc_node(sizeof(*pool), GFP_KERNEL, target_node);\n\tif (!pool || init_worker_pool(pool) < 0)\n\t\tgoto fail;\n\n\tlockdep_set_subclass(&pool->lock, 1);\t/* see put_pwq() */\n\tcopy_workqueue_attrs(pool->attrs, attrs);\n\tpool->node = target_node;\n\n\t/*\n\t * no_numa isn't a worker_pool attribute, always clear it.  See\n\t * 'struct workqueue_attrs' comments for detail.\n\t */\n\tpool->attrs->no_numa = false;\n\n\tif (worker_pool_assign_id(pool) < 0)\n\t\tgoto fail;\n\n\t/* create and start the initial worker */\n\tif (wq_online && !create_worker(pool))\n\t\tgoto fail;\n\n\t/* install */\n\thash_add(unbound_pool_hash, &pool->hash_node, hash);\n\n\treturn pool;\nfail:\n\tif (pool)\n\t\tput_unbound_pool(pool);\n\treturn NULL;\n}"
  },
  {
    "function_name": "put_unbound_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3577-3627",
    "snippet": "static void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t * Because of how wq_manager_inactive() works, we will hold the\n\t * spinlock after a successful wait.\n\t */\n\trcuwait_wait_event(&manager_wait, wq_manager_inactive(pool),\n\t\t\t   TASK_UNINTERRUPTIBLE);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\traw_spin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu(&pool->rcu, rcu_free_pool);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static DEFINE_IDR(worker_pool_idr);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&pool->rcu",
            "rcu_free_pool"
          ],
          "line": 3626
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&pool->mayday_timer"
          ],
          "line": 3623
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "pool->detach_completion"
          ],
          "line": 3619
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 3616
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->workers"
          ],
          "line": 3614
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 3613
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pool->nr_workers || pool->nr_idle"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_worker",
          "args": [
            "worker"
          ],
          "line": 3609
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2003-2021",
          "snippet": "static void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_idle_worker",
          "args": [
            "pool"
          ],
          "line": 3608
        },
        "resolved": true,
        "details": {
          "function_name": "first_idle_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "830-836",
          "snippet": "static struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcuwait_wait_event",
          "args": [
            "&manager_wait",
            "wq_manager_inactive(pool)",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_manager_inactive",
          "args": [
            "pool"
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "wq_manager_inactive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3555-3564",
          "snippet": "static bool wq_manager_inactive(struct worker_pool *pool)\n{\n\traw_spin_lock_irq(&pool->lock);\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE) {\n\t\traw_spin_unlock_irq(&pool->lock);\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool wq_manager_inactive(struct worker_pool *pool)\n{\n\traw_spin_lock_irq(&pool->lock);\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE) {\n\t\traw_spin_unlock_irq(&pool->lock);\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&pool->hash_node"
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&worker_pool_idr",
            "pool->id"
          ],
          "line": 3594
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "342-347",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&pool->worklist)"
          ],
          "line": 3589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(pool->cpu < 0)"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_COMPLETION_ONSTACK",
          "args": [
            "detach_completion"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t * Because of how wq_manager_inactive() works, we will hold the\n\t * spinlock after a successful wait.\n\t */\n\trcuwait_wait_event(&manager_wait, wq_manager_inactive(pool),\n\t\t\t   TASK_UNINTERRUPTIBLE);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\traw_spin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu(&pool->rcu, rcu_free_pool);\n}"
  },
  {
    "function_name": "wq_manager_inactive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3555-3564",
    "snippet": "static bool wq_manager_inactive(struct worker_pool *pool)\n{\n\traw_spin_lock_irq(&pool->lock);\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE) {\n\t\traw_spin_unlock_irq(&pool->lock);\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 3557
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool wq_manager_inactive(struct worker_pool *pool)\n{\n\traw_spin_lock_irq(&pool->lock);\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE) {\n\t\traw_spin_unlock_irq(&pool->lock);\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "rcu_free_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3545-3552",
    "snippet": "static void rcu_free_pool(struct rcu_head *rcu)\n{\n\tstruct worker_pool *pool = container_of(rcu, struct worker_pool, rcu);\n\n\tida_destroy(&pool->worker_ida);\n\tfree_workqueue_attrs(pool->attrs);\n\tkfree(pool);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pool"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "pool->attrs"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3385-3391",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_destroy",
          "args": [
            "&pool->worker_ida"
          ],
          "line": 3549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structworker_pool",
            "rcu"
          ],
          "line": 3547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void rcu_free_pool(struct rcu_head *rcu)\n{\n\tstruct worker_pool *pool = container_of(rcu, struct worker_pool, rcu);\n\n\tida_destroy(&pool->worker_ida);\n\tfree_workqueue_attrs(pool->attrs);\n\tkfree(pool);\n}"
  },
  {
    "function_name": "rcu_free_wq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3530-3543",
    "snippet": "static void rcu_free_wq(struct rcu_head *rcu)\n{\n\tstruct workqueue_struct *wq =\n\t\tcontainer_of(rcu, struct workqueue_struct, rcu);\n\n\twq_free_lockdep(wq);\n\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tfree_percpu(wq->cpu_pwqs);\n\telse\n\t\tfree_workqueue_attrs(wq->unbound_attrs);\n\n\tkfree(wq);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq"
          ],
          "line": 3542
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "wq->unbound_attrs"
          ],
          "line": 3540
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3385-3391",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "wq->cpu_pwqs"
          ],
          "line": 3538
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_free_lockdep",
          "args": [
            "wq"
          ],
          "line": 3535
        },
        "resolved": true,
        "details": {
          "function_name": "wq_free_lockdep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3525-3527",
          "snippet": "static void wq_free_lockdep(struct workqueue_struct *wq)\n{\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_free_lockdep(struct workqueue_struct *wq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structworkqueue_struct",
            "rcu"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void rcu_free_wq(struct rcu_head *rcu)\n{\n\tstruct workqueue_struct *wq =\n\t\tcontainer_of(rcu, struct workqueue_struct, rcu);\n\n\twq_free_lockdep(wq);\n\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tfree_percpu(wq->cpu_pwqs);\n\telse\n\t\tfree_workqueue_attrs(wq->unbound_attrs);\n\n\tkfree(wq);\n}"
  },
  {
    "function_name": "wq_free_lockdep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3525-3527",
    "snippet": "static void wq_free_lockdep(struct workqueue_struct *wq)\n{\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_free_lockdep(struct workqueue_struct *wq)\n{\n}"
  },
  {
    "function_name": "wq_unregister_lockdep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3521-3523",
    "snippet": "static void wq_unregister_lockdep(struct workqueue_struct *wq)\n{\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_unregister_lockdep(struct workqueue_struct *wq)\n{\n}"
  },
  {
    "function_name": "wq_init_lockdep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3517-3519",
    "snippet": "static void wq_init_lockdep(struct workqueue_struct *wq)\n{\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_init_lockdep(struct workqueue_struct *wq)\n{\n}"
  },
  {
    "function_name": "wq_free_lockdep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3511-3515",
    "snippet": "static void wq_free_lockdep(struct workqueue_struct *wq)\n{\n\tif (wq->lock_name != wq->name)\n\t\tkfree(wq->lock_name);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq->lock_name"
          ],
          "line": 3514
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_free_lockdep(struct workqueue_struct *wq)\n{\n\tif (wq->lock_name != wq->name)\n\t\tkfree(wq->lock_name);\n}"
  },
  {
    "function_name": "wq_unregister_lockdep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3506-3509",
    "snippet": "static void wq_unregister_lockdep(struct workqueue_struct *wq)\n{\n\tlockdep_unregister_key(&wq->key);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_unregister_key",
          "args": [
            "&wq->key"
          ],
          "line": 3508
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_unregister_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6294-6328",
          "snippet": "void lockdep_unregister_key(struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head = keyhashentry(key);\n\tstruct lock_class_key *k;\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\tbool found = false;\n\n\tmight_sleep();\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tif (!graph_lock())\n\t\tgoto out_irq;\n\n\tpf = get_pending_free();\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (k == key) {\n\t\t\thlist_del_rcu(&k->hash_entry);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tWARN_ON_ONCE(!found);\n\t__lockdep_free_key_range(pf, key, 1);\n\tcall_rcu_zapped(pf);\n\tgraph_unlock();\nout_irq:\n\traw_local_irq_restore(flags);\n\n\t/* Wait until is_dynamic_key() has finished accessing k->hash_entry. */\n\tsynchronize_rcu();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;",
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic struct delayed_free {\n\tstruct rcu_head\t\trcu_head;\n\tint\t\t\tindex;\n\tint\t\t\tscheduled;\n\tstruct pending_free\tpf[2];\n} delayed_free;\nstatic noinstr struct;\n\nvoid lockdep_unregister_key(struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head = keyhashentry(key);\n\tstruct lock_class_key *k;\n\tstruct pending_free *pf;\n\tunsigned long flags;\n\tbool found = false;\n\n\tmight_sleep();\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tif (!graph_lock())\n\t\tgoto out_irq;\n\n\tpf = get_pending_free();\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (k == key) {\n\t\t\thlist_del_rcu(&k->hash_entry);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tWARN_ON_ONCE(!found);\n\t__lockdep_free_key_range(pf, key, 1);\n\tcall_rcu_zapped(pf);\n\tgraph_unlock();\nout_irq:\n\traw_local_irq_restore(flags);\n\n\t/* Wait until is_dynamic_key() has finished accessing k->hash_entry. */\n\tsynchronize_rcu();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_unregister_lockdep(struct workqueue_struct *wq)\n{\n\tlockdep_unregister_key(&wq->key);\n}"
  },
  {
    "function_name": "wq_init_lockdep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3493-3504",
    "snippet": "static void wq_init_lockdep(struct workqueue_struct *wq)\n{\n\tchar *lock_name;\n\n\tlockdep_register_key(&wq->key);\n\tlock_name = kasprintf(GFP_KERNEL, \"%s%s\", \"(wq_completion)\", wq->name);\n\tif (!lock_name)\n\t\tlock_name = wq->name;\n\n\twq->lock_name = lock_name;\n\tlockdep_init_map(&wq->lockdep_map, lock_name, &wq->key, 0);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&wq->lockdep_map",
            "lock_name",
            "&wq->key",
            "0"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s%s\"",
            "\"(wq_completion)\"",
            "wq->name"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_register_key",
          "args": [
            "&wq->key"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_register_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "1187-1209",
          "snippet": "void lockdep_register_key(struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head;\n\tstruct lock_class_key *k;\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn;\n\thash_head = keyhashentry(key);\n\n\traw_local_irq_save(flags);\n\tif (!graph_lock())\n\t\tgoto restore_irqs;\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (WARN_ON_ONCE(k == key))\n\t\t\tgoto out_unlock;\n\t}\n\thlist_add_head_rcu(&key->hash_entry, hash_head);\nout_unlock:\n\tgraph_unlock();\nrestore_irqs:\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid lockdep_register_key(struct lock_class_key *key)\n{\n\tstruct hlist_head *hash_head;\n\tstruct lock_class_key *k;\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(static_obj(key)))\n\t\treturn;\n\thash_head = keyhashentry(key);\n\n\traw_local_irq_save(flags);\n\tif (!graph_lock())\n\t\tgoto restore_irqs;\n\thlist_for_each_entry_rcu(k, hash_head, hash_entry) {\n\t\tif (WARN_ON_ONCE(k == key))\n\t\t\tgoto out_unlock;\n\t}\n\thlist_add_head_rcu(&key->hash_entry, hash_head);\nout_unlock:\n\tgraph_unlock();\nrestore_irqs:\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_init_lockdep(struct workqueue_struct *wq)\n{\n\tchar *lock_name;\n\n\tlockdep_register_key(&wq->key);\n\tlock_name = kasprintf(GFP_KERNEL, \"%s%s\", \"(wq_completion)\", wq->name);\n\tif (!lock_name)\n\t\tlock_name = wq->name;\n\n\twq->lock_name = lock_name;\n\tlockdep_init_map(&wq->lockdep_map, lock_name, &wq->key, 0);\n}"
  },
  {
    "function_name": "init_worker_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3463-3490",
    "snippet": "static int init_worker_pool(struct worker_pool *pool)\n{\n\traw_spin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs();\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [],
          "line": 3486
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3401-3416",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&pool->hash_node"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_init",
          "args": [
            "&pool->worker_ida"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pool->workers"
          ],
          "line": 3479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&pool->mayday_timer",
            "pool_mayday_timeout",
            "0"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&pool->idle_timer",
            "idle_worker_timeout",
            "TIMER_DEFERRABLE"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_init",
          "args": [
            "pool->busy_hash"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pool->idle_list"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pool->worklist"
          ],
          "line": 3471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&pool->lock"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int init_worker_pool(struct worker_pool *pool)\n{\n\traw_spin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs();\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "wqattrs_equal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3443-3451",
    "snippet": "static bool wqattrs_equal(const struct workqueue_attrs *a,\n\t\t\t  const struct workqueue_attrs *b)\n{\n\tif (a->nice != b->nice)\n\t\treturn false;\n\tif (!cpumask_equal(a->cpumask, b->cpumask))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "a->cpumask",
            "b->cpumask"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wqattrs_equal(const struct workqueue_attrs *a,\n\t\t\t  const struct workqueue_attrs *b)\n{\n\tif (a->nice != b->nice)\n\t\treturn false;\n\tif (!cpumask_equal(a->cpumask, b->cpumask))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "wqattrs_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3432-3440",
    "snippet": "static u32 wqattrs_hash(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = 0;\n\n\thash = jhash_1word(attrs->nice, hash);\n\thash = jhash(cpumask_bits(attrs->cpumask),\n\t\t     BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long), hash);\n\treturn hash;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "cpumask_bits(attrs->cpumask)",
            "BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long)",
            "hash"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "nr_cpumask_bits"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_bits",
          "args": [
            "attrs->cpumask"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhash_1word",
          "args": [
            "attrs->nice",
            "hash"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic u32 wqattrs_hash(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = 0;\n\n\thash = jhash_1word(attrs->nice, hash);\n\thash = jhash(cpumask_bits(attrs->cpumask),\n\t\t     BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long), hash);\n\treturn hash;\n}"
  },
  {
    "function_name": "copy_workqueue_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3418-3429",
    "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "to->cpumask",
            "from->cpumask"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
  },
  {
    "function_name": "alloc_workqueue_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3401-3416",
    "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "attrs"
          ],
          "line": 3414
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3385-3391",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "attrs->cpumask",
            "cpu_possible_mask"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&attrs->cpumask",
            "GFP_KERNEL"
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*attrs)",
            "GFP_KERNEL"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_workqueue_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3385-3391",
    "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "attrs"
          ],
          "line": 3389
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "attrs->cpumask"
          ],
          "line": 3388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
  },
  {
    "function_name": "execute_in_process_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3365-3376",
    "snippet": "int execute_in_process_context(work_func_t fn, struct execute_work *ew)\n{\n\tif (!in_interrupt()) {\n\t\tfn(&ew->work);\n\t\treturn 0;\n\t}\n\n\tINIT_WORK(&ew->work, fn);\n\tschedule_work(&ew->work);\n\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&ew->work"
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ew->work",
            "fn"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "&ew->work"
          ],
          "line": 3368
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_timer_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5838-5892",
          "snippet": "static void wq_watchdog_timer_fn(struct timer_list *unused)\n{\n\tunsigned long thresh = READ_ONCE(wq_watchdog_thresh) * HZ;\n\tbool lockup_detected = false;\n\tunsigned long now = jiffies;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\tif (!thresh)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tfor_each_pool(pool, pi) {\n\t\tunsigned long pool_ts, touched, ts;\n\n\t\tif (list_empty(&pool->worklist))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like a stall.\n\t\t */\n\t\tkvm_check_and_clear_guest_paused();\n\n\t\t/* get the latest of pool and touched timestamps */\n\t\tif (pool->cpu >= 0)\n\t\t\ttouched = READ_ONCE(per_cpu(wq_watchdog_touched_cpu, pool->cpu));\n\t\telse\n\t\t\ttouched = READ_ONCE(wq_watchdog_touched);\n\t\tpool_ts = READ_ONCE(pool->watchdog_ts);\n\n\t\tif (time_after(pool_ts, touched))\n\t\t\tts = pool_ts;\n\t\telse\n\t\t\tts = touched;\n\n\t\t/* did we stall? */\n\t\tif (time_after(now, ts + thresh)) {\n\t\t\tlockup_detected = true;\n\t\t\tpr_emerg(\"BUG: workqueue lockup - pool\");\n\t\t\tpr_cont_pool_info(pool);\n\t\t\tpr_cont(\" stuck for %us!\\n\",\n\t\t\t\tjiffies_to_msecs(now - pool_ts) / 1000);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (lockup_detected)\n\t\tshow_all_workqueues();\n\n\twq_watchdog_reset_touched();\n\tmod_timer(&wq_watchdog_timer, jiffies + thresh);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wq_watchdog_timer_fn(struct timer_list *unused)\n{\n\tunsigned long thresh = READ_ONCE(wq_watchdog_thresh) * HZ;\n\tbool lockup_detected = false;\n\tunsigned long now = jiffies;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\tif (!thresh)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tfor_each_pool(pool, pi) {\n\t\tunsigned long pool_ts, touched, ts;\n\n\t\tif (list_empty(&pool->worklist))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If a virtual machine is stopped by the host it can look to\n\t\t * the watchdog like a stall.\n\t\t */\n\t\tkvm_check_and_clear_guest_paused();\n\n\t\t/* get the latest of pool and touched timestamps */\n\t\tif (pool->cpu >= 0)\n\t\t\ttouched = READ_ONCE(per_cpu(wq_watchdog_touched_cpu, pool->cpu));\n\t\telse\n\t\t\ttouched = READ_ONCE(wq_watchdog_touched);\n\t\tpool_ts = READ_ONCE(pool->watchdog_ts);\n\n\t\tif (time_after(pool_ts, touched))\n\t\t\tts = pool_ts;\n\t\telse\n\t\t\tts = touched;\n\n\t\t/* did we stall? */\n\t\tif (time_after(now, ts + thresh)) {\n\t\t\tlockup_detected = true;\n\t\t\tpr_emerg(\"BUG: workqueue lockup - pool\");\n\t\t\tpr_cont_pool_info(pool);\n\t\t\tpr_cont(\" stuck for %us!\\n\",\n\t\t\t\tjiffies_to_msecs(now - pool_ts) / 1000);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (lockup_detected)\n\t\tshow_all_workqueues();\n\n\twq_watchdog_reset_touched();\n\tmod_timer(&wq_watchdog_timer, jiffies + thresh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint execute_in_process_context(work_func_t fn, struct execute_work *ew)\n{\n\tif (!in_interrupt()) {\n\t\tfn(&ew->work);\n\t\treturn 0;\n\t}\n\n\tINIT_WORK(&ew->work, fn);\n\tschedule_work(&ew->work);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "schedule_on_each_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3327-3351",
    "snippet": "int schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tcpus_read_unlock();\n\tfree_percpu(works);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "works"
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 3348
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work_on",
          "args": [
            "cpu",
            "work"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "work",
            "func"
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "works",
            "cpu"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 3336
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structwork_struct"
          ],
          "line": 3332
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tcpus_read_unlock();\n\tfree_percpu(works);\n\treturn 0;\n}"
  },
  {
    "function_name": "cancel_delayed_work_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3310-3313",
    "snippet": "bool cancel_delayed_work_sync(struct delayed_work *dwork)\n{\n\treturn __cancel_work_timer(&dwork->work, true);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cancel_work_timer",
          "args": [
            "&dwork->work",
            "true"
          ],
          "line": 3312
        },
        "resolved": true,
        "details": {
          "function_name": "__cancel_work_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3132-3194",
          "snippet": "static bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_delayed_work_sync(struct delayed_work *dwork)\n{\n\treturn __cancel_work_timer(&dwork->work, true);\n}"
  },
  {
    "function_name": "cancel_delayed_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3295-3298",
    "snippet": "bool cancel_delayed_work(struct delayed_work *dwork)\n{\n\treturn __cancel_work(&dwork->work, true);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cancel_work",
          "args": [
            "&dwork->work",
            "true"
          ],
          "line": 3297
        },
        "resolved": true,
        "details": {
          "function_name": "__cancel_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3262-3277",
          "snippet": "static bool __cancel_work(struct work_struct *work, bool is_dwork)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (unlikely(ret < 0))\n\t\treturn false;\n\n\tset_work_pool_and_clear_pending(work, get_work_pool_id(work));\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool __cancel_work(struct work_struct *work, bool is_dwork)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (unlikely(ret < 0))\n\t\treturn false;\n\n\tset_work_pool_and_clear_pending(work, get_work_pool_id(work));\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_delayed_work(struct delayed_work *dwork)\n{\n\treturn __cancel_work(&dwork->work, true);\n}"
  },
  {
    "function_name": "__cancel_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3262-3277",
    "snippet": "static bool __cancel_work(struct work_struct *work, bool is_dwork)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (unlikely(ret < 0))\n\t\treturn false;\n\n\tset_work_pool_and_clear_pending(work, get_work_pool_id(work));\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_work_pool_and_clear_pending",
          "args": [
            "work",
            "get_work_pool_id(work)"
          ],
          "line": 3274
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_pool_and_clear_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "648-688",
          "snippet": "static void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to queue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to queue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pool_id",
          "args": [
            "work"
          ],
          "line": 3274
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "746-755",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -EAGAIN"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_grab_pending",
          "args": [
            "work",
            "is_dwork",
            "&flags"
          ],
          "line": 3268
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_grab_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1268-1347",
          "snippet": "static int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\trcu_read_lock();\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\traw_spin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A cancelable inactive work item must be in the\n\t\t * pwq->inactive_works since a queued barrier can't be\n\t\t * canceled (see the comments in insert_wq_barrier()).\n\t\t *\n\t\t * An inactive work item cannot be grabbed directly because\n\t\t * it might have linked barrier work items which, if left\n\t\t * on the inactive_works list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_INACTIVE)\n\t\t\tpwq_activate_inactive_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, *work_data_bits(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\traw_spin_unlock(&pool->lock);\n\t\trcu_read_unlock();\n\t\treturn 1;\n\t}\n\traw_spin_unlock(&pool->lock);\nfail:\n\trcu_read_unlock();\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\trcu_read_lock();\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\traw_spin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A cancelable inactive work item must be in the\n\t\t * pwq->inactive_works since a queued barrier can't be\n\t\t * canceled (see the comments in insert_wq_barrier()).\n\t\t *\n\t\t * An inactive work item cannot be grabbed directly because\n\t\t * it might have linked barrier work items which, if left\n\t\t * on the inactive_works list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_INACTIVE)\n\t\t\tpwq_activate_inactive_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, *work_data_bits(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\traw_spin_unlock(&pool->lock);\n\t\trcu_read_unlock();\n\t\treturn 1;\n\t}\n\traw_spin_unlock(&pool->lock);\nfail:\n\trcu_read_unlock();\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool __cancel_work(struct work_struct *work, bool is_dwork)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (unlikely(ret < 0))\n\t\treturn false;\n\n\tset_work_pool_and_clear_pending(work, get_work_pool_id(work));\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "flush_rcu_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3250-3259",
    "snippet": "bool flush_rcu_work(struct rcu_work *rwork)\n{\n\tif (test_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&rwork->work))) {\n\t\trcu_barrier();\n\t\tflush_work(&rwork->work);\n\t\treturn true;\n\t} else {\n\t\treturn flush_work(&rwork->work);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&rwork->work"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3112-3115",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1569-1572",
          "snippet": "void rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid rcu_barrier_tasks_trace(void)\n{\n\trcu_barrier_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(&rwork->work)"
          ],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "&rwork->work"
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_rcu_work(struct rcu_work *rwork)\n{\n\tif (test_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&rwork->work))) {\n\t\trcu_barrier();\n\t\tflush_work(&rwork->work);\n\t\treturn true;\n\t} else {\n\t\treturn flush_work(&rwork->work);\n\t}\n}"
  },
  {
    "function_name": "flush_delayed_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3232-3239",
    "snippet": "bool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&dwork->work"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3112-3115",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_work",
          "args": [
            "dwork->cpu",
            "dwork->wq",
            "&dwork->work"
          ],
          "line": 3236
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1435-1539",
          "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&dwork->timer"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}"
  },
  {
    "function_name": "cancel_work_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3214-3217",
    "snippet": "bool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cancel_work_timer",
          "args": [
            "work",
            "false"
          ],
          "line": 3216
        },
        "resolved": true,
        "details": {
          "function_name": "__cancel_work_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3132-3194",
          "snippet": "static bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}"
  },
  {
    "function_name": "__cancel_work_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3132-3194",
    "snippet": "static bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_online;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up",
          "args": [
            "&cancel_waitq",
            "TASK_NORMAL",
            "1",
            "work"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_locked_key_bookmark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "176-180",
          "snippet": "void __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, bookmark);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, bookmark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&cancel_waitq"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_work_data",
          "args": [
            "work"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "clear_work_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "690-694",
          "snippet": "static void clear_work_data(struct work_struct *work)\n{\n\tsmp_wmb();\t/* see set_work_pool_and_clear_pending() */\n\tset_work_data(work, WORK_STRUCT_NO_POOL, 0);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void clear_work_data(struct work_struct *work)\n{\n\tsmp_wmb();\t/* see set_work_pool_and_clear_pending() */\n\tset_work_data(work, WORK_STRUCT_NO_POOL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__flush_work",
          "args": [
            "work",
            "true"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3077-3099",
          "snippet": "static bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (WARN_ON(!work->func))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (WARN_ON(!work->func))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_work_canceling",
          "args": [
            "work"
          ],
          "line": 3172
        },
        "resolved": true,
        "details": {
          "function_name": "mark_work_canceling",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "757-763",
          "snippet": "static void mark_work_canceling(struct work_struct *work)\n{\n\tunsigned long pool_id = get_work_pool_id(work);\n\n\tpool_id <<= WORK_OFFQ_POOL_SHIFT;\n\tset_work_data(work, pool_id | WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void mark_work_canceling(struct work_struct *work)\n{\n\tunsigned long pool_id = get_work_pool_id(work);\n\n\tpool_id <<= WORK_OFFQ_POOL_SHIFT;\n\tset_work_data(work, pool_id | WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&cancel_waitq",
            "&cwait.wait"
          ],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "finish_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "388-411",
          "snippet": "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 3166
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_is_canceling",
          "args": [
            "work"
          ],
          "line": 3165
        },
        "resolved": true,
        "details": {
          "function_name": "work_is_canceling",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "765-770",
          "snippet": "static bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait_exclusive",
          "args": [
            "&cancel_waitq",
            "&cwait.wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 3163
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_to_wait_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "275-290",
          "snippet": "bool\nprepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tbool was_empty = false;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry)) {\n\t\twas_empty = list_empty(&wq_head->head);\n\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t}\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\treturn was_empty;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool\nprepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tbool was_empty = false;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry)) {\n\t\twas_empty = list_empty(&wq_head->head);\n\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t}\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\treturn was_empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_wait",
          "args": [
            "&cwait.wait"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_waiter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_common.h",
          "lines": "190-197",
          "snippet": "static inline void rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tdebug_rt_mutex_init_waiter(waiter);\n\tRB_CLEAR_NODE(&waiter->pi_tree_entry);\n\tRB_CLEAR_NODE(&waiter->tree_entry);\n\twaiter->wake_state = TASK_NORMAL;\n\twaiter->task = NULL;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/rtmutex.h>\n#include <linux/debug_locks.h>\n\nstatic inline void rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tdebug_rt_mutex_init_waiter(waiter);\n\tRB_CLEAR_NODE(&waiter->pi_tree_entry);\n\tRB_CLEAR_NODE(&waiter->tree_entry);\n\twaiter->wake_state = TASK_NORMAL;\n\twaiter->task = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -ENOENT"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_grab_pending",
          "args": [
            "work",
            "is_dwork",
            "&flags"
          ],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_grab_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1268-1347",
          "snippet": "static int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\trcu_read_lock();\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\traw_spin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A cancelable inactive work item must be in the\n\t\t * pwq->inactive_works since a queued barrier can't be\n\t\t * canceled (see the comments in insert_wq_barrier()).\n\t\t *\n\t\t * An inactive work item cannot be grabbed directly because\n\t\t * it might have linked barrier work items which, if left\n\t\t * on the inactive_works list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_INACTIVE)\n\t\t\tpwq_activate_inactive_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, *work_data_bits(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\traw_spin_unlock(&pool->lock);\n\t\trcu_read_unlock();\n\t\treturn 1;\n\t}\n\traw_spin_unlock(&pool->lock);\nfail:\n\trcu_read_unlock();\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\trcu_read_lock();\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\traw_spin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A cancelable inactive work item must be in the\n\t\t * pwq->inactive_works since a queued barrier can't be\n\t\t * canceled (see the comments in insert_wq_barrier()).\n\t\t *\n\t\t * An inactive work item cannot be grabbed directly because\n\t\t * it might have linked barrier work items which, if left\n\t\t * on the inactive_works list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_INACTIVE)\n\t\t\tpwq_activate_inactive_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, *work_data_bits(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\traw_spin_unlock(&pool->lock);\n\t\trcu_read_unlock();\n\t\treturn 1;\n\t}\n\traw_spin_unlock(&pool->lock);\nfail:\n\trcu_read_unlock();\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cwt_wakefn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3123-3130",
    "snippet": "static int cwt_wakefn(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct cwt_wait *cwait = container_of(wait, struct cwt_wait, wait);\n\n\tif (cwait->work != key)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autoremove_wake_function",
          "args": [
            "wait",
            "mode",
            "sync",
            "key"
          ],
          "line": 3129
        },
        "resolved": true,
        "details": {
          "function_name": "autoremove_wake_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "414-422",
          "snippet": "int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init_careful(&wq_entry->entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init_careful(&wq_entry->entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structcwt_wait",
            "wait"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int cwt_wakefn(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct cwt_wait *cwait = container_of(wait, struct cwt_wait, wait);\n\n\tif (cwait->work != key)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}"
  },
  {
    "function_name": "flush_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3112-3115",
    "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__flush_work",
          "args": [
            "work",
            "false"
          ],
          "line": 3114
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3077-3099",
          "snippet": "static bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (WARN_ON(!work->func))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (WARN_ON(!work->func))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
  },
  {
    "function_name": "__flush_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3077-3099",
    "snippet": "static bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (WARN_ON(!work->func))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_online;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_work_on_stack",
          "args": [
            "&barr.work"
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_work_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "522-525",
          "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&barr.done"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_flush_work",
          "args": [
            "work",
            "&barr",
            "from_cancel"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "start_flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3021-3075",
          "snippet": "static bool start_flush_work(struct work_struct *work, struct wq_barrier *barr,\n\t\t\t     bool from_cancel)\n{\n\tstruct worker *worker = NULL;\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tmight_sleep();\n\n\trcu_read_lock();\n\tpool = get_work_pool(work);\n\tif (!pool) {\n\t\trcu_read_unlock();\n\t\treturn false;\n\t}\n\n\traw_spin_lock_irq(&pool->lock);\n\t/* see the comment in try_to_grab_pending() with the same code */\n\tpwq = get_work_pwq(work);\n\tif (pwq) {\n\t\tif (unlikely(pwq->pool != pool))\n\t\t\tgoto already_gone;\n\t} else {\n\t\tworker = find_worker_executing_work(pool, work);\n\t\tif (!worker)\n\t\t\tgoto already_gone;\n\t\tpwq = worker->current_pwq;\n\t}\n\n\tcheck_flush_dependency(pwq->wq, work);\n\n\tinsert_wq_barrier(pwq, barr, work, worker);\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/*\n\t * Force a lock recursion deadlock when using flush_work() inside a\n\t * single-threaded or rescuer equipped workqueue.\n\t *\n\t * For single threaded workqueues the deadlock happens when the work\n\t * is after the work issuing the flush_work(). For rescuer equipped\n\t * workqueues the deadlock happens when the rescuer stalls, blocking\n\t * forward progress.\n\t */\n\tif (!from_cancel &&\n\t    (pwq->wq->saved_max_active == 1 || pwq->wq->rescuer)) {\n\t\tlock_map_acquire(&pwq->wq->lockdep_map);\n\t\tlock_map_release(&pwq->wq->lockdep_map);\n\t}\n\trcu_read_unlock();\n\treturn true;\nalready_gone:\n\traw_spin_unlock_irq(&pool->lock);\n\trcu_read_unlock();\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool start_flush_work(struct work_struct *work, struct wq_barrier *barr,\n\t\t\t     bool from_cancel)\n{\n\tstruct worker *worker = NULL;\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tmight_sleep();\n\n\trcu_read_lock();\n\tpool = get_work_pool(work);\n\tif (!pool) {\n\t\trcu_read_unlock();\n\t\treturn false;\n\t}\n\n\traw_spin_lock_irq(&pool->lock);\n\t/* see the comment in try_to_grab_pending() with the same code */\n\tpwq = get_work_pwq(work);\n\tif (pwq) {\n\t\tif (unlikely(pwq->pool != pool))\n\t\t\tgoto already_gone;\n\t} else {\n\t\tworker = find_worker_executing_work(pool, work);\n\t\tif (!worker)\n\t\t\tgoto already_gone;\n\t\tpwq = worker->current_pwq;\n\t}\n\n\tcheck_flush_dependency(pwq->wq, work);\n\n\tinsert_wq_barrier(pwq, barr, work, worker);\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/*\n\t * Force a lock recursion deadlock when using flush_work() inside a\n\t * single-threaded or rescuer equipped workqueue.\n\t *\n\t * For single threaded workqueues the deadlock happens when the work\n\t * is after the work issuing the flush_work(). For rescuer equipped\n\t * workqueues the deadlock happens when the rescuer stalls, blocking\n\t * forward progress.\n\t */\n\tif (!from_cancel &&\n\t    (pwq->wq->saved_max_active == 1 || pwq->wq->rescuer)) {\n\t\tlock_map_acquire(&pwq->wq->lockdep_map);\n\t\tlock_map_release(&pwq->wq->lockdep_map);\n\t}\n\trcu_read_unlock();\n\treturn true;\nalready_gone:\n\traw_spin_unlock_irq(&pool->lock);\n\trcu_read_unlock();\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&work->lockdep_map"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&work->lockdep_map"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!work->func"
          ],
          "line": 3084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!wq_online"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (WARN_ON(!work->func))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "start_flush_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "3021-3075",
    "snippet": "static bool start_flush_work(struct work_struct *work, struct wq_barrier *barr,\n\t\t\t     bool from_cancel)\n{\n\tstruct worker *worker = NULL;\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tmight_sleep();\n\n\trcu_read_lock();\n\tpool = get_work_pool(work);\n\tif (!pool) {\n\t\trcu_read_unlock();\n\t\treturn false;\n\t}\n\n\traw_spin_lock_irq(&pool->lock);\n\t/* see the comment in try_to_grab_pending() with the same code */\n\tpwq = get_work_pwq(work);\n\tif (pwq) {\n\t\tif (unlikely(pwq->pool != pool))\n\t\t\tgoto already_gone;\n\t} else {\n\t\tworker = find_worker_executing_work(pool, work);\n\t\tif (!worker)\n\t\t\tgoto already_gone;\n\t\tpwq = worker->current_pwq;\n\t}\n\n\tcheck_flush_dependency(pwq->wq, work);\n\n\tinsert_wq_barrier(pwq, barr, work, worker);\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/*\n\t * Force a lock recursion deadlock when using flush_work() inside a\n\t * single-threaded or rescuer equipped workqueue.\n\t *\n\t * For single threaded workqueues the deadlock happens when the work\n\t * is after the work issuing the flush_work(). For rescuer equipped\n\t * workqueues the deadlock happens when the rescuer stalls, blocking\n\t * forward progress.\n\t */\n\tif (!from_cancel &&\n\t    (pwq->wq->saved_max_active == 1 || pwq->wq->rescuer)) {\n\t\tlock_map_acquire(&pwq->wq->lockdep_map);\n\t\tlock_map_release(&pwq->wq->lockdep_map);\n\t}\n\trcu_read_unlock();\n\treturn true;\nalready_gone:\n\traw_spin_unlock_irq(&pool->lock);\n\trcu_read_unlock();\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3073
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&pwq->wq->lockdep_map"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&pwq->wq->lockdep_map"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_wq_barrier",
          "args": [
            "pwq",
            "barr",
            "work",
            "worker"
          ],
          "line": 3052
        },
        "resolved": true,
        "details": {
          "function_name": "insert_wq_barrier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2689-2735",
          "snippet": "static void insert_wq_barrier(struct pool_workqueue *pwq,\n\t\t\t      struct wq_barrier *barr,\n\t\t\t      struct work_struct *target, struct worker *worker)\n{\n\tunsigned int work_flags = 0;\n\tunsigned int work_color;\n\tstruct list_head *head;\n\n\t/*\n\t * debugobject calls are safe here even with pool->lock locked\n\t * as we know for sure that this will not trigger any of the\n\t * checks and call back into the fixup functions where we\n\t * might deadlock.\n\t */\n\tINIT_WORK_ONSTACK(&barr->work, wq_barrier_func);\n\t__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&barr->work));\n\n\tinit_completion_map(&barr->done, &target->lockdep_map);\n\n\tbarr->task = current;\n\n\t/* The barrier work item does not participate in pwq->nr_active. */\n\twork_flags |= WORK_STRUCT_INACTIVE;\n\n\t/*\n\t * If @target is currently being executed, schedule the\n\t * barrier to the worker; otherwise, put it after @target.\n\t */\n\tif (worker) {\n\t\thead = worker->scheduled.next;\n\t\twork_color = worker->current_color;\n\t} else {\n\t\tunsigned long *bits = work_data_bits(target);\n\n\t\thead = target->entry.next;\n\t\t/* there can already be other linked works, inherit and set */\n\t\twork_flags |= *bits & WORK_STRUCT_LINKED;\n\t\twork_color = get_work_color(*bits);\n\t\t__set_bit(WORK_STRUCT_LINKED_BIT, bits);\n\t}\n\n\tpwq->nr_in_flight[work_color]++;\n\twork_flags |= work_color_to_flags(work_color);\n\n\tdebug_work_activate(&barr->work);\n\tinsert_work(pwq, &barr->work, head, work_flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void insert_wq_barrier(struct pool_workqueue *pwq,\n\t\t\t      struct wq_barrier *barr,\n\t\t\t      struct work_struct *target, struct worker *worker)\n{\n\tunsigned int work_flags = 0;\n\tunsigned int work_color;\n\tstruct list_head *head;\n\n\t/*\n\t * debugobject calls are safe here even with pool->lock locked\n\t * as we know for sure that this will not trigger any of the\n\t * checks and call back into the fixup functions where we\n\t * might deadlock.\n\t */\n\tINIT_WORK_ONSTACK(&barr->work, wq_barrier_func);\n\t__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&barr->work));\n\n\tinit_completion_map(&barr->done, &target->lockdep_map);\n\n\tbarr->task = current;\n\n\t/* The barrier work item does not participate in pwq->nr_active. */\n\twork_flags |= WORK_STRUCT_INACTIVE;\n\n\t/*\n\t * If @target is currently being executed, schedule the\n\t * barrier to the worker; otherwise, put it after @target.\n\t */\n\tif (worker) {\n\t\thead = worker->scheduled.next;\n\t\twork_color = worker->current_color;\n\t} else {\n\t\tunsigned long *bits = work_data_bits(target);\n\n\t\thead = target->entry.next;\n\t\t/* there can already be other linked works, inherit and set */\n\t\twork_flags |= *bits & WORK_STRUCT_LINKED;\n\t\twork_color = get_work_color(*bits);\n\t\t__set_bit(WORK_STRUCT_LINKED_BIT, bits);\n\t}\n\n\tpwq->nr_in_flight[work_color]++;\n\twork_flags |= work_color_to_flags(work_color);\n\n\tdebug_work_activate(&barr->work);\n\tinsert_work(pwq, &barr->work, head, work_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flush_dependency",
          "args": [
            "pwq->wq",
            "work"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "check_flush_dependency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2632-2651",
          "snippet": "static void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%ps is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%ps is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_worker_executing_work",
          "args": [
            "pool",
            "work"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "find_worker_executing_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1058-1070",
          "snippet": "static struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pwq->pool != pool"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 3039
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "696-704",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 3037
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pool",
          "args": [
            "work"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "746-755",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool start_flush_work(struct work_struct *work, struct wq_barrier *barr,\n\t\t\t     bool from_cancel)\n{\n\tstruct worker *worker = NULL;\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tmight_sleep();\n\n\trcu_read_lock();\n\tpool = get_work_pool(work);\n\tif (!pool) {\n\t\trcu_read_unlock();\n\t\treturn false;\n\t}\n\n\traw_spin_lock_irq(&pool->lock);\n\t/* see the comment in try_to_grab_pending() with the same code */\n\tpwq = get_work_pwq(work);\n\tif (pwq) {\n\t\tif (unlikely(pwq->pool != pool))\n\t\t\tgoto already_gone;\n\t} else {\n\t\tworker = find_worker_executing_work(pool, work);\n\t\tif (!worker)\n\t\t\tgoto already_gone;\n\t\tpwq = worker->current_pwq;\n\t}\n\n\tcheck_flush_dependency(pwq->wq, work);\n\n\tinsert_wq_barrier(pwq, barr, work, worker);\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/*\n\t * Force a lock recursion deadlock when using flush_work() inside a\n\t * single-threaded or rescuer equipped workqueue.\n\t *\n\t * For single threaded workqueues the deadlock happens when the work\n\t * is after the work issuing the flush_work(). For rescuer equipped\n\t * workqueues the deadlock happens when the rescuer stalls, blocking\n\t * forward progress.\n\t */\n\tif (!from_cancel &&\n\t    (pwq->wq->saved_max_active == 1 || pwq->wq->rescuer)) {\n\t\tlock_map_acquire(&pwq->wq->lockdep_map);\n\t\tlock_map_release(&pwq->wq->lockdep_map);\n\t}\n\trcu_read_unlock();\n\treturn true;\nalready_gone:\n\traw_spin_unlock_irq(&pool->lock);\n\trcu_read_unlock();\n\treturn false;\n}"
  },
  {
    "function_name": "drain_workqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2977-3018",
    "snippet": "void drain_workqueue(struct workqueue_struct *wq)\n{\n\tunsigned int flush_cnt = 0;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * __queue_work() needs to test whether there are drainers, is much\n\t * hotter than drain_workqueue() and already looks at @wq->flags.\n\t * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.\n\t */\n\tmutex_lock(&wq->mutex);\n\tif (!wq->nr_drainers++)\n\t\twq->flags |= __WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\nreflush:\n\tflush_workqueue(wq);\n\n\tmutex_lock(&wq->mutex);\n\n\tfor_each_pwq(pwq, wq) {\n\t\tbool drained;\n\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tdrained = !pwq->nr_active && list_empty(&pwq->inactive_works);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\n\t\tif (drained)\n\t\t\tcontinue;\n\n\t\tif (++flush_cnt == 10 ||\n\t\t    (flush_cnt % 100 == 0 && flush_cnt <= 1000))\n\t\t\tpr_warn(\"workqueue %s: %s() isn't complete after %u tries\\n\",\n\t\t\t\twq->name, __func__, flush_cnt);\n\n\t\tmutex_unlock(&wq->mutex);\n\t\tgoto reflush;\n\t}\n\n\tif (!--wq->nr_drainers)\n\t\twq->flags &= ~__WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"workqueue %s: %s() isn't complete after %u tries\\n\"",
            "wq->name",
            "__func__",
            "flush_cnt"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->inactive_works"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "wq"
          ],
          "line": 2992
        },
        "resolved": true,
        "details": {
          "function_name": "flush_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2815-2963",
          "snippet": "void flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid drain_workqueue(struct workqueue_struct *wq)\n{\n\tunsigned int flush_cnt = 0;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * __queue_work() needs to test whether there are drainers, is much\n\t * hotter than drain_workqueue() and already looks at @wq->flags.\n\t * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.\n\t */\n\tmutex_lock(&wq->mutex);\n\tif (!wq->nr_drainers++)\n\t\twq->flags |= __WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\nreflush:\n\tflush_workqueue(wq);\n\n\tmutex_lock(&wq->mutex);\n\n\tfor_each_pwq(pwq, wq) {\n\t\tbool drained;\n\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tdrained = !pwq->nr_active && list_empty(&pwq->inactive_works);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\n\t\tif (drained)\n\t\t\tcontinue;\n\n\t\tif (++flush_cnt == 10 ||\n\t\t    (flush_cnt % 100 == 0 && flush_cnt <= 1000))\n\t\t\tpr_warn(\"workqueue %s: %s() isn't complete after %u tries\\n\",\n\t\t\t\twq->name, __func__, flush_cnt);\n\n\t\tmutex_unlock(&wq->mutex);\n\t\tgoto reflush;\n\t}\n\n\tif (!--wq->nr_drainers)\n\t\twq->flags &= ~__WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\n}"
  },
  {
    "function_name": "flush_workqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2815-2963",
    "snippet": "void flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_online;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue_prep_pwqs",
          "args": [
            "wq",
            "wq->flush_color",
            "-1"
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "flush_workqueue_prep_pwqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2768-2806",
          "snippet": "static bool flush_workqueue_prep_pwqs(struct workqueue_struct *wq,\n\t\t\t\t      int flush_color, int work_color)\n{\n\tbool wait = false;\n\tstruct pool_workqueue *pwq;\n\n\tif (flush_color >= 0) {\n\t\tWARN_ON_ONCE(atomic_read(&wq->nr_pwqs_to_flush));\n\t\tatomic_set(&wq->nr_pwqs_to_flush, 1);\n\t}\n\n\tfor_each_pwq(pwq, wq) {\n\t\tstruct worker_pool *pool = pwq->pool;\n\n\t\traw_spin_lock_irq(&pool->lock);\n\n\t\tif (flush_color >= 0) {\n\t\t\tWARN_ON_ONCE(pwq->flush_color != -1);\n\n\t\t\tif (pwq->nr_in_flight[flush_color]) {\n\t\t\t\tpwq->flush_color = flush_color;\n\t\t\t\tatomic_inc(&wq->nr_pwqs_to_flush);\n\t\t\t\twait = true;\n\t\t\t}\n\t\t}\n\n\t\tif (work_color >= 0) {\n\t\t\tWARN_ON_ONCE(work_color != work_next_color(pwq->work_color));\n\t\t\tpwq->work_color = work_color;\n\t\t}\n\n\t\traw_spin_unlock_irq(&pool->lock);\n\t}\n\n\tif (flush_color >= 0 && atomic_dec_and_test(&wq->nr_pwqs_to_flush))\n\t\tcomplete(&wq->first_flusher->done);\n\n\treturn wait;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool flush_workqueue_prep_pwqs(struct workqueue_struct *wq,\n\t\t\t\t      int flush_color, int work_color)\n{\n\tbool wait = false;\n\tstruct pool_workqueue *pwq;\n\n\tif (flush_color >= 0) {\n\t\tWARN_ON_ONCE(atomic_read(&wq->nr_pwqs_to_flush));\n\t\tatomic_set(&wq->nr_pwqs_to_flush, 1);\n\t}\n\n\tfor_each_pwq(pwq, wq) {\n\t\tstruct worker_pool *pool = pwq->pool;\n\n\t\traw_spin_lock_irq(&pool->lock);\n\n\t\tif (flush_color >= 0) {\n\t\t\tWARN_ON_ONCE(pwq->flush_color != -1);\n\n\t\t\tif (pwq->nr_in_flight[flush_color]) {\n\t\t\t\tpwq->flush_color = flush_color;\n\t\t\t\tatomic_inc(&wq->nr_pwqs_to_flush);\n\t\t\t\twait = true;\n\t\t\t}\n\t\t}\n\n\t\tif (work_color >= 0) {\n\t\t\tWARN_ON_ONCE(work_color != work_next_color(pwq->work_color));\n\t\t\tpwq->work_color = work_color;\n\t\t}\n\n\t\traw_spin_unlock_irq(&pool->lock);\n\t}\n\n\tif (flush_color >= 0 && atomic_dec_and_test(&wq->nr_pwqs_to_flush))\n\t\tcomplete(&wq->first_flusher->done);\n\n\treturn wait;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&next->list"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color != next->flush_color"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color == wq->work_color"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color != wq->work_color"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq->flusher_queue"
          ],
          "line": 2936
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&wq->flusher_overflow",
            "&wq->flusher_queue"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_next_color",
          "args": [
            "wq->work_color"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "work_next_color",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "602-605",
          "snippet": "static int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&wq->flusher_overflow",
            "list"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color)"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&next->done"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&next->list"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "next",
            "tmp",
            "&wq->flusher_queue",
            "list"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color != this_flusher.flush_color"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&this_flusher.list)"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "wq->first_flusher",
            "NULL"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "wq->first_flusher"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&this_flusher.done"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flush_dependency",
          "args": [
            "wq",
            "NULL"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "check_flush_dependency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2632-2651",
          "snippet": "static void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%ps is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%ps is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&this_flusher.list",
            "&wq->flusher_overflow"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&this_flusher.list",
            "&wq->flusher_queue"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color == this_flusher.flush_color"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color != this_flusher.flush_color"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&wq->flusher_overflow)"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&wq->lockdep_map"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&wq->lockdep_map"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!wq_online"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPLETION_INITIALIZER_ONSTACK_MAP",
          "args": [
            "this_flusher.done",
            "wq->lockdep_map"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD_INIT",
          "args": [
            "this_flusher.list"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}"
  },
  {
    "function_name": "flush_workqueue_prep_pwqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2768-2806",
    "snippet": "static bool flush_workqueue_prep_pwqs(struct workqueue_struct *wq,\n\t\t\t\t      int flush_color, int work_color)\n{\n\tbool wait = false;\n\tstruct pool_workqueue *pwq;\n\n\tif (flush_color >= 0) {\n\t\tWARN_ON_ONCE(atomic_read(&wq->nr_pwqs_to_flush));\n\t\tatomic_set(&wq->nr_pwqs_to_flush, 1);\n\t}\n\n\tfor_each_pwq(pwq, wq) {\n\t\tstruct worker_pool *pool = pwq->pool;\n\n\t\traw_spin_lock_irq(&pool->lock);\n\n\t\tif (flush_color >= 0) {\n\t\t\tWARN_ON_ONCE(pwq->flush_color != -1);\n\n\t\t\tif (pwq->nr_in_flight[flush_color]) {\n\t\t\t\tpwq->flush_color = flush_color;\n\t\t\t\tatomic_inc(&wq->nr_pwqs_to_flush);\n\t\t\t\twait = true;\n\t\t\t}\n\t\t}\n\n\t\tif (work_color >= 0) {\n\t\t\tWARN_ON_ONCE(work_color != work_next_color(pwq->work_color));\n\t\t\tpwq->work_color = work_color;\n\t\t}\n\n\t\traw_spin_unlock_irq(&pool->lock);\n\t}\n\n\tif (flush_color >= 0 && atomic_dec_and_test(&wq->nr_pwqs_to_flush))\n\t\tcomplete(&wq->first_flusher->done);\n\n\treturn wait;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&wq->first_flusher->done"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&wq->nr_pwqs_to_flush"
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "work_color != work_next_color(pwq->work_color)"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_next_color",
          "args": [
            "pwq->work_color"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "work_next_color",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "602-605",
          "snippet": "static int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&wq->nr_pwqs_to_flush"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pwq->flush_color != -1"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&wq->nr_pwqs_to_flush",
            "1"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&wq->nr_pwqs_to_flush)"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&wq->nr_pwqs_to_flush"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool flush_workqueue_prep_pwqs(struct workqueue_struct *wq,\n\t\t\t\t      int flush_color, int work_color)\n{\n\tbool wait = false;\n\tstruct pool_workqueue *pwq;\n\n\tif (flush_color >= 0) {\n\t\tWARN_ON_ONCE(atomic_read(&wq->nr_pwqs_to_flush));\n\t\tatomic_set(&wq->nr_pwqs_to_flush, 1);\n\t}\n\n\tfor_each_pwq(pwq, wq) {\n\t\tstruct worker_pool *pool = pwq->pool;\n\n\t\traw_spin_lock_irq(&pool->lock);\n\n\t\tif (flush_color >= 0) {\n\t\t\tWARN_ON_ONCE(pwq->flush_color != -1);\n\n\t\t\tif (pwq->nr_in_flight[flush_color]) {\n\t\t\t\tpwq->flush_color = flush_color;\n\t\t\t\tatomic_inc(&wq->nr_pwqs_to_flush);\n\t\t\t\twait = true;\n\t\t\t}\n\t\t}\n\n\t\tif (work_color >= 0) {\n\t\t\tWARN_ON_ONCE(work_color != work_next_color(pwq->work_color));\n\t\t\tpwq->work_color = work_color;\n\t\t}\n\n\t\traw_spin_unlock_irq(&pool->lock);\n\t}\n\n\tif (flush_color >= 0 && atomic_dec_and_test(&wq->nr_pwqs_to_flush))\n\t\tcomplete(&wq->first_flusher->done);\n\n\treturn wait;\n}"
  },
  {
    "function_name": "insert_wq_barrier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2689-2735",
    "snippet": "static void insert_wq_barrier(struct pool_workqueue *pwq,\n\t\t\t      struct wq_barrier *barr,\n\t\t\t      struct work_struct *target, struct worker *worker)\n{\n\tunsigned int work_flags = 0;\n\tunsigned int work_color;\n\tstruct list_head *head;\n\n\t/*\n\t * debugobject calls are safe here even with pool->lock locked\n\t * as we know for sure that this will not trigger any of the\n\t * checks and call back into the fixup functions where we\n\t * might deadlock.\n\t */\n\tINIT_WORK_ONSTACK(&barr->work, wq_barrier_func);\n\t__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&barr->work));\n\n\tinit_completion_map(&barr->done, &target->lockdep_map);\n\n\tbarr->task = current;\n\n\t/* The barrier work item does not participate in pwq->nr_active. */\n\twork_flags |= WORK_STRUCT_INACTIVE;\n\n\t/*\n\t * If @target is currently being executed, schedule the\n\t * barrier to the worker; otherwise, put it after @target.\n\t */\n\tif (worker) {\n\t\thead = worker->scheduled.next;\n\t\twork_color = worker->current_color;\n\t} else {\n\t\tunsigned long *bits = work_data_bits(target);\n\n\t\thead = target->entry.next;\n\t\t/* there can already be other linked works, inherit and set */\n\t\twork_flags |= *bits & WORK_STRUCT_LINKED;\n\t\twork_color = get_work_color(*bits);\n\t\t__set_bit(WORK_STRUCT_LINKED_BIT, bits);\n\t}\n\n\tpwq->nr_in_flight[work_color]++;\n\twork_flags |= work_color_to_flags(work_color);\n\n\tdebug_work_activate(&barr->work);\n\tinsert_work(pwq, &barr->work, head, work_flags);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_work",
          "args": [
            "pwq",
            "&barr->work",
            "head",
            "work_flags"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "insert_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1362-1384",
          "snippet": "static void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack_noalloc(work);\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack_noalloc(work);\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_work_activate",
          "args": [
            "&barr->work"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "debug_work_activate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "536-536",
          "snippet": "static inline void debug_work_activate(struct work_struct *work) { }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_activate(struct work_struct *work) { }"
        }
      },
      {
        "call_info": {
          "callee": "work_color_to_flags",
          "args": [
            "work_color"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "work_color_to_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "591-594",
          "snippet": "static unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "WORK_STRUCT_LINKED_BIT",
            "bits"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_color",
          "args": [
            "*bits"
          ],
          "line": 2726
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_color",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "596-600",
          "snippet": "static int get_work_color(unsigned long work_data)\n{\n\treturn (work_data >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_color(unsigned long work_data)\n{\n\treturn (work_data >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "target"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion_map",
          "args": [
            "&barr->done",
            "&target->lockdep_map"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(&barr->work)"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "&barr->work"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&barr->work",
            "wq_barrier_func"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void insert_wq_barrier(struct pool_workqueue *pwq,\n\t\t\t      struct wq_barrier *barr,\n\t\t\t      struct work_struct *target, struct worker *worker)\n{\n\tunsigned int work_flags = 0;\n\tunsigned int work_color;\n\tstruct list_head *head;\n\n\t/*\n\t * debugobject calls are safe here even with pool->lock locked\n\t * as we know for sure that this will not trigger any of the\n\t * checks and call back into the fixup functions where we\n\t * might deadlock.\n\t */\n\tINIT_WORK_ONSTACK(&barr->work, wq_barrier_func);\n\t__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&barr->work));\n\n\tinit_completion_map(&barr->done, &target->lockdep_map);\n\n\tbarr->task = current;\n\n\t/* The barrier work item does not participate in pwq->nr_active. */\n\twork_flags |= WORK_STRUCT_INACTIVE;\n\n\t/*\n\t * If @target is currently being executed, schedule the\n\t * barrier to the worker; otherwise, put it after @target.\n\t */\n\tif (worker) {\n\t\thead = worker->scheduled.next;\n\t\twork_color = worker->current_color;\n\t} else {\n\t\tunsigned long *bits = work_data_bits(target);\n\n\t\thead = target->entry.next;\n\t\t/* there can already be other linked works, inherit and set */\n\t\twork_flags |= *bits & WORK_STRUCT_LINKED;\n\t\twork_color = get_work_color(*bits);\n\t\t__set_bit(WORK_STRUCT_LINKED_BIT, bits);\n\t}\n\n\tpwq->nr_in_flight[work_color]++;\n\twork_flags |= work_color_to_flags(work_color);\n\n\tdebug_work_activate(&barr->work);\n\tinsert_work(pwq, &barr->work, head, work_flags);\n}"
  },
  {
    "function_name": "wq_barrier_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2659-2663",
    "snippet": "static void wq_barrier_func(struct work_struct *work)\n{\n\tstruct wq_barrier *barr = container_of(work, struct wq_barrier, work);\n\tcomplete(&barr->done);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&barr->done"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structwq_barrier",
            "work"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_barrier_func(struct work_struct *work)\n{\n\tstruct wq_barrier *barr = container_of(work, struct wq_barrier, work);\n\tcomplete(&barr->done);\n}"
  },
  {
    "function_name": "check_flush_dependency",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2632-2651",
    "snippet": "static void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%ps is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM)",
            "\"workqueue: WQ_MEM_RECLAIM %s:%ps is flushing !WQ_MEM_RECLAIM %s:%ps\"",
            "worker->current_pwq->wq->name",
            "worker->current_func",
            "target_wq->name",
            "target_func"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "current->flags & PF_MEMALLOC",
            "\"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%ps\"",
            "current->pid",
            "current->comm",
            "target_wq->name",
            "target_func"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue_internal.h",
          "lines": "66-71",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%ps is flushing !WQ_MEM_RECLAIM %s:%ps\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}"
  },
  {
    "function_name": "rescuer_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2500-2619",
    "snippet": "static int rescuer_thread(void *__rescuer)\n{\n\tstruct worker *rescuer = __rescuer;\n\tstruct workqueue_struct *wq = rescuer->rescue_wq;\n\tstruct list_head *scheduled = &rescuer->scheduled;\n\tbool should_stop;\n\n\tset_user_nice(current, RESCUER_NICE_LEVEL);\n\n\t/*\n\t * Mark rescuer as worker too.  As WORKER_PREP is never cleared, it\n\t * doesn't participate in concurrency management.\n\t */\n\tset_pf_worker(true);\nrepeat:\n\tset_current_state(TASK_IDLE);\n\n\t/*\n\t * By the time the rescuer is requested to stop, the workqueue\n\t * shouldn't have any work pending, but @wq->maydays may still have\n\t * pwq(s) queued.  This can happen by non-rescuer workers consuming\n\t * all the work items before the rescuer got to them.  Go through\n\t * @wq->maydays processing before acting on should_stop so that the\n\t * list is always empty on exit.\n\t */\n\tshould_stop = kthread_should_stop();\n\n\t/* see whether any pwq is asking for help */\n\traw_spin_lock_irq(&wq_mayday_lock);\n\n\twhile (!list_empty(&wq->maydays)) {\n\t\tstruct pool_workqueue *pwq = list_first_entry(&wq->maydays,\n\t\t\t\t\tstruct pool_workqueue, mayday_node);\n\t\tstruct worker_pool *pool = pwq->pool;\n\t\tstruct work_struct *work, *n;\n\t\tbool first = true;\n\n\t\t__set_current_state(TASK_RUNNING);\n\t\tlist_del_init(&pwq->mayday_node);\n\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\tworker_attach_to_pool(rescuer, pool);\n\n\t\traw_spin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * Slurp in all works issued via this workqueue and\n\t\t * process'em.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(scheduled));\n\t\tlist_for_each_entry_safe(work, n, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) == pwq) {\n\t\t\t\tif (first)\n\t\t\t\t\tpool->watchdog_ts = jiffies;\n\t\t\t\tmove_linked_works(work, scheduled, &n);\n\t\t\t}\n\t\t\tfirst = false;\n\t\t}\n\n\t\tif (!list_empty(scheduled)) {\n\t\t\tprocess_scheduled_works(rescuer);\n\n\t\t\t/*\n\t\t\t * The above execution of rescued work items could\n\t\t\t * have created more to rescue through\n\t\t\t * pwq_activate_first_inactive() or chained\n\t\t\t * queueing.  Let's put @pwq back on mayday list so\n\t\t\t * that such back-to-back work items, which may be\n\t\t\t * being used to relieve memory pressure, don't\n\t\t\t * incur MAYDAY_INTERVAL delay inbetween.\n\t\t\t */\n\t\t\tif (pwq->nr_active && need_to_create_worker(pool)) {\n\t\t\t\traw_spin_lock(&wq_mayday_lock);\n\t\t\t\t/*\n\t\t\t\t * Queue iff we aren't racing destruction\n\t\t\t\t * and somebody else hasn't queued it already.\n\t\t\t\t */\n\t\t\t\tif (wq->rescuer && list_empty(&pwq->mayday_node)) {\n\t\t\t\t\tget_pwq(pwq);\n\t\t\t\t\tlist_add_tail(&pwq->mayday_node, &wq->maydays);\n\t\t\t\t}\n\t\t\t\traw_spin_unlock(&wq_mayday_lock);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Put the reference grabbed by send_mayday().  @pool won't\n\t\t * go away while we're still attached to it.\n\t\t */\n\t\tput_pwq(pwq);\n\n\t\t/*\n\t\t * Leave this pool.  If need_more_worker() is %true, notify a\n\t\t * regular worker; otherwise, we end up with 0 concurrency\n\t\t * and stalling the execution.\n\t\t */\n\t\tif (need_more_worker(pool))\n\t\t\twake_up_worker(pool);\n\n\t\traw_spin_unlock_irq(&pool->lock);\n\n\t\tworker_detach_from_pool(rescuer);\n\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t}\n\n\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\tif (should_stop) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\tset_pf_worker(false);\n\t\treturn 0;\n\t}\n\n\t/* rescuers should never participate in concurrency management */\n\tWARN_ON_ONCE(!(rescuer->flags & WORKER_NOT_RUNNING));\n\tschedule();\n\tgoto repeat;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(wq_mayday_lock);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(rescuer->flags & WORKER_NOT_RUNNING)"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pf_worker",
          "args": [
            "false"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "set_pf_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2374-2382",
          "snippet": "static void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\n\nstatic void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 2607
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_detach_from_pool",
          "args": [
            "rescuer"
          ],
          "line": 2602
        },
        "resolved": true,
        "details": {
          "function_name": "worker_detach_from_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1910-1930",
          "snippet": "static void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tkthread_set_per_cpu(worker->task, -1);\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tkthread_set_per_cpu(worker->task, -1);\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_worker",
          "args": [
            "pool"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_more_worker",
          "args": [
            "pool"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "need_more_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "791-794",
          "snippet": "static bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pwq",
          "args": [
            "pwq"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1158-1169",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pwq->mayday_node",
            "&wq->maydays"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pwq",
          "args": [
            "pwq"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "get_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1120-1125",
          "snippet": "static void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->mayday_node"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_to_create_worker",
          "args": [
            "pool"
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "need_to_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "810-813",
          "snippet": "static bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_scheduled_works",
          "args": [
            "rescuer"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "process_scheduled_works",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2365-2372",
          "snippet": "static void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_linked_works",
          "args": [
            "work",
            "scheduled",
            "&n"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "move_linked_works",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1089-1111",
          "snippet": "static void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "696-704",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "work",
            "n",
            "&pool->worklist",
            "entry"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(scheduled)"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_attach_to_pool",
          "args": [
            "rescuer",
            "pool"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "worker_attach_to_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1878-1900",
          "snippet": "static void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\telse\n\t\tkthread_set_per_cpu(worker->task, pool->cpu);\n\n\tif (worker->rescue_wq)\n\t\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\telse\n\t\tkthread_set_per_cpu(worker->task, pool->cpu);\n\n\tif (worker->rescue_wq)\n\t\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&pwq->mayday_node"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&wq->maydays",
            "structpool_workqueue",
            "mayday_node"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_IDLE"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "RESCUER_NICE_LEVEL"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_RAW_SPINLOCK(wq_mayday_lock);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int rescuer_thread(void *__rescuer)\n{\n\tstruct worker *rescuer = __rescuer;\n\tstruct workqueue_struct *wq = rescuer->rescue_wq;\n\tstruct list_head *scheduled = &rescuer->scheduled;\n\tbool should_stop;\n\n\tset_user_nice(current, RESCUER_NICE_LEVEL);\n\n\t/*\n\t * Mark rescuer as worker too.  As WORKER_PREP is never cleared, it\n\t * doesn't participate in concurrency management.\n\t */\n\tset_pf_worker(true);\nrepeat:\n\tset_current_state(TASK_IDLE);\n\n\t/*\n\t * By the time the rescuer is requested to stop, the workqueue\n\t * shouldn't have any work pending, but @wq->maydays may still have\n\t * pwq(s) queued.  This can happen by non-rescuer workers consuming\n\t * all the work items before the rescuer got to them.  Go through\n\t * @wq->maydays processing before acting on should_stop so that the\n\t * list is always empty on exit.\n\t */\n\tshould_stop = kthread_should_stop();\n\n\t/* see whether any pwq is asking for help */\n\traw_spin_lock_irq(&wq_mayday_lock);\n\n\twhile (!list_empty(&wq->maydays)) {\n\t\tstruct pool_workqueue *pwq = list_first_entry(&wq->maydays,\n\t\t\t\t\tstruct pool_workqueue, mayday_node);\n\t\tstruct worker_pool *pool = pwq->pool;\n\t\tstruct work_struct *work, *n;\n\t\tbool first = true;\n\n\t\t__set_current_state(TASK_RUNNING);\n\t\tlist_del_init(&pwq->mayday_node);\n\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\tworker_attach_to_pool(rescuer, pool);\n\n\t\traw_spin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * Slurp in all works issued via this workqueue and\n\t\t * process'em.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(scheduled));\n\t\tlist_for_each_entry_safe(work, n, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) == pwq) {\n\t\t\t\tif (first)\n\t\t\t\t\tpool->watchdog_ts = jiffies;\n\t\t\t\tmove_linked_works(work, scheduled, &n);\n\t\t\t}\n\t\t\tfirst = false;\n\t\t}\n\n\t\tif (!list_empty(scheduled)) {\n\t\t\tprocess_scheduled_works(rescuer);\n\n\t\t\t/*\n\t\t\t * The above execution of rescued work items could\n\t\t\t * have created more to rescue through\n\t\t\t * pwq_activate_first_inactive() or chained\n\t\t\t * queueing.  Let's put @pwq back on mayday list so\n\t\t\t * that such back-to-back work items, which may be\n\t\t\t * being used to relieve memory pressure, don't\n\t\t\t * incur MAYDAY_INTERVAL delay inbetween.\n\t\t\t */\n\t\t\tif (pwq->nr_active && need_to_create_worker(pool)) {\n\t\t\t\traw_spin_lock(&wq_mayday_lock);\n\t\t\t\t/*\n\t\t\t\t * Queue iff we aren't racing destruction\n\t\t\t\t * and somebody else hasn't queued it already.\n\t\t\t\t */\n\t\t\t\tif (wq->rescuer && list_empty(&pwq->mayday_node)) {\n\t\t\t\t\tget_pwq(pwq);\n\t\t\t\t\tlist_add_tail(&pwq->mayday_node, &wq->maydays);\n\t\t\t\t}\n\t\t\t\traw_spin_unlock(&wq_mayday_lock);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Put the reference grabbed by send_mayday().  @pool won't\n\t\t * go away while we're still attached to it.\n\t\t */\n\t\tput_pwq(pwq);\n\n\t\t/*\n\t\t * Leave this pool.  If need_more_worker() is %true, notify a\n\t\t * regular worker; otherwise, we end up with 0 concurrency\n\t\t * and stalling the execution.\n\t\t */\n\t\tif (need_more_worker(pool))\n\t\t\twake_up_worker(pool);\n\n\t\traw_spin_unlock_irq(&pool->lock);\n\n\t\tworker_detach_from_pool(rescuer);\n\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t}\n\n\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\tif (should_stop) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\tset_pf_worker(false);\n\t\treturn 0;\n\t}\n\n\t/* rescuers should never participate in concurrency management */\n\tWARN_ON_ONCE(!(rescuer->flags & WORKER_NOT_RUNNING));\n\tschedule();\n\tgoto repeat;\n}"
  },
  {
    "function_name": "worker_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2396-2477",
    "snippet": "static int worker_thread(void *__worker)\n{\n\tstruct worker *worker = __worker;\n\tstruct worker_pool *pool = worker->pool;\n\n\t/* tell the scheduler that this is a workqueue worker */\n\tset_pf_worker(true);\nwoke_up:\n\traw_spin_lock_irq(&pool->lock);\n\n\t/* am I supposed to die? */\n\tif (unlikely(worker->flags & WORKER_DIE)) {\n\t\traw_spin_unlock_irq(&pool->lock);\n\t\tWARN_ON_ONCE(!list_empty(&worker->entry));\n\t\tset_pf_worker(false);\n\n\t\tset_task_comm(worker->task, \"kworker/dying\");\n\t\tida_free(&pool->worker_ida, worker->id);\n\t\tworker_detach_from_pool(worker);\n\t\tkfree(worker);\n\t\treturn 0;\n\t}\n\n\tworker_leave_idle(worker);\nrecheck:\n\t/* no more worker necessary? */\n\tif (!need_more_worker(pool))\n\t\tgoto sleep;\n\n\t/* do we need to manage? */\n\tif (unlikely(!may_start_working(pool)) && manage_workers(worker))\n\t\tgoto recheck;\n\n\t/*\n\t * ->scheduled list can only be filled while a worker is\n\t * preparing to process a work or actually processing it.\n\t * Make sure nobody diddled with it while I was sleeping.\n\t */\n\tWARN_ON_ONCE(!list_empty(&worker->scheduled));\n\n\t/*\n\t * Finish PREP stage.  We're guaranteed to have at least one idle\n\t * worker or that someone else has already assumed the manager\n\t * role.  This is where @worker starts participating in concurrency\n\t * management if applicable and concurrency management is restored\n\t * after being rebound.  See rebind_workers() for details.\n\t */\n\tworker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);\n\n\tdo {\n\t\tstruct work_struct *work =\n\t\t\tlist_first_entry(&pool->worklist,\n\t\t\t\t\t struct work_struct, entry);\n\n\t\tpool->watchdog_ts = jiffies;\n\n\t\tif (likely(!(*work_data_bits(work) & WORK_STRUCT_LINKED))) {\n\t\t\t/* optimization path, not strictly necessary */\n\t\t\tprocess_one_work(worker, work);\n\t\t\tif (unlikely(!list_empty(&worker->scheduled)))\n\t\t\t\tprocess_scheduled_works(worker);\n\t\t} else {\n\t\t\tmove_linked_works(work, &worker->scheduled, NULL);\n\t\t\tprocess_scheduled_works(worker);\n\t\t}\n\t} while (keep_working(pool));\n\n\tworker_set_flags(worker, WORKER_PREP);\nsleep:\n\t/*\n\t * pool->lock is held and there's no work to process and no need to\n\t * manage, sleep.  Workers are woken up only while holding\n\t * pool->lock or from local cpu, so setting the current state\n\t * before releasing pool->lock is enough to prevent losing any\n\t * event.\n\t */\n\tworker_enter_idle(worker);\n\t__set_current_state(TASK_IDLE);\n\traw_spin_unlock_irq(&pool->lock);\n\tschedule();\n\tgoto woke_up;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static int worker_thread(void *__worker);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_IDLE"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_enter_idle",
          "args": [
            "worker"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "worker_enter_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1809-1832",
          "snippet": "static void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/* Sanity check nr_running. */\n\tWARN_ON_ONCE(pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/* Sanity check nr_running. */\n\tWARN_ON_ONCE(pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_set_flags",
          "args": [
            "worker",
            "WORKER_PREP"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "worker_set_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "981-994",
          "snippet": "static inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "keep_working",
          "args": [
            "pool"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "keep_working",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "803-807",
          "snippet": "static bool keep_working(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) &&\n\t\tatomic_read(&pool->nr_running) <= 1;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool keep_working(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) &&\n\t\tatomic_read(&pool->nr_running) <= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_scheduled_works",
          "args": [
            "worker"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "process_scheduled_works",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2365-2372",
          "snippet": "static void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_linked_works",
          "args": [
            "work",
            "&worker->scheduled",
            "NULL"
          ],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "move_linked_works",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1089-1111",
          "snippet": "static void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!list_empty(&worker->scheduled)"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&worker->scheduled"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_one_work",
          "args": [
            "worker",
            "work"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "process_one_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2199-2351",
          "snippet": "static void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tunsigned long work_data;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_data = *work_data_bits(work);\n\tworker->current_color = get_work_color(work_data);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\traw_spin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work, worker->current_func);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %ps\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPTION\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\traw_spin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* tag the worker for identification in schedule() */\n\tworker->last_func = worker->current_func;\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tworker->current_color = INT_MAX;\n\tpwq_dec_nr_in_flight(pwq, work_data);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tunsigned long work_data;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_data = *work_data_bits(work);\n\tworker->current_color = get_work_color(work_data);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\traw_spin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work, worker->current_func);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %ps\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPTION\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\traw_spin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* tag the worker for identification in schedule() */\n\tworker->last_func = worker->current_func;\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tworker->current_color = INT_MAX;\n\tpwq_dec_nr_in_flight(pwq, work_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(*work_data_bits(work) & WORK_STRUCT_LINKED)"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pool->worklist",
            "structwork_struct",
            "entry"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_clr_flags",
          "args": [
            "worker",
            "WORKER_PREP | WORKER_REBOUND"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "worker_clr_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1006-1023",
          "snippet": "static inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&worker->scheduled)"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "manage_workers",
          "args": [
            "worker"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "manage_workers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2167-2183",
          "snippet": "static bool manage_workers(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE)\n\t\treturn false;\n\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\tpool->manager = worker;\n\n\tmaybe_create_worker(pool);\n\n\tpool->manager = NULL;\n\tpool->flags &= ~POOL_MANAGER_ACTIVE;\n\trcuwait_wake_up(&manager_wait);\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool manage_workers(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE)\n\t\treturn false;\n\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\tpool->manager = worker;\n\n\tmaybe_create_worker(pool);\n\n\tpool->manager = NULL;\n\tpool->flags &= ~POOL_MANAGER_ACTIVE;\n\trcuwait_wake_up(&manager_wait);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!may_start_working(pool)"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_start_working",
          "args": [
            "pool"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "may_start_working",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "797-800",
          "snippet": "static bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_more_worker",
          "args": [
            "pool"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "need_more_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "791-794",
          "snippet": "static bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_leave_idle",
          "args": [
            "worker"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "worker_leave_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1843-1852",
          "snippet": "static void worker_leave_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\tworker_clr_flags(worker, WORKER_IDLE);\n\tpool->nr_idle--;\n\tlist_del_init(&worker->entry);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void worker_leave_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\tworker_clr_flags(worker, WORKER_IDLE);\n\tpool->nr_idle--;\n\tlist_del_init(&worker->entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "worker"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_detach_from_pool",
          "args": [
            "worker"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "worker_detach_from_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1910-1930",
          "snippet": "static void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tkthread_set_per_cpu(worker->task, -1);\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tkthread_set_per_cpu(worker->task, -1);\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_free",
          "args": [
            "&pool->worker_ida",
            "worker->id"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_task_comm",
          "args": [
            "worker->task",
            "\"kworker/dying\""
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pf_worker",
          "args": [
            "false"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "set_pf_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2374-2382",
          "snippet": "static void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\n\nstatic void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&worker->entry)"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "worker->flags & WORKER_DIE"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic int worker_thread(void *__worker);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int worker_thread(void *__worker)\n{\n\tstruct worker *worker = __worker;\n\tstruct worker_pool *pool = worker->pool;\n\n\t/* tell the scheduler that this is a workqueue worker */\n\tset_pf_worker(true);\nwoke_up:\n\traw_spin_lock_irq(&pool->lock);\n\n\t/* am I supposed to die? */\n\tif (unlikely(worker->flags & WORKER_DIE)) {\n\t\traw_spin_unlock_irq(&pool->lock);\n\t\tWARN_ON_ONCE(!list_empty(&worker->entry));\n\t\tset_pf_worker(false);\n\n\t\tset_task_comm(worker->task, \"kworker/dying\");\n\t\tida_free(&pool->worker_ida, worker->id);\n\t\tworker_detach_from_pool(worker);\n\t\tkfree(worker);\n\t\treturn 0;\n\t}\n\n\tworker_leave_idle(worker);\nrecheck:\n\t/* no more worker necessary? */\n\tif (!need_more_worker(pool))\n\t\tgoto sleep;\n\n\t/* do we need to manage? */\n\tif (unlikely(!may_start_working(pool)) && manage_workers(worker))\n\t\tgoto recheck;\n\n\t/*\n\t * ->scheduled list can only be filled while a worker is\n\t * preparing to process a work or actually processing it.\n\t * Make sure nobody diddled with it while I was sleeping.\n\t */\n\tWARN_ON_ONCE(!list_empty(&worker->scheduled));\n\n\t/*\n\t * Finish PREP stage.  We're guaranteed to have at least one idle\n\t * worker or that someone else has already assumed the manager\n\t * role.  This is where @worker starts participating in concurrency\n\t * management if applicable and concurrency management is restored\n\t * after being rebound.  See rebind_workers() for details.\n\t */\n\tworker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);\n\n\tdo {\n\t\tstruct work_struct *work =\n\t\t\tlist_first_entry(&pool->worklist,\n\t\t\t\t\t struct work_struct, entry);\n\n\t\tpool->watchdog_ts = jiffies;\n\n\t\tif (likely(!(*work_data_bits(work) & WORK_STRUCT_LINKED))) {\n\t\t\t/* optimization path, not strictly necessary */\n\t\t\tprocess_one_work(worker, work);\n\t\t\tif (unlikely(!list_empty(&worker->scheduled)))\n\t\t\t\tprocess_scheduled_works(worker);\n\t\t} else {\n\t\t\tmove_linked_works(work, &worker->scheduled, NULL);\n\t\t\tprocess_scheduled_works(worker);\n\t\t}\n\t} while (keep_working(pool));\n\n\tworker_set_flags(worker, WORKER_PREP);\nsleep:\n\t/*\n\t * pool->lock is held and there's no work to process and no need to\n\t * manage, sleep.  Workers are woken up only while holding\n\t * pool->lock or from local cpu, so setting the current state\n\t * before releasing pool->lock is enough to prevent losing any\n\t * event.\n\t */\n\tworker_enter_idle(worker);\n\t__set_current_state(TASK_IDLE);\n\traw_spin_unlock_irq(&pool->lock);\n\tschedule();\n\tgoto woke_up;\n}"
  },
  {
    "function_name": "set_pf_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2374-2382",
    "snippet": "static void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\n\nstatic void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
  },
  {
    "function_name": "process_scheduled_works",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2365-2372",
    "snippet": "static void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_one_work",
          "args": [
            "worker",
            "work"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "process_one_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2199-2351",
          "snippet": "static void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tunsigned long work_data;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_data = *work_data_bits(work);\n\tworker->current_color = get_work_color(work_data);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\traw_spin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work, worker->current_func);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %ps\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPTION\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\traw_spin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* tag the worker for identification in schedule() */\n\tworker->last_func = worker->current_func;\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tworker->current_color = INT_MAX;\n\tpwq_dec_nr_in_flight(pwq, work_data);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tunsigned long work_data;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_data = *work_data_bits(work);\n\tworker->current_color = get_work_color(work_data);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\traw_spin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work, worker->current_func);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %ps\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPTION\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\traw_spin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* tag the worker for identification in schedule() */\n\tworker->last_func = worker->current_func;\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tworker->current_color = INT_MAX;\n\tpwq_dec_nr_in_flight(pwq, work_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&worker->scheduled",
            "structwork_struct",
            "entry"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&worker->scheduled"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}"
  },
  {
    "function_name": "process_one_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2199-2351",
    "snippet": "static void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tunsigned long work_data;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_data = *work_data_bits(work);\n\tworker->current_color = get_work_color(work_data);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\traw_spin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work, worker->current_func);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %ps\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPTION\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\traw_spin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* tag the worker for identification in schedule() */\n\tworker->last_func = worker->current_func;\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tworker->current_color = INT_MAX;\n\tpwq_dec_nr_in_flight(pwq, work_data);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwq_dec_nr_in_flight",
          "args": [
            "pwq",
            "work_data"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_dec_nr_in_flight",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1202-1236",
          "snippet": "static void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, unsigned long work_data)\n{\n\tint color = get_work_color(work_data);\n\n\tif (!(work_data & WORK_STRUCT_INACTIVE)) {\n\t\tpwq->nr_active--;\n\t\tif (!list_empty(&pwq->inactive_works)) {\n\t\t\t/* one down, submit an inactive one */\n\t\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\t\tpwq_activate_first_inactive(pwq);\n\t\t}\n\t}\n\n\tpwq->nr_in_flight[color]--;\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, unsigned long work_data)\n{\n\tint color = get_work_color(work_data);\n\n\tif (!(work_data & WORK_STRUCT_INACTIVE)) {\n\t\tpwq->nr_active--;\n\t\tif (!list_empty(&pwq->inactive_works)) {\n\t\t\t/* one down, submit an inactive one */\n\t\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\t\tpwq_activate_first_inactive(pwq);\n\t\t}\n\t}\n\n\tpwq->nr_in_flight[color]--;\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&worker->hentry"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_clr_flags",
          "args": [
            "worker",
            "WORKER_CPU_INTENSIVE"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "worker_clr_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1006-1023",
          "snippet": "static inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpu_intensive"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_show_held_locks",
          "args": [
            "current"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_held_locks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6486-6493",
          "snippet": "void debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %ps\\n\"",
            "current->comm",
            "preempt_count()",
            "task_pid_nr(current)",
            "worker->current_func"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_atomic() || lockdep_depth(current) > 0"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_depth",
          "args": [
            "current"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&pwq->wq->lockdep_map"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&lockdep_map"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_workqueue_execute_end",
          "args": [
            "work",
            "worker->current_func"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker->current_func",
          "args": [
            "work"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_workqueue_execute_start",
          "args": [
            "work"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_invariant_state",
          "args": [
            "true"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&lockdep_map"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&pwq->wq->lockdep_map"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_work_pool_and_clear_pending",
          "args": [
            "work",
            "pool->id"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_pool_and_clear_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "648-688",
          "snippet": "static void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to queue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to queue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_worker",
          "args": [
            "pool"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_more_worker",
          "args": [
            "pool"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "need_more_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "791-794",
          "snippet": "static bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_set_flags",
          "args": [
            "worker",
            "WORKER_CPU_INTENSIVE"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "worker_set_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "981-994",
          "snippet": "static inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpu_intensive"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&work->entry"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "worker->desc",
            "pwq->wq->name",
            "WORKER_DESC_LEN"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_color",
          "args": [
            "work_data"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_color",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "596-600",
          "snippet": "static int get_work_color(unsigned long work_data)\n{\n\treturn (work_data >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_color(unsigned long work_data)\n{\n\treturn (work_data >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "pool->busy_hash",
            "&worker->hentry",
            "(unsigned long)work"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_work_deactivate",
          "args": [
            "work"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "debug_work_deactivate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "537-537",
          "snippet": "static inline void debug_work_deactivate(struct work_struct *work) { }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_deactivate(struct work_struct *work) { }"
        }
      },
      {
        "call_info": {
          "callee": "move_linked_works",
          "args": [
            "work",
            "&collision->scheduled",
            "NULL"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "move_linked_works",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1089-1111",
          "snippet": "static void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "collision"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_worker_executing_work",
          "args": [
            "pool",
            "work"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "find_worker_executing_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1058-1070",
          "snippet": "static struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_copy_map",
          "args": [
            "&lockdep_map",
            "&work->lockdep_map"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "696-704",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&pool->lock"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&pool->lock"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tunsigned long work_data;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_data = *work_data_bits(work);\n\tworker->current_color = get_work_color(work_data);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\traw_spin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work, worker->current_func);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %ps\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPTION\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\traw_spin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* tag the worker for identification in schedule() */\n\tworker->last_func = worker->current_func;\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tworker->current_color = INT_MAX;\n\tpwq_dec_nr_in_flight(pwq, work_data);\n}"
  },
  {
    "function_name": "manage_workers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2167-2183",
    "snippet": "static bool manage_workers(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE)\n\t\treturn false;\n\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\tpool->manager = worker;\n\n\tmaybe_create_worker(pool);\n\n\tpool->manager = NULL;\n\tpool->flags &= ~POOL_MANAGER_ACTIVE;\n\trcuwait_wake_up(&manager_wait);\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcuwait_wake_up",
          "args": [
            "&manager_wait"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "rcuwait_wake_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "234-260",
          "snippet": "int rcuwait_wake_up(struct rcuwait *w)\n{\n\tint ret = 0;\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\n\t/*\n\t * Order condition vs @task, such that everything prior to the load\n\t * of @task is visible. This is the condition as to why the user called\n\t * rcuwait_wake() in the first place. Pairs with set_current_state()\n\t * barrier (A) in rcuwait_wait_event().\n\t *\n\t *    WAIT                WAKE\n\t *    [S] tsk = current\t  [S] cond = true\n\t *        MB (A)\t      MB (B)\n\t *    [L] cond\t\t  [L] tsk\n\t */\n\tsmp_mb(); /* (B) */\n\n\ttask = rcu_dereference(w->task);\n\tif (task)\n\t\tret = wake_up_process(task);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint rcuwait_wake_up(struct rcuwait *w)\n{\n\tint ret = 0;\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\n\t/*\n\t * Order condition vs @task, such that everything prior to the load\n\t * of @task is visible. This is the condition as to why the user called\n\t * rcuwait_wake() in the first place. Pairs with set_current_state()\n\t * barrier (A) in rcuwait_wait_event().\n\t *\n\t *    WAIT                WAKE\n\t *    [S] tsk = current\t  [S] cond = true\n\t *        MB (A)\t      MB (B)\n\t *    [L] cond\t\t  [L] tsk\n\t */\n\tsmp_mb(); /* (B) */\n\n\ttask = rcu_dereference(w->task);\n\tif (task)\n\t\tret = wake_up_process(task);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_create_worker",
          "args": [
            "pool"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2114-2143",
          "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\traw_spin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\traw_spin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct rcuwait manager_wait = __RCUWAIT_INITIALIZER(manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool manage_workers(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE)\n\t\treturn false;\n\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\tpool->manager = worker;\n\n\tmaybe_create_worker(pool);\n\n\tpool->manager = NULL;\n\tpool->flags &= ~POOL_MANAGER_ACTIVE;\n\trcuwait_wake_up(&manager_wait);\n\treturn true;\n}"
  },
  {
    "function_name": "maybe_create_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2114-2143",
    "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\traw_spin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_to_create_worker",
          "args": [
            "pool"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "need_to_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "810-813",
          "snippet": "static bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&pool->mayday_timer"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "CREATE_COOLDOWN"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_worker",
          "args": [
            "pool"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2114-2143",
          "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\traw_spin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&pool->mayday_timer",
            "jiffies + MAYDAY_INITIAL_TIMEOUT"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&pool->lock"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&pool->lock"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\traw_spin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\traw_spin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}"
  },
  {
    "function_name": "pool_mayday_timeout",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2071-2094",
    "snippet": "static void pool_mayday_timeout(struct timer_list *t)\n{\n\tstruct worker_pool *pool = from_timer(pool, t, mayday_timer);\n\tstruct work_struct *work;\n\n\traw_spin_lock_irq(&pool->lock);\n\traw_spin_lock(&wq_mayday_lock);\t\t/* for wq->maydays */\n\n\tif (need_to_create_worker(pool)) {\n\t\t/*\n\t\t * We've been trying to create a new worker but\n\t\t * haven't been successful.  We might be hitting an\n\t\t * allocation deadlock.  Send distress signals to\n\t\t * rescuers.\n\t\t */\n\t\tlist_for_each_entry(work, &pool->worklist, entry)\n\t\t\tsend_mayday(work);\n\t}\n\n\traw_spin_unlock(&wq_mayday_lock);\n\traw_spin_unlock_irq(&pool->lock);\n\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INTERVAL);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(wq_mayday_lock);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&pool->mayday_timer",
            "jiffies + MAYDAY_INTERVAL"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_mayday",
          "args": [
            "work"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "send_mayday",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2048-2069",
          "snippet": "static void send_mayday(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq_mayday_lock);\n\n\tif (!wq->rescuer)\n\t\treturn;\n\n\t/* mayday mayday mayday */\n\tif (list_empty(&pwq->mayday_node)) {\n\t\t/*\n\t\t * If @pwq is for an unbound wq, its base ref may be put at\n\t\t * any time due to an attribute change.  Pin @pwq until the\n\t\t * rescuer is done with it.\n\t\t */\n\t\tget_pwq(pwq);\n\t\tlist_add_tail(&pwq->mayday_node, &wq->maydays);\n\t\twake_up_process(wq->rescuer->task);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(wq_mayday_lock);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_RAW_SPINLOCK(wq_mayday_lock);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void send_mayday(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq_mayday_lock);\n\n\tif (!wq->rescuer)\n\t\treturn;\n\n\t/* mayday mayday mayday */\n\tif (list_empty(&pwq->mayday_node)) {\n\t\t/*\n\t\t * If @pwq is for an unbound wq, its base ref may be put at\n\t\t * any time due to an attribute change.  Pin @pwq until the\n\t\t * rescuer is done with it.\n\t\t */\n\t\tget_pwq(pwq);\n\t\tlist_add_tail(&pwq->mayday_node, &wq->maydays);\n\t\twake_up_process(wq->rescuer->task);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "work",
            "&pool->worklist",
            "entry"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_to_create_worker",
          "args": [
            "pool"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "need_to_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "810-813",
          "snippet": "static bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "pool",
            "t",
            "mayday_timer"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_RAW_SPINLOCK(wq_mayday_lock);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pool_mayday_timeout(struct timer_list *t)\n{\n\tstruct worker_pool *pool = from_timer(pool, t, mayday_timer);\n\tstruct work_struct *work;\n\n\traw_spin_lock_irq(&pool->lock);\n\traw_spin_lock(&wq_mayday_lock);\t\t/* for wq->maydays */\n\n\tif (need_to_create_worker(pool)) {\n\t\t/*\n\t\t * We've been trying to create a new worker but\n\t\t * haven't been successful.  We might be hitting an\n\t\t * allocation deadlock.  Send distress signals to\n\t\t * rescuers.\n\t\t */\n\t\tlist_for_each_entry(work, &pool->worklist, entry)\n\t\t\tsend_mayday(work);\n\t}\n\n\traw_spin_unlock(&wq_mayday_lock);\n\traw_spin_unlock_irq(&pool->lock);\n\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INTERVAL);\n}"
  },
  {
    "function_name": "send_mayday",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2048-2069",
    "snippet": "static void send_mayday(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq_mayday_lock);\n\n\tif (!wq->rescuer)\n\t\treturn;\n\n\t/* mayday mayday mayday */\n\tif (list_empty(&pwq->mayday_node)) {\n\t\t/*\n\t\t * If @pwq is for an unbound wq, its base ref may be put at\n\t\t * any time due to an attribute change.  Pin @pwq until the\n\t\t * rescuer is done with it.\n\t\t */\n\t\tget_pwq(pwq);\n\t\tlist_add_tail(&pwq->mayday_node, &wq->maydays);\n\t\twake_up_process(wq->rescuer->task);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(wq_mayday_lock);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "wq->rescuer->task"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pwq->mayday_node",
            "&wq->maydays"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pwq",
          "args": [
            "pwq"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "get_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1120-1125",
          "snippet": "static void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->mayday_node"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "696-704",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_RAW_SPINLOCK(wq_mayday_lock);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void send_mayday(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq_mayday_lock);\n\n\tif (!wq->rescuer)\n\t\treturn;\n\n\t/* mayday mayday mayday */\n\tif (list_empty(&pwq->mayday_node)) {\n\t\t/*\n\t\t * If @pwq is for an unbound wq, its base ref may be put at\n\t\t * any time due to an attribute change.  Pin @pwq until the\n\t\t * rescuer is done with it.\n\t\t */\n\t\tget_pwq(pwq);\n\t\tlist_add_tail(&pwq->mayday_node, &wq->maydays);\n\t\twake_up_process(wq->rescuer->task);\n\t}\n}"
  },
  {
    "function_name": "idle_worker_timeout",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2023-2046",
    "snippet": "static void idle_worker_timeout(struct timer_list *t)\n{\n\tstruct worker_pool *pool = from_timer(pool, t, idle_timer);\n\n\traw_spin_lock_irq(&pool->lock);\n\n\twhile (too_many_workers(pool)) {\n\t\tstruct worker *worker;\n\t\tunsigned long expires;\n\n\t\t/* idle_list is kept in LIFO order, check the last one */\n\t\tworker = list_entry(pool->idle_list.prev, struct worker, entry);\n\t\texpires = worker->last_active + IDLE_WORKER_TIMEOUT;\n\n\t\tif (time_before(jiffies, expires)) {\n\t\t\tmod_timer(&pool->idle_timer, expires);\n\t\t\tbreak;\n\t\t}\n\n\t\tdestroy_worker(worker);\n\t}\n\n\traw_spin_unlock_irq(&pool->lock);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_worker",
          "args": [
            "worker"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2003-2021",
          "snippet": "static void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&pool->idle_timer",
            "expires"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "expires"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pool->idle_list.prev",
            "structworker",
            "entry"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "too_many_workers",
          "args": [
            "pool"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "too_many_workers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "816-823",
          "snippet": "static bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "pool",
            "t",
            "idle_timer"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void idle_worker_timeout(struct timer_list *t)\n{\n\tstruct worker_pool *pool = from_timer(pool, t, idle_timer);\n\n\traw_spin_lock_irq(&pool->lock);\n\n\twhile (too_many_workers(pool)) {\n\t\tstruct worker *worker;\n\t\tunsigned long expires;\n\n\t\t/* idle_list is kept in LIFO order, check the last one */\n\t\tworker = list_entry(pool->idle_list.prev, struct worker, entry);\n\t\texpires = worker->last_active + IDLE_WORKER_TIMEOUT;\n\n\t\tif (time_before(jiffies, expires)) {\n\t\t\tmod_timer(&pool->idle_timer, expires);\n\t\t\tbreak;\n\t\t}\n\n\t\tdestroy_worker(worker);\n\t}\n\n\traw_spin_unlock_irq(&pool->lock);\n}"
  },
  {
    "function_name": "destroy_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "2003-2021",
    "snippet": "static void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "worker->task"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&worker->entry"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(worker->flags & WORKER_IDLE)"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&worker->scheduled)"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&worker->scheduled"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "worker->current_work"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pool->lock"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}"
  },
  {
    "function_name": "create_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1944-1991",
    "snippet": "static struct worker *create_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\tint id;\n\tchar id_buf[16];\n\n\t/* ID is needed to determine kthread name */\n\tid = ida_alloc(&pool->worker_ida, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn NULL;\n\n\tworker = alloc_worker(pool->node);\n\tif (!worker)\n\t\tgoto fail;\n\n\tworker->id = id;\n\n\tif (pool->cpu >= 0)\n\t\tsnprintf(id_buf, sizeof(id_buf), \"%d:%d%s\", pool->cpu, id,\n\t\t\t pool->attrs->nice < 0  ? \"H\" : \"\");\n\telse\n\t\tsnprintf(id_buf, sizeof(id_buf), \"u%d:%d\", pool->id, id);\n\n\tworker->task = kthread_create_on_node(worker_thread, worker, pool->node,\n\t\t\t\t\t      \"kworker/%s\", id_buf);\n\tif (IS_ERR(worker->task))\n\t\tgoto fail;\n\n\tset_user_nice(worker->task, pool->attrs->nice);\n\tkthread_bind_mask(worker->task, pool->attrs->cpumask);\n\n\t/* successful, attach the worker to the pool */\n\tworker_attach_to_pool(worker, pool);\n\n\t/* start the newly created worker */\n\traw_spin_lock_irq(&pool->lock);\n\tworker->pool->nr_workers++;\n\tworker_enter_idle(worker);\n\twake_up_process(worker->task);\n\traw_spin_unlock_irq(&pool->lock);\n\n\treturn worker;\n\nfail:\n\tida_free(&pool->worker_ida, id);\n\tkfree(worker);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "worker"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_free",
          "args": [
            "&pool->worker_ida",
            "id"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "worker->task"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_enter_idle",
          "args": [
            "worker"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "worker_enter_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1809-1832",
          "snippet": "static void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/* Sanity check nr_running. */\n\tWARN_ON_ONCE(pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/* Sanity check nr_running. */\n\tWARN_ON_ONCE(pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_attach_to_pool",
          "args": [
            "worker",
            "pool"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "worker_attach_to_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1878-1900",
          "snippet": "static void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\telse\n\t\tkthread_set_per_cpu(worker->task, pool->cpu);\n\n\tif (worker->rescue_wq)\n\t\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\telse\n\t\tkthread_set_per_cpu(worker->task, pool->cpu);\n\n\tif (worker->rescue_wq)\n\t\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_bind_mask",
          "args": [
            "worker->task",
            "pool->attrs->cpumask"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_bind_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "541-544",
          "snippet": "void kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "worker->task",
            "pool->attrs->nice"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "worker->task"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create_on_node",
          "args": [
            "worker_thread",
            "worker",
            "pool->node",
            "\"kworker/%s\"",
            "id_buf"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_on_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "504-517",
          "snippet": "struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;",
            "struct task_struct *task;",
            "int node = NUMA_NO_NODE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\nstruct task_struct *task;\nint node = NUMA_NO_NODE;\n\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "id_buf",
            "sizeof(id_buf)",
            "\"u%d:%d\"",
            "pool->id",
            "id"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "id_buf",
            "sizeof(id_buf)",
            "\"%d:%d%s\"",
            "pool->cpu",
            "id",
            "pool->attrs->nice < 0  ? \"H\" : \"\""
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5994-6013",
          "snippet": "int btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_worker",
          "args": [
            "pool->node"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1854-1867",
          "snippet": "static struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_alloc",
          "args": [
            "&pool->worker_ida",
            "GFP_KERNEL"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker *create_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\tint id;\n\tchar id_buf[16];\n\n\t/* ID is needed to determine kthread name */\n\tid = ida_alloc(&pool->worker_ida, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn NULL;\n\n\tworker = alloc_worker(pool->node);\n\tif (!worker)\n\t\tgoto fail;\n\n\tworker->id = id;\n\n\tif (pool->cpu >= 0)\n\t\tsnprintf(id_buf, sizeof(id_buf), \"%d:%d%s\", pool->cpu, id,\n\t\t\t pool->attrs->nice < 0  ? \"H\" : \"\");\n\telse\n\t\tsnprintf(id_buf, sizeof(id_buf), \"u%d:%d\", pool->id, id);\n\n\tworker->task = kthread_create_on_node(worker_thread, worker, pool->node,\n\t\t\t\t\t      \"kworker/%s\", id_buf);\n\tif (IS_ERR(worker->task))\n\t\tgoto fail;\n\n\tset_user_nice(worker->task, pool->attrs->nice);\n\tkthread_bind_mask(worker->task, pool->attrs->cpumask);\n\n\t/* successful, attach the worker to the pool */\n\tworker_attach_to_pool(worker, pool);\n\n\t/* start the newly created worker */\n\traw_spin_lock_irq(&pool->lock);\n\tworker->pool->nr_workers++;\n\tworker_enter_idle(worker);\n\twake_up_process(worker->task);\n\traw_spin_unlock_irq(&pool->lock);\n\n\treturn worker;\n\nfail:\n\tida_free(&pool->worker_ida, id);\n\tkfree(worker);\n\treturn NULL;\n}"
  },
  {
    "function_name": "worker_detach_from_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1910-1930",
    "snippet": "static void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tkthread_set_per_cpu(worker->task, -1);\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "detach_completion"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->workers"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&worker->node"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_set_per_cpu",
          "args": [
            "worker->task",
            "-1"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tkthread_set_per_cpu(worker->task, -1);\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}"
  },
  {
    "function_name": "worker_attach_to_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1878-1900",
    "snippet": "static void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\telse\n\t\tkthread_set_per_cpu(worker->task, pool->cpu);\n\n\tif (worker->rescue_wq)\n\t\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&worker->node",
            "&pool->workers"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "worker->task",
            "pool->attrs->cpumask"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_set_per_cpu",
          "args": [
            "worker->task",
            "pool->cpu"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\telse\n\t\tkthread_set_per_cpu(worker->task, pool->cpu);\n\n\tif (worker->rescue_wq)\n\t\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
  },
  {
    "function_name": "alloc_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1854-1867",
    "snippet": "static struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&worker->node"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&worker->scheduled"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&worker->entry"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*worker)",
            "GFP_KERNEL",
            "node"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}"
  },
  {
    "function_name": "worker_leave_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1843-1852",
    "snippet": "static void worker_leave_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\tworker_clr_flags(worker, WORKER_IDLE);\n\tpool->nr_idle--;\n\tlist_del_init(&worker->entry);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&worker->entry"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_clr_flags",
          "args": [
            "worker",
            "WORKER_IDLE"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "worker_clr_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1006-1023",
          "snippet": "static inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(worker->flags & WORKER_IDLE)"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void worker_leave_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\tworker_clr_flags(worker, WORKER_IDLE);\n\tpool->nr_idle--;\n\tlist_del_init(&worker->entry);\n}"
  },
  {
    "function_name": "worker_enter_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1809-1832",
    "snippet": "static void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/* Sanity check nr_running. */\n\tWARN_ON_ONCE(pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running)"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pool->nr_running"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&pool->idle_timer",
            "jiffies + IDLE_WORKER_TIMEOUT"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&pool->idle_timer"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "too_many_workers",
          "args": [
            "pool"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "too_many_workers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "816-823",
          "snippet": "static bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&worker->entry",
            "&pool->idle_list"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&worker->entry"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "worker->flags & WORKER_IDLE"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/* Sanity check nr_running. */\n\tWARN_ON_ONCE(pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}"
  },
  {
    "function_name": "queue_rcu_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1785-1796",
    "snippet": "bool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork)\n{\n\tstruct work_struct *work = &rwork->work;\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\trwork->wq = wq;\n\t\tcall_rcu(&rwork->rcu, rcu_work_rcufn);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&rwork->rcu",
            "rcu_work_rcufn"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(work)"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork)\n{\n\tstruct work_struct *work = &rwork->work;\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\trwork->wq = wq;\n\t\tcall_rcu(&rwork->rcu, rcu_work_rcufn);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_work_rcufn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1765-1773",
    "snippet": "static void rcu_work_rcufn(struct rcu_head *rcu)\n{\n\tstruct rcu_work *rwork = container_of(rcu, struct rcu_work, rcu);\n\n\t/* read the comment in __queue_work() */\n\tlocal_irq_disable();\n\t__queue_work(WORK_CPU_UNBOUND, rwork->wq, &rwork->work);\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_work",
          "args": [
            "WORK_CPU_UNBOUND",
            "rwork->wq",
            "&rwork->work"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1435-1539",
          "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structrcu_work",
            "rcu"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void rcu_work_rcufn(struct rcu_head *rcu)\n{\n\tstruct rcu_work *rwork = container_of(rcu, struct rcu_work, rcu);\n\n\t/* read the comment in __queue_work() */\n\tlocal_irq_disable();\n\t__queue_work(WORK_CPU_UNBOUND, rwork->wq, &rwork->work);\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "mod_delayed_work_on",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1745-1762",
    "snippet": "bool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t struct delayed_work *dwork, unsigned long delay)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(&dwork->work, true, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (likely(ret >= 0)) {\n\t\t__queue_delayed_work(cpu, wq, dwork, delay);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\t/* -ENOENT from try_to_grab_pending() becomes %true */\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_delayed_work",
          "args": [
            "cpu",
            "wq",
            "dwork",
            "delay"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_delayed_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1664-1694",
          "snippet": "static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_FUNCTION_MISMATCH(timer->function, delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_FUNCTION_MISMATCH(timer->function, delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ret >= 0"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -EAGAIN"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_grab_pending",
          "args": [
            "&dwork->work",
            "true",
            "&flags"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_grab_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1268-1347",
          "snippet": "static int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\trcu_read_lock();\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\traw_spin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A cancelable inactive work item must be in the\n\t\t * pwq->inactive_works since a queued barrier can't be\n\t\t * canceled (see the comments in insert_wq_barrier()).\n\t\t *\n\t\t * An inactive work item cannot be grabbed directly because\n\t\t * it might have linked barrier work items which, if left\n\t\t * on the inactive_works list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_INACTIVE)\n\t\t\tpwq_activate_inactive_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, *work_data_bits(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\traw_spin_unlock(&pool->lock);\n\t\trcu_read_unlock();\n\t\treturn 1;\n\t}\n\traw_spin_unlock(&pool->lock);\nfail:\n\trcu_read_unlock();\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\trcu_read_lock();\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\traw_spin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A cancelable inactive work item must be in the\n\t\t * pwq->inactive_works since a queued barrier can't be\n\t\t * canceled (see the comments in insert_wq_barrier()).\n\t\t *\n\t\t * An inactive work item cannot be grabbed directly because\n\t\t * it might have linked barrier work items which, if left\n\t\t * on the inactive_works list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_INACTIVE)\n\t\t\tpwq_activate_inactive_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, *work_data_bits(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\traw_spin_unlock(&pool->lock);\n\t\trcu_read_unlock();\n\t\treturn 1;\n\t}\n\traw_spin_unlock(&pool->lock);\nfail:\n\trcu_read_unlock();\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t struct delayed_work *dwork, unsigned long delay)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(&dwork->work, true, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (likely(ret >= 0)) {\n\t\t__queue_delayed_work(cpu, wq, dwork, delay);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\t/* -ENOENT from try_to_grab_pending() becomes %true */\n\treturn ret;\n}"
  },
  {
    "function_name": "queue_delayed_work_on",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1707-1724",
    "snippet": "bool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t   struct delayed_work *dwork, unsigned long delay)\n{\n\tstruct work_struct *work = &dwork->work;\n\tbool ret = false;\n\tunsigned long flags;\n\n\t/* read the comment in __queue_work() */\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_delayed_work(cpu, wq, dwork, delay);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_delayed_work",
          "args": [
            "cpu",
            "wq",
            "dwork",
            "delay"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_delayed_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1664-1694",
          "snippet": "static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_FUNCTION_MISMATCH(timer->function, delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_FUNCTION_MISMATCH(timer->function, delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(work)"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t   struct delayed_work *dwork, unsigned long delay)\n{\n\tstruct work_struct *work = &dwork->work;\n\tbool ret = false;\n\tunsigned long flags;\n\n\t/* read the comment in __queue_work() */\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_delayed_work(cpu, wq, dwork, delay);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "__queue_delayed_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1664-1694",
    "snippet": "static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_FUNCTION_MISMATCH(timer->function, delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_timer",
          "args": [
            "timer"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "add_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1141-1145",
          "snippet": "void add_timer(struct timer_list *timer)\n{\n\tBUG_ON(timer_pending(timer));\n\t__mod_timer(timer, timer->expires, MOD_TIMER_NOTPENDING);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define MOD_TIMER_NOTPENDING\t\t0x04"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define MOD_TIMER_NOTPENDING\t\t0x04\n\nvoid add_timer(struct timer_list *timer)\n{\n\tBUG_ON(timer_pending(timer));\n\t__mod_timer(timer, timer->expires, MOD_TIMER_NOTPENDING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_timer_on",
          "args": [
            "timer",
            "cpu"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "add_timer_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1155-1184",
          "snippet": "void add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_timer_activate(timer);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_timer_activate(timer);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpu != WORK_CPU_UNBOUND"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_work",
          "args": [
            "cpu",
            "wq",
            "&dwork->work"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1435-1539",
          "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&work->entry)"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&work->entry"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "timer_pending(timer)"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "timer"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_FUNCTION_MISMATCH",
          "args": [
            "timer->function",
            "delayed_work_timer_fn"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!wq"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_FUNCTION_MISMATCH(timer->function, delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}"
  },
  {
    "function_name": "delayed_work_timer_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1655-1661",
    "snippet": "void delayed_work_timer_fn(struct timer_list *t)\n{\n\tstruct delayed_work *dwork = from_timer(dwork, t, timer);\n\n\t/* should have been called from irqsafe timer with irq already off */\n\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__queue_work",
          "args": [
            "dwork->cpu",
            "dwork->wq",
            "&dwork->work"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1435-1539",
          "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "dwork",
            "t",
            "timer"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid delayed_work_timer_fn(struct timer_list *t)\n{\n\tstruct delayed_work *dwork = from_timer(dwork, t, timer);\n\n\t/* should have been called from irqsafe timer with irq already off */\n\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n}"
  },
  {
    "function_name": "queue_work_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1624-1652",
    "snippet": "bool queue_work_node(int node, struct workqueue_struct *wq,\n\t\t     struct work_struct *work)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\n\t/*\n\t * This current implementation is specific to unbound workqueues.\n\t * Specifically we only return the first available CPU for a given\n\t * node instead of cycling through individual CPUs within the node.\n\t *\n\t * If this is used with a per-cpu workqueue then the logic in\n\t * workqueue_select_cpu_near would need to be updated to allow for\n\t * some round robin type logic.\n\t */\n\tWARN_ON_ONCE(!(wq->flags & WQ_UNBOUND));\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\tint cpu = workqueue_select_cpu_near(node);\n\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_work",
          "args": [
            "cpu",
            "wq",
            "work"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1435-1539",
          "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "workqueue_select_cpu_near",
          "args": [
            "node"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_select_cpu_near",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1580-1602",
          "snippet": "static int workqueue_select_cpu_near(int node)\n{\n\tint cpu;\n\n\t/* No point in doing this if NUMA isn't enabled for workqueues */\n\tif (!wq_numa_enabled)\n\t\treturn WORK_CPU_UNBOUND;\n\n\t/* Delay binding to CPU if node is not valid or online */\n\tif (node < 0 || node >= MAX_NUMNODES || !node_online(node))\n\t\treturn WORK_CPU_UNBOUND;\n\n\t/* Use local node/cpu if we are already there */\n\tcpu = raw_smp_processor_id();\n\tif (node == cpu_to_node(cpu))\n\t\treturn cpu;\n\n\t/* Use \"random\" otherwise know as \"first\" online CPU of node */\n\tcpu = cpumask_any_and(cpumask_of_node(node), cpu_online_mask);\n\n\t/* If CPU is valid return that, otherwise just defer */\n\treturn cpu < nr_cpu_ids ? cpu : WORK_CPU_UNBOUND;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_numa_enabled;",
            "static LIST_HEAD(workqueues);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_numa_enabled;\nstatic LIST_HEAD(workqueues);\n\nstatic int workqueue_select_cpu_near(int node)\n{\n\tint cpu;\n\n\t/* No point in doing this if NUMA isn't enabled for workqueues */\n\tif (!wq_numa_enabled)\n\t\treturn WORK_CPU_UNBOUND;\n\n\t/* Delay binding to CPU if node is not valid or online */\n\tif (node < 0 || node >= MAX_NUMNODES || !node_online(node))\n\t\treturn WORK_CPU_UNBOUND;\n\n\t/* Use local node/cpu if we are already there */\n\tcpu = raw_smp_processor_id();\n\tif (node == cpu_to_node(cpu))\n\t\treturn cpu;\n\n\t/* Use \"random\" otherwise know as \"first\" online CPU of node */\n\tcpu = cpumask_any_and(cpumask_of_node(node), cpu_online_mask);\n\n\t/* If CPU is valid return that, otherwise just defer */\n\treturn cpu < nr_cpu_ids ? cpu : WORK_CPU_UNBOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(work)"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(wq->flags & WQ_UNBOUND)"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_node(int node, struct workqueue_struct *wq,\n\t\t     struct work_struct *work)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\n\t/*\n\t * This current implementation is specific to unbound workqueues.\n\t * Specifically we only return the first available CPU for a given\n\t * node instead of cycling through individual CPUs within the node.\n\t *\n\t * If this is used with a per-cpu workqueue then the logic in\n\t * workqueue_select_cpu_near would need to be updated to allow for\n\t * some round robin type logic.\n\t */\n\tWARN_ON_ONCE(!(wq->flags & WQ_UNBOUND));\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\tint cpu = workqueue_select_cpu_near(node);\n\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "workqueue_select_cpu_near",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1580-1602",
    "snippet": "static int workqueue_select_cpu_near(int node)\n{\n\tint cpu;\n\n\t/* No point in doing this if NUMA isn't enabled for workqueues */\n\tif (!wq_numa_enabled)\n\t\treturn WORK_CPU_UNBOUND;\n\n\t/* Delay binding to CPU if node is not valid or online */\n\tif (node < 0 || node >= MAX_NUMNODES || !node_online(node))\n\t\treturn WORK_CPU_UNBOUND;\n\n\t/* Use local node/cpu if we are already there */\n\tcpu = raw_smp_processor_id();\n\tif (node == cpu_to_node(cpu))\n\t\treturn cpu;\n\n\t/* Use \"random\" otherwise know as \"first\" online CPU of node */\n\tcpu = cpumask_any_and(cpumask_of_node(node), cpu_online_mask);\n\n\t/* If CPU is valid return that, otherwise just defer */\n\treturn cpu < nr_cpu_ids ? cpu : WORK_CPU_UNBOUND;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_numa_enabled;",
      "static LIST_HEAD(workqueues);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "cpumask_of_node(node)",
            "cpu_online_mask"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "node"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "node"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_numa_enabled;\nstatic LIST_HEAD(workqueues);\n\nstatic int workqueue_select_cpu_near(int node)\n{\n\tint cpu;\n\n\t/* No point in doing this if NUMA isn't enabled for workqueues */\n\tif (!wq_numa_enabled)\n\t\treturn WORK_CPU_UNBOUND;\n\n\t/* Delay binding to CPU if node is not valid or online */\n\tif (node < 0 || node >= MAX_NUMNODES || !node_online(node))\n\t\treturn WORK_CPU_UNBOUND;\n\n\t/* Use local node/cpu if we are already there */\n\tcpu = raw_smp_processor_id();\n\tif (node == cpu_to_node(cpu))\n\t\treturn cpu;\n\n\t/* Use \"random\" otherwise know as \"first\" online CPU of node */\n\tcpu = cpumask_any_and(cpumask_of_node(node), cpu_online_mask);\n\n\t/* If CPU is valid return that, otherwise just defer */\n\treturn cpu < nr_cpu_ids ? cpu : WORK_CPU_UNBOUND;\n}"
  },
  {
    "function_name": "queue_work_on",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1553-1568",
    "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_work",
          "args": [
            "cpu",
            "wq",
            "work"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1435-1539",
          "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(work)"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "__queue_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1435-1539",
    "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_work",
          "args": [
            "pwq",
            "work",
            "worklist",
            "work_flags"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "insert_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1362-1384",
          "snippet": "static void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack_noalloc(work);\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack_noalloc(work);\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_work_activate",
          "args": [
            "work"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "debug_work_activate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "536-536",
          "snippet": "static inline void debug_work_activate(struct work_struct *work) { }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_activate(struct work_struct *work) { }"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "worklist"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_workqueue_activate_work",
          "args": [
            "work"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pwq->nr_active < pwq->max_active"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_color_to_flags",
          "args": [
            "pwq->work_color"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "work_color_to_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "591-594",
          "snippet": "static unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&work->entry)"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_workqueue_queue_work",
          "args": [
            "req_cpu",
            "pwq",
            "work"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "true",
            "\"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\"",
            "wq->name",
            "cpu"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pwq->refcnt"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_worker_executing_work",
          "args": [
            "last_pool",
            "work"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "find_worker_executing_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1058-1070",
          "snippet": "static struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pool",
          "args": [
            "work"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "746-755",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wq->cpu_pwqs",
            "cpu"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unbound_pwq_by_node",
          "args": [
            "wq",
            "cpu_to_node(cpu)"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "unbound_pwq_by_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "574-589",
          "snippet": "static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_select_unbound_cpu",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "wq_select_unbound_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1407-1433",
          "snippet": "static int wq_select_unbound_cpu(int cpu)\n{\n\tstatic bool printed_dbg_warning;\n\tint new_cpu;\n\n\tif (likely(!wq_debug_force_rr_cpu)) {\n\t\tif (cpumask_test_cpu(cpu, wq_unbound_cpumask))\n\t\t\treturn cpu;\n\t} else if (!printed_dbg_warning) {\n\t\tpr_warn(\"workqueue: round-robin CPU selection forced, expect performance impact\\n\");\n\t\tprinted_dbg_warning = true;\n\t}\n\n\tif (cpumask_empty(wq_unbound_cpumask))\n\t\treturn cpu;\n\n\tnew_cpu = __this_cpu_read(wq_rr_cpu_last);\n\tnew_cpu = cpumask_next_and(new_cpu, wq_unbound_cpumask, cpu_online_mask);\n\tif (unlikely(new_cpu >= nr_cpu_ids)) {\n\t\tnew_cpu = cpumask_first_and(wq_unbound_cpumask, cpu_online_mask);\n\t\tif (unlikely(new_cpu >= nr_cpu_ids))\n\t\t\treturn cpu;\n\t}\n\t__this_cpu_write(wq_rr_cpu_last, new_cpu);\n\n\treturn new_cpu;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t wq_unbound_cpumask;",
            "static DEFINE_PER_CPU(int, wq_rr_cpu_last);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic DEFINE_PER_CPU(int, wq_rr_cpu_last);\n\nstatic int wq_select_unbound_cpu(int cpu)\n{\n\tstatic bool printed_dbg_warning;\n\tint new_cpu;\n\n\tif (likely(!wq_debug_force_rr_cpu)) {\n\t\tif (cpumask_test_cpu(cpu, wq_unbound_cpumask))\n\t\t\treturn cpu;\n\t} else if (!printed_dbg_warning) {\n\t\tpr_warn(\"workqueue: round-robin CPU selection forced, expect performance impact\\n\");\n\t\tprinted_dbg_warning = true;\n\t}\n\n\tif (cpumask_empty(wq_unbound_cpumask))\n\t\treturn cpu;\n\n\tnew_cpu = __this_cpu_read(wq_rr_cpu_last);\n\tnew_cpu = cpumask_next_and(new_cpu, wq_unbound_cpumask, cpu_online_mask);\n\tif (unlikely(new_cpu >= nr_cpu_ids)) {\n\t\tnew_cpu = cpumask_first_and(wq_unbound_cpumask, cpu_online_mask);\n\t\tif (unlikely(new_cpu >= nr_cpu_ids))\n\t\t\treturn cpu;\n\t}\n\t__this_cpu_write(wq_rr_cpu_last, new_cpu);\n\n\treturn new_cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!is_chained_work(wq)"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_chained_work",
          "args": [
            "wq"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "is_chained_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1390-1400",
          "snippet": "static bool is_chained_work(struct workqueue_struct *wq)\n{\n\tstruct worker *worker;\n\n\tworker = current_wq_worker();\n\t/*\n\t * Return %true iff I'm a worker executing a work item on @wq.  If\n\t * I'm @worker, it's safe to dereference it without locking.\n\t */\n\treturn worker && worker->current_pwq->wq == wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic bool is_chained_work(struct workqueue_struct *wq)\n{\n\tstruct worker *worker;\n\n\tworker = current_wq_worker();\n\t/*\n\t * Return %true iff I'm a worker executing a work item on @wq.  If\n\t * I'm @worker, it's safe to dereference it without locking.\n\t */\n\treturn worker && worker->current_pwq->wq == wq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wq->flags & __WQ_DRAINING"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\n\trcu_read_lock();\nretry:\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\t} else {\n\t\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\t\tcpu = raw_smp_processor_id();\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\t}\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\traw_spin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\traw_spin_unlock(&last_pool->lock);\n\t\t\traw_spin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\traw_spin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\traw_spin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry)))\n\t\tgoto out;\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_INACTIVE;\n\t\tworklist = &pwq->inactive_works;\n\t}\n\n\tdebug_work_activate(work);\n\tinsert_work(pwq, work, worklist, work_flags);\n\nout:\n\traw_spin_unlock(&pwq->pool->lock);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "wq_select_unbound_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1407-1433",
    "snippet": "static int wq_select_unbound_cpu(int cpu)\n{\n\tstatic bool printed_dbg_warning;\n\tint new_cpu;\n\n\tif (likely(!wq_debug_force_rr_cpu)) {\n\t\tif (cpumask_test_cpu(cpu, wq_unbound_cpumask))\n\t\t\treturn cpu;\n\t} else if (!printed_dbg_warning) {\n\t\tpr_warn(\"workqueue: round-robin CPU selection forced, expect performance impact\\n\");\n\t\tprinted_dbg_warning = true;\n\t}\n\n\tif (cpumask_empty(wq_unbound_cpumask))\n\t\treturn cpu;\n\n\tnew_cpu = __this_cpu_read(wq_rr_cpu_last);\n\tnew_cpu = cpumask_next_and(new_cpu, wq_unbound_cpumask, cpu_online_mask);\n\tif (unlikely(new_cpu >= nr_cpu_ids)) {\n\t\tnew_cpu = cpumask_first_and(wq_unbound_cpumask, cpu_online_mask);\n\t\tif (unlikely(new_cpu >= nr_cpu_ids))\n\t\t\treturn cpu;\n\t}\n\t__this_cpu_write(wq_rr_cpu_last, new_cpu);\n\n\treturn new_cpu;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t wq_unbound_cpumask;",
      "static DEFINE_PER_CPU(int, wq_rr_cpu_last);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "wq_rr_cpu_last",
            "new_cpu"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new_cpu >= nr_cpu_ids"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first_and",
          "args": [
            "wq_unbound_cpumask",
            "cpu_online_mask"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new_cpu >= nr_cpu_ids"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next_and",
          "args": [
            "new_cpu",
            "wq_unbound_cpumask",
            "cpu_online_mask"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "wq_rr_cpu_last"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "wq_unbound_cpumask"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"workqueue: round-robin CPU selection forced, expect performance impact\\n\""
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "wq_unbound_cpumask"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!wq_debug_force_rr_cpu"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic DEFINE_PER_CPU(int, wq_rr_cpu_last);\n\nstatic int wq_select_unbound_cpu(int cpu)\n{\n\tstatic bool printed_dbg_warning;\n\tint new_cpu;\n\n\tif (likely(!wq_debug_force_rr_cpu)) {\n\t\tif (cpumask_test_cpu(cpu, wq_unbound_cpumask))\n\t\t\treturn cpu;\n\t} else if (!printed_dbg_warning) {\n\t\tpr_warn(\"workqueue: round-robin CPU selection forced, expect performance impact\\n\");\n\t\tprinted_dbg_warning = true;\n\t}\n\n\tif (cpumask_empty(wq_unbound_cpumask))\n\t\treturn cpu;\n\n\tnew_cpu = __this_cpu_read(wq_rr_cpu_last);\n\tnew_cpu = cpumask_next_and(new_cpu, wq_unbound_cpumask, cpu_online_mask);\n\tif (unlikely(new_cpu >= nr_cpu_ids)) {\n\t\tnew_cpu = cpumask_first_and(wq_unbound_cpumask, cpu_online_mask);\n\t\tif (unlikely(new_cpu >= nr_cpu_ids))\n\t\t\treturn cpu;\n\t}\n\t__this_cpu_write(wq_rr_cpu_last, new_cpu);\n\n\treturn new_cpu;\n}"
  },
  {
    "function_name": "is_chained_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1390-1400",
    "snippet": "static bool is_chained_work(struct workqueue_struct *wq)\n{\n\tstruct worker *worker;\n\n\tworker = current_wq_worker();\n\t/*\n\t * Return %true iff I'm a worker executing a work item on @wq.  If\n\t * I'm @worker, it's safe to dereference it without locking.\n\t */\n\treturn worker && worker->current_pwq->wq == wq;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue_internal.h",
          "lines": "66-71",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic bool is_chained_work(struct workqueue_struct *wq)\n{\n\tstruct worker *worker;\n\n\tworker = current_wq_worker();\n\t/*\n\t * Return %true iff I'm a worker executing a work item on @wq.  If\n\t * I'm @worker, it's safe to dereference it without locking.\n\t */\n\treturn worker && worker->current_pwq->wq == wq;\n}"
  },
  {
    "function_name": "insert_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1362-1384",
    "snippet": "static void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack_noalloc(work);\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_worker",
          "args": [
            "pool"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__need_more_worker",
          "args": [
            "pool"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "__need_more_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "778-781",
          "snippet": "static bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pwq",
          "args": [
            "pwq"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "get_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1120-1125",
          "snippet": "static void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&work->entry",
            "head"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_work_pwq",
          "args": [
            "work",
            "pwq",
            "extra_flags"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "634-639",
          "snippet": "static void set_work_pwq(struct work_struct *work, struct pool_workqueue *pwq,\n\t\t\t unsigned long extra_flags)\n{\n\tset_work_data(work, (unsigned long)pwq,\n\t\t      WORK_STRUCT_PENDING | WORK_STRUCT_PWQ | extra_flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void set_work_pwq(struct work_struct *work, struct pool_workqueue *pwq,\n\t\t\t unsigned long extra_flags)\n{\n\tset_work_data(work, (unsigned long)pwq,\n\t\t      WORK_STRUCT_PENDING | WORK_STRUCT_PWQ | extra_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_record_aux_stack_noalloc",
          "args": [
            "work"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack_noalloc(work);\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}"
  },
  {
    "function_name": "try_to_grab_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1268-1347",
    "snippet": "static int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\trcu_read_lock();\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\traw_spin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A cancelable inactive work item must be in the\n\t\t * pwq->inactive_works since a queued barrier can't be\n\t\t * canceled (see the comments in insert_wq_barrier()).\n\t\t *\n\t\t * An inactive work item cannot be grabbed directly because\n\t\t * it might have linked barrier work items which, if left\n\t\t * on the inactive_works list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_INACTIVE)\n\t\t\tpwq_activate_inactive_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, *work_data_bits(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\traw_spin_unlock(&pool->lock);\n\t\trcu_read_unlock();\n\t\treturn 1;\n\t}\n\traw_spin_unlock(&pool->lock);\nfail:\n\trcu_read_unlock();\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_is_canceling",
          "args": [
            "work"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "work_is_canceling",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "765-770",
          "snippet": "static bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "*flags"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_work_pool_and_keep_pending",
          "args": [
            "work",
            "pool->id"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_pool_and_keep_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "641-646",
          "snippet": "static void set_work_pool_and_keep_pending(struct work_struct *work,\n\t\t\t\t\t   int pool_id)\n{\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT,\n\t\t      WORK_STRUCT_PENDING);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pool_and_keep_pending(struct work_struct *work,\n\t\t\t\t\t   int pool_id)\n{\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT,\n\t\t      WORK_STRUCT_PENDING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwq_dec_nr_in_flight",
          "args": [
            "pwq",
            "*work_data_bits(work)"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_dec_nr_in_flight",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1202-1236",
          "snippet": "static void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, unsigned long work_data)\n{\n\tint color = get_work_color(work_data);\n\n\tif (!(work_data & WORK_STRUCT_INACTIVE)) {\n\t\tpwq->nr_active--;\n\t\tif (!list_empty(&pwq->inactive_works)) {\n\t\t\t/* one down, submit an inactive one */\n\t\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\t\tpwq_activate_first_inactive(pwq);\n\t\t}\n\t}\n\n\tpwq->nr_in_flight[color]--;\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, unsigned long work_data)\n{\n\tint color = get_work_color(work_data);\n\n\tif (!(work_data & WORK_STRUCT_INACTIVE)) {\n\t\tpwq->nr_active--;\n\t\tif (!list_empty(&pwq->inactive_works)) {\n\t\t\t/* one down, submit an inactive one */\n\t\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\t\tpwq_activate_first_inactive(pwq);\n\t\t}\n\t}\n\n\tpwq->nr_in_flight[color]--;\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&work->entry"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwq_activate_inactive_work",
          "args": [
            "work"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_activate_inactive_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1171-1181",
          "snippet": "static void pwq_activate_inactive_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_INACTIVE_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pwq_activate_inactive_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_INACTIVE_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_work_deactivate",
          "args": [
            "work"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "debug_work_deactivate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "537-537",
          "snippet": "static inline void debug_work_deactivate(struct work_struct *work) { }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_deactivate(struct work_struct *work) { }"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "696-704",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pool",
          "args": [
            "work"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "746-755",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(work)"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "del_timer(&dwork->timer)"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&dwork->timer"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "*flags"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\trcu_read_lock();\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\traw_spin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A cancelable inactive work item must be in the\n\t\t * pwq->inactive_works since a queued barrier can't be\n\t\t * canceled (see the comments in insert_wq_barrier()).\n\t\t *\n\t\t * An inactive work item cannot be grabbed directly because\n\t\t * it might have linked barrier work items which, if left\n\t\t * on the inactive_works list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_INACTIVE)\n\t\t\tpwq_activate_inactive_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, *work_data_bits(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\traw_spin_unlock(&pool->lock);\n\t\trcu_read_unlock();\n\t\treturn 1;\n\t}\n\traw_spin_unlock(&pool->lock);\nfail:\n\trcu_read_unlock();\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "pwq_dec_nr_in_flight",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1202-1236",
    "snippet": "static void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, unsigned long work_data)\n{\n\tint color = get_work_color(work_data);\n\n\tif (!(work_data & WORK_STRUCT_INACTIVE)) {\n\t\tpwq->nr_active--;\n\t\tif (!list_empty(&pwq->inactive_works)) {\n\t\t\t/* one down, submit an inactive one */\n\t\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\t\tpwq_activate_first_inactive(pwq);\n\t\t}\n\t}\n\n\tpwq->nr_in_flight[color]--;\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pwq",
          "args": [
            "pwq"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1158-1169",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&pwq->wq->first_flusher->done"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&pwq->wq->nr_pwqs_to_flush"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pwq->flush_color != color"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwq_activate_first_inactive",
          "args": [
            "pwq"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_activate_first_inactive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1183-1189",
          "snippet": "static void pwq_activate_first_inactive(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->inactive_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_inactive_work(work);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void pwq_activate_first_inactive(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->inactive_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_inactive_work(work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->inactive_works"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_color",
          "args": [
            "work_data"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_color",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "596-600",
          "snippet": "static int get_work_color(unsigned long work_data)\n{\n\treturn (work_data >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_color(unsigned long work_data)\n{\n\treturn (work_data >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\n\t/*\n\t * nr_active management and WORK_STRUCT_INACTIVE:\n\t *\n\t * When pwq->nr_active >= max_active, new work item is queued to\n\t * pwq->inactive_works instead of pool->worklist and marked with\n\t * WORK_STRUCT_INACTIVE.\n\t *\n\t * All work items marked with WORK_STRUCT_INACTIVE do not participate\n\t * in pwq->nr_active and all work items in pwq->inactive_works are\n\t * marked with WORK_STRUCT_INACTIVE.  But not all WORK_STRUCT_INACTIVE\n\t * work items are in pwq->inactive_works.  Some of them are ready to\n\t * run in pool->worklist or worker->scheduled.  Those work itmes are\n\t * only struct wq_barrier which is used for flush_work() and should\n\t * not participate in pwq->nr_active.  For non-barrier work item, it\n\t * is marked with WORK_STRUCT_INACTIVE iff it is in pwq->inactive_works.\n\t */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tinactive_works;\t/* L: inactive works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, unsigned long work_data)\n{\n\tint color = get_work_color(work_data);\n\n\tif (!(work_data & WORK_STRUCT_INACTIVE)) {\n\t\tpwq->nr_active--;\n\t\tif (!list_empty(&pwq->inactive_works)) {\n\t\t\t/* one down, submit an inactive one */\n\t\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\t\tpwq_activate_first_inactive(pwq);\n\t\t}\n\t}\n\n\tpwq->nr_in_flight[color]--;\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}"
  },
  {
    "function_name": "pwq_activate_first_inactive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1183-1189",
    "snippet": "static void pwq_activate_first_inactive(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->inactive_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_inactive_work(work);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwq_activate_inactive_work",
          "args": [
            "work"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_activate_inactive_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1171-1181",
          "snippet": "static void pwq_activate_inactive_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_INACTIVE_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pwq_activate_inactive_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_INACTIVE_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pwq->inactive_works",
            "structwork_struct",
            "entry"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void pwq_activate_first_inactive(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->inactive_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_inactive_work(work);\n}"
  },
  {
    "function_name": "pwq_activate_inactive_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1171-1181",
    "snippet": "static void pwq_activate_inactive_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_INACTIVE_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "WORK_STRUCT_INACTIVE_BIT",
            "work_data_bits(work)"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_linked_works",
          "args": [
            "work",
            "&pwq->pool->worklist",
            "NULL"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "move_linked_works",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1089-1111",
          "snippet": "static void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->pool->worklist"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_workqueue_activate_work",
          "args": [
            "work"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "696-704",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pwq_activate_inactive_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_INACTIVE_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}"
  },
  {
    "function_name": "put_pwq_unlocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1158-1169",
    "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pwq",
          "args": [
            "pwq"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1158-1169",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
  },
  {
    "function_name": "put_pwq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1134-1150",
    "snippet": "static void put_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tif (likely(--pwq->refcnt))\n\t\treturn;\n\tif (WARN_ON_ONCE(!(pwq->wq->flags & WQ_UNBOUND)))\n\t\treturn;\n\t/*\n\t * @pwq can't be released under pool->lock, bounce to\n\t * pwq_unbound_release_workfn().  This never recurses on the same\n\t * pool->lock as this path is taken only for unbound workqueues and\n\t * the release work item is scheduled on a per-cpu workqueue.  To\n\t * avoid lockdep warning, unbound pool->locks are given lockdep\n\t * subclass of 1 in get_unbound_pool().\n\t */\n\tschedule_work(&pwq->unbound_release_work);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&pwq->unbound_release_work"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(pwq->wq->flags & WQ_UNBOUND)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "--pwq->refcnt"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void put_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tif (likely(--pwq->refcnt))\n\t\treturn;\n\tif (WARN_ON_ONCE(!(pwq->wq->flags & WQ_UNBOUND)))\n\t\treturn;\n\t/*\n\t * @pwq can't be released under pool->lock, bounce to\n\t * pwq_unbound_release_workfn().  This never recurses on the same\n\t * pool->lock as this path is taken only for unbound workqueues and\n\t * the release work item is scheduled on a per-cpu workqueue.  To\n\t * avoid lockdep warning, unbound pool->locks are given lockdep\n\t * subclass of 1 in get_unbound_pool().\n\t */\n\tschedule_work(&pwq->unbound_release_work);\n}"
  },
  {
    "function_name": "get_pwq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1120-1125",
    "snippet": "static void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void show_pwq(struct pool_workqueue *pwq);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pwq->refcnt <= 0"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}"
  },
  {
    "function_name": "move_linked_works",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1089-1111",
    "snippet": "static void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&work->entry",
            "head"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_from",
          "args": [
            "work",
            "n",
            "NULL",
            "entry"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}"
  },
  {
    "function_name": "find_worker_executing_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1058-1070",
    "snippet": "static struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "pool->busy_hash",
            "worker",
            "hentry",
            "(unsigned long)work"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "worker_clr_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "1006-1023",
    "snippet": "static inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&pool->nr_running"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "worker->task != current"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}"
  },
  {
    "function_name": "worker_set_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "981-994",
    "snippet": "static inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&pool->nr_running"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "worker->task != current"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}"
  },
  {
    "function_name": "wq_worker_last_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "964-969",
    "snippet": "work_func_t wq_worker_last_func(struct task_struct *task)\n{\n\tstruct worker *worker = kthread_data(task);\n\n\treturn worker->last_func;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_data",
          "args": [
            "task"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "233-236",
          "snippet": "void *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nwork_func_t wq_worker_last_func(struct task_struct *task)\n{\n\tstruct worker *worker = kthread_data(task);\n\n\treturn worker->last_func;\n}"
  },
  {
    "function_name": "wq_worker_sleeping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "888-938",
    "snippet": "void wq_worker_sleeping(struct task_struct *task)\n{\n\tstruct worker *next, *worker = kthread_data(task);\n\tstruct worker_pool *pool;\n\n\t/*\n\t * Rescuers, which may not have all the fields set up like normal\n\t * workers, also reach here, let's not access anything before\n\t * checking NOT_RUNNING.\n\t */\n\tif (worker->flags & WORKER_NOT_RUNNING)\n\t\treturn;\n\n\tpool = worker->pool;\n\n\t/* Return if preempted before wq_worker_running() was reached */\n\tif (worker->sleeping)\n\t\treturn;\n\n\tworker->sleeping = 1;\n\traw_spin_lock_irq(&pool->lock);\n\n\t/*\n\t * Recheck in case unbind_workers() preempted us. We don't\n\t * want to decrement nr_running after the worker is unbound\n\t * and nr_running has been reset.\n\t */\n\tif (worker->flags & WORKER_NOT_RUNNING) {\n\t\traw_spin_unlock_irq(&pool->lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * The counterpart of the following dec_and_test, implied mb,\n\t * worklist not empty test sequence is in insert_work().\n\t * Please read comment there.\n\t *\n\t * NOT_RUNNING is clear.  This means that we're bound to and\n\t * running on the local cpu w/ rq lock held and preemption\n\t * disabled, which in turn means that none else could be\n\t * manipulating idle_list, so dereferencing idle_list without pool\n\t * lock is safe.\n\t */\n\tif (atomic_dec_and_test(&pool->nr_running) &&\n\t    !list_empty(&pool->worklist)) {\n\t\tnext = first_idle_worker(pool);\n\t\tif (next)\n\t\t\twake_up_process(next->task);\n\t}\n\traw_spin_unlock_irq(&pool->lock);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "next->task"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_idle_worker",
          "args": [
            "pool"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "first_idle_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "830-836",
          "snippet": "static struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->worklist"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&pool->nr_running"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_data",
          "args": [
            "task"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "233-236",
          "snippet": "void *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid wq_worker_sleeping(struct task_struct *task)\n{\n\tstruct worker *next, *worker = kthread_data(task);\n\tstruct worker_pool *pool;\n\n\t/*\n\t * Rescuers, which may not have all the fields set up like normal\n\t * workers, also reach here, let's not access anything before\n\t * checking NOT_RUNNING.\n\t */\n\tif (worker->flags & WORKER_NOT_RUNNING)\n\t\treturn;\n\n\tpool = worker->pool;\n\n\t/* Return if preempted before wq_worker_running() was reached */\n\tif (worker->sleeping)\n\t\treturn;\n\n\tworker->sleeping = 1;\n\traw_spin_lock_irq(&pool->lock);\n\n\t/*\n\t * Recheck in case unbind_workers() preempted us. We don't\n\t * want to decrement nr_running after the worker is unbound\n\t * and nr_running has been reset.\n\t */\n\tif (worker->flags & WORKER_NOT_RUNNING) {\n\t\traw_spin_unlock_irq(&pool->lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * The counterpart of the following dec_and_test, implied mb,\n\t * worklist not empty test sequence is in insert_work().\n\t * Please read comment there.\n\t *\n\t * NOT_RUNNING is clear.  This means that we're bound to and\n\t * running on the local cpu w/ rq lock held and preemption\n\t * disabled, which in turn means that none else could be\n\t * manipulating idle_list, so dereferencing idle_list without pool\n\t * lock is safe.\n\t */\n\tif (atomic_dec_and_test(&pool->nr_running) &&\n\t    !list_empty(&pool->worklist)) {\n\t\tnext = first_idle_worker(pool);\n\t\tif (next)\n\t\t\twake_up_process(next->task);\n\t}\n\traw_spin_unlock_irq(&pool->lock);\n}"
  },
  {
    "function_name": "wq_worker_running",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "861-879",
    "snippet": "void wq_worker_running(struct task_struct *task)\n{\n\tstruct worker *worker = kthread_data(task);\n\n\tif (!worker->sleeping)\n\t\treturn;\n\n\t/*\n\t * If preempted by unbind_workers() between the WORKER_NOT_RUNNING check\n\t * and the nr_running increment below, we may ruin the nr_running reset\n\t * and leave with an unexpected pool->nr_running == 1 on the newly unbound\n\t * pool. Protect against such race.\n\t */\n\tpreempt_disable();\n\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\tatomic_inc(&worker->pool->nr_running);\n\tpreempt_enable();\n\tworker->sleeping = 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&worker->pool->nr_running"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_data",
          "args": [
            "task"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "233-236",
          "snippet": "void *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid wq_worker_running(struct task_struct *task)\n{\n\tstruct worker *worker = kthread_data(task);\n\n\tif (!worker->sleeping)\n\t\treturn;\n\n\t/*\n\t * If preempted by unbind_workers() between the WORKER_NOT_RUNNING check\n\t * and the nr_running increment below, we may ruin the nr_running reset\n\t * and leave with an unexpected pool->nr_running == 1 on the newly unbound\n\t * pool. Protect against such race.\n\t */\n\tpreempt_disable();\n\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\tatomic_inc(&worker->pool->nr_running);\n\tpreempt_enable();\n\tworker->sleeping = 0;\n}"
  },
  {
    "function_name": "wake_up_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "847-853",
    "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "worker->task"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "worker"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_idle_worker",
          "args": [
            "pool"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "first_idle_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "830-836",
          "snippet": "static struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
  },
  {
    "function_name": "first_idle_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "830-836",
    "snippet": "static struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pool->idle_list",
            "structworker",
            "entry"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "list_empty(&pool->idle_list)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->idle_list"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}"
  },
  {
    "function_name": "too_many_workers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "816-823",
    "snippet": "static bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}"
  },
  {
    "function_name": "need_to_create_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "810-813",
    "snippet": "static bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "may_start_working",
          "args": [
            "pool"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "may_start_working",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "797-800",
          "snippet": "static bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_more_worker",
          "args": [
            "pool"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "need_more_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "791-794",
          "snippet": "static bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}"
  },
  {
    "function_name": "keep_working",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "803-807",
    "snippet": "static bool keep_working(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) &&\n\t\tatomic_read(&pool->nr_running) <= 1;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pool->nr_running"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->worklist"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool keep_working(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) &&\n\t\tatomic_read(&pool->nr_running) <= 1;\n}"
  },
  {
    "function_name": "may_start_working",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "797-800",
    "snippet": "static bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}"
  },
  {
    "function_name": "need_more_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "791-794",
    "snippet": "static bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__need_more_worker",
          "args": [
            "pool"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "__need_more_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "778-781",
          "snippet": "static bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->worklist"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}"
  },
  {
    "function_name": "__need_more_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "778-781",
    "snippet": "static bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pool->nr_running"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}"
  },
  {
    "function_name": "work_is_canceling",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "765-770",
    "snippet": "static bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&work->data"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}"
  },
  {
    "function_name": "mark_work_canceling",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "757-763",
    "snippet": "static void mark_work_canceling(struct work_struct *work)\n{\n\tunsigned long pool_id = get_work_pool_id(work);\n\n\tpool_id <<= WORK_OFFQ_POOL_SHIFT;\n\tset_work_data(work, pool_id | WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_work_data",
          "args": [
            "work",
            "pool_id | WORK_OFFQ_CANCELING",
            "WORK_STRUCT_PENDING"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "627-632",
          "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pool_id",
          "args": [
            "work"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "746-755",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void mark_work_canceling(struct work_struct *work)\n{\n\tunsigned long pool_id = get_work_pool_id(work);\n\n\tpool_id <<= WORK_OFFQ_POOL_SHIFT;\n\tset_work_data(work, pool_id | WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING);\n}"
  },
  {
    "function_name": "get_work_pool_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "746-755",
    "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&work->data"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
  },
  {
    "function_name": "get_work_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "721-737",
    "snippet": "static struct worker_pool *get_work_pool(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\tint pool_id;\n\n\tassert_rcu_or_pool_mutex();\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool;\n\n\tpool_id = data >> WORK_OFFQ_POOL_SHIFT;\n\tif (pool_id == WORK_OFFQ_POOL_NONE)\n\t\treturn NULL;\n\n\treturn idr_find(&worker_pool_idr, pool_id);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static DEFINE_IDR(worker_pool_idr);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&worker_pool_idr",
            "pool_id"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_rcu_or_pool_mutex",
          "args": [],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&work->data"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic struct worker_pool *get_work_pool(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\tint pool_id;\n\n\tassert_rcu_or_pool_mutex();\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool;\n\n\tpool_id = data >> WORK_OFFQ_POOL_SHIFT;\n\tif (pool_id == WORK_OFFQ_POOL_NONE)\n\t\treturn NULL;\n\n\treturn idr_find(&worker_pool_idr, pool_id);\n}"
  },
  {
    "function_name": "get_work_pwq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "696-704",
    "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&work->data"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "clear_work_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "690-694",
    "snippet": "static void clear_work_data(struct work_struct *work)\n{\n\tsmp_wmb();\t/* see set_work_pool_and_clear_pending() */\n\tset_work_data(work, WORK_STRUCT_NO_POOL, 0);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_work_data",
          "args": [
            "work",
            "WORK_STRUCT_NO_POOL",
            "0"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "627-632",
          "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void clear_work_data(struct work_struct *work)\n{\n\tsmp_wmb();\t/* see set_work_pool_and_clear_pending() */\n\tset_work_data(work, WORK_STRUCT_NO_POOL, 0);\n}"
  },
  {
    "function_name": "set_work_pool_and_clear_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "648-688",
    "snippet": "static void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to queue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_work_data",
          "args": [
            "work",
            "(unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT",
            "0"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "627-632",
          "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to queue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}"
  },
  {
    "function_name": "set_work_pool_and_keep_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "641-646",
    "snippet": "static void set_work_pool_and_keep_pending(struct work_struct *work,\n\t\t\t\t\t   int pool_id)\n{\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT,\n\t\t      WORK_STRUCT_PENDING);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_work_data",
          "args": [
            "work",
            "(unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT",
            "WORK_STRUCT_PENDING"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "627-632",
          "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pool_and_keep_pending(struct work_struct *work,\n\t\t\t\t\t   int pool_id)\n{\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT,\n\t\t      WORK_STRUCT_PENDING);\n}"
  },
  {
    "function_name": "set_work_pwq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "634-639",
    "snippet": "static void set_work_pwq(struct work_struct *work, struct pool_workqueue *pwq,\n\t\t\t unsigned long extra_flags)\n{\n\tset_work_data(work, (unsigned long)pwq,\n\t\t      WORK_STRUCT_PENDING | WORK_STRUCT_PWQ | extra_flags);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void show_pwq(struct pool_workqueue *pwq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_work_data",
          "args": [
            "work",
            "(unsigned long)pwq",
            "WORK_STRUCT_PENDING | WORK_STRUCT_PWQ | extra_flags"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "627-632",
          "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstatic void set_work_pwq(struct work_struct *work, struct pool_workqueue *pwq,\n\t\t\t unsigned long extra_flags)\n{\n\tset_work_data(work, (unsigned long)pwq,\n\t\t      WORK_STRUCT_PENDING | WORK_STRUCT_PWQ | extra_flags);\n}"
  },
  {
    "function_name": "set_work_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "627-632",
    "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&work->data",
            "data | flags | work_static(work)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_static",
          "args": [
            "work"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!work_pending(work)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_pending",
          "args": [
            "work"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
  },
  {
    "function_name": "work_next_color",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "602-605",
    "snippet": "static int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}"
  },
  {
    "function_name": "get_work_color",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "596-600",
    "snippet": "static int get_work_color(unsigned long work_data)\n{\n\treturn (work_data >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_color(unsigned long work_data)\n{\n\treturn (work_data >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}"
  },
  {
    "function_name": "work_color_to_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "591-594",
    "snippet": "static unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}"
  },
  {
    "function_name": "unbound_pwq_by_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "574-589",
    "snippet": "static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "wq->numa_pwq_tbl[node]"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "node == NUMA_NO_NODE"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_rcu_or_wq_mutex_or_pool_mutex",
          "args": [
            "wq"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}"
  },
  {
    "function_name": "worker_pool_assign_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "547-560",
    "snippet": "static int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static DEFINE_IDR(worker_pool_idr);",
      "static void show_one_worker_pool(struct worker_pool *pool);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "&worker_pool_idr",
            "pool",
            "0",
            "WORK_OFFQ_POOL_NONE",
            "GFP_KERNEL"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "319-330",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "debug_work_deactivate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "537-537",
    "snippet": "static inline void debug_work_deactivate(struct work_struct *work) { }",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_deactivate(struct work_struct *work) { }"
  },
  {
    "function_name": "debug_work_activate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "536-536",
    "snippet": "static inline void debug_work_activate(struct work_struct *work) { }",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_activate(struct work_struct *work) { }"
  },
  {
    "function_name": "destroy_delayed_work_on_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "528-532",
    "snippet": "void destroy_delayed_work_on_stack(struct delayed_work *work)\n{\n\tdestroy_timer_on_stack(&work->timer);\n\tdebug_object_free(&work->work, &work_debug_descr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "&work->work",
            "&work_debug_descr"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_timer_on_stack",
          "args": [
            "&work->timer"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_timer_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "757-760",
          "snippet": "void destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_delayed_work_on_stack(struct delayed_work *work)\n{\n\tdestroy_timer_on_stack(&work->timer);\n\tdebug_object_free(&work->work, &work_debug_descr);\n}"
  },
  {
    "function_name": "destroy_work_on_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "522-525",
    "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
  },
  {
    "function_name": "__init_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "513-519",
    "snippet": "void __init_work(struct work_struct *work, int onstack)\n{\n\tif (onstack)\n\t\tdebug_object_init_on_stack(work, &work_debug_descr);\n\telse\n\t\tdebug_object_init(work, &work_debug_descr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_init",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_object_init_on_stack",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid __init_work(struct work_struct *work, int onstack)\n{\n\tif (onstack)\n\t\tdebug_object_init_on_stack(work, &work_debug_descr);\n\telse\n\t\tdebug_object_init(work, &work_debug_descr);\n}"
  },
  {
    "function_name": "debug_work_deactivate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "508-511",
    "snippet": "static inline void debug_work_deactivate(struct work_struct *work)\n{\n\tdebug_object_deactivate(work, &work_debug_descr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_deactivate",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_deactivate(struct work_struct *work)\n{\n\tdebug_object_deactivate(work, &work_debug_descr);\n}"
  },
  {
    "function_name": "debug_work_activate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "503-506",
    "snippet": "static inline void debug_work_activate(struct work_struct *work)\n{\n\tdebug_object_activate(work, &work_debug_descr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_activate",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_activate(struct work_struct *work)\n{\n\tdebug_object_activate(work, &work_debug_descr);\n}"
  },
  {
    "function_name": "work_fixup_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "481-493",
    "snippet": "static bool work_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct work_struct *work = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tcancel_work_sync(work);\n\t\tdebug_object_free(work, &work_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "work"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_work_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3214-3217",
          "snippet": "bool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct work_struct *work = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tcancel_work_sync(work);\n\t\tdebug_object_free(work, &work_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "work_fixup_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "463-475",
    "snippet": "static bool work_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct work_struct *work = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tcancel_work_sync(work);\n\t\tdebug_object_init(work, &work_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_init",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "work"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_work_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3214-3217",
          "snippet": "bool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct work_struct *work = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tcancel_work_sync(work);\n\t\tdebug_object_init(work, &work_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "work_is_static_object",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "452-457",
    "snippet": "static bool work_is_static_object(void *addr)\n{\n\tstruct work_struct *work = addr;\n\n\treturn test_bit(WORK_STRUCT_STATIC_BIT, work_data_bits(work));\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WORK_STRUCT_STATIC_BIT",
            "work_data_bits(work)"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_is_static_object(void *addr)\n{\n\tstruct work_struct *work = addr;\n\n\treturn test_bit(WORK_STRUCT_STATIC_BIT, work_data_bits(work));\n}"
  },
  {
    "function_name": "work_debug_hint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
    "lines": "447-450",
    "snippet": "static void *work_debug_hint(void *addr)\n{\n\treturn ((struct work_struct *) addr)->func;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/kvm_para.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void *work_debug_hint(void *addr)\n{\n\treturn ((struct work_struct *) addr)->func;\n}"
  }
]