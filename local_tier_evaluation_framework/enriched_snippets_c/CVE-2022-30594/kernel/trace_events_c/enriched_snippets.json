[
  {
    "function_name": "event_trace_self_tests_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3964-3972",
    "snippet": "static __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trace_self_test_with_function",
          "args": [],
          "line": 3968
        },
        "resolved": true,
        "details": {
          "function_name": "event_trace_self_test_with_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3959-3961",
          "snippet": "static __init void event_trace_self_test_with_function(void)\n{\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init void event_trace_self_test_with_function(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_trace_self_tests",
          "args": [],
          "line": 3967
        },
        "resolved": true,
        "details": {
          "function_name": "event_trace_self_tests_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3964-3972",
          "snippet": "static __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trace_self_test_with_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3959-3961",
    "snippet": "static __init void event_trace_self_test_with_function(void)\n{\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init void event_trace_self_test_with_function(void)\n{\n}"
  },
  {
    "function_name": "event_trace_self_test_with_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3941-3957",
    "snippet": "static __init void event_trace_self_test_with_function(void)\n{\n\tint ret;\n\n\tevent_trace_file.tr = top_trace_array();\n\tif (WARN_ON(!event_trace_file.tr))\n\t\treturn;\n\n\tret = register_ftrace_function(&trace_ops);\n\tif (WARN_ON(ret < 0)) {\n\t\tpr_info(\"Failed to enable function tracer for event tests\\n\");\n\t\treturn;\n\t}\n\tpr_info(\"Running tests again, along with the function tracer\\n\");\n\tevent_trace_self_tests();\n\tunregister_ftrace_function(&trace_ops);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&trace_ops"
          ],
          "line": 3956
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_trace_self_tests",
          "args": [],
          "line": 3955
        },
        "resolved": true,
        "details": {
          "function_name": "event_trace_self_tests_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3964-3972",
          "snippet": "static __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Running tests again, along with the function tracer\\n\""
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to enable function tracer for event tests\\n\""
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 3950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!event_trace_file.tr"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 3945
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "411-422",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init void event_trace_self_test_with_function(void)\n{\n\tint ret;\n\n\tevent_trace_file.tr = top_trace_array();\n\tif (WARN_ON(!event_trace_file.tr))\n\t\treturn;\n\n\tret = register_ftrace_function(&trace_ops);\n\tif (WARN_ON(ret < 0)) {\n\t\tpr_info(\"Failed to enable function tracer for event tests\\n\");\n\t\treturn;\n\t}\n\tpr_info(\"Running tests again, along with the function tracer\\n\");\n\tevent_trace_self_tests();\n\tunregister_ftrace_function(&trace_ops);\n}"
  },
  {
    "function_name": "function_test_events_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3901-3934",
    "snippet": "static void __init\nfunction_test_events_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *regs)\n{\n\tstruct trace_buffer *buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_entry *entry;\n\tunsigned int trace_ctx;\n\tlong disabled;\n\tint cpu;\n\n\ttrace_ctx = tracing_gen_ctx();\n\tpreempt_disable_notrace();\n\tcpu = raw_smp_processor_id();\n\tdisabled = atomic_inc_return(&per_cpu(ftrace_test_event_disable, cpu));\n\n\tif (disabled != 1)\n\t\tgoto out;\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, &event_trace_file,\n\t\t\t\t\t\tTRACE_FN, sizeof(*entry),\n\t\t\t\t\t\ttrace_ctx);\n\tif (!event)\n\t\tgoto out;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->parent_ip\t\t= parent_ip;\n\n\tevent_trigger_unlock_commit(&event_trace_file, buffer, event,\n\t\t\t\t    entry, trace_ctx);\n out:\n\tatomic_dec(&per_cpu(ftrace_test_event_disable, cpu));\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&per_cpu(ftrace_test_event_disable, cpu)"
          ],
          "line": 3932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "ftrace_test_event_disable",
            "cpu"
          ],
          "line": 3932
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_trigger_unlock_commit",
          "args": [
            "&event_trace_file",
            "buffer",
            "event",
            "entry",
            "trace_ctx"
          ],
          "line": 3929
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_unlock_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1408-1421",
          "snippet": "static inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct trace_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned int trace_ctx)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, trace_ctx);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct trace_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned int trace_ctx)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, trace_ctx);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 3925
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_lock_reserve",
          "args": [
            "&buffer",
            "&event_trace_file",
            "TRACE_FN",
            "sizeof(*entry)",
            "trace_ctx"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2739-2819",
          "snippet": "struct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct trace_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\tstruct ring_buffer_event *entry;\n\tstruct trace_array *tr = trace_file->tr;\n\tint val;\n\n\t*current_rb = tr->array_buffer.buffer;\n\n\tif (!tr->no_filter_buffering_ref &&\n\t    (trace_file->flags & (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED))) {\n\t\tpreempt_disable_notrace();\n\t\t/*\n\t\t * Filtering is on, so try to use the per cpu buffer first.\n\t\t * This buffer will simulate a ring_buffer_event,\n\t\t * where the type_len is zero and the array[0] will\n\t\t * hold the full length.\n\t\t * (see include/linux/ring-buffer.h for details on\n\t\t *  how the ring_buffer_event is structured).\n\t\t *\n\t\t * Using a temp buffer during filtering and copying it\n\t\t * on a matched filter is quicker than writing directly\n\t\t * into the ring buffer and then discarding it when\n\t\t * it doesn't match. That is because the discard\n\t\t * requires several atomic operations to get right.\n\t\t * Copying on match and doing nothing on a failed match\n\t\t * is still quicker than no copy on match, but having\n\t\t * to discard out of the ring buffer on a failed match.\n\t\t */\n\t\tif ((entry = __this_cpu_read(trace_buffered_event))) {\n\t\t\tint max_len = PAGE_SIZE - struct_size(entry, array, 1);\n\n\t\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\n\t\t\t/*\n\t\t\t * Preemption is disabled, but interrupts and NMIs\n\t\t\t * can still come in now. If that happens after\n\t\t\t * the above increment, then it will have to go\n\t\t\t * back to the old method of allocating the event\n\t\t\t * on the ring buffer, and if the filter fails, it\n\t\t\t * will have to call ring_buffer_discard_commit()\n\t\t\t * to remove it.\n\t\t\t *\n\t\t\t * Need to also check the unlikely case that the\n\t\t\t * length is bigger than the temp buffer size.\n\t\t\t * If that happens, then the reserve is pretty much\n\t\t\t * guaranteed to fail, as the ring buffer currently\n\t\t\t * only allows events less than a page. But that may\n\t\t\t * change in the future, so let the ring buffer reserve\n\t\t\t * handle the failure in that case.\n\t\t\t */\n\t\t\tif (val == 1 && likely(len <= max_len)) {\n\t\t\t\ttrace_event_setup(entry, type, trace_ctx);\n\t\t\t\tentry->array[0] = len;\n\t\t\t\t/* Return with preemption disabled */\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t\t}\n\t\t/* __trace_buffer_lock_reserve() disables preemption */\n\t\tpreempt_enable_notrace();\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t    trace_ctx);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the trigger to use. It's recursive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t\t    trace_ctx);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static struct trace_buffer *temp_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic struct trace_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct trace_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\tstruct ring_buffer_event *entry;\n\tstruct trace_array *tr = trace_file->tr;\n\tint val;\n\n\t*current_rb = tr->array_buffer.buffer;\n\n\tif (!tr->no_filter_buffering_ref &&\n\t    (trace_file->flags & (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED))) {\n\t\tpreempt_disable_notrace();\n\t\t/*\n\t\t * Filtering is on, so try to use the per cpu buffer first.\n\t\t * This buffer will simulate a ring_buffer_event,\n\t\t * where the type_len is zero and the array[0] will\n\t\t * hold the full length.\n\t\t * (see include/linux/ring-buffer.h for details on\n\t\t *  how the ring_buffer_event is structured).\n\t\t *\n\t\t * Using a temp buffer during filtering and copying it\n\t\t * on a matched filter is quicker than writing directly\n\t\t * into the ring buffer and then discarding it when\n\t\t * it doesn't match. That is because the discard\n\t\t * requires several atomic operations to get right.\n\t\t * Copying on match and doing nothing on a failed match\n\t\t * is still quicker than no copy on match, but having\n\t\t * to discard out of the ring buffer on a failed match.\n\t\t */\n\t\tif ((entry = __this_cpu_read(trace_buffered_event))) {\n\t\t\tint max_len = PAGE_SIZE - struct_size(entry, array, 1);\n\n\t\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\n\t\t\t/*\n\t\t\t * Preemption is disabled, but interrupts and NMIs\n\t\t\t * can still come in now. If that happens after\n\t\t\t * the above increment, then it will have to go\n\t\t\t * back to the old method of allocating the event\n\t\t\t * on the ring buffer, and if the filter fails, it\n\t\t\t * will have to call ring_buffer_discard_commit()\n\t\t\t * to remove it.\n\t\t\t *\n\t\t\t * Need to also check the unlikely case that the\n\t\t\t * length is bigger than the temp buffer size.\n\t\t\t * If that happens, then the reserve is pretty much\n\t\t\t * guaranteed to fail, as the ring buffer currently\n\t\t\t * only allows events less than a page. But that may\n\t\t\t * change in the future, so let the ring buffer reserve\n\t\t\t * handle the failure in that case.\n\t\t\t */\n\t\t\tif (val == 1 && likely(len <= max_len)) {\n\t\t\t\ttrace_event_setup(entry, type, trace_ctx);\n\t\t\t\tentry->array[0] = len;\n\t\t\t\t/* Return with preemption disabled */\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t\t}\n\t\t/* __trace_buffer_lock_reserve() disables preemption */\n\t\tpreempt_enable_notrace();\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t    trace_ctx);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the trigger to use. It's recursive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t\t    trace_ctx);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&per_cpu(ftrace_test_event_disable, cpu)"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 3913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx",
          "args": [],
          "line": 3912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __init\nfunction_test_events_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct ftrace_regs *regs)\n{\n\tstruct trace_buffer *buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_entry *entry;\n\tunsigned int trace_ctx;\n\tlong disabled;\n\tint cpu;\n\n\ttrace_ctx = tracing_gen_ctx();\n\tpreempt_disable_notrace();\n\tcpu = raw_smp_processor_id();\n\tdisabled = atomic_inc_return(&per_cpu(ftrace_test_event_disable, cpu));\n\n\tif (disabled != 1)\n\t\tgoto out;\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, &event_trace_file,\n\t\t\t\t\t\tTRACE_FN, sizeof(*entry),\n\t\t\t\t\t\ttrace_ctx);\n\tif (!event)\n\t\tgoto out;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->parent_ip\t\t= parent_ip;\n\n\tevent_trigger_unlock_commit(&event_trace_file, buffer, event,\n\t\t\t\t    entry, trace_ctx);\n out:\n\tatomic_dec(&per_cpu(ftrace_test_event_disable, cpu));\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "event_trace_self_tests",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3785-3893",
    "snippet": "static __init void event_trace_self_tests(void)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tstruct event_subsystem *system;\n\tstruct trace_array *tr;\n\tint ret;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn;\n\n\tpr_info(\"Running tests on trace events:\\n\");\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\n\t\t/* Only test those that have a probe */\n\t\tif (!call->class || !call->class->probe)\n\t\t\tcontinue;\n\n/*\n * Testing syscall events here is pretty useless, but\n * we still do it if configured. But this is time consuming.\n * What we really need is a user thread to perform the\n * syscalls as we test.\n */\n#ifndef CONFIG_EVENT_TRACE_TEST_SYSCALLS\n\t\tif (call->class->system &&\n\t\t    strcmp(call->class->system, \"syscalls\") == 0)\n\t\t\tcontinue;\n#endif\n\n\t\tpr_info(\"Testing event %s: \", trace_event_name(call));\n\n\t\t/*\n\t\t * If an event is already enabled, someone is using\n\t\t * it and the self test should not be on.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED) {\n\t\t\tpr_warn(\"Enabled event during self test!\\n\");\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tftrace_event_enable_disable(file, 1);\n\t\tevent_test_stuff();\n\t\tftrace_event_enable_disable(file, 0);\n\n\t\tpr_cont(\"OK\\n\");\n\t}\n\n\t/* Now test at the sub system level */\n\n\tpr_info(\"Running tests on trace event systems:\\n\");\n\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\n\t\tsystem = dir->subsystem;\n\n\t\t/* the ftrace system is special, skip it */\n\t\tif (strcmp(system->name, \"ftrace\") == 0)\n\t\t\tcontinue;\n\n\t\tpr_info(\"Testing event system %s: \", system->name);\n\n\t\tret = __ftrace_set_clr_event(tr, NULL, system->name, NULL, 1);\n\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\tpr_warn(\"error enabling system %s\\n\",\n\t\t\t\tsystem->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent_test_stuff();\n\n\t\tret = __ftrace_set_clr_event(tr, NULL, system->name, NULL, 0);\n\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\tpr_warn(\"error disabling system %s\\n\",\n\t\t\t\tsystem->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_cont(\"OK\\n\");\n\t}\n\n\t/* Test with all events enabled */\n\n\tpr_info(\"Running tests on all trace events:\\n\");\n\tpr_info(\"Testing all events: \");\n\n\tret = __ftrace_set_clr_event(tr, NULL, NULL, NULL, 1);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error enabling all events\\n\");\n\t\treturn;\n\t}\n\n\tevent_test_stuff();\n\n\t/* reset sysname */\n\tret = __ftrace_set_clr_event(tr, NULL, NULL, NULL, 0);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error disabling all events\\n\");\n\t\treturn;\n\t}\n\n\tpr_cont(\"OK\\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"OK\\n\""
          ],
          "line": 3892
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error disabling all events\\n\""
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event",
          "args": [
            "tr",
            "NULL",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 3886
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1035-1045",
          "snippet": "static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_test_stuff",
          "args": [],
          "line": 3883
        },
        "resolved": true,
        "details": {
          "function_name": "event_test_stuff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3772-3779",
          "snippet": "static __init void event_test_stuff(void)\n{\n\tstruct task_struct *test_thread;\n\n\ttest_thread = kthread_run(event_test_thread, NULL, \"test-events\");\n\tmsleep(1);\n\tkthread_stop(test_thread);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init void event_test_stuff(void)\n{\n\tstruct task_struct *test_thread;\n\n\ttest_thread = kthread_run(event_test_thread, NULL, \"test-events\");\n\tmsleep(1);\n\tkthread_stop(test_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error enabling all events\\n\""
          ],
          "line": 3879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing all events: \""
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Running tests on all trace events:\\n\""
          ],
          "line": 3874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error disabling system %s\\n\"",
            "system->name"
          ],
          "line": 3864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error enabling system %s\\n\"",
            "system->name"
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 3854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing event system %s: \"",
            "system->name"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "system->name",
            "\"ftrace\""
          ],
          "line": 3848
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dir",
            "&tr->systems",
            "list"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Running tests on trace event systems:\\n\""
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_event_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 3834
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "700-704",
          "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 3828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Enabled event during self test!\\n\""
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing event %s: \"",
            "trace_event_name(call)"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Running tests on trace events:\\n\""
          ],
          "line": 3798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 3794
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "411-422",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic __init void event_trace_self_tests(void)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tstruct event_subsystem *system;\n\tstruct trace_array *tr;\n\tint ret;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn;\n\n\tpr_info(\"Running tests on trace events:\\n\");\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\n\t\t/* Only test those that have a probe */\n\t\tif (!call->class || !call->class->probe)\n\t\t\tcontinue;\n\n/*\n * Testing syscall events here is pretty useless, but\n * we still do it if configured. But this is time consuming.\n * What we really need is a user thread to perform the\n * syscalls as we test.\n */\n#ifndef CONFIG_EVENT_TRACE_TEST_SYSCALLS\n\t\tif (call->class->system &&\n\t\t    strcmp(call->class->system, \"syscalls\") == 0)\n\t\t\tcontinue;\n#endif\n\n\t\tpr_info(\"Testing event %s: \", trace_event_name(call));\n\n\t\t/*\n\t\t * If an event is already enabled, someone is using\n\t\t * it and the self test should not be on.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED) {\n\t\t\tpr_warn(\"Enabled event during self test!\\n\");\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tftrace_event_enable_disable(file, 1);\n\t\tevent_test_stuff();\n\t\tftrace_event_enable_disable(file, 0);\n\n\t\tpr_cont(\"OK\\n\");\n\t}\n\n\t/* Now test at the sub system level */\n\n\tpr_info(\"Running tests on trace event systems:\\n\");\n\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\n\t\tsystem = dir->subsystem;\n\n\t\t/* the ftrace system is special, skip it */\n\t\tif (strcmp(system->name, \"ftrace\") == 0)\n\t\t\tcontinue;\n\n\t\tpr_info(\"Testing event system %s: \", system->name);\n\n\t\tret = __ftrace_set_clr_event(tr, NULL, system->name, NULL, 1);\n\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\tpr_warn(\"error enabling system %s\\n\",\n\t\t\t\tsystem->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent_test_stuff();\n\n\t\tret = __ftrace_set_clr_event(tr, NULL, system->name, NULL, 0);\n\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\tpr_warn(\"error disabling system %s\\n\",\n\t\t\t\tsystem->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_cont(\"OK\\n\");\n\t}\n\n\t/* Test with all events enabled */\n\n\tpr_info(\"Running tests on all trace events:\\n\");\n\tpr_info(\"Testing all events: \");\n\n\tret = __ftrace_set_clr_event(tr, NULL, NULL, NULL, 1);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error enabling all events\\n\");\n\t\treturn;\n\t}\n\n\tevent_test_stuff();\n\n\t/* reset sysname */\n\tret = __ftrace_set_clr_event(tr, NULL, NULL, NULL, 0);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error disabling all events\\n\");\n\t\treturn;\n\t}\n\n\tpr_cont(\"OK\\n\");\n}"
  },
  {
    "function_name": "event_test_stuff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3772-3779",
    "snippet": "static __init void event_test_stuff(void)\n{\n\tstruct task_struct *test_thread;\n\n\ttest_thread = kthread_run(event_test_thread, NULL, \"test-events\");\n\tmsleep(1);\n\tkthread_stop(test_thread);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "test_thread"
          ],
          "line": 3778
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1"
          ],
          "line": 3777
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "event_test_thread",
            "NULL",
            "\"test-events\""
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init void event_test_stuff(void)\n{\n\tstruct task_struct *test_thread;\n\n\ttest_thread = kthread_run(event_test_thread, NULL, \"test-events\");\n\tmsleep(1);\n\tkthread_stop(test_thread);\n}"
  },
  {
    "function_name": "event_test_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3747-3767",
    "snippet": "static __init int event_test_thread(void *unused)\n{\n\tvoid *test_malloc;\n\n\ttest_malloc = kmalloc(1234, GFP_KERNEL);\n\tif (!test_malloc)\n\t\tpr_info(\"failed to kmalloc\\n\");\n\n\tschedule_on_each_cpu(test_work);\n\n\tkfree(test_malloc);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 3761
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 3760
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "test_malloc"
          ],
          "line": 3757
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_on_each_cpu",
          "args": [
            "test_work"
          ],
          "line": 3755
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_on_each_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3327-3351",
          "snippet": "int schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tcpus_read_unlock();\n\tfree_percpu(works);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tcpus_read_unlock();\n\tfree_percpu(works);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"failed to kmalloc\\n\""
          ],
          "line": 3753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "1234",
            "GFP_KERNEL"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_test_thread(void *unused)\n{\n\tvoid *test_malloc;\n\n\ttest_malloc = kmalloc(1234, GFP_KERNEL);\n\tif (!test_malloc)\n\t\tpr_info(\"failed to kmalloc\\n\");\n\n\tschedule_on_each_cpu(test_work);\n\n\tkfree(test_malloc);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "test_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3734-3745",
    "snippet": "static __init void test_work(struct work_struct *dummy)\n{\n\tspin_lock(&test_spinlock);\n\tspin_lock_irq(&test_spinlock_irq);\n\tudelay(1);\n\tspin_unlock_irq(&test_spinlock_irq);\n\tspin_unlock(&test_spinlock);\n\n\tmutex_lock(&test_mutex);\n\tmsleep(1);\n\tmutex_unlock(&test_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&test_mutex"
          ],
          "line": 3744
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1"
          ],
          "line": 3743
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&test_mutex"
          ],
          "line": 3742
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&test_spinlock"
          ],
          "line": 3740
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&test_spinlock_irq"
          ],
          "line": 3737
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&test_spinlock"
          ],
          "line": 3736
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init void test_work(struct work_struct *dummy)\n{\n\tspin_lock(&test_spinlock);\n\tspin_lock_irq(&test_spinlock_irq);\n\tudelay(1);\n\tspin_unlock_irq(&test_spinlock_irq);\n\tspin_unlock(&test_spinlock);\n\n\tmutex_lock(&test_mutex);\n\tmsleep(1);\n\tmutex_unlock(&test_mutex);\n}"
  },
  {
    "function_name": "trace_event_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3720-3726",
    "snippet": "void __init trace_event_init(void)\n{\n\tevent_trace_memsetup();\n\tinit_ftrace_syscalls();\n\tevent_trace_enable();\n\tevent_trace_init_fields();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trace_init_fields",
          "args": [],
          "line": 3725
        },
        "resolved": true,
        "details": {
          "function_name": "event_trace_init_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3679-3688",
          "snippet": "static __init int event_trace_init_fields(void)\n{\n\tif (trace_define_generic_fields())\n\t\tpr_warn(\"tracing: Failed to allocated generic fields\");\n\n\tif (trace_define_common_fields())\n\t\tpr_warn(\"tracing: Failed to allocate common fields\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_trace_init_fields(void)\n{\n\tif (trace_define_generic_fields())\n\t\tpr_warn(\"tracing: Failed to allocated generic fields\");\n\n\tif (trace_define_common_fields())\n\t\tpr_warn(\"tracing: Failed to allocate common fields\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_trace_enable",
          "args": [],
          "line": 3724
        },
        "resolved": true,
        "details": {
          "function_name": "event_trace_enable_again",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3663-3674",
          "snippet": "static __init int event_trace_enable_again(void)\n{\n\tstruct trace_array *tr;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tearly_enable_events(tr, true);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_trace_enable_again(void)\n{\n\tstruct trace_array *tr;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tearly_enable_events(tr, true);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_ftrace_syscalls",
          "args": [],
          "line": 3723
        },
        "resolved": true,
        "details": {
          "function_name": "init_ftrace_syscalls",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1918-1918",
          "snippet": "static inline void init_ftrace_syscalls(void) { }",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void init_ftrace_syscalls(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "event_trace_memsetup",
          "args": [],
          "line": 3722
        },
        "resolved": true,
        "details": {
          "function_name": "event_trace_memsetup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3581-3586",
          "snippet": "static __init int event_trace_memsetup(void)\n{\n\tfield_cachep = KMEM_CACHE(ftrace_event_field, SLAB_PANIC);\n\tfile_cachep = KMEM_CACHE(trace_event_file, SLAB_PANIC);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *field_cachep;",
            "static struct kmem_cache *file_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *field_cachep;\nstatic struct kmem_cache *file_cachep;\n\nstatic __init int event_trace_memsetup(void)\n{\n\tfield_cachep = KMEM_CACHE(ftrace_event_field, SLAB_PANIC);\n\tfile_cachep = KMEM_CACHE(trace_event_file, SLAB_PANIC);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nvoid __init trace_event_init(void)\n{\n\tevent_trace_memsetup();\n\tinit_ftrace_syscalls();\n\tevent_trace_enable();\n\tevent_trace_init_fields();\n}"
  },
  {
    "function_name": "event_trace_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3690-3718",
    "snippet": "__init int event_trace_init(void)\n{\n\tstruct trace_array *tr;\n\tstruct dentry *entry;\n\tint ret;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tentry = tracefs_create_file(\"available_events\", TRACE_MODE_READ,\n\t\t\t\t    NULL, tr, &ftrace_avail_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'available_events' entry\\n\");\n\n\tret = early_event_add_tracer(NULL, tr);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_MODULES\n\tret = register_module_notifier(&trace_module_nb);\n\tif (ret)\n\t\tpr_warn(\"Failed to register trace events module notifier\\n\");\n#endif\n\n\teventdir_initialized = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool eventdir_initialized;",
      "static const struct file_operations ftrace_avail_fops = {\n\t.open = ftrace_event_avail_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to register trace events module notifier\\n\""
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&trace_module_nb"
          ],
          "line": 3710
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "307-310",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_event_add_tracer",
          "args": [
            "NULL",
            "tr"
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "early_event_add_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3533-3552",
          "snippet": "static __init int\nearly_event_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdown_write(&trace_event_sem);\n\t__trace_early_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init int\nearly_event_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdown_write(&trace_event_sem);\n\t__trace_early_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'available_events' entry\\n\""
          ],
          "line": 3703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"available_events\"",
            "TRACE_MODE_READ",
            "NULL",
            "tr",
            "&ftrace_avail_fops"
          ],
          "line": 3700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "411-422",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic bool eventdir_initialized;\nstatic const struct file_operations ftrace_avail_fops = {\n\t.open = ftrace_event_avail_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\n__init int event_trace_init(void)\n{\n\tstruct trace_array *tr;\n\tstruct dentry *entry;\n\tint ret;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tentry = tracefs_create_file(\"available_events\", TRACE_MODE_READ,\n\t\t\t\t    NULL, tr, &ftrace_avail_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'available_events' entry\\n\");\n\n\tret = early_event_add_tracer(NULL, tr);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_MODULES\n\tret = register_module_notifier(&trace_module_nb);\n\tif (ret)\n\t\tpr_warn(\"Failed to register trace events module notifier\\n\");\n#endif\n\n\teventdir_initialized = true;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trace_init_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3679-3688",
    "snippet": "static __init int event_trace_init_fields(void)\n{\n\tif (trace_define_generic_fields())\n\t\tpr_warn(\"tracing: Failed to allocated generic fields\");\n\n\tif (trace_define_common_fields())\n\t\tpr_warn(\"tracing: Failed to allocate common fields\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"tracing: Failed to allocate common fields\""
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_define_common_fields",
          "args": [],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "trace_define_common_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "177-189",
          "snippet": "static int trace_define_common_fields(void)\n{\n\tint ret;\n\tstruct trace_entry ent;\n\n\t__common_field(unsigned short, type);\n\t__common_field(unsigned char, flags);\n\t/* Holds both preempt_count and migrate_disable */\n\t__common_field(unsigned char, preempt_count);\n\t__common_field(int, pid);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int trace_define_common_fields(void)\n{\n\tint ret;\n\tstruct trace_entry ent;\n\n\t__common_field(unsigned short, type);\n\t__common_field(unsigned char, flags);\n\t/* Holds both preempt_count and migrate_disable */\n\t__common_field(unsigned char, preempt_count);\n\t__common_field(int, pid);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"tracing: Failed to allocated generic fields\""
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_define_generic_fields",
          "args": [],
          "line": 3681
        },
        "resolved": true,
        "details": {
          "function_name": "trace_define_generic_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "165-175",
          "snippet": "static int trace_define_generic_fields(void)\n{\n\tint ret;\n\n\t__generic_field(int, CPU, FILTER_CPU);\n\t__generic_field(int, cpu, FILTER_CPU);\n\t__generic_field(char *, COMM, FILTER_COMM);\n\t__generic_field(char *, comm, FILTER_COMM);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int trace_define_generic_fields(void)\n{\n\tint ret;\n\n\t__generic_field(int, CPU, FILTER_CPU);\n\t__generic_field(int, cpu, FILTER_CPU);\n\t__generic_field(char *, COMM, FILTER_COMM);\n\t__generic_field(char *, comm, FILTER_COMM);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_trace_init_fields(void)\n{\n\tif (trace_define_generic_fields())\n\t\tpr_warn(\"tracing: Failed to allocated generic fields\");\n\n\tif (trace_define_common_fields())\n\t\tpr_warn(\"tracing: Failed to allocate common fields\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trace_enable_again",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3663-3674",
    "snippet": "static __init int event_trace_enable_again(void)\n{\n\tstruct trace_array *tr;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tearly_enable_events(tr, true);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "early_enable_events",
          "args": [
            "tr",
            "true"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "early_enable_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3588-3615",
          "snippet": "static __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char bootup_event_buf[COMMAND_LINE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic char bootup_event_buf[COMMAND_LINE_SIZE];\n\nstatic __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 3667
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "411-422",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_trace_enable_again(void)\n{\n\tstruct trace_array *tr;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tearly_enable_events(tr, true);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trace_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3617-3651",
    "snippet": "static __init int event_trace_enable(void)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_call **iter, *call;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tfor_each_event(iter, __start_ftrace_events, __stop_ftrace_events) {\n\n\t\tcall = *iter;\n\t\tret = event_init(call);\n\t\tif (!ret)\n\t\t\tlist_add(&call->list, &ftrace_events);\n\t}\n\n\t/*\n\t * We need the top trace array to have a working set of trace\n\t * points at early init, before the debug files and directories\n\t * are created. Create the file entries now, and attach them\n\t * to the actual file dentries later.\n\t */\n\t__trace_early_add_events(tr);\n\n\tearly_enable_events(tr, false);\n\n\ttrace_printk_start_comm();\n\n\tregister_event_cmds();\n\n\tregister_trigger_cmds();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);",
      "extern struct trace_event_call *__start_ftrace_events[];",
      "extern struct trace_event_call *__stop_ftrace_events[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_trigger_cmds",
          "args": [],
          "line": 3648
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_cmds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "2020-2030",
          "snippet": "__init int register_trigger_cmds(void)\n{\n\tregister_trigger_traceon_traceoff_cmds();\n\tregister_trigger_snapshot_cmd();\n\tregister_trigger_stacktrace_cmd();\n\tregister_trigger_enable_disable_cmds();\n\tregister_trigger_hist_enable_disable_cmds();\n\tregister_trigger_hist_cmd();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\n__init int register_trigger_cmds(void)\n{\n\tregister_trigger_traceon_traceoff_cmds();\n\tregister_trigger_snapshot_cmd();\n\tregister_trigger_stacktrace_cmd();\n\tregister_trigger_enable_disable_cmds();\n\tregister_trigger_hist_enable_disable_cmds();\n\tregister_trigger_hist_cmd();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_event_cmds",
          "args": [],
          "line": 3646
        },
        "resolved": true,
        "details": {
          "function_name": "register_event_cmds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3361-3361",
          "snippet": "static inline int register_event_cmds(void) { return 0; }",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic inline int register_event_cmds(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "trace_printk_start_comm",
          "args": [],
          "line": 3644
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_start_comm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3304-3310",
          "snippet": "void trace_printk_start_comm(void)\n{\n\t/* Start tracing comms if trace printk is set */\n\tif (!buffers_allocated)\n\t\treturn;\n\ttracing_start_cmdline_record();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int buffers_allocated;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int buffers_allocated;\n\nvoid trace_printk_start_comm(void)\n{\n\t/* Start tracing comms if trace printk is set */\n\tif (!buffers_allocated)\n\t\treturn;\n\ttracing_start_cmdline_record();\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_enable_events",
          "args": [
            "tr",
            "false"
          ],
          "line": 3642
        },
        "resolved": true,
        "details": {
          "function_name": "early_enable_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3588-3615",
          "snippet": "static __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char bootup_event_buf[COMMAND_LINE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic char bootup_event_buf[COMMAND_LINE_SIZE];\n\nstatic __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_early_add_events",
          "args": [
            "tr"
          ],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_early_add_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3391-3407",
          "snippet": "void __trace_early_add_events(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\t/* Early boot up should not have any modules loaded */\n\t\tif (!(call->flags & TRACE_EVENT_FL_DYNAMIC) &&\n\t\t    WARN_ON_ONCE(call->module))\n\t\t\tcontinue;\n\n\t\tret = __trace_early_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create early event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nvoid __trace_early_add_events(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\t/* Early boot up should not have any modules loaded */\n\t\tif (!(call->flags & TRACE_EVENT_FL_DYNAMIC) &&\n\t\t    WARN_ON_ONCE(call->module))\n\t\t\tcontinue;\n\n\t\tret = __trace_early_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create early event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&call->list",
            "&ftrace_events"
          ],
          "line": 3631
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_init",
          "args": [
            "call"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2502-2518",
          "snippet": "static int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_event",
          "args": [
            "iter",
            "__start_ftrace_events",
            "__stop_ftrace_events"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 3619
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "411-422",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\nextern struct trace_event_call *__start_ftrace_events[];\nextern struct trace_event_call *__stop_ftrace_events[];\n\nstatic __init int event_trace_enable(void)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_call **iter, *call;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tfor_each_event(iter, __start_ftrace_events, __stop_ftrace_events) {\n\n\t\tcall = *iter;\n\t\tret = event_init(call);\n\t\tif (!ret)\n\t\t\tlist_add(&call->list, &ftrace_events);\n\t}\n\n\t/*\n\t * We need the top trace array to have a working set of trace\n\t * points at early init, before the debug files and directories\n\t * are created. Create the file entries now, and attach them\n\t * to the actual file dentries later.\n\t */\n\t__trace_early_add_events(tr);\n\n\tearly_enable_events(tr, false);\n\n\ttrace_printk_start_comm();\n\n\tregister_event_cmds();\n\n\tregister_trigger_cmds();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "early_enable_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3588-3615",
    "snippet": "static __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char bootup_event_buf[COMMAND_LINE_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to enable trace event: %s\\n\"",
            "token"
          ],
          "line": 3608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_clr_event",
          "args": [
            "tr",
            "token",
            "1"
          ],
          "line": 3606
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1047-1085",
          "snippet": "int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&buf",
            "\",\""
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic char bootup_event_buf[COMMAND_LINE_SIZE];\n\nstatic __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}"
  },
  {
    "function_name": "event_trace_memsetup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3581-3586",
    "snippet": "static __init int event_trace_memsetup(void)\n{\n\tfield_cachep = KMEM_CACHE(ftrace_event_field, SLAB_PANIC);\n\tfile_cachep = KMEM_CACHE(trace_event_file, SLAB_PANIC);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *field_cachep;",
      "static struct kmem_cache *file_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "trace_event_file",
            "SLAB_PANIC"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "ftrace_event_field",
            "SLAB_PANIC"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *field_cachep;\nstatic struct kmem_cache *file_cachep;\n\nstatic __init int event_trace_memsetup(void)\n{\n\tfield_cachep = KMEM_CACHE(ftrace_event_field, SLAB_PANIC);\n\tfile_cachep = KMEM_CACHE(trace_event_file, SLAB_PANIC);\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trace_del_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3555-3579",
    "snippet": "int event_trace_del_tracer(struct trace_array *tr)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\t/* Disable any event triggers and associated soft-disabled events */\n\tclear_event_triggers(tr);\n\n\t/* Clear the pid list */\n\t__ftrace_clear_event_pids(tr, TRACE_PIDS | TRACE_NO_PIDS);\n\n\t/* Disable any running events */\n\t__ftrace_set_clr_event_nolock(tr, NULL, NULL, NULL, 0);\n\n\t/* Make sure no more events are being executed */\n\ttracepoint_synchronize_unregister();\n\n\tdown_write(&trace_event_sem);\n\t__trace_remove_event_dirs(tr);\n\ttracefs_remove(tr->event_dir);\n\tup_write(&trace_event_sem);\n\n\ttr->event_dir = NULL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 3574
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracefs_remove",
          "args": [
            "tr->event_dir"
          ],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_remove_event_dirs",
          "args": [
            "tr"
          ],
          "line": 3572
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_remove_event_dirs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3410-3417",
          "snippet": "static void\n__trace_remove_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file, *next;\n\n\tlist_for_each_entry_safe(file, next, &tr->events, list)\n\t\tremove_event_file_dir(file);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void\n__trace_remove_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file, *next;\n\n\tlist_for_each_entry_safe(file, next, &tr->events, list)\n\t\tremove_event_file_dir(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 3571
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event_nolock",
          "args": [
            "tr",
            "NULL",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 3566
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event_nolock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "987-1033",
          "snippet": "static int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_clear_event_pids",
          "args": [
            "tr",
            "TRACE_PIDS | TRACE_NO_PIDS"
          ],
          "line": 3563
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_clear_event_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "851-892",
          "snippet": "static void __ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_pid_events(tr);\n\n\t\tlist_for_each_entry(file, &tr->events, list) {\n\t\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t\t}\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ignore_pid = false;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->filtered_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void __ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_pid_events(tr);\n\n\t\tlist_for_each_entry(file, &tr->events, list) {\n\t\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t\t}\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ignore_pid = false;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->filtered_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_event_triggers",
          "args": [
            "tr"
          ],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "clear_event_triggers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "493-507",
          "snippet": "void\nclear_event_triggers(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tstruct event_trigger_data *data, *n;\n\t\tlist_for_each_entry_safe(data, n, &file->triggers, list) {\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tlist_del_rcu(&data->list);\n\t\t\tif (data->ops->free)\n\t\t\t\tdata->ops->free(data->ops, data);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid\nclear_event_triggers(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tstruct event_trigger_data *data, *n;\n\t\tlist_for_each_entry_safe(data, n, &file->triggers, list) {\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tlist_del_rcu(&data->list);\n\t\t\tif (data->ops->free)\n\t\t\t\tdata->ops->free(data->ops, data);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint event_trace_del_tracer(struct trace_array *tr)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\t/* Disable any event triggers and associated soft-disabled events */\n\tclear_event_triggers(tr);\n\n\t/* Clear the pid list */\n\t__ftrace_clear_event_pids(tr, TRACE_PIDS | TRACE_NO_PIDS);\n\n\t/* Disable any running events */\n\t__ftrace_set_clr_event_nolock(tr, NULL, NULL, NULL, 0);\n\n\t/* Make sure no more events are being executed */\n\ttracepoint_synchronize_unregister();\n\n\tdown_write(&trace_event_sem);\n\t__trace_remove_event_dirs(tr);\n\ttracefs_remove(tr->event_dir);\n\tup_write(&trace_event_sem);\n\n\ttr->event_dir = NULL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "early_event_add_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3533-3552",
    "snippet": "static __init int\nearly_event_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdown_write(&trace_event_sem);\n\t__trace_early_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 3549
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 3546
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_early_add_event_dirs",
          "args": [
            "tr"
          ],
          "line": 3545
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_early_add_event_dirs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3371-3383",
          "snippet": "static void __trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tret = event_create_dir(tr->event_dir, file);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(file->event_call));\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void __trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tret = event_create_dir(tr->event_dir, file);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(file->event_call));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 3544
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_event_toplevel_files",
          "args": [
            "parent",
            "tr"
          ],
          "line": 3540
        },
        "resolved": true,
        "details": {
          "function_name": "create_event_toplevel_files",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3443-3492",
          "snippet": "static int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", TRACE_MODE_WRITE, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\tentry = tracefs_create_file(\"set_event_notrace_pid\",\n\t\t\t\t    TRACE_MODE_WRITE, parent, tr,\n\t\t\t\t    &ftrace_set_event_notrace_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_notrace_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\ttrace_create_file(\"header_page\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttrace_create_file(\"header_event\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
            "static const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
            "static const struct file_operations ftrace_set_event_notrace_pid_fops = {\n\t.open = ftrace_event_set_npid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_npid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
            "static const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};",
            "static const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_set_event_notrace_pid_fops = {\n\t.open = ftrace_event_set_npid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_npid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\nstatic const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};\n\nstatic int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", TRACE_MODE_WRITE, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\tentry = tracefs_create_file(\"set_event_notrace_pid\",\n\t\t\t\t    TRACE_MODE_WRITE, parent, tr,\n\t\t\t\t    &ftrace_set_event_notrace_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_notrace_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\ttrace_create_file(\"header_page\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttrace_create_file(\"header_event\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 3538
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init int\nearly_event_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdown_write(&trace_event_sem);\n\t__trace_early_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trace_add_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3507-3527",
    "snippet": "int event_trace_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out;\n\n\tdown_write(&trace_event_sem);\n\t/* If tr already has the event list, it is initialized in early boot. */\n\tif (unlikely(!list_empty(&tr->events)))\n\t\t__trace_early_add_event_dirs(tr);\n\telse\n\t\t__trace_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 3523
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_add_event_dirs",
          "args": [
            "tr"
          ],
          "line": 3522
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_add_event_dirs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2905-2917",
          "snippet": "static void\n__trace_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\tret = __trace_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void\n__trace_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\tret = __trace_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_early_add_event_dirs",
          "args": [
            "tr"
          ],
          "line": 3520
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_early_add_event_dirs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3371-3383",
          "snippet": "static void __trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tret = event_create_dir(tr->event_dir, file);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(file->event_call));\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void __trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tret = event_create_dir(tr->event_dir, file);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(file->event_call));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!list_empty(&tr->events)"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tr->events"
          ],
          "line": 3519
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 3517
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_event_toplevel_files",
          "args": [
            "parent",
            "tr"
          ],
          "line": 3513
        },
        "resolved": true,
        "details": {
          "function_name": "create_event_toplevel_files",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3443-3492",
          "snippet": "static int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", TRACE_MODE_WRITE, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\tentry = tracefs_create_file(\"set_event_notrace_pid\",\n\t\t\t\t    TRACE_MODE_WRITE, parent, tr,\n\t\t\t\t    &ftrace_set_event_notrace_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_notrace_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\ttrace_create_file(\"header_page\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttrace_create_file(\"header_event\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
            "static const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
            "static const struct file_operations ftrace_set_event_notrace_pid_fops = {\n\t.open = ftrace_event_set_npid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_npid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
            "static const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};",
            "static const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_set_event_notrace_pid_fops = {\n\t.open = ftrace_event_set_npid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_npid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\nstatic const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};\n\nstatic int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", TRACE_MODE_WRITE, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\tentry = tracefs_create_file(\"set_event_notrace_pid\",\n\t\t\t\t    TRACE_MODE_WRITE, parent, tr,\n\t\t\t\t    &ftrace_set_event_notrace_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_notrace_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\ttrace_create_file(\"header_page\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttrace_create_file(\"header_event\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint event_trace_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out;\n\n\tdown_write(&trace_event_sem);\n\t/* If tr already has the event list, it is initialized in early boot. */\n\tif (unlikely(!list_empty(&tr->events)))\n\t\t__trace_early_add_event_dirs(tr);\n\telse\n\t\t__trace_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_event_toplevel_files",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3443-3492",
    "snippet": "static int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", TRACE_MODE_WRITE, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\tentry = tracefs_create_file(\"set_event_notrace_pid\",\n\t\t\t\t    TRACE_MODE_WRITE, parent, tr,\n\t\t\t\t    &ftrace_set_event_notrace_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_notrace_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\ttrace_create_file(\"header_page\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttrace_create_file(\"header_event\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
      "static const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
      "static const struct file_operations ftrace_set_event_notrace_pid_fops = {\n\t.open = ftrace_event_set_npid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_npid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
      "static const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};",
      "static const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"header_event\"",
            "TRACE_MODE_READ",
            "d_events",
            "ring_buffer_print_entry_header",
            "&ftrace_show_header_fops"
          ],
          "line": 3485
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'set_event_notrace_pid' entry\\n\""
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"set_event_notrace_pid\"",
            "TRACE_MODE_WRITE",
            "parent",
            "tr",
            "&ftrace_set_event_notrace_pid_fops"
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'set_event_pid' entry\\n\""
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"set_event_pid\"",
            "TRACE_MODE_WRITE",
            "parent",
            "tr",
            "&ftrace_set_event_pid_fops"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'events' directory\\n\""
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_dir",
          "args": [
            "\"events\"",
            "parent"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'set_event' entry\\n\""
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"set_event\"",
            "TRACE_MODE_WRITE",
            "parent",
            "tr",
            "&ftrace_set_event_fops"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_set_event_notrace_pid_fops = {\n\t.open = ftrace_event_set_npid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_npid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\nstatic const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};\n\nstatic int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", TRACE_MODE_WRITE, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", TRACE_MODE_WRITE, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\tentry = tracefs_create_file(\"set_event_notrace_pid\",\n\t\t\t\t    TRACE_MODE_WRITE, parent, tr,\n\t\t\t\t    &ftrace_set_event_notrace_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_notrace_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\ttrace_create_file(\"header_page\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttrace_create_file(\"header_event\", TRACE_MODE_READ, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_trace_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3432-3439",
    "snippet": "static __init int setup_trace_event(char *str)\n{\n\tstrlcpy(bootup_event_buf, str, COMMAND_LINE_SIZE);\n\tring_buffer_expanded = true;\n\tdisable_tracing_selftest(\"running event tracing\");\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char bootup_event_buf[COMMAND_LINE_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_tracing_selftest",
          "args": [
            "\"running event tracing\""
          ],
          "line": 3436
        },
        "resolved": true,
        "details": {
          "function_name": "disable_tracing_selftest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "78-84",
          "snippet": "void __init disable_tracing_selftest(const char *reason)\n{\n\tif (!tracing_selftest_disabled) {\n\t\ttracing_selftest_disabled = true;\n\t\tpr_info(\"Ftrace startup test is disabled due to %s\\n\", reason);\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nvoid __init disable_tracing_selftest(const char *reason)\n{\n\tif (!tracing_selftest_disabled) {\n\t\ttracing_selftest_disabled = true;\n\t\tpr_info(\"Ftrace startup test is disabled due to %s\\n\", reason);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "bootup_event_buf",
            "str",
            "COMMAND_LINE_SIZE"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic char bootup_event_buf[COMMAND_LINE_SIZE];\n\nstatic __init int setup_trace_event(char *str)\n{\n\tstrlcpy(bootup_event_buf, str, COMMAND_LINE_SIZE);\n\tring_buffer_expanded = true;\n\tdisable_tracing_selftest(\"running event tracing\");\n\n\treturn 1;\n}"
  },
  {
    "function_name": "__add_event_to_tracers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3419-3425",
    "snippet": "static void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_add_new_event",
          "args": [
            "call",
            "tr"
          ],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_add_new_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2710-2723",
          "snippet": "static int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\tif (eventdir_initialized)\n\t\treturn event_create_dir(tr->event_dir, file);\n\telse\n\t\treturn event_define_fields(call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool eventdir_initialized;",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic bool eventdir_initialized;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\tif (eventdir_initialized)\n\t\treturn event_create_dir(tr->event_dir, file);\n\telse\n\t\treturn event_define_fields(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tr",
            "&ftrace_trace_arrays",
            "list"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}"
  },
  {
    "function_name": "__trace_remove_event_dirs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3410-3417",
    "snippet": "static void\n__trace_remove_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file, *next;\n\n\tlist_for_each_entry_safe(file, next, &tr->events, list)\n\t\tremove_event_file_dir(file);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_event_file_dir",
          "args": [
            "file"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "remove_event_file_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "962-982",
          "snippet": "static void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *file_cachep;",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "file",
            "next",
            "&tr->events",
            "list"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void\n__trace_remove_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file, *next;\n\n\tlist_for_each_entry_safe(file, next, &tr->events, list)\n\t\tremove_event_file_dir(file);\n}"
  },
  {
    "function_name": "__trace_early_add_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3391-3407",
    "snippet": "void __trace_early_add_events(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\t/* Early boot up should not have any modules loaded */\n\t\tif (!(call->flags & TRACE_EVENT_FL_DYNAMIC) &&\n\t\t    WARN_ON_ONCE(call->module))\n\t\t\tcontinue;\n\n\t\tret = __trace_early_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create early event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create early event %s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_early_add_new_event",
          "args": [
            "call",
            "tr"
          ],
          "line": 3402
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_early_add_new_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2730-2741",
          "snippet": "static int\n__trace_early_add_new_event(struct trace_event_call *call,\n\t\t\t    struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn event_define_fields(call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__trace_early_add_new_event(struct trace_event_call *call,\n\t\t\t    struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn event_define_fields(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "call->module"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "call",
            "&ftrace_events",
            "list"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nvoid __trace_early_add_events(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\t/* Early boot up should not have any modules loaded */\n\t\tif (!(call->flags & TRACE_EVENT_FL_DYNAMIC) &&\n\t\t    WARN_ON_ONCE(call->module))\n\t\t\tcontinue;\n\n\t\tret = __trace_early_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create early event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}"
  },
  {
    "function_name": "__trace_early_add_event_dirs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3371-3383",
    "snippet": "static void __trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tret = event_create_dir(tr->event_dir, file);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(file->event_call));\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create directory for event %s\\n\"",
            "trace_event_name(file->event_call)"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "file->event_call"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_create_dir",
          "args": [
            "tr->event_dir",
            "file"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "event_create_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2378-2452",
          "snippet": "static int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", TRACE_MODE_WRITE, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", TRACE_MODE_READ, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\tret = event_define_fields(call);\n\tif (ret < 0) {\n\t\tpr_warn(\"Could not initialize trace point events/%s\\n\", name);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n#ifdef CONFIG_HIST_TRIGGERS_DEBUG\n\ttrace_create_file(\"hist_debug\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_debug_fops);\n#endif\n\ttrace_create_file(\"format\", TRACE_MODE_READ, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n#ifdef CONFIG_TRACE_EVENT_INJECT\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"inject\", 0200, file->dir, file,\n\t\t\t\t  &event_inject_fops);\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [
            "#define TRACE_SYSTEM \"TRACE_SYSTEM\""
          ],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};",
            "static const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};",
            "static const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};",
            "static const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define TRACE_SYSTEM \"TRACE_SYSTEM\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\nstatic const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", TRACE_MODE_WRITE, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", TRACE_MODE_READ, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\tret = event_define_fields(call);\n\tif (ret < 0) {\n\t\tpr_warn(\"Could not initialize trace point events/%s\\n\", name);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n#ifdef CONFIG_HIST_TRIGGERS_DEBUG\n\ttrace_create_file(\"hist_debug\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_debug_fops);\n#endif\n\ttrace_create_file(\"format\", TRACE_MODE_READ, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n#ifdef CONFIG_TRACE_EVENT_INJECT\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"inject\", 0200, file->dir, file,\n\t\t\t\t  &event_inject_fops);\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void __trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tret = event_create_dir(tr->event_dir, file);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(file->event_call));\n\t}\n}"
  },
  {
    "function_name": "register_event_cmds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3361-3361",
    "snippet": "static inline int register_event_cmds(void) { return 0; }",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic inline int register_event_cmds(void) { return 0; }"
  },
  {
    "function_name": "register_event_cmds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3348-3359",
    "snippet": "static __init int register_event_cmds(void)\n{\n\tint ret;\n\n\tret = register_ftrace_command(&event_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_ftrace_command(&event_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_ftrace_command(&event_enable_cmd);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_command",
          "args": [
            "&event_enable_cmd"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4851-4868",
          "snippet": "__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic __init int register_event_cmds(void)\n{\n\tint ret;\n\n\tret = register_ftrace_command(&event_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_ftrace_command(&event_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_ftrace_command(&event_enable_cmd);\n\treturn ret;\n}"
  },
  {
    "function_name": "event_enable_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3228-3336",
    "snippet": "static int\nevent_enable_func(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t  char *glob, char *cmd, char *param, int enabled)\n{\n\tstruct trace_event_file *file;\n\tstruct ftrace_probe_ops *ops;\n\tstruct event_probe_data *data;\n\tconst char *system;\n\tconst char *event;\n\tchar *number;\n\tbool enable;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enabled || !param)\n\t\treturn -EINVAL;\n\n\tsystem = strsep(&param, \":\");\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tevent = strsep(&param, \":\");\n\n\tmutex_lock(&event_mutex);\n\n\tret = -EINVAL;\n\tfile = find_event_file(tr, system, event);\n\tif (!file)\n\t\tgoto out;\n\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n\n\tif (enable)\n\t\tops = param ? &event_enable_count_probe_ops : &event_enable_probe_ops;\n\telse\n\t\tops = param ? &event_disable_count_probe_ops : &event_disable_probe_ops;\n\n\tif (glob[0] == '!') {\n\t\tret = unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto out;\n\n\tdata->enable = enable;\n\tdata->count = -1;\n\tdata->file = file;\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tret = -EINVAL;\n\tif (!strlen(number))\n\t\tgoto out_free;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, &data->count);\n\tif (ret)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Don't let event modules unload while probe registered */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = __ftrace_event_enable_disable(file, 1, 1);\n\tif (ret < 0)\n\t\tgoto out_put;\n\n\tret = register_ftrace_function_probe(glob, tr, ops, data);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tret = -ENOENT;\n\t\tgoto out_disable;\n\t} else if (ret < 0)\n\t\tgoto out_disable;\n\t/* Just return zero, not the number of enabled functions */\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n\n out_disable:\n\t__ftrace_event_enable_disable(file, 0, 1);\n out_put:\n\ttrace_event_put_ref(file->event_call);\n out_free:\n\tkfree(data);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define ENABLE_EVENT_STR\t\"enable_event\""
    ],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 3334
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_put_ref",
          "args": [
            "file->event_call"
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ftrace_event_enable_disable",
          "args": [
            "file",
            "0",
            "1"
          ],
          "line": 3330
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "576-692",
          "snippet": "static int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 3326
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_ftrace_function_probe",
          "args": [
            "glob",
            "tr",
            "ops",
            "data"
          ],
          "line": 3312
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_function_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4541-4682",
          "snippet": "int\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\t/*\n\t * Note, there's a small window here that the func_hash->filter_hash\n\t * may be NULL or empty. Need to be careful when reading the loop.\n\t */\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tif (!hash) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_try_get_ref",
          "args": [
            "file->event_call"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "number",
            "0",
            "&data->count"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "number"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\":\""
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function_probe_func",
          "args": [
            "glob+1",
            "tr",
            "ops"
          ],
          "line": 3269
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function_probe_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4684-4811",
          "snippet": "int\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_rcu();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_rcu();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_EVENT_STR"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_event_file",
          "args": [
            "tr",
            "system",
            "event"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2943-2954",
          "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 3254
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\":\""
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\":\""
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define ENABLE_EVENT_STR\t\"enable_event\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nevent_enable_func(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t  char *glob, char *cmd, char *param, int enabled)\n{\n\tstruct trace_event_file *file;\n\tstruct ftrace_probe_ops *ops;\n\tstruct event_probe_data *data;\n\tconst char *system;\n\tconst char *event;\n\tchar *number;\n\tbool enable;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enabled || !param)\n\t\treturn -EINVAL;\n\n\tsystem = strsep(&param, \":\");\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tevent = strsep(&param, \":\");\n\n\tmutex_lock(&event_mutex);\n\n\tret = -EINVAL;\n\tfile = find_event_file(tr, system, event);\n\tif (!file)\n\t\tgoto out;\n\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n\n\tif (enable)\n\t\tops = param ? &event_enable_count_probe_ops : &event_enable_probe_ops;\n\telse\n\t\tops = param ? &event_disable_count_probe_ops : &event_disable_probe_ops;\n\n\tif (glob[0] == '!') {\n\t\tret = unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto out;\n\n\tdata->enable = enable;\n\tdata->count = -1;\n\tdata->file = file;\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tret = -EINVAL;\n\tif (!strlen(number))\n\t\tgoto out_free;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, &data->count);\n\tif (ret)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Don't let event modules unload while probe registered */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = __ftrace_event_enable_disable(file, 1, 1);\n\tif (ret < 0)\n\t\tgoto out_put;\n\n\tret = register_ftrace_function_probe(glob, tr, ops, data);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tret = -ENOENT;\n\t\tgoto out_disable;\n\t} else if (ret < 0)\n\t\tgoto out_disable;\n\t/* Just return zero, not the number of enabled functions */\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n\n out_disable:\n\t__ftrace_event_enable_disable(file, 0, 1);\n out_put:\n\ttrace_event_put_ref(file->event_call);\n out_free:\n\tkfree(data);\n\tgoto out;\n}"
  },
  {
    "function_name": "event_enable_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3175-3198",
    "snippet": "static void\nevent_enable_free(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\n\tif (!ip) {\n\t\tif (!mapper)\n\t\t\treturn;\n\t\tfree_ftrace_func_mapper(mapper, free_probe_data);\n\t\treturn;\n\t}\n\n\tedata = ftrace_func_mapper_remove_ip(mapper, ip);\n\n\tif (WARN_ON_ONCE(!edata))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(edata->ref <= 0))\n\t\treturn;\n\n\tfree_probe_data(edata);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_probe_data",
          "args": [
            "edata"
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "free_probe_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3161-3173",
          "snippet": "static int free_probe_data(void *data)\n{\n\tstruct event_probe_data *edata = data;\n\n\tedata->ref--;\n\tif (!edata->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\t__ftrace_event_enable_disable(edata->file, 0, 1);\n\t\ttrace_event_put_ref(edata->file->event_call);\n\t\tkfree(edata);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int free_probe_data(void *data)\n{\n\tstruct event_probe_data *edata = data;\n\n\tedata->ref--;\n\tif (!edata->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\t__ftrace_event_enable_disable(edata->file, 0, 1);\n\t\ttrace_event_put_ref(edata->file->event_call);\n\t\tkfree(edata);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "edata->ref <= 0"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!edata"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_remove_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_remove_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4455-4473",
          "snippet": "void *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_func_mapper",
          "args": [
            "mapper",
            "free_probe_data"
          ],
          "line": 3185
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_func_mapper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4483-4505",
          "snippet": "void free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size, i;\n\n\tif (!mapper)\n\t\treturn;\n\n\tif (free_func && mapper->hash.count) {\n\t\tsize = 1 << mapper->hash.size_bits;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size, i;\n\n\tif (!mapper)\n\t\treturn;\n\n\tif (free_func && mapper->hash.count) {\n\t\tsize = 1 << mapper->hash.size_bits;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_enable_free(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\n\tif (!ip) {\n\t\tif (!mapper)\n\t\t\treturn;\n\t\tfree_ftrace_func_mapper(mapper, free_probe_data);\n\t\treturn;\n\t}\n\n\tedata = ftrace_func_mapper_remove_ip(mapper, ip);\n\n\tif (WARN_ON_ONCE(!edata))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(edata->ref <= 0))\n\t\treturn;\n\n\tfree_probe_data(edata);\n}"
  },
  {
    "function_name": "free_probe_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3161-3173",
    "snippet": "static int free_probe_data(void *data)\n{\n\tstruct event_probe_data *edata = data;\n\n\tedata->ref--;\n\tif (!edata->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\t__ftrace_event_enable_disable(edata->file, 0, 1);\n\t\ttrace_event_put_ref(edata->file->event_call);\n\t\tkfree(edata);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "edata"
          ],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_put_ref",
          "args": [
            "edata->file->event_call"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ftrace_event_enable_disable",
          "args": [
            "edata->file",
            "0",
            "1"
          ],
          "line": 3168
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "576-692",
          "snippet": "static int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int free_probe_data(void *data)\n{\n\tstruct event_probe_data *edata = data;\n\n\tedata->ref--;\n\tif (!edata->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\t__ftrace_event_enable_disable(edata->file, 0, 1);\n\t\ttrace_event_put_ref(edata->file->event_call);\n\t\tkfree(edata);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "event_enable_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3137-3159",
    "snippet": "static int\nevent_enable_init(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *init_data, void **data)\n{\n\tstruct ftrace_func_mapper *mapper = *data;\n\tstruct event_probe_data *edata = init_data;\n\tint ret;\n\n\tif (!mapper) {\n\t\tmapper = allocate_ftrace_func_mapper();\n\t\tif (!mapper)\n\t\t\treturn -ENODEV;\n\t\t*data = mapper;\n\t}\n\n\tret = ftrace_func_mapper_add_ip(mapper, ip, edata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tedata->ref++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_func_mapper_add_ip",
          "args": [
            "mapper",
            "ip",
            "edata"
          ],
          "line": 3152
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_add_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4423-4443",
          "snippet": "int ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_ftrace_func_mapper",
          "args": [],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_ftrace_func_mapper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4377-4388",
          "snippet": "struct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstruct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int\nevent_enable_init(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *init_data, void **data)\n{\n\tstruct ftrace_func_mapper *mapper = *data;\n\tstruct event_probe_data *edata = init_data;\n\tint ret;\n\n\tif (!mapper) {\n\t\tmapper = allocate_ftrace_func_mapper();\n\t\tif (!mapper)\n\t\t\treturn -ENODEV;\n\t\t*data = mapper;\n\t}\n\n\tret = ftrace_func_mapper_add_ip(mapper, ip, edata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tedata->ref++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_enable_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3107-3135",
    "snippet": "static int\nevent_enable_print(struct seq_file *m, unsigned long ip,\n\t\t   struct ftrace_probe_ops *ops, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (WARN_ON_ONCE(!pdata || !*pdata))\n\t\treturn 0;\n\n\tedata = *pdata;\n\n\tseq_printf(m, \"%ps:\", (void *)ip);\n\n\tseq_printf(m, \"%s:%s:%s\",\n\t\t   edata->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR,\n\t\t   edata->file->event_call->class->system,\n\t\t   trace_event_name(edata->file->event_call));\n\n\tif (edata->count == -1)\n\t\tseq_puts(m, \":unlimited\\n\");\n\telse\n\t\tseq_printf(m, \":count=%ld\\n\", edata->count);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define DISABLE_EVENT_STR\t\"disable_event\"",
      "#define ENABLE_EVENT_STR\t\"enable_event\""
    ],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\":count=%ld\\n\"",
            "edata->count"
          ],
          "line": 3132
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\":unlimited\\n\""
          ],
          "line": 3130
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "edata->file->event_call"
          ],
          "line": 3127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pdata || !*pdata"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4401-4413",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define DISABLE_EVENT_STR\t\"disable_event\"\n#define ENABLE_EVENT_STR\t\"enable_event\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nevent_enable_print(struct seq_file *m, unsigned long ip,\n\t\t   struct ftrace_probe_ops *ops, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (WARN_ON_ONCE(!pdata || !*pdata))\n\t\treturn 0;\n\n\tedata = *pdata;\n\n\tseq_printf(m, \"%ps:\", (void *)ip);\n\n\tseq_printf(m, \"%s:%s:%s\",\n\t\t   edata->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR,\n\t\t   edata->file->event_call->class->system,\n\t\t   trace_event_name(edata->file->event_call));\n\n\tif (edata->count == -1)\n\t\tseq_puts(m, \":unlimited\\n\");\n\telse\n\t\tseq_printf(m, \":count=%ld\\n\", edata->count);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_enable_count_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3079-3105",
    "snippet": "static void\nevent_enable_count_probe(unsigned long ip, unsigned long parent_ip,\n\t\t\t struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\tif (!pdata || !*pdata)\n\t\treturn;\n\n\tedata = *pdata;\n\n\tif (!edata->count)\n\t\treturn;\n\n\t/* Skip if the event is in a state we want to switch to */\n\tif (edata->enable == !(edata->file->flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\treturn;\n\n\tif (edata->count != -1)\n\t\t(edata->count)--;\n\n\tupdate_event_probe(edata);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_event_probe",
          "args": [
            "edata"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "update_event_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3054-3060",
          "snippet": "static void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 3088
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4401-4413",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void\nevent_enable_count_probe(unsigned long ip, unsigned long parent_ip,\n\t\t\t struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\tif (!pdata || !*pdata)\n\t\treturn;\n\n\tedata = *pdata;\n\n\tif (!edata->count)\n\t\treturn;\n\n\t/* Skip if the event is in a state we want to switch to */\n\tif (edata->enable == !(edata->file->flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\treturn;\n\n\tif (edata->count != -1)\n\t\t(edata->count)--;\n\n\tupdate_event_probe(edata);\n}"
  },
  {
    "function_name": "event_enable_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3062-3077",
    "snippet": "static void\nevent_enable_probe(unsigned long ip, unsigned long parent_ip,\n\t\t   struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\tif (!pdata || !*pdata)\n\t\treturn;\n\n\tedata = *pdata;\n\tupdate_event_probe(edata);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_event_probe",
          "args": [
            "edata"
          ],
          "line": 3076
        },
        "resolved": true,
        "details": {
          "function_name": "update_event_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3054-3060",
          "snippet": "static void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 3071
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "4401-4413",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_enable_probe(unsigned long ip, unsigned long parent_ip,\n\t\t   struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\tif (!pdata || !*pdata)\n\t\treturn;\n\n\tedata = *pdata;\n\tupdate_event_probe(edata);\n}"
  },
  {
    "function_name": "update_event_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3054-3060",
    "snippet": "static void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_SOFT_DISABLED_BIT",
            "&data->file->flags"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_SOFT_DISABLED_BIT",
            "&data->file->flags"
          ],
          "line": 3057
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}"
  },
  {
    "function_name": "trace_put_event_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "3031-3038",
    "snippet": "void trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "file->tr"
          ],
          "line": 3037
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_put_ref",
          "args": [
            "file->event_call"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_put_event_file(struct trace_event_file *file)\n{\n\tmutex_lock(&event_mutex);\n\ttrace_event_put_ref(file->event_call);\n\tmutex_unlock(&event_mutex);\n\n\ttrace_array_put(file->tr);\n}"
  },
  {
    "function_name": "trace_get_event_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2976-3019",
    "snippet": "struct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 3013
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_try_get_ref",
          "args": [
            "file->event_call"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_event_file",
          "args": [
            "tr",
            "system",
            "event"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2943-2954",
          "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_array_get",
          "args": [
            "tr"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_get_by_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9283-9306",
          "snippet": "struct trace_array *trace_array_get_by_name(const char *name)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttr = trace_array_create(name);\n\n\tif (IS_ERR(tr))\n\t\ttr = NULL;\nout_unlock:\n\tif (tr)\n\t\ttr->ref++;\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct trace_array *trace_array_get_by_name(const char *name)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttr = trace_array_create(name);\n\n\tif (IS_ERR(tr))\n\t\ttr = NULL;\nout_unlock:\n\tif (tr)\n\t\ttr->ref++;\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_array_find_get",
          "args": [
            "instance"
          ],
          "line": 2985
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_find_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9147-9158",
          "snippet": "struct trace_array *trace_array_find_get(const char *instance)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\ttr = trace_array_find(instance);\n\tif (tr)\n\t\ttr->ref++;\n\tmutex_unlock(&trace_types_lock);\n\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct trace_array *trace_array_find_get(const char *instance)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\ttr = trace_array_find(instance);\n\tif (tr)\n\t\ttr->ref++;\n\tmutex_unlock(&trace_types_lock);\n\n\treturn tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "411-422",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *trace_get_event_file(const char *instance,\n\t\t\t\t\t      const char *system,\n\t\t\t\t\t      const char *event)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_file *file = NULL;\n\tint ret = -EINVAL;\n\n\tif (instance) {\n\t\ttr = trace_array_find_get(instance);\n\t\tif (!tr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tret = trace_array_get(tr);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tfile = find_event_file(tr, system, event);\n\tif (!file) {\n\t\ttrace_array_put(tr);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Don't let event modules unload while in use */\n\tret = trace_event_try_get_ref(file->event_call);\n\tif (!ret) {\n\t\ttrace_array_put(tr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret)\n\t\tfile = ERR_PTR(ret);\n\n\treturn file;\n}"
  },
  {
    "function_name": "find_event_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2943-2954",
    "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__find_event_file",
          "args": [
            "tr",
            "system",
            "event"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "__find_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2920-2940",
          "snippet": "struct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
  },
  {
    "function_name": "__find_event_file",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2920-2940",
    "snippet": "struct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "system",
            "call->class->system"
          ],
          "line": 2936
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "__trace_add_event_dirs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2905-2917",
    "snippet": "static void\n__trace_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\tret = __trace_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create directory for event %s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_add_new_event",
          "args": [
            "call",
            "tr"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_add_new_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2710-2723",
          "snippet": "static int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\tif (eventdir_initialized)\n\t\treturn event_create_dir(tr->event_dir, file);\n\telse\n\t\treturn event_define_fields(call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool eventdir_initialized;",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic bool eventdir_initialized;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\tif (eventdir_initialized)\n\t\treturn event_create_dir(tr->event_dir, file);\n\telse\n\t\treturn event_define_fields(call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "call",
            "&ftrace_events",
            "list"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void\n__trace_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\tret = __trace_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}"
  },
  {
    "function_name": "trace_module_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2877-2896",
    "snippet": "static int trace_module_notify(struct notifier_block *self,\n\t\t\t       unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\ttrace_module_add_events(mod);\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\ttrace_module_remove_events(mod);\n\t\tbreak;\n\t}\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_module_remove_events",
          "args": [
            "mod"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "trace_module_remove_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2853-2875",
          "snippet": "static void trace_module_remove_events(struct module *mod)\n{\n\tstruct trace_event_call *call, *p;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\tif ((call->flags & TRACE_EVENT_FL_DYNAMIC) || !call->module)\n\t\t\tcontinue;\n\t\tif (call->module == mod)\n\t\t\t__trace_remove_event_call(call);\n\t}\n\tup_write(&trace_event_sem);\n\n\t/*\n\t * It is safest to reset the ring buffer if the module being unloaded\n\t * registered any events that were used. The only worry is if\n\t * a new module gets loaded, and takes on the same id as the events\n\t * of this module. When printing out the buffer, traced events left\n\t * over from this module may be passed to the new module events and\n\t * unexpected results may occur.\n\t */\n\ttracing_reset_all_online_cpus();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_module_remove_events(struct module *mod)\n{\n\tstruct trace_event_call *call, *p;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\tif ((call->flags & TRACE_EVENT_FL_DYNAMIC) || !call->module)\n\t\t\tcontinue;\n\t\tif (call->module == mod)\n\t\t\t__trace_remove_event_call(call);\n\t}\n\tup_write(&trace_event_sem);\n\n\t/*\n\t * It is safest to reset the ring buffer if the module being unloaded\n\t * registered any events that were used. The only worry is if\n\t * a new module gets loaded, and takes on the same id as the events\n\t * of this module. When printing out the buffer, traced events left\n\t * over from this module may be passed to the new module events and\n\t * unexpected results may occur.\n\t */\n\ttracing_reset_all_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_module_add_events",
          "args": [
            "mod"
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "trace_module_add_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2830-2851",
          "snippet": "static void trace_module_add_events(struct module *mod)\n{\n\tstruct trace_event_call **call, **start, **end;\n\n\tif (!mod->num_trace_events)\n\t\treturn;\n\n\t/* Don't add infrastructure for mods without tracepoints */\n\tif (trace_module_has_bad_taint(mod)) {\n\t\tpr_err(\"%s: module has bad taint, not creating trace events\\n\",\n\t\t       mod->name);\n\t\treturn;\n\t}\n\n\tstart = mod->trace_events;\n\tend = mod->trace_events + mod->num_trace_events;\n\n\tfor_each_event(call, start, end) {\n\t\t__register_event(*call, mod);\n\t\t__add_event_to_tracers(*call);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_module_add_events(struct module *mod)\n{\n\tstruct trace_event_call **call, **start, **end;\n\n\tif (!mod->num_trace_events)\n\t\treturn;\n\n\t/* Don't add infrastructure for mods without tracepoints */\n\tif (trace_module_has_bad_taint(mod)) {\n\t\tpr_err(\"%s: module has bad taint, not creating trace events\\n\",\n\t\t       mod->name);\n\t\treturn;\n\t}\n\n\tstart = mod->trace_events;\n\tend = mod->trace_events + mod->num_trace_events;\n\n\tfor_each_event(call, start, end) {\n\t\t__register_event(*call, mod);\n\t\t__add_event_to_tracers(*call);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int trace_module_notify(struct notifier_block *self,\n\t\t\t       unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\ttrace_module_add_events(mod);\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\ttrace_module_remove_events(mod);\n\t\tbreak;\n\t}\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "trace_module_remove_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2853-2875",
    "snippet": "static void trace_module_remove_events(struct module *mod)\n{\n\tstruct trace_event_call *call, *p;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\tif ((call->flags & TRACE_EVENT_FL_DYNAMIC) || !call->module)\n\t\t\tcontinue;\n\t\tif (call->module == mod)\n\t\t\t__trace_remove_event_call(call);\n\t}\n\tup_write(&trace_event_sem);\n\n\t/*\n\t * It is safest to reset the ring buffer if the module being unloaded\n\t * registered any events that were used. The only worry is if\n\t * a new module gets loaded, and takes on the same id as the events\n\t * of this module. When printing out the buffer, traced events left\n\t * over from this module may be passed to the new module events and\n\t * unexpected results may occur.\n\t */\n\ttracing_reset_all_online_cpus();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_reset_all_online_cpus",
          "args": [],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_all_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2158-2171",
          "snippet": "void tracing_reset_all_online_cpus(void)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->clear_trace)\n\t\t\tcontinue;\n\t\ttr->clear_trace = false;\n\t\ttracing_reset_online_cpus(&tr->array_buffer);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_reset_all_online_cpus(void)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->clear_trace)\n\t\t\tcontinue;\n\t\ttr->clear_trace = false;\n\t\ttracing_reset_online_cpus(&tr->array_buffer);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_remove_event_call",
          "args": [
            "call"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_remove_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2766-2772",
          "snippet": "static void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "call",
            "p",
            "&ftrace_events",
            "list"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_module_remove_events(struct module *mod)\n{\n\tstruct trace_event_call *call, *p;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\tif ((call->flags & TRACE_EVENT_FL_DYNAMIC) || !call->module)\n\t\t\tcontinue;\n\t\tif (call->module == mod)\n\t\t\t__trace_remove_event_call(call);\n\t}\n\tup_write(&trace_event_sem);\n\n\t/*\n\t * It is safest to reset the ring buffer if the module being unloaded\n\t * registered any events that were used. The only worry is if\n\t * a new module gets loaded, and takes on the same id as the events\n\t * of this module. When printing out the buffer, traced events left\n\t * over from this module may be passed to the new module events and\n\t * unexpected results may occur.\n\t */\n\ttracing_reset_all_online_cpus();\n}"
  },
  {
    "function_name": "trace_module_add_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2830-2851",
    "snippet": "static void trace_module_add_events(struct module *mod)\n{\n\tstruct trace_event_call **call, **start, **end;\n\n\tif (!mod->num_trace_events)\n\t\treturn;\n\n\t/* Don't add infrastructure for mods without tracepoints */\n\tif (trace_module_has_bad_taint(mod)) {\n\t\tpr_err(\"%s: module has bad taint, not creating trace events\\n\",\n\t\t       mod->name);\n\t\treturn;\n\t}\n\n\tstart = mod->trace_events;\n\tend = mod->trace_events + mod->num_trace_events;\n\n\tfor_each_event(call, start, end) {\n\t\t__register_event(*call, mod);\n\t\t__add_event_to_tracers(*call);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_event_to_tracers",
          "args": [
            "*call"
          ],
          "line": 2849
        },
        "resolved": true,
        "details": {
          "function_name": "__add_event_to_tracers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3419-3425",
          "snippet": "static void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_event",
          "args": [
            "*call",
            "mod"
          ],
          "line": 2848
        },
        "resolved": true,
        "details": {
          "function_name": "__register_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2520-2536",
          "snippet": "static int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tif (call->flags & TRACE_EVENT_FL_DYNAMIC)\n\t\tatomic_set(&call->refcnt, 0);\n\telse\n\t\tcall->module = mod;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tif (call->flags & TRACE_EVENT_FL_DYNAMIC)\n\t\tatomic_set(&call->refcnt, 0);\n\telse\n\t\tcall->module = mod;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_event",
          "args": [
            "call",
            "start",
            "end"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: module has bad taint, not creating trace events\\n\"",
            "mod->name"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_module_has_bad_taint",
          "args": [
            "mod"
          ],
          "line": 2838
        },
        "resolved": true,
        "details": {
          "function_name": "trace_module_has_bad_taint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "571-575",
          "snippet": "bool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nbool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_module_add_events(struct module *mod)\n{\n\tstruct trace_event_call **call, **start, **end;\n\n\tif (!mod->num_trace_events)\n\t\treturn;\n\n\t/* Don't add infrastructure for mods without tracepoints */\n\tif (trace_module_has_bad_taint(mod)) {\n\t\tpr_err(\"%s: module has bad taint, not creating trace events\\n\",\n\t\t       mod->name);\n\t\treturn;\n\t}\n\n\tstart = mod->trace_events;\n\tend = mod->trace_events + mod->num_trace_events;\n\n\tfor_each_event(call, start, end) {\n\t\t__register_event(*call, mod);\n\t\t__add_event_to_tracers(*call);\n\t}\n}"
  },
  {
    "function_name": "trace_remove_event_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2808-2821",
    "snippet": "int trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_remove_event_call",
          "args": [
            "call"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "probe_remove_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2774-2805",
          "snippet": "static int probe_remove_event_call(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->perf_refcount)\n\t\treturn -EBUSY;\n#endif\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can't rely on ftrace_event_enable_disable(enable => 0)\n\t\t * we are going to do, EVENT_FILE_FL_SOFT_MODE can suppress\n\t\t * TRACE_REG_UNREGISTER.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\t__trace_remove_event_call(call);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int probe_remove_event_call(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->perf_refcount)\n\t\treturn -EBUSY;\n#endif\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can't rely on ftrace_event_enable_disable(enable => 0)\n\t\t * we are going to do, EVENT_FILE_FL_SOFT_MODE can suppress\n\t\t * TRACE_REG_UNREGISTER.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\t__trace_remove_event_call(call);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "probe_remove_event_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2774-2805",
    "snippet": "static int probe_remove_event_call(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->perf_refcount)\n\t\treturn -EBUSY;\n#endif\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can't rely on ftrace_event_enable_disable(enable => 0)\n\t\t * we are going to do, EVENT_FILE_FL_SOFT_MODE can suppress\n\t\t * TRACE_REG_UNREGISTER.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\t__trace_remove_event_call(call);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_remove_event_call",
          "args": [
            "call"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_remove_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2766-2772",
          "snippet": "static void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_event_file",
          "args": [],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_event_file",
          "args": [
            "tr",
            "file"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int probe_remove_event_call(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->perf_refcount)\n\t\treturn -EBUSY;\n#endif\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can't rely on ftrace_event_enable_disable(enable => 0)\n\t\t * we are going to do, EVENT_FILE_FL_SOFT_MODE can suppress\n\t\t * TRACE_REG_UNREGISTER.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\t__trace_remove_event_call(call);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__trace_remove_event_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2766-2772",
    "snippet": "static void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_event_filter",
          "args": [
            "call->filter"
          ],
          "line": 2770
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1134-1137",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_destroy_fields",
          "args": [
            "call"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "trace_destroy_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "191-201",
          "snippet": "static void trace_destroy_fields(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field, *next;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry_safe(field, next, head, link) {\n\t\tlist_del(&field->link);\n\t\tkmem_cache_free(field_cachep, field);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *field_cachep;",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *field_cachep;\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_destroy_fields(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field, *next;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry_safe(field, next, head, link) {\n\t\tlist_del(&field->link);\n\t\tkmem_cache_free(field_cachep, field);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_remove",
          "args": [
            "call"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "event_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2474-2500",
          "snippet": "static void event_remove(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tif (file->flags & EVENT_FILE_FL_WAS_ENABLED)\n\t\t\ttr->clear_trace = true;\n\n\t\tftrace_event_enable_disable(file, 0);\n\t\t/*\n\t\t * The do_for_each_event_file() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\tif (call->event.funcs)\n\t\t__unregister_trace_event(&call->event);\n\tremove_event_from_tracers(call);\n\tlist_del(&call->list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void event_remove(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tif (file->flags & EVENT_FILE_FL_WAS_ENABLED)\n\t\t\ttr->clear_trace = true;\n\n\t\tftrace_event_enable_disable(file, 0);\n\t\t/*\n\t\t * The do_for_each_event_file() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\tif (call->event.funcs)\n\t\t__unregister_trace_event(&call->event);\n\tremove_event_from_tracers(call);\n\tlist_del(&call->list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}"
  },
  {
    "function_name": "trace_add_event_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2747-2760",
    "snippet": "int trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_event_to_tracers",
          "args": [
            "call"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "__add_event_to_tracers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "3419-3425",
          "snippet": "static void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_event",
          "args": [
            "call",
            "NULL"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "__register_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2520-2536",
          "snippet": "static int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tif (call->flags & TRACE_EVENT_FL_DYNAMIC)\n\t\tatomic_set(&call->refcnt, 0);\n\telse\n\t\tcall->module = mod;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tif (call->flags & TRACE_EVENT_FL_DYNAMIC)\n\t\tatomic_set(&call->refcnt, 0);\n\telse\n\t\tcall->module = mod;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__trace_early_add_new_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2730-2741",
    "snippet": "static int\n__trace_early_add_new_event(struct trace_event_call *call,\n\t\t\t    struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn event_define_fields(call);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_define_fields",
          "args": [
            "call"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "event_define_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2341-2376",
          "snippet": "static int\nevent_define_fields(struct trace_event_call *call)\n{\n\tstruct list_head *head;\n\tint ret = 0;\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tstruct trace_event_fields *field = call->class->fields_array;\n\t\tunsigned int offset = sizeof(struct trace_entry);\n\n\t\tfor (; field->type; field++) {\n\t\t\tif (field->type == TRACE_FUNCTION_TYPE) {\n\t\t\t\tfield->define_fields(call);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset = ALIGN(offset, field->align);\n\t\t\tret = trace_define_field(call, field->type, field->name,\n\t\t\t\t\t\t offset, field->size,\n\t\t\t\t\t\t field->is_signed, field->filter_type);\n\t\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\t\tpr_err(\"error code is %d\\n\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset += field->size;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\nevent_define_fields(struct trace_event_call *call)\n{\n\tstruct list_head *head;\n\tint ret = 0;\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tstruct trace_event_fields *field = call->class->fields_array;\n\t\tunsigned int offset = sizeof(struct trace_entry);\n\n\t\tfor (; field->type; field++) {\n\t\t\tif (field->type == TRACE_FUNCTION_TYPE) {\n\t\t\t\tfield->define_fields(call);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset = ALIGN(offset, field->align);\n\t\t\tret = trace_define_field(call, field->type, field->name,\n\t\t\t\t\t\t offset, field->size,\n\t\t\t\t\t\t field->is_signed, field->filter_type);\n\t\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\t\tpr_err(\"error code is %d\\n\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset += field->size;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_create_new_event",
          "args": [
            "call",
            "tr"
          ],
          "line": 2736
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_new_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2677-2707",
          "snippet": "static struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tunsigned int first;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\tif (!trace_pid_list_first(pid_list, &first) ||\n\t    !trace_pid_list_first(no_pid_list, &first))\n\t\tfile->flags |= EVENT_FILE_FL_PID_FILTER;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [
            "#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)"
          ],
          "globals_used": [
            "static struct kmem_cache *file_cachep;",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tunsigned int first;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\tif (!trace_pid_list_first(pid_list, &first) ||\n\t    !trace_pid_list_first(no_pid_list, &first))\n\t\tfile->flags |= EVENT_FILE_FL_PID_FILTER;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__trace_early_add_new_event(struct trace_event_call *call,\n\t\t\t    struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn event_define_fields(call);\n}"
  },
  {
    "function_name": "__trace_add_new_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2710-2723",
    "snippet": "static int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\tif (eventdir_initialized)\n\t\treturn event_create_dir(tr->event_dir, file);\n\telse\n\t\treturn event_define_fields(call);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool eventdir_initialized;",
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_define_fields",
          "args": [
            "call"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "event_define_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2341-2376",
          "snippet": "static int\nevent_define_fields(struct trace_event_call *call)\n{\n\tstruct list_head *head;\n\tint ret = 0;\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tstruct trace_event_fields *field = call->class->fields_array;\n\t\tunsigned int offset = sizeof(struct trace_entry);\n\n\t\tfor (; field->type; field++) {\n\t\t\tif (field->type == TRACE_FUNCTION_TYPE) {\n\t\t\t\tfield->define_fields(call);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset = ALIGN(offset, field->align);\n\t\t\tret = trace_define_field(call, field->type, field->name,\n\t\t\t\t\t\t offset, field->size,\n\t\t\t\t\t\t field->is_signed, field->filter_type);\n\t\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\t\tpr_err(\"error code is %d\\n\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset += field->size;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\nevent_define_fields(struct trace_event_call *call)\n{\n\tstruct list_head *head;\n\tint ret = 0;\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tstruct trace_event_fields *field = call->class->fields_array;\n\t\tunsigned int offset = sizeof(struct trace_entry);\n\n\t\tfor (; field->type; field++) {\n\t\t\tif (field->type == TRACE_FUNCTION_TYPE) {\n\t\t\t\tfield->define_fields(call);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset = ALIGN(offset, field->align);\n\t\t\tret = trace_define_field(call, field->type, field->name,\n\t\t\t\t\t\t offset, field->size,\n\t\t\t\t\t\t field->is_signed, field->filter_type);\n\t\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\t\tpr_err(\"error code is %d\\n\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset += field->size;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_create_dir",
          "args": [
            "tr->event_dir",
            "file"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "event_create_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2378-2452",
          "snippet": "static int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", TRACE_MODE_WRITE, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", TRACE_MODE_READ, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\tret = event_define_fields(call);\n\tif (ret < 0) {\n\t\tpr_warn(\"Could not initialize trace point events/%s\\n\", name);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n#ifdef CONFIG_HIST_TRIGGERS_DEBUG\n\ttrace_create_file(\"hist_debug\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_debug_fops);\n#endif\n\ttrace_create_file(\"format\", TRACE_MODE_READ, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n#ifdef CONFIG_TRACE_EVENT_INJECT\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"inject\", 0200, file->dir, file,\n\t\t\t\t  &event_inject_fops);\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [
            "#define TRACE_SYSTEM \"TRACE_SYSTEM\""
          ],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};",
            "static const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};",
            "static const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};",
            "static const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define TRACE_SYSTEM \"TRACE_SYSTEM\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\nstatic const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", TRACE_MODE_WRITE, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", TRACE_MODE_READ, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\tret = event_define_fields(call);\n\tif (ret < 0) {\n\t\tpr_warn(\"Could not initialize trace point events/%s\\n\", name);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n#ifdef CONFIG_HIST_TRIGGERS_DEBUG\n\ttrace_create_file(\"hist_debug\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_debug_fops);\n#endif\n\ttrace_create_file(\"format\", TRACE_MODE_READ, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n#ifdef CONFIG_TRACE_EVENT_INJECT\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"inject\", 0200, file->dir, file,\n\t\t\t\t  &event_inject_fops);\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_create_new_event",
          "args": [
            "call",
            "tr"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_new_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2677-2707",
          "snippet": "static struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tunsigned int first;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\tif (!trace_pid_list_first(pid_list, &first) ||\n\t    !trace_pid_list_first(no_pid_list, &first))\n\t\tfile->flags |= EVENT_FILE_FL_PID_FILTER;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [
            "#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)"
          ],
          "globals_used": [
            "static struct kmem_cache *file_cachep;",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tunsigned int first;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\tif (!trace_pid_list_first(pid_list, &first) ||\n\t    !trace_pid_list_first(no_pid_list, &first))\n\t\tfile->flags |= EVENT_FILE_FL_PID_FILTER;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic bool eventdir_initialized;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\tif (eventdir_initialized)\n\t\treturn event_create_dir(tr->event_dir, file);\n\telse\n\t\treturn event_define_fields(call);\n}"
  },
  {
    "function_name": "trace_create_new_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2677-2707",
    "snippet": "static struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tunsigned int first;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\tif (!trace_pid_list_first(pid_list, &first) ||\n\t    !trace_pid_list_first(no_pid_list, &first))\n\t\tfile->flags |= EVENT_FILE_FL_PID_FILTER;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)"
    ],
    "globals_used": [
      "static struct kmem_cache *file_cachep;",
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&file->list",
            "&tr->events"
          ],
          "line": 2704
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&file->triggers"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&file->tm_ref",
            "0"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&file->sm_ref",
            "0"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_pid_list_first",
          "args": [
            "no_pid_list",
            "&first"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_list_first",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "327-330",
          "snippet": "int trace_pid_list_first(struct trace_pid_list *pid_list, unsigned int *pid)\n{\n\treturn trace_pid_list_next(pid_list, 0, pid);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nint trace_pid_list_first(struct trace_pid_list *pid_list, unsigned int *pid)\n{\n\treturn trace_pid_list_next(pid_list, 0, pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_no_pids",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&event_mutex"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_pids",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "file_cachep",
            "GFP_TRACE"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tunsigned int first;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\tif (!trace_pid_list_first(pid_list, &first) ||\n\t    !trace_pid_list_first(no_pid_list, &first))\n\t\tfile->flags |= EVENT_FILE_FL_PID_FILTER;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}"
  },
  {
    "function_name": "trace_event_eval_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2636-2675",
    "snippet": "void trace_event_eval_update(struct trace_eval_map **map, int len)\n{\n\tstruct trace_event_call *call, *p;\n\tconst char *last_system = NULL;\n\tbool first = false;\n\tint last_i;\n\tint i;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\t/* events are usually grouped together with systems */\n\t\tif (!last_system || call->class->system != last_system) {\n\t\t\tfirst = true;\n\t\t\tlast_i = 0;\n\t\t\tlast_system = call->class->system;\n\t\t}\n\n\t\t/*\n\t\t * Since calls are grouped by systems, the likelihood that the\n\t\t * next call in the iteration belongs to the same system as the\n\t\t * previous call is high. As an optimization, we skip searching\n\t\t * for a map[] that matches the call's system if the last call\n\t\t * was from the same system. That's what last_i is for. If the\n\t\t * call has the same system as the previous call, then last_i\n\t\t * will be the index of the first map[] that has a matching\n\t\t * system.\n\t\t */\n\t\tfor (i = last_i; i < len; i++) {\n\t\t\tif (call->class->system == map[i]->system) {\n\t\t\t\t/* Save the first system if need be */\n\t\t\t\tif (first) {\n\t\t\t\t\tlast_i = i;\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\tupdate_event_printk(call, map[i]);\n\t\t\t}\n\t\t}\n\t}\n\tup_write(&trace_event_sem);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2674
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_event_printk",
          "args": [
            "call",
            "map[i]"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "update_event_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2560-2634",
          "snippet": "static void update_event_printk(struct trace_event_call *call,\n\t\t\t\tstruct trace_eval_map *map)\n{\n\tchar *ptr;\n\tint quote = 0;\n\tint len = strlen(map->eval_string);\n\n\tfor (ptr = call->print_fmt; *ptr; ptr++) {\n\t\tif (*ptr == '\\\\') {\n\t\t\tptr++;\n\t\t\t/* paranoid */\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*ptr == '\"') {\n\t\t\tquote ^= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (quote)\n\t\t\tcontinue;\n\t\tif (isdigit(*ptr)) {\n\t\t\t/* skip numbers */\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t\t/* Check for alpha chars like ULL */\n\t\t\t} while (isalnum(*ptr));\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * A number must have some kind of delimiter after\n\t\t\t * it, and we can ignore that too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (isalpha(*ptr) || *ptr == '_') {\n\t\t\tif (strncmp(map->eval_string, ptr, len) == 0 &&\n\t\t\t    !isalnum(ptr[len]) && ptr[len] != '_') {\n\t\t\t\tptr = eval_replace(ptr, map, len);\n\t\t\t\t/* enum/sizeof string smaller than value */\n\t\t\t\tif (WARN_ON_ONCE(!ptr))\n\t\t\t\t\treturn;\n\t\t\t\t/*\n\t\t\t\t * No need to decrement here, as eval_replace()\n\t\t\t\t * returns the pointer to the character passed\n\t\t\t\t * the eval, and two evals can not be placed\n\t\t\t\t * back to back without something in between.\n\t\t\t\t * We can skip that something in between.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\tskip_more:\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t} while (isalnum(*ptr) || *ptr == '_');\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If what comes after this variable is a '.' or\n\t\t\t * '->' then we can continue to ignore that string.\n\t\t\t */\n\t\t\tif (*ptr == '.' || (ptr[0] == '-' && ptr[1] == '>')) {\n\t\t\t\tptr += *ptr == '.' ? 1 : 2;\n\t\t\t\tif (!*ptr)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto skip_more;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Once again, we can skip the delimiter that came\n\t\t\t * after the string.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void update_event_printk(struct trace_event_call *call,\n\t\t\t\tstruct trace_eval_map *map)\n{\n\tchar *ptr;\n\tint quote = 0;\n\tint len = strlen(map->eval_string);\n\n\tfor (ptr = call->print_fmt; *ptr; ptr++) {\n\t\tif (*ptr == '\\\\') {\n\t\t\tptr++;\n\t\t\t/* paranoid */\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*ptr == '\"') {\n\t\t\tquote ^= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (quote)\n\t\t\tcontinue;\n\t\tif (isdigit(*ptr)) {\n\t\t\t/* skip numbers */\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t\t/* Check for alpha chars like ULL */\n\t\t\t} while (isalnum(*ptr));\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * A number must have some kind of delimiter after\n\t\t\t * it, and we can ignore that too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (isalpha(*ptr) || *ptr == '_') {\n\t\t\tif (strncmp(map->eval_string, ptr, len) == 0 &&\n\t\t\t    !isalnum(ptr[len]) && ptr[len] != '_') {\n\t\t\t\tptr = eval_replace(ptr, map, len);\n\t\t\t\t/* enum/sizeof string smaller than value */\n\t\t\t\tif (WARN_ON_ONCE(!ptr))\n\t\t\t\t\treturn;\n\t\t\t\t/*\n\t\t\t\t * No need to decrement here, as eval_replace()\n\t\t\t\t * returns the pointer to the character passed\n\t\t\t\t * the eval, and two evals can not be placed\n\t\t\t\t * back to back without something in between.\n\t\t\t\t * We can skip that something in between.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\tskip_more:\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t} while (isalnum(*ptr) || *ptr == '_');\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If what comes after this variable is a '.' or\n\t\t\t * '->' then we can continue to ignore that string.\n\t\t\t */\n\t\t\tif (*ptr == '.' || (ptr[0] == '-' && ptr[1] == '>')) {\n\t\t\t\tptr += *ptr == '.' ? 1 : 2;\n\t\t\t\tif (!*ptr)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto skip_more;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Once again, we can skip the delimiter that came\n\t\t\t * after the string.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "call",
            "p",
            "&ftrace_events",
            "list"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nvoid trace_event_eval_update(struct trace_eval_map **map, int len)\n{\n\tstruct trace_event_call *call, *p;\n\tconst char *last_system = NULL;\n\tbool first = false;\n\tint last_i;\n\tint i;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\t/* events are usually grouped together with systems */\n\t\tif (!last_system || call->class->system != last_system) {\n\t\t\tfirst = true;\n\t\t\tlast_i = 0;\n\t\t\tlast_system = call->class->system;\n\t\t}\n\n\t\t/*\n\t\t * Since calls are grouped by systems, the likelihood that the\n\t\t * next call in the iteration belongs to the same system as the\n\t\t * previous call is high. As an optimization, we skip searching\n\t\t * for a map[] that matches the call's system if the last call\n\t\t * was from the same system. That's what last_i is for. If the\n\t\t * call has the same system as the previous call, then last_i\n\t\t * will be the index of the first map[] that has a matching\n\t\t * system.\n\t\t */\n\t\tfor (i = last_i; i < len; i++) {\n\t\t\tif (call->class->system == map[i]->system) {\n\t\t\t\t/* Save the first system if need be */\n\t\t\t\tif (first) {\n\t\t\t\t\tlast_i = i;\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\tupdate_event_printk(call, map[i]);\n\t\t\t}\n\t\t}\n\t}\n\tup_write(&trace_event_sem);\n}"
  },
  {
    "function_name": "update_event_printk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2560-2634",
    "snippet": "static void update_event_printk(struct trace_event_call *call,\n\t\t\t\tstruct trace_eval_map *map)\n{\n\tchar *ptr;\n\tint quote = 0;\n\tint len = strlen(map->eval_string);\n\n\tfor (ptr = call->print_fmt; *ptr; ptr++) {\n\t\tif (*ptr == '\\\\') {\n\t\t\tptr++;\n\t\t\t/* paranoid */\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*ptr == '\"') {\n\t\t\tquote ^= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (quote)\n\t\t\tcontinue;\n\t\tif (isdigit(*ptr)) {\n\t\t\t/* skip numbers */\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t\t/* Check for alpha chars like ULL */\n\t\t\t} while (isalnum(*ptr));\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * A number must have some kind of delimiter after\n\t\t\t * it, and we can ignore that too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (isalpha(*ptr) || *ptr == '_') {\n\t\t\tif (strncmp(map->eval_string, ptr, len) == 0 &&\n\t\t\t    !isalnum(ptr[len]) && ptr[len] != '_') {\n\t\t\t\tptr = eval_replace(ptr, map, len);\n\t\t\t\t/* enum/sizeof string smaller than value */\n\t\t\t\tif (WARN_ON_ONCE(!ptr))\n\t\t\t\t\treturn;\n\t\t\t\t/*\n\t\t\t\t * No need to decrement here, as eval_replace()\n\t\t\t\t * returns the pointer to the character passed\n\t\t\t\t * the eval, and two evals can not be placed\n\t\t\t\t * back to back without something in between.\n\t\t\t\t * We can skip that something in between.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\tskip_more:\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t} while (isalnum(*ptr) || *ptr == '_');\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If what comes after this variable is a '.' or\n\t\t\t * '->' then we can continue to ignore that string.\n\t\t\t */\n\t\t\tif (*ptr == '.' || (ptr[0] == '-' && ptr[1] == '>')) {\n\t\t\t\tptr += *ptr == '.' ? 1 : 2;\n\t\t\t\tif (!*ptr)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto skip_more;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Once again, we can skip the delimiter that came\n\t\t\t * after the string.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "*ptr"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!ptr"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eval_replace",
          "args": [
            "ptr",
            "map",
            "len"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "eval_replace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2538-2558",
          "snippet": "static char *eval_replace(char *ptr, struct trace_eval_map *map, int len)\n{\n\tint rlen;\n\tint elen;\n\n\t/* Find the length of the eval value as a string */\n\telen = snprintf(ptr, 0, \"%ld\", map->eval_value);\n\t/* Make sure there's enough room to replace the string with the value */\n\tif (len < elen)\n\t\treturn NULL;\n\n\tsnprintf(ptr, elen + 1, \"%ld\", map->eval_value);\n\n\t/* Get the rest of the string of ptr */\n\trlen = strlen(ptr + len);\n\tmemmove(ptr + elen, ptr + len, rlen);\n\t/* Make sure we end the new string */\n\tptr[elen + rlen] = 0;\n\n\treturn ptr + elen;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic char *eval_replace(char *ptr, struct trace_eval_map *map, int len)\n{\n\tint rlen;\n\tint elen;\n\n\t/* Find the length of the eval value as a string */\n\telen = snprintf(ptr, 0, \"%ld\", map->eval_value);\n\t/* Make sure there's enough room to replace the string with the value */\n\tif (len < elen)\n\t\treturn NULL;\n\n\tsnprintf(ptr, elen + 1, \"%ld\", map->eval_value);\n\n\t/* Get the rest of the string of ptr */\n\trlen = strlen(ptr + len);\n\tmemmove(ptr + elen, ptr + len, rlen);\n\t/* Make sure we end the new string */\n\tptr[elen + rlen] = 0;\n\n\treturn ptr + elen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "ptr[len]"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "map->eval_string",
            "ptr",
            "len"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "*ptr"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "*ptr"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*ptr"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "map->eval_string"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void update_event_printk(struct trace_event_call *call,\n\t\t\t\tstruct trace_eval_map *map)\n{\n\tchar *ptr;\n\tint quote = 0;\n\tint len = strlen(map->eval_string);\n\n\tfor (ptr = call->print_fmt; *ptr; ptr++) {\n\t\tif (*ptr == '\\\\') {\n\t\t\tptr++;\n\t\t\t/* paranoid */\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*ptr == '\"') {\n\t\t\tquote ^= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (quote)\n\t\t\tcontinue;\n\t\tif (isdigit(*ptr)) {\n\t\t\t/* skip numbers */\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t\t/* Check for alpha chars like ULL */\n\t\t\t} while (isalnum(*ptr));\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * A number must have some kind of delimiter after\n\t\t\t * it, and we can ignore that too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (isalpha(*ptr) || *ptr == '_') {\n\t\t\tif (strncmp(map->eval_string, ptr, len) == 0 &&\n\t\t\t    !isalnum(ptr[len]) && ptr[len] != '_') {\n\t\t\t\tptr = eval_replace(ptr, map, len);\n\t\t\t\t/* enum/sizeof string smaller than value */\n\t\t\t\tif (WARN_ON_ONCE(!ptr))\n\t\t\t\t\treturn;\n\t\t\t\t/*\n\t\t\t\t * No need to decrement here, as eval_replace()\n\t\t\t\t * returns the pointer to the character passed\n\t\t\t\t * the eval, and two evals can not be placed\n\t\t\t\t * back to back without something in between.\n\t\t\t\t * We can skip that something in between.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\tskip_more:\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t} while (isalnum(*ptr) || *ptr == '_');\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If what comes after this variable is a '.' or\n\t\t\t * '->' then we can continue to ignore that string.\n\t\t\t */\n\t\t\tif (*ptr == '.' || (ptr[0] == '-' && ptr[1] == '>')) {\n\t\t\t\tptr += *ptr == '.' ? 1 : 2;\n\t\t\t\tif (!*ptr)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto skip_more;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Once again, we can skip the delimiter that came\n\t\t\t * after the string.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "eval_replace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2538-2558",
    "snippet": "static char *eval_replace(char *ptr, struct trace_eval_map *map, int len)\n{\n\tint rlen;\n\tint elen;\n\n\t/* Find the length of the eval value as a string */\n\telen = snprintf(ptr, 0, \"%ld\", map->eval_value);\n\t/* Make sure there's enough room to replace the string with the value */\n\tif (len < elen)\n\t\treturn NULL;\n\n\tsnprintf(ptr, elen + 1, \"%ld\", map->eval_value);\n\n\t/* Get the rest of the string of ptr */\n\trlen = strlen(ptr + len);\n\tmemmove(ptr + elen, ptr + len, rlen);\n\t/* Make sure we end the new string */\n\tptr[elen + rlen] = 0;\n\n\treturn ptr + elen;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ptr + elen",
            "ptr + len",
            "rlen"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr + len"
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ptr",
            "elen + 1",
            "\"%ld\"",
            "map->eval_value"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ptr",
            "0",
            "\"%ld\"",
            "map->eval_value"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic char *eval_replace(char *ptr, struct trace_eval_map *map, int len)\n{\n\tint rlen;\n\tint elen;\n\n\t/* Find the length of the eval value as a string */\n\telen = snprintf(ptr, 0, \"%ld\", map->eval_value);\n\t/* Make sure there's enough room to replace the string with the value */\n\tif (len < elen)\n\t\treturn NULL;\n\n\tsnprintf(ptr, elen + 1, \"%ld\", map->eval_value);\n\n\t/* Get the rest of the string of ptr */\n\trlen = strlen(ptr + len);\n\tmemmove(ptr + elen, ptr + len, rlen);\n\t/* Make sure we end the new string */\n\tptr[elen + rlen] = 0;\n\n\treturn ptr + elen;\n}"
  },
  {
    "function_name": "__register_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2520-2536",
    "snippet": "static int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tif (call->flags & TRACE_EVENT_FL_DYNAMIC)\n\t\tatomic_set(&call->refcnt, 0);\n\telse\n\t\tcall->module = mod;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&call->refcnt",
            "0"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&call->list",
            "&ftrace_events"
          ],
          "line": 2529
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_init",
          "args": [
            "call"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2502-2518",
          "snippet": "static int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tif (call->flags & TRACE_EVENT_FL_DYNAMIC)\n\t\tatomic_set(&call->refcnt, 0);\n\telse\n\t\tcall->module = mod;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2502-2518",
    "snippet": "static int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not initialize trace events/%s\\n\"",
            "name"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call->class->raw_init",
          "args": [
            "call"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!name"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2474-2500",
    "snippet": "static void event_remove(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tif (file->flags & EVENT_FILE_FL_WAS_ENABLED)\n\t\t\ttr->clear_trace = true;\n\n\t\tftrace_event_enable_disable(file, 0);\n\t\t/*\n\t\t * The do_for_each_event_file() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\tif (call->event.funcs)\n\t\t__unregister_trace_event(&call->event);\n\tremove_event_from_tracers(call);\n\tlist_del(&call->list);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&call->list"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_event_from_tracers",
          "args": [
            "call"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "remove_event_from_tracers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2454-2472",
          "snippet": "static void remove_event_from_tracers(struct trace_event_call *call)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tdo_for_each_event_file_safe(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tremove_event_file_dir(file);\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void remove_event_from_tracers(struct trace_event_call *call)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tdo_for_each_event_file_safe(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tremove_event_file_dir(file);\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_trace_event",
          "args": [
            "&call->event"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_trace_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "815-820",
          "snippet": "int __unregister_trace_event(struct trace_event *event)\n{\n\thlist_del(&event->node);\n\tlist_del(&event->list);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint __unregister_trace_event(struct trace_event *event)\n{\n\thlist_del(&event->node);\n\tlist_del(&event->list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_event_file",
          "args": [],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_event_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "700-704",
          "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_event_file",
          "args": [
            "tr",
            "file"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void event_remove(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tif (file->flags & EVENT_FILE_FL_WAS_ENABLED)\n\t\t\ttr->clear_trace = true;\n\n\t\tftrace_event_enable_disable(file, 0);\n\t\t/*\n\t\t * The do_for_each_event_file() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\tif (call->event.funcs)\n\t\t__unregister_trace_event(&call->event);\n\tremove_event_from_tracers(call);\n\tlist_del(&call->list);\n}"
  },
  {
    "function_name": "remove_event_from_tracers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2454-2472",
    "snippet": "static void remove_event_from_tracers(struct trace_event_call *call)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tdo_for_each_event_file_safe(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tremove_event_file_dir(file);\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_event_file",
          "args": [],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_event_file_dir",
          "args": [
            "file"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "remove_event_file_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "962-982",
          "snippet": "static void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *file_cachep;",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_event_file_safe",
          "args": [
            "tr",
            "file"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void remove_event_from_tracers(struct trace_event_call *call)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tdo_for_each_event_file_safe(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tremove_event_file_dir(file);\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n}"
  },
  {
    "function_name": "event_create_dir",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2378-2452",
    "snippet": "static int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", TRACE_MODE_WRITE, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", TRACE_MODE_READ, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\tret = event_define_fields(call);\n\tif (ret < 0) {\n\t\tpr_warn(\"Could not initialize trace point events/%s\\n\", name);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n#ifdef CONFIG_HIST_TRIGGERS_DEBUG\n\ttrace_create_file(\"hist_debug\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_debug_fops);\n#endif\n\ttrace_create_file(\"format\", TRACE_MODE_READ, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n#ifdef CONFIG_TRACE_EVENT_INJECT\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"inject\", 0200, file->dir, file,\n\t\t\t\t  &event_inject_fops);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define TRACE_SYSTEM \"TRACE_SYSTEM\""
    ],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};",
      "static const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};",
      "static const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};",
      "static const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"inject\"",
            "0200",
            "file->dir",
            "file",
            "&event_inject_fops"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not initialize trace point events/%s\\n\"",
            "name"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_define_fields",
          "args": [
            "call"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "event_define_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2341-2376",
          "snippet": "static int\nevent_define_fields(struct trace_event_call *call)\n{\n\tstruct list_head *head;\n\tint ret = 0;\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tstruct trace_event_fields *field = call->class->fields_array;\n\t\tunsigned int offset = sizeof(struct trace_entry);\n\n\t\tfor (; field->type; field++) {\n\t\t\tif (field->type == TRACE_FUNCTION_TYPE) {\n\t\t\t\tfield->define_fields(call);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset = ALIGN(offset, field->align);\n\t\t\tret = trace_define_field(call, field->type, field->name,\n\t\t\t\t\t\t offset, field->size,\n\t\t\t\t\t\t field->is_signed, field->filter_type);\n\t\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\t\tpr_err(\"error code is %d\\n\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset += field->size;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\nevent_define_fields(struct trace_event_call *call)\n{\n\tstruct list_head *head;\n\tint ret = 0;\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tstruct trace_event_fields *field = call->class->fields_array;\n\t\tunsigned int offset = sizeof(struct trace_entry);\n\n\t\tfor (; field->type; field++) {\n\t\t\tif (field->type == TRACE_FUNCTION_TYPE) {\n\t\t\t\tfield->define_fields(call);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset = ALIGN(offset, field->align);\n\t\t\tret = trace_define_field(call, field->type, field->name,\n\t\t\t\t\t\t offset, field->size,\n\t\t\t\t\t\t field->is_signed, field->filter_type);\n\t\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\t\tpr_err(\"error code is %d\\n\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset += field->size;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs '%s' directory\\n\"",
            "name"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_dir",
          "args": [
            "name",
            "d_events"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_subsystem_dir",
          "args": [
            "tr",
            "call->class->system",
            "file",
            "parent"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "event_subsystem_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2261-2339",
          "snippet": "static struct dentry *\nevent_subsystem_dir(struct trace_array *tr, const char *name,\n\t\t    struct trace_event_file *file, struct dentry *parent)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct event_subsystem *system;\n\tstruct dentry *entry;\n\n\t/* First see if we did not already create this dir */\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\tsystem = dir->subsystem;\n\t\tif (strcmp(system->name, name) == 0) {\n\t\t\tdir->nr_events++;\n\t\t\tfile->system = dir;\n\t\t\treturn dir->entry;\n\t\t}\n\t}\n\n\t/* Now see if the system itself exists. */\n\tlist_for_each_entry(system, &event_subsystems, list) {\n\t\tif (strcmp(system->name, name) == 0)\n\t\t\tbreak;\n\t}\n\t/* Reset system variable when not found */\n\tif (&system->list == &event_subsystems)\n\t\tsystem = NULL;\n\n\tdir = kmalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\tgoto out_fail;\n\n\tif (!system) {\n\t\tsystem = create_new_subsystem(name);\n\t\tif (!system)\n\t\t\tgoto out_free;\n\t} else\n\t\t__get_system(system);\n\n\tdir->entry = tracefs_create_dir(name, parent);\n\tif (!dir->entry) {\n\t\tpr_warn(\"Failed to create system directory %s\\n\", name);\n\t\t__put_system(system);\n\t\tgoto out_free;\n\t}\n\n\tdir->tr = tr;\n\tdir->ref_count = 1;\n\tdir->nr_events = 1;\n\tdir->subsystem = system;\n\tfile->system = dir;\n\n\t/* the ftrace system is special, do not create enable or filter files */\n\tif (strcmp(name, \"ftrace\") != 0) {\n\n\t\tentry = tracefs_create_file(\"filter\", TRACE_MODE_WRITE,\n\t\t\t\t\t    dir->entry, dir,\n\t\t\t\t\t    &ftrace_subsystem_filter_fops);\n\t\tif (!entry) {\n\t\t\tkfree(system->filter);\n\t\t\tsystem->filter = NULL;\n\t\t\tpr_warn(\"Could not create tracefs '%s/filter' entry\\n\", name);\n\t\t}\n\n\t\ttrace_create_file(\"enable\", TRACE_MODE_WRITE, dir->entry, dir,\n\t\t\t\t  &ftrace_system_enable_fops);\n\t}\n\n\tlist_add(&dir->list, &tr->systems);\n\n\treturn dir->entry;\n\n out_free:\n\tkfree(dir);\n out_fail:\n\t/* Only print this message if failed on memory allocation */\n\tif (!dir || !system)\n\t\tpr_warn(\"No memory to create event subsystem %s\\n\", name);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(event_subsystems);",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static const struct file_operations ftrace_subsystem_filter_fops = {\n\t.open = subsystem_open,\n\t.read = subsystem_filter_read,\n\t.write = subsystem_filter_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};",
            "static const struct file_operations ftrace_system_enable_fops = {\n\t.open = subsystem_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(event_subsystems);\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct file_operations ftrace_subsystem_filter_fops = {\n\t.open = subsystem_open,\n\t.read = subsystem_filter_read,\n\t.write = subsystem_filter_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\nstatic const struct file_operations ftrace_system_enable_fops = {\n\t.open = subsystem_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\n\nstatic struct dentry *\nevent_subsystem_dir(struct trace_array *tr, const char *name,\n\t\t    struct trace_event_file *file, struct dentry *parent)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct event_subsystem *system;\n\tstruct dentry *entry;\n\n\t/* First see if we did not already create this dir */\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\tsystem = dir->subsystem;\n\t\tif (strcmp(system->name, name) == 0) {\n\t\t\tdir->nr_events++;\n\t\t\tfile->system = dir;\n\t\t\treturn dir->entry;\n\t\t}\n\t}\n\n\t/* Now see if the system itself exists. */\n\tlist_for_each_entry(system, &event_subsystems, list) {\n\t\tif (strcmp(system->name, name) == 0)\n\t\t\tbreak;\n\t}\n\t/* Reset system variable when not found */\n\tif (&system->list == &event_subsystems)\n\t\tsystem = NULL;\n\n\tdir = kmalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\tgoto out_fail;\n\n\tif (!system) {\n\t\tsystem = create_new_subsystem(name);\n\t\tif (!system)\n\t\t\tgoto out_free;\n\t} else\n\t\t__get_system(system);\n\n\tdir->entry = tracefs_create_dir(name, parent);\n\tif (!dir->entry) {\n\t\tpr_warn(\"Failed to create system directory %s\\n\", name);\n\t\t__put_system(system);\n\t\tgoto out_free;\n\t}\n\n\tdir->tr = tr;\n\tdir->ref_count = 1;\n\tdir->nr_events = 1;\n\tdir->subsystem = system;\n\tfile->system = dir;\n\n\t/* the ftrace system is special, do not create enable or filter files */\n\tif (strcmp(name, \"ftrace\") != 0) {\n\n\t\tentry = tracefs_create_file(\"filter\", TRACE_MODE_WRITE,\n\t\t\t\t\t    dir->entry, dir,\n\t\t\t\t\t    &ftrace_subsystem_filter_fops);\n\t\tif (!entry) {\n\t\t\tkfree(system->filter);\n\t\t\tsystem->filter = NULL;\n\t\t\tpr_warn(\"Could not create tracefs '%s/filter' entry\\n\", name);\n\t\t}\n\n\t\ttrace_create_file(\"enable\", TRACE_MODE_WRITE, dir->entry, dir,\n\t\t\t\t  &ftrace_system_enable_fops);\n\t}\n\n\tlist_add(&dir->list, &tr->systems);\n\n\treturn dir->entry;\n\n out_free:\n\tkfree(dir);\n out_fail:\n\t/* Only print this message if failed on memory allocation */\n\tif (!dir || !system)\n\t\tpr_warn(\"No memory to create event subsystem %s\\n\", name);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "call->class->system",
            "TRACE_SYSTEM"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define TRACE_SYSTEM \"TRACE_SYSTEM\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\nstatic const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", TRACE_MODE_WRITE, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", TRACE_MODE_READ, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\tret = event_define_fields(call);\n\tif (ret < 0) {\n\t\tpr_warn(\"Could not initialize trace point events/%s\\n\", name);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", TRACE_MODE_WRITE, file->dir,\n\t\t\t\t  file, &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n#ifdef CONFIG_HIST_TRIGGERS_DEBUG\n\ttrace_create_file(\"hist_debug\", TRACE_MODE_READ, file->dir, file,\n\t\t\t  &event_hist_debug_fops);\n#endif\n\ttrace_create_file(\"format\", TRACE_MODE_READ, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n#ifdef CONFIG_TRACE_EVENT_INJECT\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"inject\", 0200, file->dir, file,\n\t\t\t\t  &event_inject_fops);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_define_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2341-2376",
    "snippet": "static int\nevent_define_fields(struct trace_event_call *call)\n{\n\tstruct list_head *head;\n\tint ret = 0;\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tstruct trace_event_fields *field = call->class->fields_array;\n\t\tunsigned int offset = sizeof(struct trace_entry);\n\n\t\tfor (; field->type; field++) {\n\t\t\tif (field->type == TRACE_FUNCTION_TYPE) {\n\t\t\t\tfield->define_fields(call);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset = ALIGN(offset, field->align);\n\t\t\tret = trace_define_field(call, field->type, field->name,\n\t\t\t\t\t\t offset, field->size,\n\t\t\t\t\t\t field->is_signed, field->filter_type);\n\t\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\t\tpr_err(\"error code is %d\\n\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset += field->size;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"error code is %d\\n\"",
            "ret"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_define_field",
          "args": [
            "call",
            "field->type",
            "field->name",
            "offset",
            "field->size",
            "field->is_signed",
            "field->filter_type"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "trace_define_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "134-146",
          "snippet": "int trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "offset",
            "field->align"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field->define_fields",
          "args": [
            "call"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\nevent_define_fields(struct trace_event_call *call)\n{\n\tstruct list_head *head;\n\tint ret = 0;\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tstruct trace_event_fields *field = call->class->fields_array;\n\t\tunsigned int offset = sizeof(struct trace_entry);\n\n\t\tfor (; field->type; field++) {\n\t\t\tif (field->type == TRACE_FUNCTION_TYPE) {\n\t\t\t\tfield->define_fields(call);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset = ALIGN(offset, field->align);\n\t\t\tret = trace_define_field(call, field->type, field->name,\n\t\t\t\t\t\t offset, field->size,\n\t\t\t\t\t\t field->is_signed, field->filter_type);\n\t\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\t\tpr_err(\"error code is %d\\n\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset += field->size;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_subsystem_dir",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2261-2339",
    "snippet": "static struct dentry *\nevent_subsystem_dir(struct trace_array *tr, const char *name,\n\t\t    struct trace_event_file *file, struct dentry *parent)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct event_subsystem *system;\n\tstruct dentry *entry;\n\n\t/* First see if we did not already create this dir */\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\tsystem = dir->subsystem;\n\t\tif (strcmp(system->name, name) == 0) {\n\t\t\tdir->nr_events++;\n\t\t\tfile->system = dir;\n\t\t\treturn dir->entry;\n\t\t}\n\t}\n\n\t/* Now see if the system itself exists. */\n\tlist_for_each_entry(system, &event_subsystems, list) {\n\t\tif (strcmp(system->name, name) == 0)\n\t\t\tbreak;\n\t}\n\t/* Reset system variable when not found */\n\tif (&system->list == &event_subsystems)\n\t\tsystem = NULL;\n\n\tdir = kmalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\tgoto out_fail;\n\n\tif (!system) {\n\t\tsystem = create_new_subsystem(name);\n\t\tif (!system)\n\t\t\tgoto out_free;\n\t} else\n\t\t__get_system(system);\n\n\tdir->entry = tracefs_create_dir(name, parent);\n\tif (!dir->entry) {\n\t\tpr_warn(\"Failed to create system directory %s\\n\", name);\n\t\t__put_system(system);\n\t\tgoto out_free;\n\t}\n\n\tdir->tr = tr;\n\tdir->ref_count = 1;\n\tdir->nr_events = 1;\n\tdir->subsystem = system;\n\tfile->system = dir;\n\n\t/* the ftrace system is special, do not create enable or filter files */\n\tif (strcmp(name, \"ftrace\") != 0) {\n\n\t\tentry = tracefs_create_file(\"filter\", TRACE_MODE_WRITE,\n\t\t\t\t\t    dir->entry, dir,\n\t\t\t\t\t    &ftrace_subsystem_filter_fops);\n\t\tif (!entry) {\n\t\t\tkfree(system->filter);\n\t\t\tsystem->filter = NULL;\n\t\t\tpr_warn(\"Could not create tracefs '%s/filter' entry\\n\", name);\n\t\t}\n\n\t\ttrace_create_file(\"enable\", TRACE_MODE_WRITE, dir->entry, dir,\n\t\t\t\t  &ftrace_system_enable_fops);\n\t}\n\n\tlist_add(&dir->list, &tr->systems);\n\n\treturn dir->entry;\n\n out_free:\n\tkfree(dir);\n out_fail:\n\t/* Only print this message if failed on memory allocation */\n\tif (!dir || !system)\n\t\tpr_warn(\"No memory to create event subsystem %s\\n\", name);\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(event_subsystems);",
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static const struct file_operations ftrace_subsystem_filter_fops = {\n\t.open = subsystem_open,\n\t.read = subsystem_filter_read,\n\t.write = subsystem_filter_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};",
      "static const struct file_operations ftrace_system_enable_fops = {\n\t.open = subsystem_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"No memory to create event subsystem %s\\n\"",
            "name"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dir->list",
            "&tr->systems"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"enable\"",
            "TRACE_MODE_WRITE",
            "dir->entry",
            "dir",
            "&ftrace_system_enable_fops"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs '%s/filter' entry\\n\"",
            "name"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"filter\"",
            "TRACE_MODE_WRITE",
            "dir->entry",
            "dir",
            "&ftrace_subsystem_filter_fops"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"ftrace\""
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_system",
          "args": [
            "system"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "__put_system_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "932-941",
          "snippet": "static void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to create system directory %s\\n\"",
            "name"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_dir",
          "args": [
            "name",
            "parent"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_system",
          "args": [
            "system"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "__get_system_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "925-930",
          "snippet": "static void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_new_subsystem",
          "args": [
            "name"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_subsystem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2228-2259",
          "snippet": "static struct event_subsystem *\ncreate_new_subsystem(const char *name)\n{\n\tstruct event_subsystem *system;\n\n\t/* need to create new entry */\n\tsystem = kmalloc(sizeof(*system), GFP_KERNEL);\n\tif (!system)\n\t\treturn NULL;\n\n\tsystem->ref_count = 1;\n\n\t/* Only allocate if dynamic (kprobes and modules) */\n\tsystem->name = kstrdup_const(name, GFP_KERNEL);\n\tif (!system->name)\n\t\tgoto out_free;\n\n\tsystem->filter = NULL;\n\n\tsystem->filter = kzalloc(sizeof(struct event_filter), GFP_KERNEL);\n\tif (!system->filter)\n\t\tgoto out_free;\n\n\tlist_add(&system->list, &event_subsystems);\n\n\treturn system;\n\n out_free:\n\tkfree_const(system->name);\n\tkfree(system);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(event_subsystems);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(event_subsystems);\n\nstatic struct event_subsystem *\ncreate_new_subsystem(const char *name)\n{\n\tstruct event_subsystem *system;\n\n\t/* need to create new entry */\n\tsystem = kmalloc(sizeof(*system), GFP_KERNEL);\n\tif (!system)\n\t\treturn NULL;\n\n\tsystem->ref_count = 1;\n\n\t/* Only allocate if dynamic (kprobes and modules) */\n\tsystem->name = kstrdup_const(name, GFP_KERNEL);\n\tif (!system->name)\n\t\tgoto out_free;\n\n\tsystem->filter = NULL;\n\n\tsystem->filter = kzalloc(sizeof(struct event_filter), GFP_KERNEL);\n\tif (!system->filter)\n\t\tgoto out_free;\n\n\tlist_add(&system->list, &event_subsystems);\n\n\treturn system;\n\n out_free:\n\tkfree_const(system->name);\n\tkfree(system);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*dir)",
            "GFP_KERNEL"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "system",
            "&event_subsystems",
            "list"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dir",
            "&tr->systems",
            "list"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(event_subsystems);\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct file_operations ftrace_subsystem_filter_fops = {\n\t.open = subsystem_open,\n\t.read = subsystem_filter_read,\n\t.write = subsystem_filter_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\nstatic const struct file_operations ftrace_system_enable_fops = {\n\t.open = subsystem_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\n\nstatic struct dentry *\nevent_subsystem_dir(struct trace_array *tr, const char *name,\n\t\t    struct trace_event_file *file, struct dentry *parent)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct event_subsystem *system;\n\tstruct dentry *entry;\n\n\t/* First see if we did not already create this dir */\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\tsystem = dir->subsystem;\n\t\tif (strcmp(system->name, name) == 0) {\n\t\t\tdir->nr_events++;\n\t\t\tfile->system = dir;\n\t\t\treturn dir->entry;\n\t\t}\n\t}\n\n\t/* Now see if the system itself exists. */\n\tlist_for_each_entry(system, &event_subsystems, list) {\n\t\tif (strcmp(system->name, name) == 0)\n\t\t\tbreak;\n\t}\n\t/* Reset system variable when not found */\n\tif (&system->list == &event_subsystems)\n\t\tsystem = NULL;\n\n\tdir = kmalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\tgoto out_fail;\n\n\tif (!system) {\n\t\tsystem = create_new_subsystem(name);\n\t\tif (!system)\n\t\t\tgoto out_free;\n\t} else\n\t\t__get_system(system);\n\n\tdir->entry = tracefs_create_dir(name, parent);\n\tif (!dir->entry) {\n\t\tpr_warn(\"Failed to create system directory %s\\n\", name);\n\t\t__put_system(system);\n\t\tgoto out_free;\n\t}\n\n\tdir->tr = tr;\n\tdir->ref_count = 1;\n\tdir->nr_events = 1;\n\tdir->subsystem = system;\n\tfile->system = dir;\n\n\t/* the ftrace system is special, do not create enable or filter files */\n\tif (strcmp(name, \"ftrace\") != 0) {\n\n\t\tentry = tracefs_create_file(\"filter\", TRACE_MODE_WRITE,\n\t\t\t\t\t    dir->entry, dir,\n\t\t\t\t\t    &ftrace_subsystem_filter_fops);\n\t\tif (!entry) {\n\t\t\tkfree(system->filter);\n\t\t\tsystem->filter = NULL;\n\t\t\tpr_warn(\"Could not create tracefs '%s/filter' entry\\n\", name);\n\t\t}\n\n\t\ttrace_create_file(\"enable\", TRACE_MODE_WRITE, dir->entry, dir,\n\t\t\t\t  &ftrace_system_enable_fops);\n\t}\n\n\tlist_add(&dir->list, &tr->systems);\n\n\treturn dir->entry;\n\n out_free:\n\tkfree(dir);\n out_fail:\n\t/* Only print this message if failed on memory allocation */\n\tif (!dir || !system)\n\t\tpr_warn(\"No memory to create event subsystem %s\\n\", name);\n\treturn NULL;\n}"
  },
  {
    "function_name": "create_new_subsystem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2228-2259",
    "snippet": "static struct event_subsystem *\ncreate_new_subsystem(const char *name)\n{\n\tstruct event_subsystem *system;\n\n\t/* need to create new entry */\n\tsystem = kmalloc(sizeof(*system), GFP_KERNEL);\n\tif (!system)\n\t\treturn NULL;\n\n\tsystem->ref_count = 1;\n\n\t/* Only allocate if dynamic (kprobes and modules) */\n\tsystem->name = kstrdup_const(name, GFP_KERNEL);\n\tif (!system->name)\n\t\tgoto out_free;\n\n\tsystem->filter = NULL;\n\n\tsystem->filter = kzalloc(sizeof(struct event_filter), GFP_KERNEL);\n\tif (!system->filter)\n\t\tgoto out_free;\n\n\tlist_add(&system->list, &event_subsystems);\n\n\treturn system;\n\n out_free:\n\tkfree_const(system->name);\n\tkfree(system);\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(event_subsystems);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "system"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "system->name"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&system->list",
            "&event_subsystems"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct event_filter)",
            "GFP_KERNEL"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*system)",
            "GFP_KERNEL"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(event_subsystems);\n\nstatic struct event_subsystem *\ncreate_new_subsystem(const char *name)\n{\n\tstruct event_subsystem *system;\n\n\t/* need to create new entry */\n\tsystem = kmalloc(sizeof(*system), GFP_KERNEL);\n\tif (!system)\n\t\treturn NULL;\n\n\tsystem->ref_count = 1;\n\n\t/* Only allocate if dynamic (kprobes and modules) */\n\tsystem->name = kstrdup_const(name, GFP_KERNEL);\n\tif (!system->name)\n\t\tgoto out_free;\n\n\tsystem->filter = NULL;\n\n\tsystem->filter = kzalloc(sizeof(struct event_filter), GFP_KERNEL);\n\tif (!system->filter)\n\t\tgoto out_free;\n\n\tlist_add(&system->list, &event_subsystems);\n\n\treturn system;\n\n out_free:\n\tkfree_const(system->name);\n\tkfree(system);\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_event_set_npid_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2207-2226",
    "snippet": "static int\nftrace_event_set_npid_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_set_no_pid_seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_clear_event_pids(tr, TRACE_NO_PIDS);\n\n\tret = ftrace_event_open(inode, file, seq_ops);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static const struct seq_operations show_set_no_pid_seq_ops = {\n\t.start = np_start,\n\t.next = np_next,\n\t.show = trace_pid_show,\n\t.stop = p_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_open",
          "args": [
            "inode",
            "file",
            "seq_ops"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2126-2145",
          "snippet": "static int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_clear_event_pids",
          "args": [
            "tr",
            "TRACE_NO_PIDS"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_clear_event_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "894-899",
          "snippet": "static void ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tmutex_lock(&event_mutex);\n\t__ftrace_clear_event_pids(tr, type);\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tmutex_lock(&event_mutex);\n\t__ftrace_clear_event_pids(tr, type);\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_check_open_get_tr",
          "args": [
            "tr"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_check_open_get_tr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "485-500",
          "snippet": "int tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic __always_inline struct;\n\nint tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct seq_operations show_set_no_pid_seq_ops = {\n\t.start = np_start,\n\t.next = np_next,\n\t.show = trace_pid_show,\n\t.stop = p_stop,\n};\n\nstatic int\nftrace_event_set_npid_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_set_no_pid_seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_clear_event_pids(tr, TRACE_NO_PIDS);\n\n\tret = ftrace_event_open(inode, file, seq_ops);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_event_set_pid_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2186-2205",
    "snippet": "static int\nftrace_event_set_pid_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_set_pid_seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_clear_event_pids(tr, TRACE_PIDS);\n\n\tret = ftrace_event_open(inode, file, seq_ops);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static const struct seq_operations show_set_pid_seq_ops = {\n\t.start = p_start,\n\t.next = p_next,\n\t.show = trace_pid_show,\n\t.stop = p_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_open",
          "args": [
            "inode",
            "file",
            "seq_ops"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2126-2145",
          "snippet": "static int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_clear_event_pids",
          "args": [
            "tr",
            "TRACE_PIDS"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_clear_event_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "894-899",
          "snippet": "static void ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tmutex_lock(&event_mutex);\n\t__ftrace_clear_event_pids(tr, type);\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tmutex_lock(&event_mutex);\n\t__ftrace_clear_event_pids(tr, type);\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_check_open_get_tr",
          "args": [
            "tr"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_check_open_get_tr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "485-500",
          "snippet": "int tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic __always_inline struct;\n\nint tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct seq_operations show_set_pid_seq_ops = {\n\t.start = p_start,\n\t.next = p_next,\n\t.show = trace_pid_show,\n\t.stop = p_stop,\n};\n\nstatic int\nftrace_event_set_pid_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_set_pid_seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_clear_event_pids(tr, TRACE_PIDS);\n\n\tret = ftrace_event_open(inode, file, seq_ops);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_event_set_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2165-2184",
    "snippet": "static int\nftrace_event_set_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_set_event_seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_clear_events(tr);\n\n\tret = ftrace_event_open(inode, file, seq_ops);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static const struct seq_operations show_set_event_seq_ops = {\n\t.start = s_start,\n\t.next = s_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_open",
          "args": [
            "inode",
            "file",
            "seq_ops"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2126-2145",
          "snippet": "static int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_clear_events",
          "args": [
            "tr"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_clear_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "706-715",
          "snippet": "static void ftrace_clear_events(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tftrace_event_enable_disable(file, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void ftrace_clear_events(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tftrace_event_enable_disable(file, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_check_open_get_tr",
          "args": [
            "tr"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_check_open_get_tr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "485-500",
          "snippet": "int tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic __always_inline struct;\n\nint tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct seq_operations show_set_event_seq_ops = {\n\t.start = s_start,\n\t.next = s_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};\n\nstatic int\nftrace_event_set_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_set_event_seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_clear_events(tr);\n\n\tret = ftrace_event_open(inode, file, seq_ops);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_event_avail_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2156-2163",
    "snippet": "static int\nftrace_event_avail_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_event_seq_ops;\n\n\t/* Checks for tracefs lockdown */\n\treturn ftrace_event_open(inode, file, seq_ops);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static const struct seq_operations show_event_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_event_open",
          "args": [
            "inode",
            "file",
            "seq_ops"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2126-2145",
          "snippet": "static int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct seq_operations show_event_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};\n\nstatic int\nftrace_event_avail_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_event_seq_ops;\n\n\t/* Checks for tracefs lockdown */\n\treturn ftrace_event_open(inode, file, seq_ops);\n}"
  },
  {
    "function_name": "ftrace_event_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2147-2154",
    "snippet": "static int ftrace_event_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "328-342",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "ftrace_event_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "2126-2145",
    "snippet": "static int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "seq_ops"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_event_npid_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1998-2003",
    "snippet": "static ssize_t\nftrace_event_npid_write(struct file *filp, const char __user *ubuf,\n\t\t\tsize_t cnt, loff_t *ppos)\n{\n\treturn event_pid_write(filp, ubuf, cnt, ppos, TRACE_NO_PIDS);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_pid_write",
          "args": [
            "filp",
            "ubuf",
            "cnt",
            "ppos",
            "TRACE_NO_PIDS"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "event_pid_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1922-1989",
          "snippet": "static ssize_t\nevent_pid_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *other_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tif (type == TRACE_PIDS) {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t} else {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (type == TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, pid_list);\n\telse\n\t\trcu_assign_pointer(tr->filtered_no_pids, pid_list);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tset_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tif (filtered_pids) {\n\t\ttracepoint_synchronize_unregister();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\tregister_pid_events(tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_pid_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *other_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tif (type == TRACE_PIDS) {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t} else {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (type == TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, pid_list);\n\telse\n\t\trcu_assign_pointer(tr->filtered_no_pids, pid_list);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tset_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tif (filtered_pids) {\n\t\ttracepoint_synchronize_unregister();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\tregister_pid_events(tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nftrace_event_npid_write(struct file *filp, const char __user *ubuf,\n\t\t\tsize_t cnt, loff_t *ppos)\n{\n\treturn event_pid_write(filp, ubuf, cnt, ppos, TRACE_NO_PIDS);\n}"
  },
  {
    "function_name": "ftrace_event_pid_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1991-1996",
    "snippet": "static ssize_t\nftrace_event_pid_write(struct file *filp, const char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\treturn event_pid_write(filp, ubuf, cnt, ppos, TRACE_PIDS);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_pid_write",
          "args": [
            "filp",
            "ubuf",
            "cnt",
            "ppos",
            "TRACE_PIDS"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "event_pid_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1922-1989",
          "snippet": "static ssize_t\nevent_pid_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *other_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tif (type == TRACE_PIDS) {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t} else {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (type == TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, pid_list);\n\telse\n\t\trcu_assign_pointer(tr->filtered_no_pids, pid_list);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tset_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tif (filtered_pids) {\n\t\ttracepoint_synchronize_unregister();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\tregister_pid_events(tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_pid_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *other_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tif (type == TRACE_PIDS) {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t} else {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (type == TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, pid_list);\n\telse\n\t\trcu_assign_pointer(tr->filtered_no_pids, pid_list);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tset_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tif (filtered_pids) {\n\t\ttracepoint_synchronize_unregister();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\tregister_pid_events(tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nftrace_event_pid_write(struct file *filp, const char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\treturn event_pid_write(filp, ubuf, cnt, ppos, TRACE_PIDS);\n}"
  },
  {
    "function_name": "event_pid_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1922-1989",
    "snippet": "static ssize_t\nevent_pid_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *other_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tif (type == TRACE_PIDS) {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t} else {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (type == TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, pid_list);\n\telse\n\t\trcu_assign_pointer(tr->filtered_no_pids, pid_list);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tset_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tif (filtered_pids) {\n\t\ttracepoint_synchronize_unregister();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\tregister_pid_events(tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "ignore_task_cpu",
            "tr",
            "1"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_pid_events",
          "args": [
            "tr"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "register_pid_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1893-1920",
          "snippet": "static void register_pid_events(struct trace_array *tr)\n{\n\t/*\n\t * Register a probe that is called before all other probes\n\t * to set ignore_pid if next or prev do not match.\n\t * Register a probe this is called after all other probes\n\t * to only keep ignore_pid set if next pid matches.\n\t */\n\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_post,\n\t\t\t\t\t tr, 0);\n\n\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t tr, 0);\n\n\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t     tr, INT_MAX);\n\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t     tr, 0);\n\n\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t tr, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void register_pid_events(struct trace_array *tr)\n{\n\t/*\n\t * Register a probe that is called before all other probes\n\t * to set ignore_pid if next or prev do not match.\n\t * Register a probe this is called after all other probes\n\t * to only keep ignore_pid set if next pid matches.\n\t */\n\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_post,\n\t\t\t\t\t tr, 0);\n\n\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t tr, 0);\n\n\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t     tr, INT_MAX);\n\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t     tr, 0);\n\n\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t tr, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_pid_list_free",
          "args": [
            "filtered_pids"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_list_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "457-495",
          "snippet": "void trace_pid_list_free(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *upper;\n\tunion lower_chunk *lower;\n\tint i, j;\n\n\tif (!pid_list)\n\t\treturn;\n\n\tirq_work_sync(&pid_list->refill_irqwork);\n\n\twhile (pid_list->lower_list) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = pid_list->lower_list;\n\t\tpid_list->lower_list = pid_list->lower_list->next;\n\t\tkfree(chunk);\n\t}\n\n\twhile (pid_list->upper_list) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = pid_list->upper_list;\n\t\tpid_list->upper_list = pid_list->upper_list->next;\n\t\tkfree(chunk);\n\t}\n\n\tfor (i = 0; i < UPPER1_SIZE; i++) {\n\t\tupper = pid_list->upper[i];\n\t\tif (upper) {\n\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {\n\t\t\t\tlower = upper->data[j];\n\t\t\t\tkfree(lower);\n\t\t\t}\n\t\t\tkfree(upper);\n\t\t}\n\t}\n\tkfree(pid_list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nvoid trace_pid_list_free(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *upper;\n\tunion lower_chunk *lower;\n\tint i, j;\n\n\tif (!pid_list)\n\t\treturn;\n\n\tirq_work_sync(&pid_list->refill_irqwork);\n\n\twhile (pid_list->lower_list) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = pid_list->lower_list;\n\t\tpid_list->lower_list = pid_list->lower_list->next;\n\t\tkfree(chunk);\n\t}\n\n\twhile (pid_list->upper_list) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = pid_list->upper_list;\n\t\tpid_list->upper_list = pid_list->upper_list->next;\n\t\tkfree(chunk);\n\t}\n\n\tfor (i = 0; i < UPPER1_SIZE; i++) {\n\t\tupper = pid_list->upper[i];\n\t\tif (upper) {\n\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {\n\t\t\t\tlower = upper->data[j];\n\t\t\t\tkfree(lower);\n\t\t\t}\n\t\t\tkfree(upper);\n\t\t}\n\t}\n\tkfree(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_PID_FILTER_BIT",
            "&file->flags"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->filtered_no_pids",
            "pid_list"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->filtered_pids",
            "pid_list"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_pid_write",
          "args": [
            "filtered_pids",
            "&pid_list",
            "ubuf",
            "cnt"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_pid_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7710-7715",
          "snippet": "static ssize_t\nftrace_pid_write(struct file *filp, const char __user *ubuf,\n\t\t size_t cnt, loff_t *ppos)\n{\n\treturn pid_write(filp, ubuf, cnt, ppos, TRACE_PIDS);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic ssize_t\nftrace_pid_write(struct file *filp, const char __user *ubuf,\n\t\t size_t cnt, loff_t *ppos)\n{\n\treturn pid_write(filp, ubuf, cnt, ppos, TRACE_PIDS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_pids",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&event_mutex"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_no_pids",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_no_pids",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_pids",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_update_buffers",
          "args": [],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_update_buffers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6279-6290",
          "snippet": "int tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool ring_buffer_expanded;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nbool ring_buffer_expanded;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;\n\nint tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_pid_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos, int type)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *other_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tif (type == TRACE_PIDS) {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t} else {\n\t\tfiltered_pids = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t\tother_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t\t\t  lockdep_is_held(&event_mutex));\n\t}\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (type == TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, pid_list);\n\telse\n\t\trcu_assign_pointer(tr->filtered_no_pids, pid_list);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tset_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tif (filtered_pids) {\n\t\ttracepoint_synchronize_unregister();\n\t\ttrace_pid_list_free(filtered_pids);\n\t} else if (pid_list && !other_pids) {\n\t\tregister_pid_events(tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_pid_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1893-1920",
    "snippet": "static void register_pid_events(struct trace_array *tr)\n{\n\t/*\n\t * Register a probe that is called before all other probes\n\t * to set ignore_pid if next or prev do not match.\n\t * Register a probe this is called after all other probes\n\t * to only keep ignore_pid set if next pid matches.\n\t */\n\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_post,\n\t\t\t\t\t tr, 0);\n\n\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t tr, 0);\n\n\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t     tr, INT_MAX);\n\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t     tr, 0);\n\n\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t tr, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_trace_prio_sched_waking",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr",
            "0"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_waking",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr",
            "INT_MAX"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_wakeup_new",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr",
            "0"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_wakeup_new",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr",
            "INT_MAX"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_wakeup",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr",
            "0"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_wakeup",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr",
            "INT_MAX"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_switch",
          "args": [
            "event_filter_pid_sched_switch_probe_post",
            "tr",
            "0"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_switch",
          "args": [
            "event_filter_pid_sched_switch_probe_pre",
            "tr",
            "INT_MAX"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void register_pid_events(struct trace_array *tr)\n{\n\t/*\n\t * Register a probe that is called before all other probes\n\t * to set ignore_pid if next or prev do not match.\n\t * Register a probe this is called after all other probes\n\t * to only keep ignore_pid set if next pid matches.\n\t */\n\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_post,\n\t\t\t\t\t tr, 0);\n\n\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t tr, 0);\n\n\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t     tr, INT_MAX);\n\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t     tr, 0);\n\n\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t tr, INT_MAX);\n\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t tr, 0);\n}"
  },
  {
    "function_name": "ignore_task_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1874-1891",
    "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     mutex_is_locked(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     mutex_is_locked(&event_mutex));\n\n\tthis_cpu_write(tr->array_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, no_pid_list, current));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->array_buffer.data->ignore_pid",
            "trace_ignore_this_task(pid_list, no_pid_list, current)"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "no_pid_list",
            "current"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "538-555",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_no_pids",
            "mutex_is_locked(&event_mutex)"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&event_mutex"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_pids",
            "mutex_is_locked(&event_mutex)"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     mutex_is_locked(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     mutex_is_locked(&event_mutex));\n\n\tthis_cpu_write(tr->array_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, no_pid_list, current));\n}"
  },
  {
    "function_name": "show_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1849-1872",
    "snippet": "static ssize_t\nshow_header(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tint (*func)(struct trace_seq *s) = filp->private_data;\n\tstruct trace_seq *s;\n\tint r;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tfunc(s);\n\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "s->buffer",
            "trace_seq_used(s)"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_used",
          "args": [
            "s"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "s"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "s"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "36-40",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*s)",
            "GFP_KERNEL"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nshow_header(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tint (*func)(struct trace_seq *s) = filp->private_data;\n\tstruct trace_seq *s;\n\tint r;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tfunc(s);\n\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}"
  },
  {
    "function_name": "subsystem_filter_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1824-1847",
    "snippet": "static ssize_t\nsubsystem_filter_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t       loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tchar *buf;\n\tint err;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\terr = apply_subsystem_event_filter(dir, buf);\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_subsystem_event_filter",
          "args": [
            "dir",
            "buf"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "apply_subsystem_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1948-1989",
          "snippet": "int apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t/* Make sure the system still has events */\n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t/* Ensure all filters are no longer used */\n\t\ttracepoint_synchronize_unregister();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, filter_string, &filter);\n\tif (filter) {\n\t\t/*\n\t\t * No event actually uses the system filter\n\t\t * we can free it without synchronize_rcu().\n\t\t */\n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nint apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t/* Make sure the system still has events */\n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t/* Ensure all filters are no longer used */\n\t\ttracepoint_synchronize_unregister();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, filter_string, &filter);\n\tif (filter) {\n\t\t/*\n\t\t * No event actually uses the system filter\n\t\t * we can free it without synchronize_rcu().\n\t\t */\n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "buf"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "buf"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "ubuf",
            "cnt"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nsubsystem_filter_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t       loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tchar *buf;\n\tint err;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\terr = apply_subsystem_event_filter(dir, buf);\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "subsystem_filter_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1797-1822",
    "snippet": "static ssize_t\nsubsystem_filter_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t      loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_seq *s;\n\tint r;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tprint_subsystem_event_filter(system, s);\n\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "s->buffer",
            "trace_seq_used(s)"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_used",
          "args": [
            "s"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_subsystem_event_filter",
          "args": [
            "system",
            "s"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "print_subsystem_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1086-1098",
          "snippet": "void print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t  struct trace_seq *s)\n{\n\tstruct event_filter *filter;\n\n\tmutex_lock(&event_mutex);\n\tfilter = system->filter;\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define DEFAULT_SYS_FILTER_MESSAGE\t\t\t\t\t\\\n\t\"### global filter ###\\n\"\t\t\t\t\t\\\n\t\"# Use this to set filters for multiple events.\\n\"\t\t\\\n\t\"# Only events with the given fields will be affected.\\n\"\t\\\n\t\"# If no events are modified, an error message will be displayed here\""
          ],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define DEFAULT_SYS_FILTER_MESSAGE\t\t\t\t\t\\\n\t\"### global filter ###\\n\"\t\t\t\t\t\\\n\t\"# Use this to set filters for multiple events.\\n\"\t\t\\\n\t\"# Only events with the given fields will be affected.\\n\"\t\\\n\t\"# If no events are modified, an error message will be displayed here\"\n\nstatic __percpu struct;\n\nvoid print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t  struct trace_seq *s)\n{\n\tstruct event_filter *filter;\n\n\tmutex_lock(&event_mutex);\n\tfilter = system->filter;\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "s"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "36-40",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*s)",
            "GFP_KERNEL"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nsubsystem_filter_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t      loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_seq *s;\n\tint r;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tprint_subsystem_event_filter(system, s);\n\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}"
  },
  {
    "function_name": "subsystem_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1778-1795",
    "snippet": "static int subsystem_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_subsystem_dir *dir = file->private_data;\n\n\ttrace_array_put(dir->tr);\n\n\t/*\n\t * If dir->subsystem is NULL, then this is a temporary\n\t * descriptor that was made for a trace_array to enable\n\t * all subsystems.\n\t */\n\tif (dir->subsystem)\n\t\tput_system(dir);\n\telse\n\t\tkfree(dir);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_system",
          "args": [
            "dir"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "put_system",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "943-948",
          "snippet": "static void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "dir->tr"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int subsystem_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_subsystem_dir *dir = file->private_data;\n\n\ttrace_array_put(dir->tr);\n\n\t/*\n\t * If dir->subsystem is NULL, then this is a temporary\n\t * descriptor that was made for a trace_array to enable\n\t * all subsystems.\n\t */\n\tif (dir->subsystem)\n\t\tput_system(dir);\n\telse\n\t\tkfree(dir);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "system_tr_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1756-1776",
    "snippet": "static int system_tr_open(struct inode *inode, struct file *filp)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\t/* Make a temporary dir that has no system but points to tr */\n\tdir = kzalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tret = tracing_open_generic_tr(inode, filp);\n\tif (ret < 0) {\n\t\tkfree(dir);\n\t\treturn ret;\n\t}\n\tdir->tr = tr;\n\tfilp->private_data = dir;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_open_generic_tr",
          "args": [
            "inode",
            "filp"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_open_generic_tr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4832-4844",
          "snippet": "int tracing_open_generic_tr(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_open_generic_tr(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*dir)",
            "GFP_KERNEL"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int system_tr_open(struct inode *inode, struct file *filp)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\t/* Make a temporary dir that has no system but points to tr */\n\tdir = kzalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tret = tracing_open_generic_tr(inode, filp);\n\tif (ret < 0) {\n\t\tkfree(dir);\n\t\treturn ret;\n\t}\n\tdir->tr = tr;\n\tfilp->private_data = dir;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "subsystem_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1706-1754",
    "snippet": "static int subsystem_open(struct inode *inode, struct file *filp)\n{\n\tstruct event_subsystem *system = NULL;\n\tstruct trace_subsystem_dir *dir = NULL; /* Initialize for gcc */\n\tstruct trace_array *tr;\n\tint ret;\n\n\tif (tracing_is_disabled())\n\t\treturn -ENODEV;\n\n\t/* Make sure the system still exists */\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\t\tif (dir == inode->i_private) {\n\t\t\t\t/* Don't open systems with no events */\n\t\t\t\tif (dir->nr_events) {\n\t\t\t\t\t__get_system_dir(dir);\n\t\t\t\t\tsystem = dir->subsystem;\n\t\t\t\t}\n\t\t\t\tgoto exit_loop;\n\t\t\t}\n\t\t}\n\t}\n exit_loop:\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\tif (!system)\n\t\treturn -ENODEV;\n\n\t/* Some versions of gcc think dir can be uninitialized here */\n\tWARN_ON(!dir);\n\n\t/* Still need to increment the ref count of the system */\n\tif (trace_array_get(tr) < 0) {\n\t\tput_system(dir);\n\t\treturn -ENODEV;\n\t}\n\n\tret = tracing_open_generic(inode, filp);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t\tput_system(dir);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_system",
          "args": [
            "dir"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "put_system",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "943-948",
          "snippet": "static void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "474-482",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_open_generic",
          "args": [
            "inode",
            "filp"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_open_generic_tr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4832-4844",
          "snippet": "int tracing_open_generic_tr(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_open_generic_tr(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_get",
          "args": [
            "tr"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_get_by_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9283-9306",
          "snippet": "struct trace_array *trace_array_get_by_name(const char *name)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttr = trace_array_create(name);\n\n\tif (IS_ERR(tr))\n\t\ttr = NULL;\nout_unlock:\n\tif (tr)\n\t\ttr->ref++;\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct trace_array *trace_array_get_by_name(const char *name)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttr = trace_array_create(name);\n\n\tif (IS_ERR(tr))\n\t\ttr = NULL;\nout_unlock:\n\tif (tr)\n\t\ttr->ref++;\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dir"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_system_dir",
          "args": [
            "dir"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "__get_system_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "925-930",
          "snippet": "static void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dir",
            "&tr->systems",
            "list"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tr",
            "&ftrace_trace_arrays",
            "list"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_disabled",
          "args": [],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4823-4826",
          "snippet": "bool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\n\nbool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int subsystem_open(struct inode *inode, struct file *filp)\n{\n\tstruct event_subsystem *system = NULL;\n\tstruct trace_subsystem_dir *dir = NULL; /* Initialize for gcc */\n\tstruct trace_array *tr;\n\tint ret;\n\n\tif (tracing_is_disabled())\n\t\treturn -ENODEV;\n\n\t/* Make sure the system still exists */\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\t\tif (dir == inode->i_private) {\n\t\t\t\t/* Don't open systems with no events */\n\t\t\t\tif (dir->nr_events) {\n\t\t\t\t\t__get_system_dir(dir);\n\t\t\t\t\tsystem = dir->subsystem;\n\t\t\t\t}\n\t\t\t\tgoto exit_loop;\n\t\t\t}\n\t\t}\n\t}\n exit_loop:\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\tif (!system)\n\t\treturn -ENODEV;\n\n\t/* Some versions of gcc think dir can be uninitialized here */\n\tWARN_ON(!dir);\n\n\t/* Still need to increment the ref count of the system */\n\tif (trace_array_get(tr) < 0) {\n\t\tput_system(dir);\n\t\treturn -ENODEV;\n\t}\n\n\tret = tracing_open_generic(inode, filp);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t\tput_system(dir);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_filter_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1674-1702",
    "snippet": "static ssize_t\nevent_filter_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tchar *buf;\n\tint err = -ENODEV;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (file)\n\t\terr = apply_event_filter(file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_event_filter",
          "args": [
            "file",
            "buf"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "apply_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1897-1946",
          "snippet": "int apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(file->tr, call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nint apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(file->tr, call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "filp"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "buf"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "buf"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "ubuf",
            "cnt"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_filter_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tchar *buf;\n\tint err = -ENODEV;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (file)\n\t\terr = apply_event_filter(file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "event_filter_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1641-1672",
    "snippet": "static ssize_t\nevent_filter_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_seq *s;\n\tint r = -ENODEV;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (file)\n\t\tprint_event_filter(file, s);\n\tmutex_unlock(&event_mutex);\n\n\tif (file)\n\t\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "s->buffer",
            "trace_seq_used(s)"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_used",
          "args": [
            "s"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_event_filter",
          "args": [
            "file",
            "s"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "print_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1076-1084",
          "snippet": "void print_event_filter(struct trace_event_file *file, struct trace_seq *s)\n{\n\tstruct event_filter *filter = event_filter(file);\n\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, \"none\\n\");\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nvoid print_event_filter(struct trace_event_file *file, struct trace_seq *s)\n{\n\tstruct event_filter *filter = event_filter(file);\n\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, \"none\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "filp"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "s"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "36-40",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*s)",
            "GFP_KERNEL"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_filter_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_seq *s;\n\tint r = -ENODEV;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (file)\n\t\tprint_event_filter(file, s);\n\tmutex_unlock(&event_mutex);\n\n\tif (file)\n\t\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}"
  },
  {
    "function_name": "event_id_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1626-1639",
    "snippet": "static ssize_t\nevent_id_read(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tint id = (long)event_file_data(filp);\n\tchar buf[32];\n\tint len;\n\n\tif (unlikely(!id))\n\t\treturn -ENODEV;\n\n\tlen = sprintf(buf, \"%d\\n\", id);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, len);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "buf",
            "len"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "id"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!id"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "filp"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_id_read(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tint id = (long)event_file_data(filp);\n\tchar buf[32];\n\tint len;\n\n\tif (unlikely(!id))\n\t\treturn -ENODEV;\n\n\tlen = sprintf(buf, \"%d\\n\", id);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, len);\n}"
  },
  {
    "function_name": "trace_format_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1609-1624",
    "snippet": "static int trace_format_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\t/* Do we want to hide event format files on tracefs lockdown? */\n\n\tret = seq_open(file, &trace_format_seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = file;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations trace_format_seq_ops = {\n\t.start\t\t= f_start,\n\t.next\t\t= f_next,\n\t.stop\t\t= f_stop,\n\t.show\t\t= f_show,\n};",
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&trace_format_seq_ops"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic const struct seq_operations trace_format_seq_ops = {\n\t.start\t\t= f_start,\n\t.next\t\t= f_next,\n\t.stop\t\t= f_stop,\n\t.show\t\t= f_show,\n};\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int trace_format_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\t/* Do we want to hide event format files on tracefs lockdown? */\n\n\tret = seq_open(file, &trace_format_seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = file;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "f_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1597-1600",
    "snippet": "static void f_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void f_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "f_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1581-1595",
    "snippet": "static void *f_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *p = (void *)FORMAT_HEADER;\n\tloff_t l = 0;\n\n\t/* ->stop() is called even if ->start() fails */\n\tmutex_lock(&event_mutex);\n\tif (!event_file_data(m->private))\n\t\treturn ERR_PTR(-ENODEV);\n\n\twhile (l < *pos && p)\n\t\tp = f_next(m, p, &l);\n\n\treturn p;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f_next",
          "args": [
            "m",
            "p",
            "&l"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "f_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1499-1529",
          "snippet": "static void *f_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct list_head *common_head = &ftrace_common_fields;\n\tstruct list_head *head = trace_get_fields(call);\n\tstruct list_head *node = v;\n\n\t(*pos)++;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tnode = common_head;\n\t\tbreak;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tnode = head;\n\t\tbreak;\n\n\tcase FORMAT_PRINTFMT:\n\t\t/* all done */\n\t\treturn NULL;\n\t}\n\n\tnode = node->prev;\n\tif (node == common_head)\n\t\treturn (void *)FORMAT_FIELD_SEPERATOR;\n\telse if (node == head)\n\t\treturn (void *)FORMAT_PRINTFMT;\n\telse\n\t\treturn node;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ftrace_common_fields);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(ftrace_common_fields);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void *f_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct list_head *common_head = &ftrace_common_fields;\n\tstruct list_head *head = trace_get_fields(call);\n\tstruct list_head *node = v;\n\n\t(*pos)++;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tnode = common_head;\n\t\tbreak;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tnode = head;\n\t\tbreak;\n\n\tcase FORMAT_PRINTFMT:\n\t\t/* all done */\n\t\treturn NULL;\n\t}\n\n\tnode = node->prev;\n\tif (node == common_head)\n\t\treturn (void *)FORMAT_FIELD_SEPERATOR;\n\telse if (node == head)\n\t\treturn (void *)FORMAT_PRINTFMT;\n\telse\n\t\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void *f_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *p = (void *)FORMAT_HEADER;\n\tloff_t l = 0;\n\n\t/* ->stop() is called even if ->start() fails */\n\tmutex_lock(&event_mutex);\n\tif (!event_file_data(m->private))\n\t\treturn ERR_PTR(-ENODEV);\n\n\twhile (l < *pos && p)\n\t\tp = f_next(m, p, &l);\n\n\treturn p;\n}"
  },
  {
    "function_name": "f_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1531-1579",
    "snippet": "static int f_show(struct seq_file *m, void *v)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct ftrace_event_field *field;\n\tconst char *array_descriptor;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tseq_printf(m, \"name: %s\\n\", trace_event_name(call));\n\t\tseq_printf(m, \"ID: %d\\n\", call->event.type);\n\t\tseq_puts(m, \"format:\\n\");\n\t\treturn 0;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tseq_putc(m, '\\n');\n\t\treturn 0;\n\n\tcase FORMAT_PRINTFMT:\n\t\tseq_printf(m, \"\\nprint fmt: %s\\n\",\n\t\t\t   call->print_fmt);\n\t\treturn 0;\n\t}\n\n\tfield = list_entry(v, struct ftrace_event_field, link);\n\t/*\n\t * Smartly shows the array type(except dynamic array).\n\t * Normal:\n\t *\tfield:TYPE VAR\n\t * If TYPE := TYPE[LEN], it is shown:\n\t *\tfield:TYPE VAR[LEN]\n\t */\n\tarray_descriptor = strchr(field->type, '[');\n\n\tif (str_has_prefix(field->type, \"__data_loc\"))\n\t\tarray_descriptor = NULL;\n\n\tif (!array_descriptor)\n\t\tseq_printf(m, \"\\tfield:%s %s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\",\n\t\t\t   field->type, field->name, field->offset,\n\t\t\t   field->size, !!field->is_signed);\n\telse\n\t\tseq_printf(m, \"\\tfield:%.*s %s%s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\",\n\t\t\t   (int)(array_descriptor - field->type),\n\t\t\t   field->type, field->name,\n\t\t\t   array_descriptor, field->offset,\n\t\t\t   field->size, !!field->is_signed);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\tfield:%.*s %s%s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\"",
            "(int)(array_descriptor - field->type)",
            "field->type",
            "field->name",
            "array_descriptor",
            "field->offset",
            "field->size",
            "!!field->is_signed"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "field->type",
            "\"__data_loc\""
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "field->type",
            "'['"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structftrace_event_field",
            "link"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"format:\\n\""
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int f_show(struct seq_file *m, void *v)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct ftrace_event_field *field;\n\tconst char *array_descriptor;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tseq_printf(m, \"name: %s\\n\", trace_event_name(call));\n\t\tseq_printf(m, \"ID: %d\\n\", call->event.type);\n\t\tseq_puts(m, \"format:\\n\");\n\t\treturn 0;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tseq_putc(m, '\\n');\n\t\treturn 0;\n\n\tcase FORMAT_PRINTFMT:\n\t\tseq_printf(m, \"\\nprint fmt: %s\\n\",\n\t\t\t   call->print_fmt);\n\t\treturn 0;\n\t}\n\n\tfield = list_entry(v, struct ftrace_event_field, link);\n\t/*\n\t * Smartly shows the array type(except dynamic array).\n\t * Normal:\n\t *\tfield:TYPE VAR\n\t * If TYPE := TYPE[LEN], it is shown:\n\t *\tfield:TYPE VAR[LEN]\n\t */\n\tarray_descriptor = strchr(field->type, '[');\n\n\tif (str_has_prefix(field->type, \"__data_loc\"))\n\t\tarray_descriptor = NULL;\n\n\tif (!array_descriptor)\n\t\tseq_printf(m, \"\\tfield:%s %s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\",\n\t\t\t   field->type, field->name, field->offset,\n\t\t\t   field->size, !!field->is_signed);\n\telse\n\t\tseq_printf(m, \"\\tfield:%.*s %s%s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\",\n\t\t\t   (int)(array_descriptor - field->type),\n\t\t\t   field->type, field->name,\n\t\t\t   array_descriptor, field->offset,\n\t\t\t   field->size, !!field->is_signed);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "f_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1499-1529",
    "snippet": "static void *f_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct list_head *common_head = &ftrace_common_fields;\n\tstruct list_head *head = trace_get_fields(call);\n\tstruct list_head *node = v;\n\n\t(*pos)++;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tnode = common_head;\n\t\tbreak;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tnode = head;\n\t\tbreak;\n\n\tcase FORMAT_PRINTFMT:\n\t\t/* all done */\n\t\treturn NULL;\n\t}\n\n\tnode = node->prev;\n\tif (node == common_head)\n\t\treturn (void *)FORMAT_FIELD_SEPERATOR;\n\telse if (node == head)\n\t\treturn (void *)FORMAT_PRINTFMT;\n\telse\n\t\treturn node;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ftrace_common_fields);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(ftrace_common_fields);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void *f_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct list_head *common_head = &ftrace_common_fields;\n\tstruct list_head *head = trace_get_fields(call);\n\tstruct list_head *node = v;\n\n\t(*pos)++;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tnode = common_head;\n\t\tbreak;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tnode = head;\n\t\tbreak;\n\n\tcase FORMAT_PRINTFMT:\n\t\t/* all done */\n\t\treturn NULL;\n\t}\n\n\tnode = node->prev;\n\tif (node == common_head)\n\t\treturn (void *)FORMAT_FIELD_SEPERATOR;\n\telse if (node == head)\n\t\treturn (void *)FORMAT_PRINTFMT;\n\telse\n\t\treturn node;\n}"
  },
  {
    "function_name": "system_enable_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1453-1491",
    "snippet": "static ssize_t\nsystem_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t    loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tconst char *name = NULL;\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Opening of \"enable\" adds a ref count to system,\n\t * so the name is safe to use.\n\t */\n\tif (system)\n\t\tname = system->name;\n\n\tret = __ftrace_set_clr_event(dir->tr, NULL, name, NULL, val);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cnt;\n\nout:\n\t*ppos += cnt;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event",
          "args": [
            "dir->tr",
            "NULL",
            "name",
            "NULL",
            "val"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1035-1045",
          "snippet": "static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_update_buffers",
          "args": [],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_update_buffers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6279-6290",
          "snippet": "int tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool ring_buffer_expanded;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nbool ring_buffer_expanded;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;\n\nint tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul_from_user",
          "args": [
            "ubuf",
            "cnt",
            "10",
            "&val"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nsystem_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t    loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tconst char *name = NULL;\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Opening of \"enable\" adds a ref count to system,\n\t * so the name is safe to use.\n\t */\n\tif (system)\n\t\tname = system->name;\n\n\tret = __ftrace_set_clr_event(dir->tr, NULL, name, NULL, val);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cnt;\n\nout:\n\t*ppos += cnt;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "system_enable_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1406-1451",
    "snippet": "static ssize_t\nsystem_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tconst char set_to_char[4] = { '?', '0', '1', 'X' };\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_event_call *call;\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = dir->tr;\n\tchar buf[2];\n\tint set = 0;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\tif ((call->flags & TRACE_EVENT_FL_IGNORE_ENABLE) ||\n\t\t    !trace_event_name(call) || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (system && strcmp(call->class->system, system->name) != 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We need to find out if all the events are set\n\t\t * or if all events or cleared, or if we have\n\t\t * a mixture.\n\t\t */\n\t\tset |= (1 << !!(file->flags & EVENT_FILE_FL_ENABLED));\n\n\t\t/*\n\t\t * If we have a mixture, no need to look further.\n\t\t */\n\t\tif (set == 3)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tbuf[0] = set_to_char[set];\n\tbuf[1] = '\\n';\n\n\tret = simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "buf",
            "2"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "call->class->system",
            "system->name"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic ssize_t\nsystem_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tconst char set_to_char[4] = { '?', '0', '1', 'X' };\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_event_call *call;\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = dir->tr;\n\tchar buf[2];\n\tint set = 0;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\tif ((call->flags & TRACE_EVENT_FL_IGNORE_ENABLE) ||\n\t\t    !trace_event_name(call) || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (system && strcmp(call->class->system, system->name) != 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We need to find out if all the events are set\n\t\t * or if all events or cleared, or if we have\n\t\t * a mixture.\n\t\t */\n\t\tset |= (1 << !!(file->flags & EVENT_FILE_FL_ENABLED));\n\n\t\t/*\n\t\t * If we have a mixture, no need to look further.\n\t\t */\n\t\tif (set == 3)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tbuf[0] = set_to_char[set];\n\tbuf[1] = '\\n';\n\n\tret = simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_enable_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1370-1404",
    "snippet": "static ssize_t\nevent_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\t\tret = -ENODEV;\n\t\tmutex_lock(&event_mutex);\n\t\tfile = event_file_data(filp);\n\t\tif (likely(file))\n\t\t\tret = ftrace_event_enable_disable(file, val);\n\t\tmutex_unlock(&event_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*ppos += cnt;\n\n\treturn ret ? ret : cnt;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_enable_disable",
          "args": [
            "file",
            "val"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "700-704",
          "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "file"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "filp"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_update_buffers",
          "args": [],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_update_buffers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6279-6290",
          "snippet": "int tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool ring_buffer_expanded;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nbool ring_buffer_expanded;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;\n\nint tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul_from_user",
          "args": [
            "ubuf",
            "cnt",
            "10",
            "&val"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\t\tret = -ENODEV;\n\t\tmutex_lock(&event_mutex);\n\t\tfile = event_file_data(filp);\n\t\tif (likely(file))\n\t\t\tret = ftrace_event_enable_disable(file, val);\n\t\tmutex_unlock(&event_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*ppos += cnt;\n\n\treturn ret ? ret : cnt;\n}"
  },
  {
    "function_name": "event_enable_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1340-1368",
    "snippet": "static ssize_t\nevent_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tunsigned long flags;\n\tchar buf[4] = \"0\";\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (likely(file))\n\t\tflags = file->flags;\n\tmutex_unlock(&event_mutex);\n\n\tif (!file)\n\t\treturn -ENODEV;\n\n\tif (flags & EVENT_FILE_FL_ENABLED &&\n\t    !(flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\tstrcpy(buf, \"1\");\n\n\tif (flags & EVENT_FILE_FL_SOFT_DISABLED ||\n\t    flags & EVENT_FILE_FL_SOFT_MODE)\n\t\tstrcat(buf, \"*\");\n\n\tstrcat(buf, \"\\n\");\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, strlen(buf));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "buf",
            "strlen(buf)"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buf",
            "\"\\n\""
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buf",
            "\"*\""
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "\"1\""
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "file"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "filp"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tunsigned long flags;\n\tchar buf[4] = \"0\";\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (likely(file))\n\t\tflags = file->flags;\n\tmutex_unlock(&event_mutex);\n\n\tif (!file)\n\t\treturn -ENODEV;\n\n\tif (flags & EVENT_FILE_FL_ENABLED &&\n\t    !(flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\tstrcpy(buf, \"1\");\n\n\tif (flags & EVENT_FILE_FL_SOFT_DISABLED ||\n\t    flags & EVENT_FILE_FL_SOFT_MODE)\n\t\tstrcat(buf, \"*\");\n\n\tstrcat(buf, \"\\n\");\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, strlen(buf));\n}"
  },
  {
    "function_name": "p_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1333-1338",
    "snippet": "static void p_stop(struct seq_file *m, void *p)\n\t__releases(RCU)\n{\n\trcu_read_unlock_sched();\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "RCU"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void p_stop(struct seq_file *m, void *p)\n\t__releases(RCU)\n{\n\trcu_read_unlock_sched();\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "np_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1327-1331",
    "snippet": "static void *np_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\treturn __start(m, pos, TRACE_NO_PIDS);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__start",
          "args": [
            "m",
            "pos",
            "TRACE_NO_PIDS"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "__start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1295-1319",
          "snippet": "static void *__start(struct seq_file *m, loff_t *pos, int type)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\t/*\n\t * Grab the mutex, to keep calls to p_next() having the same\n\t * tr->filtered_pids as p_start() has.\n\t * If we just passed the tr->filtered_pids around, then RCU would\n\t * have been enough, but doing that makes things more complex.\n\t */\n\tmutex_lock(&event_mutex);\n\trcu_read_lock_sched();\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\tif (!pid_list)\n\t\treturn NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void *__start(struct seq_file *m, loff_t *pos, int type)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\t/*\n\t * Grab the mutex, to keep calls to p_next() having the same\n\t * tr->filtered_pids as p_start() has.\n\t * If we just passed the tr->filtered_pids around, then RCU would\n\t * have been enough, but doing that makes things more complex.\n\t */\n\tmutex_lock(&event_mutex);\n\trcu_read_lock_sched();\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\tif (!pid_list)\n\t\treturn NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void *np_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\treturn __start(m, pos, TRACE_NO_PIDS);\n}"
  },
  {
    "function_name": "p_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1321-1325",
    "snippet": "static void *p_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\treturn __start(m, pos, TRACE_PIDS);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__start",
          "args": [
            "m",
            "pos",
            "TRACE_PIDS"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "__start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1295-1319",
          "snippet": "static void *__start(struct seq_file *m, loff_t *pos, int type)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\t/*\n\t * Grab the mutex, to keep calls to p_next() having the same\n\t * tr->filtered_pids as p_start() has.\n\t * If we just passed the tr->filtered_pids around, then RCU would\n\t * have been enough, but doing that makes things more complex.\n\t */\n\tmutex_lock(&event_mutex);\n\trcu_read_lock_sched();\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\tif (!pid_list)\n\t\treturn NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void *__start(struct seq_file *m, loff_t *pos, int type)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\t/*\n\t * Grab the mutex, to keep calls to p_next() having the same\n\t * tr->filtered_pids as p_start() has.\n\t * If we just passed the tr->filtered_pids around, then RCU would\n\t * have been enough, but doing that makes things more complex.\n\t */\n\tmutex_lock(&event_mutex);\n\trcu_read_lock_sched();\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\tif (!pid_list)\n\t\treturn NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void *p_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\treturn __start(m, pos, TRACE_PIDS);\n}"
  },
  {
    "function_name": "__start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1295-1319",
    "snippet": "static void *__start(struct seq_file *m, loff_t *pos, int type)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\t/*\n\t * Grab the mutex, to keep calls to p_next() having the same\n\t * tr->filtered_pids as p_start() has.\n\t * If we just passed the tr->filtered_pids around, then RCU would\n\t * have been enough, but doing that makes things more complex.\n\t */\n\tmutex_lock(&event_mutex);\n\trcu_read_lock_sched();\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\tif (!pid_list)\n\t\treturn NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_start",
          "args": [
            "pid_list",
            "pos"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "629-645",
          "snippet": "void *trace_pid_start(struct trace_pid_list *pid_list, loff_t *pos)\n{\n\tunsigned long pid;\n\tunsigned int first;\n\tloff_t l = 0;\n\n\tif (trace_pid_list_first(pid_list, &first) < 0)\n\t\treturn NULL;\n\n\tpid = first;\n\n\t/* Return pid + 1 so that zero can be the exit value */\n\tfor (pid++; pid && l < *pos;\n\t     pid = (unsigned long)trace_pid_next(pid_list, (void *)pid, &l))\n\t\t;\n\treturn (void *)pid;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *trace_pid_start(struct trace_pid_list *pid_list, loff_t *pos)\n{\n\tunsigned long pid;\n\tunsigned int first;\n\tloff_t l = 0;\n\n\tif (trace_pid_list_first(pid_list, &first) < 0)\n\t\treturn NULL;\n\n\tpid = first;\n\n\t/* Return pid + 1 so that zero can be the exit value */\n\tfor (pid++; pid && l < *pos;\n\t     pid = (unsigned long)trace_pid_next(pid_list, (void *)pid, &l))\n\t\t;\n\treturn (void *)pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_no_pids"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void *__start(struct seq_file *m, loff_t *pos, int type)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\t/*\n\t * Grab the mutex, to keep calls to p_next() having the same\n\t * tr->filtered_pids as p_start() has.\n\t * If we just passed the tr->filtered_pids around, then RCU would\n\t * have been enough, but doing that makes things more complex.\n\t */\n\tmutex_lock(&event_mutex);\n\trcu_read_lock_sched();\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\tif (!pid_list)\n\t\treturn NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}"
  },
  {
    "function_name": "np_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1289-1293",
    "snippet": "static void *\nnp_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn __next(m, v, pos, TRACE_NO_PIDS);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__next",
          "args": [
            "m",
            "v",
            "pos",
            "TRACE_NO_PIDS"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "__next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1269-1281",
          "snippet": "static void *\n__next(struct seq_file *m, void *v, loff_t *pos, int type)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list;\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\treturn trace_pid_next(pid_list, v, pos);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void *\n__next(struct seq_file *m, void *v, loff_t *pos, int type)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list;\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\treturn trace_pid_next(pid_list, v, pos);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void *\nnp_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn __next(m, v, pos, TRACE_NO_PIDS);\n}"
  },
  {
    "function_name": "p_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1283-1287",
    "snippet": "static void *\np_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn __next(m, v, pos, TRACE_PIDS);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__next",
          "args": [
            "m",
            "v",
            "pos",
            "TRACE_PIDS"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "__next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1269-1281",
          "snippet": "static void *\n__next(struct seq_file *m, void *v, loff_t *pos, int type)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list;\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\treturn trace_pid_next(pid_list, v, pos);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void *\n__next(struct seq_file *m, void *v, loff_t *pos, int type)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list;\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\treturn trace_pid_next(pid_list, v, pos);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void *\np_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn __next(m, v, pos, TRACE_PIDS);\n}"
  },
  {
    "function_name": "__next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1269-1281",
    "snippet": "static void *\n__next(struct seq_file *m, void *v, loff_t *pos, int type)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list;\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\treturn trace_pid_next(pid_list, v, pos);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_next",
          "args": [
            "pid_list",
            "v",
            "pos"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "601-616",
          "snippet": "void *trace_pid_next(struct trace_pid_list *pid_list, void *v, loff_t *pos)\n{\n\tlong pid = (unsigned long)v;\n\tunsigned int next;\n\n\t(*pos)++;\n\n\t/* pid already is +1 of the actual previous bit */\n\tif (trace_pid_list_next(pid_list, pid, &next) < 0)\n\t\treturn NULL;\n\n\tpid = next;\n\n\t/* Return pid + 1 to allow zero to be represented */\n\treturn (void *)(pid + 1);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *trace_pid_next(struct trace_pid_list *pid_list, void *v, loff_t *pos)\n{\n\tlong pid = (unsigned long)v;\n\tunsigned int next;\n\n\t(*pos)++;\n\n\t/* pid already is +1 of the actual previous bit */\n\tif (trace_pid_list_next(pid_list, pid, &next) < 0)\n\t\treturn NULL;\n\n\tpid = next;\n\n\t/* Return pid + 1 to allow zero to be represented */\n\treturn (void *)(pid + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_no_pids"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void *\n__next(struct seq_file *m, void *v, loff_t *pos, int type)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list;\n\n\tif (type == TRACE_PIDS)\n\t\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\telse\n\t\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\treturn trace_pid_next(pid_list, v, pos);\n}"
  },
  {
    "function_name": "t_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1264-1267",
    "snippet": "static void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "t_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1252-1262",
    "snippet": "static int t_show(struct seq_file *m, void *v)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call = file->event_call;\n\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0)\n\t\tseq_printf(m, \"%s:\", call->class->system);\n\tseq_printf(m, \"%s\\n\", trace_event_name(call));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define TRACE_SYSTEM \"TRACE_SYSTEM\""
    ],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "call->class->system",
            "TRACE_SYSTEM"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define TRACE_SYSTEM \"TRACE_SYSTEM\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call = file->event_call;\n\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0)\n\t\tseq_printf(m, \"%s:\", call->class->system);\n\tseq_printf(m, \"%s\\n\", trace_event_name(call));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "s_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1235-1250",
    "snippet": "static void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = m->private;\n\tloff_t l;\n\n\tmutex_lock(&event_mutex);\n\n\tfile = list_entry(&tr->events, struct trace_event_file, list);\n\tfor (l = 0; l <= *pos; ) {\n\t\tfile = s_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "s_next",
          "args": [
            "m",
            "file",
            "&l"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "s_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1219-1233",
          "snippet": "static void *\ns_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void *\ns_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "&tr->events",
            "structtrace_event_file",
            "list"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = m->private;\n\tloff_t l;\n\n\tmutex_lock(&event_mutex);\n\n\tfile = list_entry(&tr->events, struct trace_event_file, list);\n\tfor (l = 0; l <= *pos; ) {\n\t\tfile = s_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}"
  },
  {
    "function_name": "s_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1219-1233",
    "snippet": "static void *\ns_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void *\ns_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "t_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1202-1217",
    "snippet": "static void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = m->private;\n\tloff_t l;\n\n\tmutex_lock(&event_mutex);\n\n\tfile = list_entry(&tr->events, struct trace_event_file, list);\n\tfor (l = 0; l <= *pos; ) {\n\t\tfile = t_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_next",
          "args": [
            "m",
            "file",
            "&l"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "t_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1179-1200",
          "snippet": "static void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\t/*\n\t\t * The ftrace subsystem is for showing formats only.\n\t\t * They can not be enabled or disabled via the event files.\n\t\t */\n\t\tif (call->class && call->class->reg &&\n\t\t    !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\t/*\n\t\t * The ftrace subsystem is for showing formats only.\n\t\t * They can not be enabled or disabled via the event files.\n\t\t */\n\t\tif (call->class && call->class->reg &&\n\t\t    !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "&tr->events",
            "structtrace_event_file",
            "list"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = m->private;\n\tloff_t l;\n\n\tmutex_lock(&event_mutex);\n\n\tfile = list_entry(&tr->events, struct trace_event_file, list);\n\tfor (l = 0; l <= *pos; ) {\n\t\tfile = t_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}"
  },
  {
    "function_name": "t_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1179-1200",
    "snippet": "static void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\t/*\n\t\t * The ftrace subsystem is for showing formats only.\n\t\t * They can not be enabled or disabled via the event files.\n\t\t */\n\t\tif (call->class && call->class->reg &&\n\t\t    !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\t/*\n\t\t * The ftrace subsystem is for showing formats only.\n\t\t * They can not be enabled or disabled via the event files.\n\t\t */\n\t\tif (call->class && call->class->reg &&\n\t\t    !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_event_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1139-1177",
    "snippet": "static ssize_t\nftrace_event_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct trace_parser parser;\n\tstruct seq_file *m = file->private_data;\n\tstruct trace_array *tr = m->private;\n\tssize_t read, ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (trace_parser_get_init(&parser, EVENT_BUF_SIZE + 1))\n\t\treturn -ENOMEM;\n\n\tread = trace_get_user(&parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded((&parser))) {\n\t\tint set = 1;\n\n\t\tif (*parser.buffer == '!')\n\t\t\tset = 0;\n\n\t\tret = ftrace_set_clr_event(tr, parser.buffer + !set, set);\n\t\tif (ret)\n\t\t\tgoto out_put;\n\t}\n\n\tret = read;\n\n out_put:\n\ttrace_parser_put(&parser);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define EVENT_BUF_SIZE\t\t127"
    ],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parser_put",
          "args": [
            "&parser"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1558-1562",
          "snippet": "void trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_clr_event",
          "args": [
            "tr",
            "parser.buffer + !set",
            "set"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1047-1085",
          "snippet": "int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_loaded",
          "args": [
            "(&parser)"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_loaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1128-1131",
          "snippet": "static inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_user",
          "args": [
            "&parser",
            "ubuf",
            "cnt",
            "ppos"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1575-1650",
          "snippet": "int trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_get_init",
          "args": [
            "&parser",
            "EVENT_BUF_SIZE + 1"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_get_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1543-1553",
          "snippet": "int trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_update_buffers",
          "args": [],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_update_buffers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6279-6290",
          "snippet": "int tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool ring_buffer_expanded;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nbool ring_buffer_expanded;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;\n\nint tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define EVENT_BUF_SIZE\t\t127\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nftrace_event_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct trace_parser parser;\n\tstruct seq_file *m = file->private_data;\n\tstruct trace_array *tr = m->private;\n\tssize_t read, ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (trace_parser_get_init(&parser, EVENT_BUF_SIZE + 1))\n\t\treturn -ENOMEM;\n\n\tread = trace_get_user(&parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded((&parser))) {\n\t\tint set = 1;\n\n\t\tif (*parser.buffer == '!')\n\t\t\tset = 0;\n\n\t\tret = ftrace_set_clr_event(tr, parser.buffer + !set, set);\n\t\tif (ret)\n\t\t\tgoto out_put;\n\t}\n\n\tret = read;\n\n out_put:\n\ttrace_parser_put(&parser);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_array_set_clr_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1123-1133",
    "snippet": "int trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event",
          "args": [
            "tr",
            "NULL",
            "system",
            "event",
            "set"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1035-1045",
          "snippet": "static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_array_set_clr_event(struct trace_array *tr, const char *system,\n\t\tconst char *event, bool enable)\n{\n\tint set;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\tset = (enable == true) ? 1 : 0;\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
  },
  {
    "function_name": "trace_set_clr_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1099-1107",
    "snippet": "int trace_set_clr_event(const char *system, const char *event, int set)\n{\n\tstruct trace_array *tr = top_trace_array();\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event",
          "args": [
            "tr",
            "NULL",
            "system",
            "event",
            "set"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1035-1045",
          "snippet": "static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "411-422",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint trace_set_clr_event(const char *system, const char *event, int set)\n{\n\tstruct trace_array *tr = top_trace_array();\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
  },
  {
    "function_name": "ftrace_set_clr_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1047-1085",
    "snippet": "int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event",
          "args": [
            "tr",
            "match",
            "sub",
            "event",
            "set"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "1035-1045",
          "snippet": "static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event",
            "\"*\""
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "event"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&buf",
            "\":\""
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nint ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__ftrace_set_clr_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "1035-1045",
    "snippet": "static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event_nolock",
          "args": [
            "tr",
            "match",
            "sub",
            "event",
            "set"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event_nolock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "987-1033",
          "snippet": "static int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__ftrace_set_clr_event_nolock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "987-1033",
    "snippet": "static int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_event_enable_disable",
          "args": [
            "file",
            "set"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "700-704",
          "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event",
            "name"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "remove_event_file_dir",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "962-982",
    "snippet": "static void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *file_cachep;",
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "file_cachep",
            "file"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_event_filter",
          "args": [
            "file->filter"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1134-1137",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_subsystem",
          "args": [
            "file->system"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "remove_subsystem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "950-960",
          "snippet": "static void remove_subsystem(struct trace_subsystem_dir *dir)\n{\n\tif (!dir)\n\t\treturn;\n\n\tif (!--dir->nr_events) {\n\t\ttracefs_remove(dir->entry);\n\t\tlist_del(&dir->list);\n\t\t__put_system_dir(dir);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void remove_subsystem(struct trace_subsystem_dir *dir)\n{\n\tif (!dir)\n\t\treturn;\n\n\tif (!--dir->nr_events) {\n\t\ttracefs_remove(dir->entry);\n\t\tlist_del(&dir->list);\n\t\t__put_system_dir(dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&file->list"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracefs_remove",
          "args": [
            "dir"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dir->d_lock"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "child"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_really_is_positive",
          "args": [
            "child"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&dir->d_subdirs",
            "d_child"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dir->d_lock"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}"
  },
  {
    "function_name": "remove_subsystem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "950-960",
    "snippet": "static void remove_subsystem(struct trace_subsystem_dir *dir)\n{\n\tif (!dir)\n\t\treturn;\n\n\tif (!--dir->nr_events) {\n\t\ttracefs_remove(dir->entry);\n\t\tlist_del(&dir->list);\n\t\t__put_system_dir(dir);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_system_dir",
          "args": [
            "dir"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "__put_system_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "932-941",
          "snippet": "static void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&dir->list"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracefs_remove",
          "args": [
            "dir->entry"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void remove_subsystem(struct trace_subsystem_dir *dir)\n{\n\tif (!dir)\n\t\treturn;\n\n\tif (!--dir->nr_events) {\n\t\ttracefs_remove(dir->entry);\n\t\tlist_del(&dir->list);\n\t\t__put_system_dir(dir);\n\t}\n}"
  },
  {
    "function_name": "put_system",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "943-948",
    "snippet": "static void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_system_dir",
          "args": [
            "dir"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "__put_system_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "932-941",
          "snippet": "static void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "__put_system_dir",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "932-941",
    "snippet": "static void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_system",
          "args": [
            "dir->subsystem"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "__put_system_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "932-941",
          "snippet": "static void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "system_refcount(dir->subsystem) == 1 && dir->ref_count != 1"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system_refcount",
          "args": [
            "dir->subsystem"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "58-61",
          "snippet": "static int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dir->ref_count == 0"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}"
  },
  {
    "function_name": "__get_system_dir",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "925-930",
    "snippet": "static void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_system",
          "args": [
            "dir->subsystem"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "__get_system_dir",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "925-930",
          "snippet": "static void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dir->ref_count == 0"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}"
  },
  {
    "function_name": "__get_system",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "919-923",
    "snippet": "static void __get_system(struct event_subsystem *system)\n{\n\tWARN_ON_ONCE(system_refcount(system) == 0);\n\tsystem_refcount_inc(system);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "system_refcount_inc",
          "args": [
            "system"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "system_refcount(system) == 0"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system_refcount",
          "args": [
            "system"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "58-61",
          "snippet": "static int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __get_system(struct event_subsystem *system)\n{\n\tWARN_ON_ONCE(system_refcount(system) == 0);\n\tsystem_refcount_inc(system);\n}"
  },
  {
    "function_name": "__put_system",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "901-917",
    "snippet": "static void __put_system(struct event_subsystem *system)\n{\n\tstruct event_filter *filter = system->filter;\n\n\tWARN_ON_ONCE(system_refcount(system) == 0);\n\tif (system_refcount_dec(system))\n\t\treturn;\n\n\tlist_del(&system->list);\n\n\tif (filter) {\n\t\tkfree(filter->filter_string);\n\t\tkfree(filter);\n\t}\n\tkfree_const(system->name);\n\tkfree(system);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "system"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "system->name"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&system->list"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "system_refcount_dec",
          "args": [
            "system"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_dec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "58-61",
          "snippet": "static int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "system_refcount(system) == 0"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __put_system(struct event_subsystem *system)\n{\n\tstruct event_filter *filter = system->filter;\n\n\tWARN_ON_ONCE(system_refcount(system) == 0);\n\tif (system_refcount_dec(system))\n\t\treturn;\n\n\tlist_del(&system->list);\n\n\tif (filter) {\n\t\tkfree(filter->filter_string);\n\t\tkfree(filter);\n\t}\n\tkfree_const(system->name);\n\tkfree(system);\n}"
  },
  {
    "function_name": "ftrace_clear_event_pids",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "894-899",
    "snippet": "static void ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tmutex_lock(&event_mutex);\n\t__ftrace_clear_event_pids(tr, type);\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_clear_event_pids",
          "args": [
            "tr",
            "type"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_clear_event_pids",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "851-892",
          "snippet": "static void __ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_pid_events(tr);\n\n\t\tlist_for_each_entry(file, &tr->events, list) {\n\t\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t\t}\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ignore_pid = false;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->filtered_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void __ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_pid_events(tr);\n\n\t\tlist_for_each_entry(file, &tr->events, list) {\n\t\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t\t}\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ignore_pid = false;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->filtered_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tmutex_lock(&event_mutex);\n\t__ftrace_clear_event_pids(tr, type);\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "__ftrace_clear_event_pids",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "851-892",
    "snippet": "static void __ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_pid_events(tr);\n\n\t\tlist_for_each_entry(file, &tr->events, list) {\n\t\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t\t}\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ignore_pid = false;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->filtered_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_list_free",
          "args": [
            "no_pid_list"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_list_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/pid_list.c",
          "lines": "457-495",
          "snippet": "void trace_pid_list_free(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *upper;\n\tunion lower_chunk *lower;\n\tint i, j;\n\n\tif (!pid_list)\n\t\treturn;\n\n\tirq_work_sync(&pid_list->refill_irqwork);\n\n\twhile (pid_list->lower_list) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = pid_list->lower_list;\n\t\tpid_list->lower_list = pid_list->lower_list->next;\n\t\tkfree(chunk);\n\t}\n\n\twhile (pid_list->upper_list) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = pid_list->upper_list;\n\t\tpid_list->upper_list = pid_list->upper_list->next;\n\t\tkfree(chunk);\n\t}\n\n\tfor (i = 0; i < UPPER1_SIZE; i++) {\n\t\tupper = pid_list->upper[i];\n\t\tif (upper) {\n\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {\n\t\t\t\tlower = upper->data[j];\n\t\t\t\tkfree(lower);\n\t\t\t}\n\t\t\tkfree(upper);\n\t\t}\n\t}\n\tkfree(pid_list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n\nvoid trace_pid_list_free(struct trace_pid_list *pid_list)\n{\n\tunion upper_chunk *upper;\n\tunion lower_chunk *lower;\n\tint i, j;\n\n\tif (!pid_list)\n\t\treturn;\n\n\tirq_work_sync(&pid_list->refill_irqwork);\n\n\twhile (pid_list->lower_list) {\n\t\tunion lower_chunk *chunk;\n\n\t\tchunk = pid_list->lower_list;\n\t\tpid_list->lower_list = pid_list->lower_list->next;\n\t\tkfree(chunk);\n\t}\n\n\twhile (pid_list->upper_list) {\n\t\tunion upper_chunk *chunk;\n\n\t\tchunk = pid_list->upper_list;\n\t\tpid_list->upper_list = pid_list->upper_list->next;\n\t\tkfree(chunk);\n\t}\n\n\tfor (i = 0; i < UPPER1_SIZE; i++) {\n\t\tupper = pid_list->upper[i];\n\t\tif (upper) {\n\t\t\tfor (j = 0; j < UPPER2_SIZE; j++) {\n\t\t\t\tlower = upper->data[j];\n\t\t\t\tkfree(lower);\n\t\t\t}\n\t\t\tkfree(upper);\n\t\t}\n\t}\n\tkfree(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->filtered_no_pids",
            "NULL"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->filtered_pids",
            "NULL"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_PID_FILTER_BIT",
            "&file->flags"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_pid_events",
          "args": [
            "tr"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_pid_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "836-849",
          "snippet": "static void unregister_pid_events(struct trace_array *tr)\n{\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_pre, tr);\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_post, tr);\n\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_post, tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void unregister_pid_events(struct trace_array *tr)\n{\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_pre, tr);\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_post, tr);\n\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_post, tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "still_need_pid_events",
          "args": [
            "type",
            "pid_list",
            "no_pid_list"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "still_need_pid_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "221-230",
          "snippet": "static inline bool still_need_pid_events(int type, struct trace_pid_list *pid_list,\n\t\t\t\t\t struct trace_pid_list *no_pid_list)\n{\n\t/*\n\t * Turning off what is in @type, return true if the \"other\"\n\t * pid list, still has pids in it.\n\t */\n\treturn (!(type & TRACE_PIDS) && pid_list) ||\n\t\t(!(type & TRACE_NO_PIDS) && no_pid_list);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool still_need_pid_events(int type, struct trace_pid_list *pid_list,\n\t\t\t\t\t struct trace_pid_list *no_pid_list)\n{\n\t/*\n\t * Turning off what is in @type, return true if the \"other\"\n\t * pid list, still has pids in it.\n\t */\n\treturn (!(type & TRACE_PIDS) && pid_list) ||\n\t\t(!(type & TRACE_NO_PIDS) && no_pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_type_enabled",
          "args": [
            "type",
            "pid_list",
            "no_pid_list"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "pid_type_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "213-219",
          "snippet": "static inline bool pid_type_enabled(int type, struct trace_pid_list *pid_list,\n\t\t\t\t    struct trace_pid_list *no_pid_list)\n{\n\t/* Return true if the pid list in type has pids */\n\treturn ((type & TRACE_PIDS) && pid_list) ||\n\t\t((type & TRACE_NO_PIDS) && no_pid_list);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool pid_type_enabled(int type, struct trace_pid_list *pid_list,\n\t\t\t\t    struct trace_pid_list *no_pid_list)\n{\n\t/* Return true if the pid list in type has pids */\n\treturn ((type & TRACE_PIDS) && pid_list) ||\n\t\t((type & TRACE_NO_PIDS) && no_pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_no_pids",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&event_mutex"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_pids",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void __ftrace_clear_event_pids(struct trace_array *tr, int type)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tno_pid_list = rcu_dereference_protected(tr->filtered_no_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\t/* Make sure there's something to do */\n\tif (!pid_type_enabled(type, pid_list, no_pid_list))\n\t\treturn;\n\n\tif (!still_need_pid_events(type, pid_list, no_pid_list)) {\n\t\tunregister_pid_events(tr);\n\n\t\tlist_for_each_entry(file, &tr->events, list) {\n\t\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t\t}\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->ignore_pid = false;\n\t}\n\n\tif (type & TRACE_PIDS)\n\t\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\tif (type & TRACE_NO_PIDS)\n\t\trcu_assign_pointer(tr->filtered_no_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\tif ((type & TRACE_PIDS) && pid_list)\n\t\ttrace_pid_list_free(pid_list);\n\n\tif ((type & TRACE_NO_PIDS) && no_pid_list)\n\t\ttrace_pid_list_free(no_pid_list);\n}"
  },
  {
    "function_name": "unregister_pid_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "836-849",
    "snippet": "static void unregister_pid_events(struct trace_array *tr)\n{\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_pre, tr);\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_post, tr);\n\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_post, tr);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_waking",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_waking",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup_new",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup_new",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "event_filter_pid_sched_switch_probe_post",
            "tr"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "event_filter_pid_sched_switch_probe_pre",
            "tr"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void unregister_pid_events(struct trace_array *tr)\n{\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_pre, tr);\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_post, tr);\n\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_post, tr);\n}"
  },
  {
    "function_name": "event_filter_pid_sched_wakeup_probe_post",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "817-834",
    "snippet": "static void\nevent_filter_pid_sched_wakeup_probe_post(void *data, struct task_struct *task)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\n\t/* Nothing to do if we are not tracing */\n\tif (this_cpu_read(tr->array_buffer.data->ignore_pid))\n\t\treturn;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\t/* Set tracing if current is enabled */\n\tthis_cpu_write(tr->array_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, no_pid_list, current));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->array_buffer.data->ignore_pid",
            "trace_ignore_this_task(pid_list, no_pid_list, current)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "no_pid_list",
            "current"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "538-555",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_no_pids"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tr->array_buffer.data->ignore_pid"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_wakeup_probe_post(void *data, struct task_struct *task)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\n\t/* Nothing to do if we are not tracing */\n\tif (this_cpu_read(tr->array_buffer.data->ignore_pid))\n\t\treturn;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\t/* Set tracing if current is enabled */\n\tthis_cpu_write(tr->array_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, no_pid_list, current));\n}"
  },
  {
    "function_name": "event_filter_pid_sched_wakeup_probe_pre",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "799-815",
    "snippet": "static void\nevent_filter_pid_sched_wakeup_probe_pre(void *data, struct task_struct *task)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\n\t/* Nothing to do if we are already tracing */\n\tif (!this_cpu_read(tr->array_buffer.data->ignore_pid))\n\t\treturn;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\tthis_cpu_write(tr->array_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, no_pid_list, task));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->array_buffer.data->ignore_pid",
            "trace_ignore_this_task(pid_list, no_pid_list, task)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "no_pid_list",
            "task"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "538-555",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_no_pids"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tr->array_buffer.data->ignore_pid"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_wakeup_probe_pre(void *data, struct task_struct *task)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\n\t/* Nothing to do if we are already tracing */\n\tif (!this_cpu_read(tr->array_buffer.data->ignore_pid))\n\t\treturn;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\tthis_cpu_write(tr->array_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, no_pid_list, task));\n}"
  },
  {
    "function_name": "event_filter_pid_sched_switch_probe_post",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "784-797",
    "snippet": "static void\nevent_filter_pid_sched_switch_probe_post(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\tthis_cpu_write(tr->array_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, no_pid_list, next));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->array_buffer.data->ignore_pid",
            "trace_ignore_this_task(pid_list, no_pid_list, next)"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "no_pid_list",
            "next"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "538-555",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_no_pids"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_switch_probe_post(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\tthis_cpu_write(tr->array_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, no_pid_list, next));\n}"
  },
  {
    "function_name": "event_filter_pid_sched_switch_probe_pre",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "760-782",
    "snippet": "static void\nevent_filter_pid_sched_switch_probe_pre(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\tbool ret;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\t/*\n\t * Sched switch is funny, as we only want to ignore it\n\t * in the notrace case if both prev and next should be ignored.\n\t */\n\tret = trace_ignore_this_task(NULL, no_pid_list, prev) &&\n\t\ttrace_ignore_this_task(NULL, no_pid_list, next);\n\n\tthis_cpu_write(tr->array_buffer.data->ignore_pid, ret ||\n\t\t       (trace_ignore_this_task(pid_list, NULL, prev) &&\n\t\t\ttrace_ignore_this_task(pid_list, NULL, next)));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->array_buffer.data->ignore_pid",
            "ret ||\n\t\t       (trace_ignore_this_task(pid_list, NULL, prev) &&\n\t\t\ttrace_ignore_this_task(pid_list, NULL, next))"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "NULL",
            "next"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "538-555",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filtered_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_no_pids"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_switch_probe_pre(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\tbool ret;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\n\t/*\n\t * Sched switch is funny, as we only want to ignore it\n\t * in the notrace case if both prev and next should be ignored.\n\t */\n\tret = trace_ignore_this_task(NULL, no_pid_list, prev) &&\n\t\ttrace_ignore_this_task(NULL, no_pid_list, next);\n\n\tthis_cpu_write(tr->array_buffer.data->ignore_pid, ret ||\n\t\t       (trace_ignore_this_task(pid_list, NULL, prev) &&\n\t\t\ttrace_ignore_this_task(pid_list, NULL, next)));\n}"
  },
  {
    "function_name": "trace_event_follow_fork",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "745-758",
    "snippet": "void trace_event_follow_fork(struct trace_array *tr, bool enable)\n{\n\tif (enable) {\n\t\tregister_trace_prio_sched_process_fork(event_filter_pid_sched_process_fork,\n\t\t\t\t\t\t       tr, INT_MIN);\n\t\tregister_trace_prio_sched_process_free(event_filter_pid_sched_process_exit,\n\t\t\t\t\t\t       tr, INT_MAX);\n\t} else {\n\t\tunregister_trace_sched_process_fork(event_filter_pid_sched_process_fork,\n\t\t\t\t\t\t    tr);\n\t\tunregister_trace_sched_process_free(event_filter_pid_sched_process_exit,\n\t\t\t\t\t\t    tr);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_process_free",
          "args": [
            "event_filter_pid_sched_process_exit",
            "tr"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_process_fork",
          "args": [
            "event_filter_pid_sched_process_fork",
            "tr"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_process_free",
          "args": [
            "event_filter_pid_sched_process_exit",
            "tr",
            "INT_MAX"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_process_fork",
          "args": [
            "event_filter_pid_sched_process_fork",
            "tr",
            "INT_MIN"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nvoid trace_event_follow_fork(struct trace_array *tr, bool enable)\n{\n\tif (enable) {\n\t\tregister_trace_prio_sched_process_fork(event_filter_pid_sched_process_fork,\n\t\t\t\t\t\t       tr, INT_MIN);\n\t\tregister_trace_prio_sched_process_free(event_filter_pid_sched_process_exit,\n\t\t\t\t\t\t       tr, INT_MAX);\n\t} else {\n\t\tunregister_trace_sched_process_fork(event_filter_pid_sched_process_fork,\n\t\t\t\t\t\t    tr);\n\t\tunregister_trace_sched_process_free(event_filter_pid_sched_process_exit,\n\t\t\t\t\t\t    tr);\n\t}\n}"
  },
  {
    "function_name": "event_filter_pid_sched_process_fork",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "730-743",
    "snippet": "static void\nevent_filter_pid_sched_process_fork(void *data,\n\t\t\t\t    struct task_struct *self,\n\t\t\t\t    struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n\n\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_filter_add_remove_task",
          "args": [
            "pid_list",
            "self",
            "task"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "trace_filter_add_remove_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "569-587",
          "snippet": "void trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\ttrace_pid_list_set(pid_list, task->pid);\n\telse\n\t\ttrace_pid_list_clear(pid_list, task->pid);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\ttrace_pid_list_set(pid_list, task->pid);\n\telse\n\t\ttrace_pid_list_clear(pid_list, task->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_no_pids"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_process_fork(void *data,\n\t\t\t\t    struct task_struct *self,\n\t\t\t\t    struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n\n\tpid_list = rcu_dereference_sched(tr->filtered_no_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n}"
  },
  {
    "function_name": "event_filter_pid_sched_process_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "717-728",
    "snippet": "static void\nevent_filter_pid_sched_process_exit(void *data, struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n\n\tpid_list = rcu_dereference_raw(tr->filtered_no_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_filter_add_remove_task",
          "args": [
            "pid_list",
            "NULL",
            "task"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "trace_filter_add_remove_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "569-587",
          "snippet": "void trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\ttrace_pid_list_set(pid_list, task->pid);\n\telse\n\t\ttrace_pid_list_clear(pid_list, task->pid);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\ttrace_pid_list_set(pid_list, task->pid);\n\telse\n\t\ttrace_pid_list_clear(pid_list, task->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "tr->filtered_no_pids"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_process_exit(void *data, struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n\n\tpid_list = rcu_dereference_raw(tr->filtered_no_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n}"
  },
  {
    "function_name": "ftrace_clear_events",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "706-715",
    "snippet": "static void ftrace_clear_events(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tftrace_event_enable_disable(file, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "700-704",
          "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void ftrace_clear_events(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tftrace_event_enable_disable(file, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "ftrace_event_enable_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "700-704",
    "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_event_enable_disable",
          "args": [
            "file",
            "enable",
            "0"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "576-692",
          "snippet": "static int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
  },
  {
    "function_name": "trace_event_enable_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "694-698",
    "snippet": "int trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_event_enable_disable",
          "args": [
            "file",
            "enable",
            "soft_disable"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "576-692",
          "snippet": "static int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nint trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}"
  },
  {
    "function_name": "__ftrace_event_enable_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "576-692",
    "snippet": "static int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffered_event_disable",
          "args": [],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffered_event_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2699-2735",
          "snippet": "void trace_buffered_event_disable(void)\n{\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (WARN_ON_ONCE(!trace_buffered_event_ref))\n\t\treturn;\n\n\tif (--trace_buffered_event_ref)\n\t\treturn;\n\n\tpreempt_disable();\n\t/* For each CPU, set the buffer as used. */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       disable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n\n\t/* Wait for all current users to finish */\n\tsynchronize_rcu();\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tfree_page((unsigned long)per_cpu(trace_buffered_event, cpu));\n\t\tper_cpu(trace_buffered_event, cpu) = NULL;\n\t}\n\t/*\n\t * Make sure trace_buffered_event is NULL before clearing\n\t * trace_buffered_event_cnt.\n\t */\n\tsmp_wmb();\n\n\tpreempt_disable();\n\t/* Do the work on each cpu */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       enable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_buffered_event_ref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int trace_buffered_event_ref;\n\nvoid trace_buffered_event_disable(void)\n{\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (WARN_ON_ONCE(!trace_buffered_event_ref))\n\t\treturn;\n\n\tif (--trace_buffered_event_ref)\n\t\treturn;\n\n\tpreempt_disable();\n\t/* For each CPU, set the buffer as used. */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       disable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n\n\t/* Wait for all current users to finish */\n\tsynchronize_rcu();\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tfree_page((unsigned long)per_cpu(trace_buffered_event, cpu));\n\t\tper_cpu(trace_buffered_event, cpu) = NULL;\n\t}\n\t/*\n\t * Make sure trace_buffered_event is NULL before clearing\n\t * trace_buffered_event_cnt.\n\t */\n\tsmp_wmb();\n\n\tpreempt_disable();\n\t/* Do the work on each cpu */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       enable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffered_event_enable",
          "args": [],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffered_event_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2644-2677",
          "snippet": "void trace_buffered_event_enable(void)\n{\n\tstruct ring_buffer_event *event;\n\tstruct page *page;\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (trace_buffered_event_ref++)\n\t\treturn;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\t\tif (!page)\n\t\t\tgoto failed;\n\n\t\tevent = page_address(page);\n\t\tmemset(event, 0, sizeof(*event));\n\n\t\tper_cpu(trace_buffered_event, cpu) = event;\n\n\t\tpreempt_disable();\n\t\tif (cpu == smp_processor_id() &&\n\t\t    __this_cpu_read(trace_buffered_event) !=\n\t\t    per_cpu(trace_buffered_event, cpu))\n\t\t\tWARN_ON_ONCE(1);\n\t\tpreempt_enable();\n\t}\n\n\treturn;\n failed:\n\ttrace_buffered_event_disable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static int trace_buffered_event_ref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic int trace_buffered_event_ref;\n\nvoid trace_buffered_event_enable(void)\n{\n\tstruct ring_buffer_event *event;\n\tstruct page *page;\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (trace_buffered_event_ref++)\n\t\treturn;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\t\tif (!page)\n\t\t\tgoto failed;\n\n\t\tevent = page_address(page);\n\t\tmemset(event, 0, sizeof(*event));\n\n\t\tper_cpu(trace_buffered_event, cpu) = event;\n\n\t\tpreempt_disable();\n\t\tif (cpu == smp_processor_id() &&\n\t\t    __this_cpu_read(trace_buffered_event) !=\n\t\t    per_cpu(trace_buffered_event, cpu))\n\t\t\tWARN_ON_ONCE(1);\n\t\tpreempt_enable();\n\t}\n\n\treturn;\n failed:\n\ttrace_buffered_event_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_WAS_ENABLED_BIT",
            "&file->flags"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_stop_tgid_record",
          "args": [],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_tgid_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "146-149",
          "snippet": "void tracing_stop_tgid_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_TGID);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n\nvoid tracing_stop_tgid_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_cmdline_record",
          "args": [],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_cmdline_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "136-139",
          "snippet": "void tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call->class->reg",
          "args": [
            "call",
            "TRACE_REG_REGISTER",
            "file"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_start_tgid_record",
          "args": [],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_tgid_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "141-144",
          "snippet": "void tracing_start_tgid_record(void)\n{\n\ttracing_start_sched_switch(RECORD_TGID);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n\nvoid tracing_start_tgid_record(void)\n{\n\ttracing_start_sched_switch(RECORD_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start_cmdline_record",
          "args": [],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_cmdline_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "131-134",
          "snippet": "void tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&file->sm_ref"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_SOFT_DISABLED_BIT",
            "&file->flags"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call->class->reg",
          "args": [
            "call",
            "TRACE_REG_UNREGISTER",
            "file"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&file->sm_ref"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_event_enable_tgid_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "554-574",
    "snippet": "void trace_event_enable_tgid_record(bool enable)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tdo_for_each_event_file(tr, file) {\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\tif (enable) {\n\t\t\ttracing_start_tgid_record();\n\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t} else {\n\t\t\ttracing_stop_tgid_record();\n\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT,\n\t\t\t\t  &file->flags);\n\t\t}\n\t} while_for_each_event_file();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_event_file",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_RECORDED_TGID_BIT",
            "&file->flags"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_tgid_record",
          "args": [],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_tgid_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "146-149",
          "snippet": "void tracing_stop_tgid_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_TGID);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n\nvoid tracing_stop_tgid_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_RECORDED_TGID_BIT",
            "&file->flags"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start_tgid_record",
          "args": [],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_tgid_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "141-144",
          "snippet": "void tracing_start_tgid_record(void)\n{\n\ttracing_start_sched_switch(RECORD_TGID);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n\nvoid tracing_start_tgid_record(void)\n{\n\ttracing_start_sched_switch(RECORD_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_event_file",
          "args": [
            "tr",
            "file"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_event_enable_tgid_record(bool enable)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tdo_for_each_event_file(tr, file) {\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\tif (enable) {\n\t\t\ttracing_start_tgid_record();\n\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t} else {\n\t\t\ttracing_stop_tgid_record();\n\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT,\n\t\t\t\t  &file->flags);\n\t\t}\n\t} while_for_each_event_file();\n}"
  },
  {
    "function_name": "trace_event_enable_cmd_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "532-552",
    "snippet": "void trace_event_enable_cmd_record(bool enable)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tdo_for_each_event_file(tr, file) {\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\tif (enable) {\n\t\t\ttracing_start_cmdline_record();\n\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t} else {\n\t\t\ttracing_stop_cmdline_record();\n\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t}\n\t} while_for_each_event_file();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_event_file",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_RECORDED_CMD_BIT",
            "&file->flags"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_cmdline_record",
          "args": [],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_cmdline_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "136-139",
          "snippet": "void tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_RECORDED_CMD_BIT",
            "&file->flags"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start_cmdline_record",
          "args": [],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_cmdline_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "131-134",
          "snippet": "void tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_event_file",
          "args": [
            "tr",
            "file"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_event_enable_cmd_record(bool enable)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tdo_for_each_event_file(tr, file) {\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\tif (enable) {\n\t\t\ttracing_start_cmdline_record();\n\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t} else {\n\t\t\ttracing_stop_cmdline_record();\n\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t}\n\t} while_for_each_event_file();\n}"
  },
  {
    "function_name": "trace_event_reg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "494-529",
    "snippet": "int trace_event_reg(struct trace_event_call *call,\n\t\t    enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tWARN_ON(!(call->flags & TRACE_EVENT_FL_TRACEPOINT));\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn tracepoint_probe_register(call->tp,\n\t\t\t\t\t\t call->class->probe,\n\t\t\t\t\t\t file);\n\tcase TRACE_REG_UNREGISTER:\n\t\ttracepoint_probe_unregister(call->tp,\n\t\t\t\t\t    call->class->probe,\n\t\t\t\t\t    file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn tracepoint_probe_register(call->tp,\n\t\t\t\t\t\t call->class->perf_probe,\n\t\t\t\t\t\t call);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\ttracepoint_probe_unregister(call->tp,\n\t\t\t\t\t    call->class->perf_probe,\n\t\t\t\t\t    call);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracepoint_probe_unregister",
          "args": [
            "call->tp",
            "call->class->perf_probe",
            "call"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_probe_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "543-554",
          "snippet": "int tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(tracepoints_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nint tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_probe_register",
          "args": [
            "call->tp",
            "call->class->perf_probe",
            "call"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_probe_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "529-532",
          "snippet": "int tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(call->flags & TRACE_EVENT_FL_TRACEPOINT)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_event_reg(struct trace_event_call *call,\n\t\t    enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tWARN_ON(!(call->flags & TRACE_EVENT_FL_TRACEPOINT));\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn tracepoint_probe_register(call->tp,\n\t\t\t\t\t\t call->class->probe,\n\t\t\t\t\t\t file);\n\tcase TRACE_REG_UNREGISTER:\n\t\ttracepoint_probe_unregister(call->tp,\n\t\t\t\t\t    call->class->probe,\n\t\t\t\t\t    file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn tracepoint_probe_register(call->tp,\n\t\t\t\t\t\t call->class->perf_probe,\n\t\t\t\t\t\t call);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\ttracepoint_probe_unregister(call->tp,\n\t\t\t\t\t    call->class->perf_probe,\n\t\t\t\t\t    call);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_event_buffer_reserve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "462-491",
    "snippet": "void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "fbuffer->event"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_lock_reserve",
          "args": [
            "&fbuffer->buffer",
            "trace_file",
            "event_call->event.type",
            "len",
            "fbuffer->trace_ctx"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2739-2819",
          "snippet": "struct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct trace_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\tstruct ring_buffer_event *entry;\n\tstruct trace_array *tr = trace_file->tr;\n\tint val;\n\n\t*current_rb = tr->array_buffer.buffer;\n\n\tif (!tr->no_filter_buffering_ref &&\n\t    (trace_file->flags & (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED))) {\n\t\tpreempt_disable_notrace();\n\t\t/*\n\t\t * Filtering is on, so try to use the per cpu buffer first.\n\t\t * This buffer will simulate a ring_buffer_event,\n\t\t * where the type_len is zero and the array[0] will\n\t\t * hold the full length.\n\t\t * (see include/linux/ring-buffer.h for details on\n\t\t *  how the ring_buffer_event is structured).\n\t\t *\n\t\t * Using a temp buffer during filtering and copying it\n\t\t * on a matched filter is quicker than writing directly\n\t\t * into the ring buffer and then discarding it when\n\t\t * it doesn't match. That is because the discard\n\t\t * requires several atomic operations to get right.\n\t\t * Copying on match and doing nothing on a failed match\n\t\t * is still quicker than no copy on match, but having\n\t\t * to discard out of the ring buffer on a failed match.\n\t\t */\n\t\tif ((entry = __this_cpu_read(trace_buffered_event))) {\n\t\t\tint max_len = PAGE_SIZE - struct_size(entry, array, 1);\n\n\t\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\n\t\t\t/*\n\t\t\t * Preemption is disabled, but interrupts and NMIs\n\t\t\t * can still come in now. If that happens after\n\t\t\t * the above increment, then it will have to go\n\t\t\t * back to the old method of allocating the event\n\t\t\t * on the ring buffer, and if the filter fails, it\n\t\t\t * will have to call ring_buffer_discard_commit()\n\t\t\t * to remove it.\n\t\t\t *\n\t\t\t * Need to also check the unlikely case that the\n\t\t\t * length is bigger than the temp buffer size.\n\t\t\t * If that happens, then the reserve is pretty much\n\t\t\t * guaranteed to fail, as the ring buffer currently\n\t\t\t * only allows events less than a page. But that may\n\t\t\t * change in the future, so let the ring buffer reserve\n\t\t\t * handle the failure in that case.\n\t\t\t */\n\t\t\tif (val == 1 && likely(len <= max_len)) {\n\t\t\t\ttrace_event_setup(entry, type, trace_ctx);\n\t\t\t\tentry->array[0] = len;\n\t\t\t\t/* Return with preemption disabled */\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t\t}\n\t\t/* __trace_buffer_lock_reserve() disables preemption */\n\t\tpreempt_enable_notrace();\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t    trace_ctx);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the trigger to use. It's recursive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t\t    trace_ctx);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static struct trace_buffer *temp_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic struct trace_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct trace_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\tstruct ring_buffer_event *entry;\n\tstruct trace_array *tr = trace_file->tr;\n\tint val;\n\n\t*current_rb = tr->array_buffer.buffer;\n\n\tif (!tr->no_filter_buffering_ref &&\n\t    (trace_file->flags & (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED))) {\n\t\tpreempt_disable_notrace();\n\t\t/*\n\t\t * Filtering is on, so try to use the per cpu buffer first.\n\t\t * This buffer will simulate a ring_buffer_event,\n\t\t * where the type_len is zero and the array[0] will\n\t\t * hold the full length.\n\t\t * (see include/linux/ring-buffer.h for details on\n\t\t *  how the ring_buffer_event is structured).\n\t\t *\n\t\t * Using a temp buffer during filtering and copying it\n\t\t * on a matched filter is quicker than writing directly\n\t\t * into the ring buffer and then discarding it when\n\t\t * it doesn't match. That is because the discard\n\t\t * requires several atomic operations to get right.\n\t\t * Copying on match and doing nothing on a failed match\n\t\t * is still quicker than no copy on match, but having\n\t\t * to discard out of the ring buffer on a failed match.\n\t\t */\n\t\tif ((entry = __this_cpu_read(trace_buffered_event))) {\n\t\t\tint max_len = PAGE_SIZE - struct_size(entry, array, 1);\n\n\t\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\n\t\t\t/*\n\t\t\t * Preemption is disabled, but interrupts and NMIs\n\t\t\t * can still come in now. If that happens after\n\t\t\t * the above increment, then it will have to go\n\t\t\t * back to the old method of allocating the event\n\t\t\t * on the ring buffer, and if the filter fails, it\n\t\t\t * will have to call ring_buffer_discard_commit()\n\t\t\t * to remove it.\n\t\t\t *\n\t\t\t * Need to also check the unlikely case that the\n\t\t\t * length is bigger than the temp buffer size.\n\t\t\t * If that happens, then the reserve is pretty much\n\t\t\t * guaranteed to fail, as the ring buffer currently\n\t\t\t * only allows events less than a page. But that may\n\t\t\t * change in the future, so let the ring buffer reserve\n\t\t\t * handle the failure in that case.\n\t\t\t */\n\t\t\tif (val == 1 && likely(len <= max_len)) {\n\t\t\t\ttrace_event_setup(entry, type, trace_ctx);\n\t\t\t\tentry->array[0] = len;\n\t\t\t\t/* Return with preemption disabled */\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t\t}\n\t\t/* __trace_buffer_lock_reserve() disables preemption */\n\t\tpreempt_enable_notrace();\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t    trace_ctx);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the trigger to use. It's recursive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb, type, len,\n\t\t\t\t\t\t    trace_ctx);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_dec",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_ignore_this_pid",
          "args": [
            "trace_file"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_ignore_this_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "443-459",
          "snippet": "bool trace_event_ignore_this_pid(struct trace_event_file *trace_file)\n{\n\tstruct trace_array *tr = trace_file->tr;\n\tstruct trace_array_cpu *data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_raw(tr->filtered_no_pids);\n\n\tif (!pid_list && !no_pid_list)\n\t\treturn false;\n\n\tdata = this_cpu_ptr(tr->array_buffer.data);\n\n\treturn data->ignore_pid;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nbool trace_event_ignore_this_pid(struct trace_event_file *trace_file)\n{\n\tstruct trace_array *tr = trace_file->tr;\n\tstruct trace_array_cpu *data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_raw(tr->filtered_no_pids);\n\n\tif (!pid_list && !no_pid_list)\n\t\treturn false;\n\n\tdata = this_cpu_ptr(tr->array_buffer.data);\n\n\treturn data->ignore_pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nvoid *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}"
  },
  {
    "function_name": "trace_event_ignore_this_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "443-459",
    "snippet": "bool trace_event_ignore_this_pid(struct trace_event_file *trace_file)\n{\n\tstruct trace_array *tr = trace_file->tr;\n\tstruct trace_array_cpu *data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_raw(tr->filtered_no_pids);\n\n\tif (!pid_list && !no_pid_list)\n\t\treturn false;\n\n\tdata = this_cpu_ptr(tr->array_buffer.data);\n\n\treturn data->ignore_pid;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "tr->array_buffer.data"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "tr->filtered_no_pids"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nbool trace_event_ignore_this_pid(struct trace_event_file *trace_file)\n{\n\tstruct trace_array *tr = trace_file->tr;\n\tstruct trace_array_cpu *data;\n\tstruct trace_pid_list *no_pid_list;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\tno_pid_list = rcu_dereference_raw(tr->filtered_no_pids);\n\n\tif (!pid_list && !no_pid_list)\n\t\treturn false;\n\n\tdata = this_cpu_ptr(tr->array_buffer.data);\n\n\treturn data->ignore_pid;\n}"
  },
  {
    "function_name": "trace_event_raw_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "429-440",
    "snippet": "int trace_event_raw_init(struct trace_event_call *call)\n{\n\tint id;\n\n\tid = register_trace_event(&call->event);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\ttest_event_printk(call);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_event_printk",
          "args": [
            "call"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "test_event_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "258-427",
          "snippet": "static void test_event_printk(struct trace_event_call *call)\n{\n\tu64 dereference_flags = 0;\n\tbool first = true;\n\tconst char *fmt, *c, *r, *a;\n\tint parens = 0;\n\tchar in_quote = 0;\n\tint start_arg = 0;\n\tint arg = 0;\n\tint i;\n\n\tfmt = call->print_fmt;\n\n\tif (!fmt)\n\t\treturn;\n\n\tfor (i = 0; fmt[i]; i++) {\n\t\tswitch (fmt[i]) {\n\t\tcase '\\\\':\n\t\t\ti++;\n\t\t\tif (!fmt[i])\n\t\t\t\treturn;\n\t\t\tcontinue;\n\t\tcase '\"':\n\t\tcase '\\'':\n\t\t\t/*\n\t\t\t * The print fmt starts with a string that\n\t\t\t * is processed first to find %p* usage,\n\t\t\t * then after the first string, the print fmt\n\t\t\t * contains arguments that are used to check\n\t\t\t * if the dereferenced %p* usage is safe.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\tif (fmt[i] == '\\'')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (in_quote) {\n\t\t\t\t\targ = 0;\n\t\t\t\t\tfirst = false;\n\t\t\t\t\t/*\n\t\t\t\t\t * If there was no %p* uses\n\t\t\t\t\t * the fmt is OK.\n\t\t\t\t\t */\n\t\t\t\t\tif (!dereference_flags)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (in_quote) {\n\t\t\t\tif (in_quote == fmt[i])\n\t\t\t\t\tin_quote = 0;\n\t\t\t} else {\n\t\t\t\tin_quote = fmt[i];\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase '%':\n\t\t\tif (!first || !in_quote)\n\t\t\t\tcontinue;\n\t\t\ti++;\n\t\t\tif (!fmt[i])\n\t\t\t\treturn;\n\t\t\tswitch (fmt[i]) {\n\t\t\tcase '%':\n\t\t\t\tcontinue;\n\t\t\tcase 'p':\n\t\t\t\t/* Find dereferencing fields */\n\t\t\t\tswitch (fmt[i + 1]) {\n\t\t\t\tcase 'B': case 'R': case 'r':\n\t\t\t\tcase 'b': case 'M': case 'm':\n\t\t\t\tcase 'I': case 'i': case 'E':\n\t\t\t\tcase 'U': case 'V': case 'N':\n\t\t\t\tcase 'a': case 'd': case 'D':\n\t\t\t\tcase 'g': case 't': case 'C':\n\t\t\t\tcase 'O': case 'f':\n\t\t\t\t\tif (WARN_ONCE(arg == 63,\n\t\t\t\t\t\t      \"Too many args for event: %s\",\n\t\t\t\t\t\t      trace_event_name(call)))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tdereference_flags |= 1ULL << arg;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tbool star = false;\n\t\t\t\tint j;\n\n\t\t\t\t/* Increment arg if %*s exists. */\n\t\t\t\tfor (j = 0; fmt[i + j]; j++) {\n\t\t\t\t\tif (isdigit(fmt[i + j]) ||\n\t\t\t\t\t    fmt[i + j] == '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (fmt[i + j] == '*') {\n\t\t\t\t\t\tstar = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((fmt[i + j] == 's') && star)\n\t\t\t\t\t\targ++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} /* default */\n\n\t\t\t} /* switch */\n\t\t\targ++;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tif (in_quote)\n\t\t\t\tcontinue;\n\t\t\tparens++;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tif (in_quote)\n\t\t\t\tcontinue;\n\t\t\tparens--;\n\t\t\tif (WARN_ONCE(parens < 0,\n\t\t\t\t      \"Paren mismatch for event: %s\\narg='%s'\\n%*s\",\n\t\t\t\t      trace_event_name(call),\n\t\t\t\t      fmt + start_arg,\n\t\t\t\t      (i - start_arg) + 5, \"^\"))\n\t\t\t\treturn;\n\t\t\tcontinue;\n\t\tcase ',':\n\t\t\tif (in_quote || parens)\n\t\t\t\tcontinue;\n\t\t\ti++;\n\t\t\twhile (isspace(fmt[i]))\n\t\t\t\ti++;\n\t\t\tstart_arg = i;\n\t\t\tif (!(dereference_flags & (1ULL << arg)))\n\t\t\t\tgoto next_arg;\n\n\t\t\t/* Find the REC-> in the argument */\n\t\t\tc = strchr(fmt + i, ',');\n\t\t\tr = strstr(fmt + i, \"REC->\");\n\t\t\tif (r && (!c || r < c)) {\n\t\t\t\t/*\n\t\t\t\t * Addresses of events on the buffer,\n\t\t\t\t * or an array on the buffer is\n\t\t\t\t * OK to dereference.\n\t\t\t\t * There's ways to fool this, but\n\t\t\t\t * this is to catch common mistakes,\n\t\t\t\t * not malicious code.\n\t\t\t\t */\n\t\t\t\ta = strchr(fmt + i, '&');\n\t\t\t\tif ((a && (a < r)) || test_field(r, call))\n\t\t\t\t\tdereference_flags &= ~(1ULL << arg);\n\t\t\t}\n\t\tnext_arg:\n\t\t\ti--;\n\t\t\targ++;\n\t\t}\n\t}\n\n\t/*\n\t * If you triggered the below warning, the trace event reported\n\t * uses an unsafe dereference pointer %p*. As the data stored\n\t * at the trace event time may no longer exist when the trace\n\t * event is printed, dereferencing to the original source is\n\t * unsafe. The source of the dereference must be copied into the\n\t * event itself, and the dereference must access the copy instead.\n\t */\n\tif (WARN_ON_ONCE(dereference_flags)) {\n\t\targ = 1;\n\t\twhile (!(dereference_flags & 1)) {\n\t\t\tdereference_flags >>= 1;\n\t\t\targ++;\n\t\t}\n\t\tpr_warn(\"event %s has unsafe dereference of argument %d\\n\",\n\t\t\ttrace_event_name(call), arg);\n\t\tpr_warn(\"print_fmt: %s\\n\", fmt);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void test_event_printk(struct trace_event_call *call)\n{\n\tu64 dereference_flags = 0;\n\tbool first = true;\n\tconst char *fmt, *c, *r, *a;\n\tint parens = 0;\n\tchar in_quote = 0;\n\tint start_arg = 0;\n\tint arg = 0;\n\tint i;\n\n\tfmt = call->print_fmt;\n\n\tif (!fmt)\n\t\treturn;\n\n\tfor (i = 0; fmt[i]; i++) {\n\t\tswitch (fmt[i]) {\n\t\tcase '\\\\':\n\t\t\ti++;\n\t\t\tif (!fmt[i])\n\t\t\t\treturn;\n\t\t\tcontinue;\n\t\tcase '\"':\n\t\tcase '\\'':\n\t\t\t/*\n\t\t\t * The print fmt starts with a string that\n\t\t\t * is processed first to find %p* usage,\n\t\t\t * then after the first string, the print fmt\n\t\t\t * contains arguments that are used to check\n\t\t\t * if the dereferenced %p* usage is safe.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\tif (fmt[i] == '\\'')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (in_quote) {\n\t\t\t\t\targ = 0;\n\t\t\t\t\tfirst = false;\n\t\t\t\t\t/*\n\t\t\t\t\t * If there was no %p* uses\n\t\t\t\t\t * the fmt is OK.\n\t\t\t\t\t */\n\t\t\t\t\tif (!dereference_flags)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (in_quote) {\n\t\t\t\tif (in_quote == fmt[i])\n\t\t\t\t\tin_quote = 0;\n\t\t\t} else {\n\t\t\t\tin_quote = fmt[i];\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase '%':\n\t\t\tif (!first || !in_quote)\n\t\t\t\tcontinue;\n\t\t\ti++;\n\t\t\tif (!fmt[i])\n\t\t\t\treturn;\n\t\t\tswitch (fmt[i]) {\n\t\t\tcase '%':\n\t\t\t\tcontinue;\n\t\t\tcase 'p':\n\t\t\t\t/* Find dereferencing fields */\n\t\t\t\tswitch (fmt[i + 1]) {\n\t\t\t\tcase 'B': case 'R': case 'r':\n\t\t\t\tcase 'b': case 'M': case 'm':\n\t\t\t\tcase 'I': case 'i': case 'E':\n\t\t\t\tcase 'U': case 'V': case 'N':\n\t\t\t\tcase 'a': case 'd': case 'D':\n\t\t\t\tcase 'g': case 't': case 'C':\n\t\t\t\tcase 'O': case 'f':\n\t\t\t\t\tif (WARN_ONCE(arg == 63,\n\t\t\t\t\t\t      \"Too many args for event: %s\",\n\t\t\t\t\t\t      trace_event_name(call)))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tdereference_flags |= 1ULL << arg;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tbool star = false;\n\t\t\t\tint j;\n\n\t\t\t\t/* Increment arg if %*s exists. */\n\t\t\t\tfor (j = 0; fmt[i + j]; j++) {\n\t\t\t\t\tif (isdigit(fmt[i + j]) ||\n\t\t\t\t\t    fmt[i + j] == '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (fmt[i + j] == '*') {\n\t\t\t\t\t\tstar = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((fmt[i + j] == 's') && star)\n\t\t\t\t\t\targ++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} /* default */\n\n\t\t\t} /* switch */\n\t\t\targ++;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tif (in_quote)\n\t\t\t\tcontinue;\n\t\t\tparens++;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tif (in_quote)\n\t\t\t\tcontinue;\n\t\t\tparens--;\n\t\t\tif (WARN_ONCE(parens < 0,\n\t\t\t\t      \"Paren mismatch for event: %s\\narg='%s'\\n%*s\",\n\t\t\t\t      trace_event_name(call),\n\t\t\t\t      fmt + start_arg,\n\t\t\t\t      (i - start_arg) + 5, \"^\"))\n\t\t\t\treturn;\n\t\t\tcontinue;\n\t\tcase ',':\n\t\t\tif (in_quote || parens)\n\t\t\t\tcontinue;\n\t\t\ti++;\n\t\t\twhile (isspace(fmt[i]))\n\t\t\t\ti++;\n\t\t\tstart_arg = i;\n\t\t\tif (!(dereference_flags & (1ULL << arg)))\n\t\t\t\tgoto next_arg;\n\n\t\t\t/* Find the REC-> in the argument */\n\t\t\tc = strchr(fmt + i, ',');\n\t\t\tr = strstr(fmt + i, \"REC->\");\n\t\t\tif (r && (!c || r < c)) {\n\t\t\t\t/*\n\t\t\t\t * Addresses of events on the buffer,\n\t\t\t\t * or an array on the buffer is\n\t\t\t\t * OK to dereference.\n\t\t\t\t * There's ways to fool this, but\n\t\t\t\t * this is to catch common mistakes,\n\t\t\t\t * not malicious code.\n\t\t\t\t */\n\t\t\t\ta = strchr(fmt + i, '&');\n\t\t\t\tif ((a && (a < r)) || test_field(r, call))\n\t\t\t\t\tdereference_flags &= ~(1ULL << arg);\n\t\t\t}\n\t\tnext_arg:\n\t\t\ti--;\n\t\t\targ++;\n\t\t}\n\t}\n\n\t/*\n\t * If you triggered the below warning, the trace event reported\n\t * uses an unsafe dereference pointer %p*. As the data stored\n\t * at the trace event time may no longer exist when the trace\n\t * event is printed, dereferencing to the original source is\n\t * unsafe. The source of the dereference must be copied into the\n\t * event itself, and the dereference must access the copy instead.\n\t */\n\tif (WARN_ON_ONCE(dereference_flags)) {\n\t\targ = 1;\n\t\twhile (!(dereference_flags & 1)) {\n\t\t\tdereference_flags >>= 1;\n\t\t\targ++;\n\t\t}\n\t\tpr_warn(\"event %s has unsafe dereference of argument %d\\n\",\n\t\t\ttrace_event_name(call), arg);\n\t\tpr_warn(\"print_fmt: %s\\n\", fmt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trace_event",
          "args": [
            "&call->event"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "826-833",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_event_raw_init(struct trace_event_call *call)\n{\n\tint id;\n\n\tid = register_trace_event(&call->event);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\ttest_event_printk(call);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "test_event_printk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "258-427",
    "snippet": "static void test_event_printk(struct trace_event_call *call)\n{\n\tu64 dereference_flags = 0;\n\tbool first = true;\n\tconst char *fmt, *c, *r, *a;\n\tint parens = 0;\n\tchar in_quote = 0;\n\tint start_arg = 0;\n\tint arg = 0;\n\tint i;\n\n\tfmt = call->print_fmt;\n\n\tif (!fmt)\n\t\treturn;\n\n\tfor (i = 0; fmt[i]; i++) {\n\t\tswitch (fmt[i]) {\n\t\tcase '\\\\':\n\t\t\ti++;\n\t\t\tif (!fmt[i])\n\t\t\t\treturn;\n\t\t\tcontinue;\n\t\tcase '\"':\n\t\tcase '\\'':\n\t\t\t/*\n\t\t\t * The print fmt starts with a string that\n\t\t\t * is processed first to find %p* usage,\n\t\t\t * then after the first string, the print fmt\n\t\t\t * contains arguments that are used to check\n\t\t\t * if the dereferenced %p* usage is safe.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\tif (fmt[i] == '\\'')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (in_quote) {\n\t\t\t\t\targ = 0;\n\t\t\t\t\tfirst = false;\n\t\t\t\t\t/*\n\t\t\t\t\t * If there was no %p* uses\n\t\t\t\t\t * the fmt is OK.\n\t\t\t\t\t */\n\t\t\t\t\tif (!dereference_flags)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (in_quote) {\n\t\t\t\tif (in_quote == fmt[i])\n\t\t\t\t\tin_quote = 0;\n\t\t\t} else {\n\t\t\t\tin_quote = fmt[i];\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase '%':\n\t\t\tif (!first || !in_quote)\n\t\t\t\tcontinue;\n\t\t\ti++;\n\t\t\tif (!fmt[i])\n\t\t\t\treturn;\n\t\t\tswitch (fmt[i]) {\n\t\t\tcase '%':\n\t\t\t\tcontinue;\n\t\t\tcase 'p':\n\t\t\t\t/* Find dereferencing fields */\n\t\t\t\tswitch (fmt[i + 1]) {\n\t\t\t\tcase 'B': case 'R': case 'r':\n\t\t\t\tcase 'b': case 'M': case 'm':\n\t\t\t\tcase 'I': case 'i': case 'E':\n\t\t\t\tcase 'U': case 'V': case 'N':\n\t\t\t\tcase 'a': case 'd': case 'D':\n\t\t\t\tcase 'g': case 't': case 'C':\n\t\t\t\tcase 'O': case 'f':\n\t\t\t\t\tif (WARN_ONCE(arg == 63,\n\t\t\t\t\t\t      \"Too many args for event: %s\",\n\t\t\t\t\t\t      trace_event_name(call)))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tdereference_flags |= 1ULL << arg;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tbool star = false;\n\t\t\t\tint j;\n\n\t\t\t\t/* Increment arg if %*s exists. */\n\t\t\t\tfor (j = 0; fmt[i + j]; j++) {\n\t\t\t\t\tif (isdigit(fmt[i + j]) ||\n\t\t\t\t\t    fmt[i + j] == '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (fmt[i + j] == '*') {\n\t\t\t\t\t\tstar = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((fmt[i + j] == 's') && star)\n\t\t\t\t\t\targ++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} /* default */\n\n\t\t\t} /* switch */\n\t\t\targ++;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tif (in_quote)\n\t\t\t\tcontinue;\n\t\t\tparens++;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tif (in_quote)\n\t\t\t\tcontinue;\n\t\t\tparens--;\n\t\t\tif (WARN_ONCE(parens < 0,\n\t\t\t\t      \"Paren mismatch for event: %s\\narg='%s'\\n%*s\",\n\t\t\t\t      trace_event_name(call),\n\t\t\t\t      fmt + start_arg,\n\t\t\t\t      (i - start_arg) + 5, \"^\"))\n\t\t\t\treturn;\n\t\t\tcontinue;\n\t\tcase ',':\n\t\t\tif (in_quote || parens)\n\t\t\t\tcontinue;\n\t\t\ti++;\n\t\t\twhile (isspace(fmt[i]))\n\t\t\t\ti++;\n\t\t\tstart_arg = i;\n\t\t\tif (!(dereference_flags & (1ULL << arg)))\n\t\t\t\tgoto next_arg;\n\n\t\t\t/* Find the REC-> in the argument */\n\t\t\tc = strchr(fmt + i, ',');\n\t\t\tr = strstr(fmt + i, \"REC->\");\n\t\t\tif (r && (!c || r < c)) {\n\t\t\t\t/*\n\t\t\t\t * Addresses of events on the buffer,\n\t\t\t\t * or an array on the buffer is\n\t\t\t\t * OK to dereference.\n\t\t\t\t * There's ways to fool this, but\n\t\t\t\t * this is to catch common mistakes,\n\t\t\t\t * not malicious code.\n\t\t\t\t */\n\t\t\t\ta = strchr(fmt + i, '&');\n\t\t\t\tif ((a && (a < r)) || test_field(r, call))\n\t\t\t\t\tdereference_flags &= ~(1ULL << arg);\n\t\t\t}\n\t\tnext_arg:\n\t\t\ti--;\n\t\t\targ++;\n\t\t}\n\t}\n\n\t/*\n\t * If you triggered the below warning, the trace event reported\n\t * uses an unsafe dereference pointer %p*. As the data stored\n\t * at the trace event time may no longer exist when the trace\n\t * event is printed, dereferencing to the original source is\n\t * unsafe. The source of the dereference must be copied into the\n\t * event itself, and the dereference must access the copy instead.\n\t */\n\tif (WARN_ON_ONCE(dereference_flags)) {\n\t\targ = 1;\n\t\twhile (!(dereference_flags & 1)) {\n\t\t\tdereference_flags >>= 1;\n\t\t\targ++;\n\t\t}\n\t\tpr_warn(\"event %s has unsafe dereference of argument %d\\n\",\n\t\t\ttrace_event_name(call), arg);\n\t\tpr_warn(\"print_fmt: %s\\n\", fmt);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"print_fmt: %s\\n\"",
            "fmt"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"event %s has unsafe dereference of argument %d\\n\"",
            "trace_event_name(call)",
            "arg"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dereference_flags"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_field",
          "args": [
            "r",
            "call"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "test_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "225-250",
          "snippet": "static bool test_field(const char *fmt, struct trace_event_call *call)\n{\n\tstruct trace_event_fields *field = call->class->fields_array;\n\tconst char *array_descriptor;\n\tconst char *p = fmt;\n\tint len;\n\n\tif (!(len = str_has_prefix(fmt, \"REC->\")))\n\t\treturn false;\n\tfmt += len;\n\tfor (p = fmt; *p; p++) {\n\t\tif (!isalnum(*p) && *p != '_')\n\t\t\tbreak;\n\t}\n\tlen = p - fmt;\n\n\tfor (; field->type; field++) {\n\t\tif (strncmp(field->name, fmt, len) ||\n\t\t    field->name[len])\n\t\t\tcontinue;\n\t\tarray_descriptor = strchr(field->type, '[');\n\t\t/* This is an array and is OK to dereference. */\n\t\treturn array_descriptor != NULL;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic bool test_field(const char *fmt, struct trace_event_call *call)\n{\n\tstruct trace_event_fields *field = call->class->fields_array;\n\tconst char *array_descriptor;\n\tconst char *p = fmt;\n\tint len;\n\n\tif (!(len = str_has_prefix(fmt, \"REC->\")))\n\t\treturn false;\n\tfmt += len;\n\tfor (p = fmt; *p; p++) {\n\t\tif (!isalnum(*p) && *p != '_')\n\t\t\tbreak;\n\t}\n\tlen = p - fmt;\n\n\tfor (; field->type; field++) {\n\t\tif (strncmp(field->name, fmt, len) ||\n\t\t    field->name[len])\n\t\t\tcontinue;\n\t\tarray_descriptor = strchr(field->type, '[');\n\t\t/* This is an array and is OK to dereference. */\n\t\treturn array_descriptor != NULL;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fmt + i",
            "'&'"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "fmt + i",
            "\"REC->\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fmt + i",
            "','"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "fmt[i]"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "parens < 0",
            "\"Paren mismatch for event: %s\\narg='%s'\\n%*s\"",
            "trace_event_name(call)",
            "fmt + start_arg",
            "(i - start_arg) + 5",
            "\"^\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "fmt[i + j]"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "arg == 63",
            "\"Too many args for event: %s\"",
            "trace_event_name(call)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void test_event_printk(struct trace_event_call *call)\n{\n\tu64 dereference_flags = 0;\n\tbool first = true;\n\tconst char *fmt, *c, *r, *a;\n\tint parens = 0;\n\tchar in_quote = 0;\n\tint start_arg = 0;\n\tint arg = 0;\n\tint i;\n\n\tfmt = call->print_fmt;\n\n\tif (!fmt)\n\t\treturn;\n\n\tfor (i = 0; fmt[i]; i++) {\n\t\tswitch (fmt[i]) {\n\t\tcase '\\\\':\n\t\t\ti++;\n\t\t\tif (!fmt[i])\n\t\t\t\treturn;\n\t\t\tcontinue;\n\t\tcase '\"':\n\t\tcase '\\'':\n\t\t\t/*\n\t\t\t * The print fmt starts with a string that\n\t\t\t * is processed first to find %p* usage,\n\t\t\t * then after the first string, the print fmt\n\t\t\t * contains arguments that are used to check\n\t\t\t * if the dereferenced %p* usage is safe.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\tif (fmt[i] == '\\'')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (in_quote) {\n\t\t\t\t\targ = 0;\n\t\t\t\t\tfirst = false;\n\t\t\t\t\t/*\n\t\t\t\t\t * If there was no %p* uses\n\t\t\t\t\t * the fmt is OK.\n\t\t\t\t\t */\n\t\t\t\t\tif (!dereference_flags)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (in_quote) {\n\t\t\t\tif (in_quote == fmt[i])\n\t\t\t\t\tin_quote = 0;\n\t\t\t} else {\n\t\t\t\tin_quote = fmt[i];\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase '%':\n\t\t\tif (!first || !in_quote)\n\t\t\t\tcontinue;\n\t\t\ti++;\n\t\t\tif (!fmt[i])\n\t\t\t\treturn;\n\t\t\tswitch (fmt[i]) {\n\t\t\tcase '%':\n\t\t\t\tcontinue;\n\t\t\tcase 'p':\n\t\t\t\t/* Find dereferencing fields */\n\t\t\t\tswitch (fmt[i + 1]) {\n\t\t\t\tcase 'B': case 'R': case 'r':\n\t\t\t\tcase 'b': case 'M': case 'm':\n\t\t\t\tcase 'I': case 'i': case 'E':\n\t\t\t\tcase 'U': case 'V': case 'N':\n\t\t\t\tcase 'a': case 'd': case 'D':\n\t\t\t\tcase 'g': case 't': case 'C':\n\t\t\t\tcase 'O': case 'f':\n\t\t\t\t\tif (WARN_ONCE(arg == 63,\n\t\t\t\t\t\t      \"Too many args for event: %s\",\n\t\t\t\t\t\t      trace_event_name(call)))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tdereference_flags |= 1ULL << arg;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tbool star = false;\n\t\t\t\tint j;\n\n\t\t\t\t/* Increment arg if %*s exists. */\n\t\t\t\tfor (j = 0; fmt[i + j]; j++) {\n\t\t\t\t\tif (isdigit(fmt[i + j]) ||\n\t\t\t\t\t    fmt[i + j] == '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (fmt[i + j] == '*') {\n\t\t\t\t\t\tstar = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((fmt[i + j] == 's') && star)\n\t\t\t\t\t\targ++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} /* default */\n\n\t\t\t} /* switch */\n\t\t\targ++;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tif (in_quote)\n\t\t\t\tcontinue;\n\t\t\tparens++;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tif (in_quote)\n\t\t\t\tcontinue;\n\t\t\tparens--;\n\t\t\tif (WARN_ONCE(parens < 0,\n\t\t\t\t      \"Paren mismatch for event: %s\\narg='%s'\\n%*s\",\n\t\t\t\t      trace_event_name(call),\n\t\t\t\t      fmt + start_arg,\n\t\t\t\t      (i - start_arg) + 5, \"^\"))\n\t\t\t\treturn;\n\t\t\tcontinue;\n\t\tcase ',':\n\t\t\tif (in_quote || parens)\n\t\t\t\tcontinue;\n\t\t\ti++;\n\t\t\twhile (isspace(fmt[i]))\n\t\t\t\ti++;\n\t\t\tstart_arg = i;\n\t\t\tif (!(dereference_flags & (1ULL << arg)))\n\t\t\t\tgoto next_arg;\n\n\t\t\t/* Find the REC-> in the argument */\n\t\t\tc = strchr(fmt + i, ',');\n\t\t\tr = strstr(fmt + i, \"REC->\");\n\t\t\tif (r && (!c || r < c)) {\n\t\t\t\t/*\n\t\t\t\t * Addresses of events on the buffer,\n\t\t\t\t * or an array on the buffer is\n\t\t\t\t * OK to dereference.\n\t\t\t\t * There's ways to fool this, but\n\t\t\t\t * this is to catch common mistakes,\n\t\t\t\t * not malicious code.\n\t\t\t\t */\n\t\t\t\ta = strchr(fmt + i, '&');\n\t\t\t\tif ((a && (a < r)) || test_field(r, call))\n\t\t\t\t\tdereference_flags &= ~(1ULL << arg);\n\t\t\t}\n\t\tnext_arg:\n\t\t\ti--;\n\t\t\targ++;\n\t\t}\n\t}\n\n\t/*\n\t * If you triggered the below warning, the trace event reported\n\t * uses an unsafe dereference pointer %p*. As the data stored\n\t * at the trace event time may no longer exist when the trace\n\t * event is printed, dereferencing to the original source is\n\t * unsafe. The source of the dereference must be copied into the\n\t * event itself, and the dereference must access the copy instead.\n\t */\n\tif (WARN_ON_ONCE(dereference_flags)) {\n\t\targ = 1;\n\t\twhile (!(dereference_flags & 1)) {\n\t\t\tdereference_flags >>= 1;\n\t\t\targ++;\n\t\t}\n\t\tpr_warn(\"event %s has unsafe dereference of argument %d\\n\",\n\t\t\ttrace_event_name(call), arg);\n\t\tpr_warn(\"print_fmt: %s\\n\", fmt);\n\t}\n}"
  },
  {
    "function_name": "test_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "225-250",
    "snippet": "static bool test_field(const char *fmt, struct trace_event_call *call)\n{\n\tstruct trace_event_fields *field = call->class->fields_array;\n\tconst char *array_descriptor;\n\tconst char *p = fmt;\n\tint len;\n\n\tif (!(len = str_has_prefix(fmt, \"REC->\")))\n\t\treturn false;\n\tfmt += len;\n\tfor (p = fmt; *p; p++) {\n\t\tif (!isalnum(*p) && *p != '_')\n\t\t\tbreak;\n\t}\n\tlen = p - fmt;\n\n\tfor (; field->type; field++) {\n\t\tif (strncmp(field->name, fmt, len) ||\n\t\t    field->name[len])\n\t\t\tcontinue;\n\t\tarray_descriptor = strchr(field->type, '[');\n\t\t/* This is an array and is OK to dereference. */\n\t\treturn array_descriptor != NULL;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "field->type",
            "'['"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "field->name",
            "fmt",
            "len"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "*p"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "fmt",
            "\"REC->\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic bool test_field(const char *fmt, struct trace_event_call *call)\n{\n\tstruct trace_event_fields *field = call->class->fields_array;\n\tconst char *array_descriptor;\n\tconst char *p = fmt;\n\tint len;\n\n\tif (!(len = str_has_prefix(fmt, \"REC->\")))\n\t\treturn false;\n\tfmt += len;\n\tfor (p = fmt; *p; p++) {\n\t\tif (!isalnum(*p) && *p != '_')\n\t\t\tbreak;\n\t}\n\tlen = p - fmt;\n\n\tfor (; field->type; field++) {\n\t\tif (strncmp(field->name, fmt, len) ||\n\t\t    field->name[len])\n\t\t\tcontinue;\n\t\tarray_descriptor = strchr(field->type, '[');\n\t\t/* This is an array and is OK to dereference. */\n\t\treturn array_descriptor != NULL;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "trace_event_get_offsets",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "207-219",
    "snippet": "int trace_event_get_offsets(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *tail;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\t/*\n\t * head->next points to the last field with the largest offset,\n\t * since it was added last by trace_define_field()\n\t */\n\ttail = list_first_entry(head, struct ftrace_event_field, link);\n\treturn tail->offset + tail->size;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structftrace_event_field",
            "link"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_event_get_offsets(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *tail;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\t/*\n\t * head->next points to the last field with the largest offset,\n\t * since it was added last by trace_define_field()\n\t */\n\ttail = list_first_entry(head, struct ftrace_event_field, link);\n\treturn tail->offset + tail->size;\n}"
  },
  {
    "function_name": "trace_destroy_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "191-201",
    "snippet": "static void trace_destroy_fields(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field, *next;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry_safe(field, next, head, link) {\n\t\tlist_del(&field->link);\n\t\tkmem_cache_free(field_cachep, field);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *field_cachep;",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "field_cachep",
            "field"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&field->link"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "field",
            "next",
            "head",
            "link"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *field_cachep;\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_destroy_fields(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field, *next;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry_safe(field, next, head, link) {\n\t\tlist_del(&field->link);\n\t\tkmem_cache_free(field_cachep, field);\n\t}\n}"
  },
  {
    "function_name": "trace_define_common_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "177-189",
    "snippet": "static int trace_define_common_fields(void)\n{\n\tint ret;\n\tstruct trace_entry ent;\n\n\t__common_field(unsigned short, type);\n\t__common_field(unsigned char, flags);\n\t/* Holds both preempt_count and migrate_disable */\n\t__common_field(unsigned char, preempt_count);\n\t__common_field(int, pid);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__common_field",
          "args": [
            "int",
            "pid"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int trace_define_common_fields(void)\n{\n\tint ret;\n\tstruct trace_entry ent;\n\n\t__common_field(unsigned short, type);\n\t__common_field(unsigned char, flags);\n\t/* Holds both preempt_count and migrate_disable */\n\t__common_field(unsigned char, preempt_count);\n\t__common_field(int, pid);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_define_generic_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "165-175",
    "snippet": "static int trace_define_generic_fields(void)\n{\n\tint ret;\n\n\t__generic_field(int, CPU, FILTER_CPU);\n\t__generic_field(int, cpu, FILTER_CPU);\n\t__generic_field(char *, COMM, FILTER_COMM);\n\t__generic_field(char *, comm, FILTER_COMM);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__generic_field",
          "args": [
            "int",
            "cpu",
            "FILTER_CPU"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__generic_field",
          "args": [
            "int",
            "CPU",
            "FILTER_CPU"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int trace_define_generic_fields(void)\n{\n\tint ret;\n\n\t__generic_field(int, CPU, FILTER_CPU);\n\t__generic_field(int, cpu, FILTER_CPU);\n\t__generic_field(char *, COMM, FILTER_COMM);\n\t__generic_field(char *, comm, FILTER_COMM);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_define_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "134-146",
    "snippet": "int trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_define_field",
          "args": [
            "head",
            "type",
            "name",
            "offset",
            "size",
            "is_signed",
            "filter_type"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_define_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "107-132",
          "snippet": "static int __trace_define_field(struct list_head *head, const char *type,\n\t\t\t\tconst char *name, int offset, int size,\n\t\t\t\tint is_signed, int filter_type)\n{\n\tstruct ftrace_event_field *field;\n\n\tfield = kmem_cache_alloc(field_cachep, GFP_TRACE);\n\tif (!field)\n\t\treturn -ENOMEM;\n\n\tfield->name = name;\n\tfield->type = type;\n\n\tif (filter_type == FILTER_OTHER)\n\t\tfield->filter_type = filter_assign_type(type);\n\telse\n\t\tfield->filter_type = filter_type;\n\n\tfield->offset = offset;\n\tfield->size = size;\n\tfield->is_signed = is_signed;\n\n\tlist_add(&field->link, head);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [
            "#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)"
          ],
          "globals_used": [
            "static struct kmem_cache *field_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)\n\nstatic struct kmem_cache *field_cachep;\n\nstatic int __trace_define_field(struct list_head *head, const char *type,\n\t\t\t\tconst char *name, int offset, int size,\n\t\t\t\tint is_signed, int filter_type)\n{\n\tstruct ftrace_event_field *field;\n\n\tfield = kmem_cache_alloc(field_cachep, GFP_TRACE);\n\tif (!field)\n\t\treturn -ENOMEM;\n\n\tfield->name = name;\n\tfield->type = type;\n\n\tif (filter_type == FILTER_OTHER)\n\t\tfield->filter_type = filter_assign_type(type);\n\telse\n\t\tfield->filter_type = filter_type;\n\n\tfield->offset = offset;\n\tfield->size = size;\n\tfield->is_signed = is_signed;\n\n\tlist_add(&field->link, head);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!call->class"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}"
  },
  {
    "function_name": "__trace_define_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "107-132",
    "snippet": "static int __trace_define_field(struct list_head *head, const char *type,\n\t\t\t\tconst char *name, int offset, int size,\n\t\t\t\tint is_signed, int filter_type)\n{\n\tstruct ftrace_event_field *field;\n\n\tfield = kmem_cache_alloc(field_cachep, GFP_TRACE);\n\tif (!field)\n\t\treturn -ENOMEM;\n\n\tfield->name = name;\n\tfield->type = type;\n\n\tif (filter_type == FILTER_OTHER)\n\t\tfield->filter_type = filter_assign_type(type);\n\telse\n\t\tfield->filter_type = filter_type;\n\n\tfield->offset = offset;\n\tfield->size = size;\n\tfield->is_signed = is_signed;\n\n\tlist_add(&field->link, head);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)"
    ],
    "globals_used": [
      "static struct kmem_cache *field_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&field->link",
            "head"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_assign_type",
          "args": [
            "type"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "filter_assign_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1175-1190",
          "snippet": "int filter_assign_type(const char *type)\n{\n\tif (strstr(type, \"__data_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_DYN_STRING;\n\n\tif (strstr(type, \"__rel_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_RDYN_STRING;\n\n\tif (strchr(type, '[') && strstr(type, \"char\"))\n\t\treturn FILTER_STATIC_STRING;\n\n\tif (strcmp(type, \"char *\") == 0 || strcmp(type, \"const char *\") == 0)\n\t\treturn FILTER_PTR_STRING;\n\n\treturn FILTER_OTHER;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nint filter_assign_type(const char *type)\n{\n\tif (strstr(type, \"__data_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_DYN_STRING;\n\n\tif (strstr(type, \"__rel_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_RDYN_STRING;\n\n\tif (strchr(type, '[') && strstr(type, \"char\"))\n\t\treturn FILTER_STATIC_STRING;\n\n\tif (strcmp(type, \"char *\") == 0 || strcmp(type, \"const char *\") == 0)\n\t\treturn FILTER_PTR_STRING;\n\n\treturn FILTER_OTHER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "field_cachep",
            "GFP_TRACE"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\n#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)\n\nstatic struct kmem_cache *field_cachep;\n\nstatic int __trace_define_field(struct list_head *head, const char *type,\n\t\t\t\tconst char *name, int offset, int size,\n\t\t\t\tint is_signed, int filter_type)\n{\n\tstruct ftrace_event_field *field;\n\n\tfield = kmem_cache_alloc(field_cachep, GFP_TRACE);\n\tif (!field)\n\t\treturn -ENOMEM;\n\n\tfield->name = name;\n\tfield->type = type;\n\n\tif (filter_type == FILTER_OTHER)\n\t\tfield->filter_type = filter_assign_type(type);\n\telse\n\t\tfield->filter_type = filter_type;\n\n\tfield->offset = offset;\n\tfield->size = size;\n\tfield->is_signed = is_signed;\n\n\tlist_add(&field->link, head);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_find_event_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "89-105",
    "snippet": "struct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ftrace_generic_fields);",
      "static LIST_HEAD(ftrace_common_fields);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__find_event_field",
          "args": [
            "&ftrace_common_fields",
            "name"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "__find_event_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "76-87",
          "snippet": "static struct ftrace_event_field *\n__find_event_field(struct list_head *head, char *name)\n{\n\tstruct ftrace_event_field *field;\n\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(field->name, name))\n\t\t\treturn field;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic struct ftrace_event_field *\n__find_event_field(struct list_head *head, char *name)\n{\n\tstruct ftrace_event_field *field;\n\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(field->name, name))\n\t\t\treturn field;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(ftrace_generic_fields);\nstatic LIST_HEAD(ftrace_common_fields);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}"
  },
  {
    "function_name": "__find_event_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "76-87",
    "snippet": "static struct ftrace_event_field *\n__find_event_field(struct list_head *head, char *name)\n{\n\tstruct ftrace_event_field *field;\n\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(field->name, name))\n\t\t\treturn field;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->name",
            "name"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "field",
            "head",
            "link"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic struct ftrace_event_field *\n__find_event_field(struct list_head *head, char *name)\n{\n\tstruct ftrace_event_field *field;\n\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(field->name, name))\n\t\t\treturn field;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "system_refcount_dec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "58-61",
    "snippet": "static int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}"
  },
  {
    "function_name": "system_refcount_inc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "53-56",
    "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
  },
  {
    "function_name": "system_refcount",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
    "lines": "48-51",
    "snippet": "static inline int system_refcount(struct event_subsystem *system)\n{\n\treturn system->ref_count;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/syscall.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic inline int system_refcount(struct event_subsystem *system)\n{\n\treturn system->ref_count;\n}"
  }
]