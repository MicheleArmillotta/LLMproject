[
  {
    "function_name": "reboot_ksysfs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "874-890",
    "snippet": "static int __init reboot_ksysfs_init(void)\n{\n\tstruct kobject *reboot_kobj;\n\tint ret;\n\n\treboot_kobj = kobject_create_and_add(\"reboot\", kernel_kobj);\n\tif (!reboot_kobj)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_create_group(reboot_kobj, &reboot_attr_group);\n\tif (ret) {\n\t\tkobject_put(reboot_kobj);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "reboot_kobj"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "mod_kobject_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1804-1810",
          "snippet": "static void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "reboot_kobj",
            "&reboot_attr_group"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"reboot\"",
            "kernel_kobj"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic int __init reboot_ksysfs_init(void)\n{\n\tstruct kobject *reboot_kobj;\n\tint ret;\n\n\treboot_kobj = kobject_create_and_add(\"reboot\", kernel_kobj);\n\tif (!reboot_kobj)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_create_group(reboot_kobj, &reboot_attr_group);\n\tif (ret) {\n\t\tkobject_put(reboot_kobj);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "833-854",
    "snippet": "static ssize_t cpu_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tunsigned int cpunum;\n\tint rc;\n\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\trc = kstrtouint(buf, 0, &cpunum);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (cpunum >= num_possible_cpus())\n\t\treturn -ERANGE;\n\n\treboot_default = 0;\n\treboot_cpu = cpunum;\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reboot_default = 1;",
      "int reboot_cpu;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "buf",
            "0",
            "&cpunum"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_BOOT"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint reboot_default = 1;\nint reboot_cpu;\n\nstatic ssize_t cpu_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tunsigned int cpunum;\n\tint rc;\n\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\trc = kstrtouint(buf, 0, &cpunum);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (cpunum >= num_possible_cpus())\n\t\treturn -ERANGE;\n\n\treboot_default = 0;\n\treboot_cpu = cpunum;\n\n\treturn count;\n}"
  },
  {
    "function_name": "cpu_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "829-832",
    "snippet": "static ssize_t cpu_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", reboot_cpu);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reboot_cpu;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "reboot_cpu"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint reboot_cpu;\n\nstatic ssize_t cpu_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", reboot_cpu);\n}"
  },
  {
    "function_name": "type_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "800-824",
    "snippet": "static ssize_t type_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\tif (!strncmp(buf, BOOT_TRIPLE_STR, strlen(BOOT_TRIPLE_STR)))\n\t\treboot_type = BOOT_TRIPLE;\n\telse if (!strncmp(buf, BOOT_KBD_STR, strlen(BOOT_KBD_STR)))\n\t\treboot_type = BOOT_KBD;\n\telse if (!strncmp(buf, BOOT_BIOS_STR, strlen(BOOT_BIOS_STR)))\n\t\treboot_type = BOOT_BIOS;\n\telse if (!strncmp(buf, BOOT_ACPI_STR, strlen(BOOT_ACPI_STR)))\n\t\treboot_type = BOOT_ACPI;\n\telse if (!strncmp(buf, BOOT_EFI_STR, strlen(BOOT_EFI_STR)))\n\t\treboot_type = BOOT_EFI;\n\telse if (!strncmp(buf, BOOT_PCI_STR, strlen(BOOT_PCI_STR)))\n\t\treboot_type = BOOT_CF9_FORCE;\n\telse\n\t\treturn -EINVAL;\n\n\treboot_default = 0;\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define BOOT_PCI_STR\t\t\"pci\"",
      "#define BOOT_EFI_STR\t\t\"efi\"",
      "#define BOOT_ACPI_STR\t\t\"acpi\"",
      "#define BOOT_BIOS_STR\t\t\"bios\"",
      "#define BOOT_KBD_STR\t\t\"kbd\"",
      "#define BOOT_TRIPLE_STR\t\t\"triple\""
    ],
    "globals_used": [
      "int reboot_default = 1;",
      "enum reboot_type reboot_type = BOOT_ACPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "BOOT_PCI_STR",
            "strlen(BOOT_PCI_STR)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "BOOT_PCI_STR"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "BOOT_EFI_STR",
            "strlen(BOOT_EFI_STR)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "BOOT_ACPI_STR",
            "strlen(BOOT_ACPI_STR)"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "BOOT_BIOS_STR",
            "strlen(BOOT_BIOS_STR)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "BOOT_KBD_STR",
            "strlen(BOOT_KBD_STR)"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "BOOT_TRIPLE_STR",
            "strlen(BOOT_TRIPLE_STR)"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_BOOT"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\n#define BOOT_PCI_STR\t\t\"pci\"\n#define BOOT_EFI_STR\t\t\"efi\"\n#define BOOT_ACPI_STR\t\t\"acpi\"\n#define BOOT_BIOS_STR\t\t\"bios\"\n#define BOOT_KBD_STR\t\t\"kbd\"\n#define BOOT_TRIPLE_STR\t\t\"triple\"\n\nint reboot_default = 1;\nenum reboot_type reboot_type = BOOT_ACPI;\n\nstatic ssize_t type_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\tif (!strncmp(buf, BOOT_TRIPLE_STR, strlen(BOOT_TRIPLE_STR)))\n\t\treboot_type = BOOT_TRIPLE;\n\telse if (!strncmp(buf, BOOT_KBD_STR, strlen(BOOT_KBD_STR)))\n\t\treboot_type = BOOT_KBD;\n\telse if (!strncmp(buf, BOOT_BIOS_STR, strlen(BOOT_BIOS_STR)))\n\t\treboot_type = BOOT_BIOS;\n\telse if (!strncmp(buf, BOOT_ACPI_STR, strlen(BOOT_ACPI_STR)))\n\t\treboot_type = BOOT_ACPI;\n\telse if (!strncmp(buf, BOOT_EFI_STR, strlen(BOOT_EFI_STR)))\n\t\treboot_type = BOOT_EFI;\n\telse if (!strncmp(buf, BOOT_PCI_STR, strlen(BOOT_PCI_STR)))\n\t\treboot_type = BOOT_CF9_FORCE;\n\telse\n\t\treturn -EINVAL;\n\n\treboot_default = 0;\n\n\treturn count;\n}"
  },
  {
    "function_name": "type_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "771-799",
    "snippet": "static ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tconst char *val;\n\n\tswitch (reboot_type) {\n\tcase BOOT_TRIPLE:\n\t\tval = BOOT_TRIPLE_STR;\n\t\tbreak;\n\tcase BOOT_KBD:\n\t\tval = BOOT_KBD_STR;\n\t\tbreak;\n\tcase BOOT_BIOS:\n\t\tval = BOOT_BIOS_STR;\n\t\tbreak;\n\tcase BOOT_ACPI:\n\t\tval = BOOT_ACPI_STR;\n\t\tbreak;\n\tcase BOOT_EFI:\n\t\tval = BOOT_EFI_STR;\n\t\tbreak;\n\tcase BOOT_CF9_FORCE:\n\t\tval = BOOT_PCI_STR;\n\t\tbreak;\n\tdefault:\n\t\tval = REBOOT_UNDEFINED_STR;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", val);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define BOOT_PCI_STR\t\t\"pci\"",
      "#define BOOT_EFI_STR\t\t\"efi\"",
      "#define BOOT_ACPI_STR\t\t\"acpi\"",
      "#define BOOT_BIOS_STR\t\t\"bios\"",
      "#define BOOT_KBD_STR\t\t\"kbd\"",
      "#define BOOT_TRIPLE_STR\t\t\"triple\"",
      "#define REBOOT_UNDEFINED_STR\t\"undefined\""
    ],
    "globals_used": [
      "enum reboot_type reboot_type = BOOT_ACPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\\n\"",
            "val"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\n#define BOOT_PCI_STR\t\t\"pci\"\n#define BOOT_EFI_STR\t\t\"efi\"\n#define BOOT_ACPI_STR\t\t\"acpi\"\n#define BOOT_BIOS_STR\t\t\"bios\"\n#define BOOT_KBD_STR\t\t\"kbd\"\n#define BOOT_TRIPLE_STR\t\t\"triple\"\n#define REBOOT_UNDEFINED_STR\t\"undefined\"\n\nenum reboot_type reboot_type = BOOT_ACPI;\n\nstatic ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tconst char *val;\n\n\tswitch (reboot_type) {\n\tcase BOOT_TRIPLE:\n\t\tval = BOOT_TRIPLE_STR;\n\t\tbreak;\n\tcase BOOT_KBD:\n\t\tval = BOOT_KBD_STR;\n\t\tbreak;\n\tcase BOOT_BIOS:\n\t\tval = BOOT_BIOS_STR;\n\t\tbreak;\n\tcase BOOT_ACPI:\n\t\tval = BOOT_ACPI_STR;\n\t\tbreak;\n\tcase BOOT_EFI:\n\t\tval = BOOT_EFI_STR;\n\t\tbreak;\n\tcase BOOT_CF9_FORCE:\n\t\tval = BOOT_PCI_STR;\n\t\tbreak;\n\tdefault:\n\t\tval = REBOOT_UNDEFINED_STR;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", val);\n}"
  },
  {
    "function_name": "force_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "753-768",
    "snippet": "static ssize_t force_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tbool res;\n\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\tif (kstrtobool(buf, &res))\n\t\treturn -EINVAL;\n\n\treboot_default = 0;\n\treboot_force = res;\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reboot_default = 1;",
      "int reboot_force;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "buf",
            "&res"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_BOOT"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint reboot_default = 1;\nint reboot_force;\n\nstatic ssize_t force_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tbool res;\n\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\tif (kstrtobool(buf, &res))\n\t\treturn -EINVAL;\n\n\treboot_default = 0;\n\treboot_force = res;\n\n\treturn count;\n}"
  },
  {
    "function_name": "force_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "749-752",
    "snippet": "static ssize_t force_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", reboot_force);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reboot_force;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "reboot_force"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint reboot_force;\n\nstatic ssize_t force_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", reboot_force);\n}"
  },
  {
    "function_name": "mode_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "723-745",
    "snippet": "static ssize_t mode_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\tif (!strncmp(buf, REBOOT_COLD_STR, strlen(REBOOT_COLD_STR)))\n\t\treboot_mode = REBOOT_COLD;\n\telse if (!strncmp(buf, REBOOT_WARM_STR, strlen(REBOOT_WARM_STR)))\n\t\treboot_mode = REBOOT_WARM;\n\telse if (!strncmp(buf, REBOOT_HARD_STR, strlen(REBOOT_HARD_STR)))\n\t\treboot_mode = REBOOT_HARD;\n\telse if (!strncmp(buf, REBOOT_SOFT_STR, strlen(REBOOT_SOFT_STR)))\n\t\treboot_mode = REBOOT_SOFT;\n\telse if (!strncmp(buf, REBOOT_GPIO_STR, strlen(REBOOT_GPIO_STR)))\n\t\treboot_mode = REBOOT_GPIO;\n\telse\n\t\treturn -EINVAL;\n\n\treboot_default = 0;\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define REBOOT_GPIO_STR\t\t\"gpio\"",
      "#define REBOOT_SOFT_STR\t\t\"soft\"",
      "#define REBOOT_HARD_STR\t\t\"hard\"",
      "#define REBOOT_WARM_STR\t\t\"warm\"",
      "#define REBOOT_COLD_STR\t\t\"cold\""
    ],
    "globals_used": [
      "enum reboot_mode reboot_mode",
      "int reboot_default = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "REBOOT_GPIO_STR",
            "strlen(REBOOT_GPIO_STR)"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "REBOOT_GPIO_STR"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "REBOOT_SOFT_STR",
            "strlen(REBOOT_SOFT_STR)"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "REBOOT_HARD_STR",
            "strlen(REBOOT_HARD_STR)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "REBOOT_WARM_STR",
            "strlen(REBOOT_WARM_STR)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "REBOOT_COLD_STR",
            "strlen(REBOOT_COLD_STR)"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_BOOT"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\n#define REBOOT_GPIO_STR\t\t\"gpio\"\n#define REBOOT_SOFT_STR\t\t\"soft\"\n#define REBOOT_HARD_STR\t\t\"hard\"\n#define REBOOT_WARM_STR\t\t\"warm\"\n#define REBOOT_COLD_STR\t\t\"cold\"\n\nenum reboot_mode reboot_mode;\nint reboot_default = 1;\n\nstatic ssize_t mode_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\tif (!strncmp(buf, REBOOT_COLD_STR, strlen(REBOOT_COLD_STR)))\n\t\treboot_mode = REBOOT_COLD;\n\telse if (!strncmp(buf, REBOOT_WARM_STR, strlen(REBOOT_WARM_STR)))\n\t\treboot_mode = REBOOT_WARM;\n\telse if (!strncmp(buf, REBOOT_HARD_STR, strlen(REBOOT_HARD_STR)))\n\t\treboot_mode = REBOOT_HARD;\n\telse if (!strncmp(buf, REBOOT_SOFT_STR, strlen(REBOOT_SOFT_STR)))\n\t\treboot_mode = REBOOT_SOFT;\n\telse if (!strncmp(buf, REBOOT_GPIO_STR, strlen(REBOOT_GPIO_STR)))\n\t\treboot_mode = REBOOT_GPIO;\n\telse\n\t\treturn -EINVAL;\n\n\treboot_default = 0;\n\n\treturn count;\n}"
  },
  {
    "function_name": "mode_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "697-722",
    "snippet": "static ssize_t mode_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tconst char *val;\n\n\tswitch (reboot_mode) {\n\tcase REBOOT_COLD:\n\t\tval = REBOOT_COLD_STR;\n\t\tbreak;\n\tcase REBOOT_WARM:\n\t\tval = REBOOT_WARM_STR;\n\t\tbreak;\n\tcase REBOOT_HARD:\n\t\tval = REBOOT_HARD_STR;\n\t\tbreak;\n\tcase REBOOT_SOFT:\n\t\tval = REBOOT_SOFT_STR;\n\t\tbreak;\n\tcase REBOOT_GPIO:\n\t\tval = REBOOT_GPIO_STR;\n\t\tbreak;\n\tdefault:\n\t\tval = REBOOT_UNDEFINED_STR;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", val);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define REBOOT_UNDEFINED_STR\t\"undefined\"",
      "#define REBOOT_GPIO_STR\t\t\"gpio\"",
      "#define REBOOT_SOFT_STR\t\t\"soft\"",
      "#define REBOOT_HARD_STR\t\t\"hard\"",
      "#define REBOOT_WARM_STR\t\t\"warm\"",
      "#define REBOOT_COLD_STR\t\t\"cold\""
    ],
    "globals_used": [
      "enum reboot_mode reboot_mode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\\n\"",
            "val"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\n#define REBOOT_UNDEFINED_STR\t\"undefined\"\n#define REBOOT_GPIO_STR\t\t\"gpio\"\n#define REBOOT_SOFT_STR\t\t\"soft\"\n#define REBOOT_HARD_STR\t\t\"hard\"\n#define REBOOT_WARM_STR\t\t\"warm\"\n#define REBOOT_COLD_STR\t\t\"cold\"\n\nenum reboot_mode reboot_mode;\n\nstatic ssize_t mode_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tconst char *val;\n\n\tswitch (reboot_mode) {\n\tcase REBOOT_COLD:\n\t\tval = REBOOT_COLD_STR;\n\t\tbreak;\n\tcase REBOOT_WARM:\n\t\tval = REBOOT_WARM_STR;\n\t\tbreak;\n\tcase REBOOT_HARD:\n\t\tval = REBOOT_HARD_STR;\n\t\tbreak;\n\tcase REBOOT_SOFT:\n\t\tval = REBOOT_SOFT_STR;\n\t\tbreak;\n\tcase REBOOT_GPIO:\n\t\tval = REBOOT_GPIO_STR;\n\t\tbreak;\n\tdefault:\n\t\tval = REBOOT_UNDEFINED_STR;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", val);\n}"
  },
  {
    "function_name": "reboot_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "600-678",
    "snippet": "static int __init reboot_setup(char *str)\n{\n\tfor (;;) {\n\t\tenum reboot_mode *mode;\n\n\t\t/*\n\t\t * Having anything passed on the command line via\n\t\t * reboot= will cause us to disable DMI checking\n\t\t * below.\n\t\t */\n\t\treboot_default = 0;\n\n\t\tif (!strncmp(str, \"panic_\", 6)) {\n\t\t\tmode = &panic_reboot_mode;\n\t\t\tstr += 6;\n\t\t} else {\n\t\t\tmode = &reboot_mode;\n\t\t}\n\n\t\tswitch (*str) {\n\t\tcase 'w':\n\t\t\t*mode = REBOOT_WARM;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\t*mode = REBOOT_COLD;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\t*mode = REBOOT_HARD;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\t/*\n\t\t\t * reboot_cpu is s[mp]#### with #### being the processor\n\t\t\t * to be used for rebooting. Skip 's' or 'smp' prefix.\n\t\t\t */\n\t\t\tstr += str[1] == 'm' && str[2] == 'p' ? 3 : 1;\n\n\t\t\tif (isdigit(str[0])) {\n\t\t\t\tint cpu = simple_strtoul(str, NULL, 0);\n\n\t\t\t\tif (cpu >= num_possible_cpus()) {\n\t\t\t\t\tpr_err(\"Ignoring the CPU number in reboot= option. \"\n\t\t\t\t\t\"CPU %d exceeds possible cpu number %d\\n\",\n\t\t\t\t\tcpu, num_possible_cpus());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treboot_cpu = cpu;\n\t\t\t} else\n\t\t\t\t*mode = REBOOT_SOFT;\n\t\t\tbreak;\n\n\t\tcase 'g':\n\t\t\t*mode = REBOOT_GPIO;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\tcase 'a':\n\t\tcase 'k':\n\t\tcase 't':\n\t\tcase 'e':\n\t\tcase 'p':\n\t\t\treboot_type = *str;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\treboot_force = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tstr = strchr(str, ',');\n\t\tif (str)\n\t\t\tstr++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum reboot_mode reboot_mode",
      "enum reboot_mode panic_reboot_mode = REBOOT_UNDEFINED;",
      "int reboot_default = 1;",
      "int reboot_cpu;",
      "enum reboot_type reboot_type = BOOT_ACPI;",
      "int reboot_force;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "','"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Ignoring the CPU number in reboot= option. \"\n\t\t\t\t\t\"CPU %d exceeds possible cpu number %d\\n\"",
            "cpu",
            "num_possible_cpus()"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "NULL",
            "0"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "str[0]"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"panic_\"",
            "6"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nenum reboot_mode reboot_mode;\nenum reboot_mode panic_reboot_mode = REBOOT_UNDEFINED;\nint reboot_default = 1;\nint reboot_cpu;\nenum reboot_type reboot_type = BOOT_ACPI;\nint reboot_force;\n\nstatic int __init reboot_setup(char *str)\n{\n\tfor (;;) {\n\t\tenum reboot_mode *mode;\n\n\t\t/*\n\t\t * Having anything passed on the command line via\n\t\t * reboot= will cause us to disable DMI checking\n\t\t * below.\n\t\t */\n\t\treboot_default = 0;\n\n\t\tif (!strncmp(str, \"panic_\", 6)) {\n\t\t\tmode = &panic_reboot_mode;\n\t\t\tstr += 6;\n\t\t} else {\n\t\t\tmode = &reboot_mode;\n\t\t}\n\n\t\tswitch (*str) {\n\t\tcase 'w':\n\t\t\t*mode = REBOOT_WARM;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\t*mode = REBOOT_COLD;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\t*mode = REBOOT_HARD;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\t/*\n\t\t\t * reboot_cpu is s[mp]#### with #### being the processor\n\t\t\t * to be used for rebooting. Skip 's' or 'smp' prefix.\n\t\t\t */\n\t\t\tstr += str[1] == 'm' && str[2] == 'p' ? 3 : 1;\n\n\t\t\tif (isdigit(str[0])) {\n\t\t\t\tint cpu = simple_strtoul(str, NULL, 0);\n\n\t\t\t\tif (cpu >= num_possible_cpus()) {\n\t\t\t\t\tpr_err(\"Ignoring the CPU number in reboot= option. \"\n\t\t\t\t\t\"CPU %d exceeds possible cpu number %d\\n\",\n\t\t\t\t\tcpu, num_possible_cpus());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treboot_cpu = cpu;\n\t\t\t} else\n\t\t\t\t*mode = REBOOT_SOFT;\n\t\t\tbreak;\n\n\t\tcase 'g':\n\t\t\t*mode = REBOOT_GPIO;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\tcase 'a':\n\t\tcase 'k':\n\t\tcase 't':\n\t\tcase 'e':\n\t\tcase 'p':\n\t\t\treboot_type = *str;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\treboot_force = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tstr = strchr(str, ',');\n\t\tif (str)\n\t\t\tstr++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "hw_protection_shutdown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "581-597",
    "snippet": "void hw_protection_shutdown(const char *reason, int ms_until_forced)\n{\n\tstatic atomic_t allow_proceed = ATOMIC_INIT(1);\n\n\tpr_emerg(\"HARDWARE PROTECTION shutdown (%s)\\n\", reason);\n\n\t/* Shutdown should be initiated only once. */\n\tif (!atomic_dec_and_test(&allow_proceed))\n\t\treturn;\n\n\t/*\n\t * Queue a backup emergency shutdown in the event of\n\t * orderly_poweroff failure\n\t */\n\thw_failure_emergency_poweroff(ms_until_forced);\n\torderly_poweroff(true);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "orderly_poweroff",
          "args": [
            "true"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "orderly_poweroff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "495-500",
          "snippet": "void orderly_poweroff(bool force)\n{\n\tif (force) /* do not override the pending \"true\" */\n\t\tpoweroff_force = true;\n\tschedule_work(&poweroff_work);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool poweroff_force;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic bool poweroff_force;\n\nvoid orderly_poweroff(bool force)\n{\n\tif (force) /* do not override the pending \"true\" */\n\t\tpoweroff_force = true;\n\tschedule_work(&poweroff_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_failure_emergency_poweroff",
          "args": [
            "ms_until_forced"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "hw_failure_emergency_poweroff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "558-564",
          "snippet": "static void hw_failure_emergency_poweroff(int poweroff_delay_ms)\n{\n\tif (poweroff_delay_ms <= 0)\n\t\treturn;\n\tschedule_delayed_work(&hw_failure_emergency_poweroff_work,\n\t\t\t      msecs_to_jiffies(poweroff_delay_ms));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic void hw_failure_emergency_poweroff(int poweroff_delay_ms)\n{\n\tif (poweroff_delay_ms <= 0)\n\t\treturn;\n\tschedule_delayed_work(&hw_failure_emergency_poweroff_work,\n\t\t\t      msecs_to_jiffies(poweroff_delay_ms));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&allow_proceed"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"HARDWARE PROTECTION shutdown (%s)\\n\"",
            "reason"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATOMIC_INIT",
          "args": [
            "1"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid hw_protection_shutdown(const char *reason, int ms_until_forced)\n{\n\tstatic atomic_t allow_proceed = ATOMIC_INIT(1);\n\n\tpr_emerg(\"HARDWARE PROTECTION shutdown (%s)\\n\", reason);\n\n\t/* Shutdown should be initiated only once. */\n\tif (!atomic_dec_and_test(&allow_proceed))\n\t\treturn;\n\n\t/*\n\t * Queue a backup emergency shutdown in the event of\n\t * orderly_poweroff failure\n\t */\n\thw_failure_emergency_poweroff(ms_until_forced);\n\torderly_poweroff(true);\n}"
  },
  {
    "function_name": "hw_failure_emergency_poweroff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "558-564",
    "snippet": "static void hw_failure_emergency_poweroff(int poweroff_delay_ms)\n{\n\tif (poweroff_delay_ms <= 0)\n\t\treturn;\n\tschedule_delayed_work(&hw_failure_emergency_poweroff_work,\n\t\t\t      msecs_to_jiffies(poweroff_delay_ms));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&hw_failure_emergency_poweroff_work",
            "msecs_to_jiffies(poweroff_delay_ms)"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "poweroff_delay_ms"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "552-560",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic void hw_failure_emergency_poweroff(int poweroff_delay_ms)\n{\n\tif (poweroff_delay_ms <= 0)\n\t\treturn;\n\tschedule_delayed_work(&hw_failure_emergency_poweroff_work,\n\t\t\t      msecs_to_jiffies(poweroff_delay_ms));\n}"
  },
  {
    "function_name": "hw_failure_emergency_poweroff_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "529-547",
    "snippet": "static void hw_failure_emergency_poweroff_func(struct work_struct *work)\n{\n\t/*\n\t * We have reached here after the emergency shutdown waiting period has\n\t * expired. This means orderly_poweroff has not been able to shut off\n\t * the system for some reason.\n\t *\n\t * Try to shut down the system immediately using kernel_power_off\n\t * if populated\n\t */\n\tpr_emerg(\"Hardware protection timed-out. Trying forced poweroff\\n\");\n\tkernel_power_off();\n\n\t/*\n\t * Worst of the worst case trigger emergency restart\n\t */\n\tpr_emerg(\"Hardware protection shutdown failed. Trying emergency restart\\n\");\n\temergency_restart();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_DELAYED_WORK(hw_failure_emergency_poweroff_work,\n\t\t\t    hw_failure_emergency_poweroff_func);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emergency_restart",
          "args": [],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "emergency_restart",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "66-70",
          "snippet": "void emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Hardware protection shutdown failed. Trying emergency restart\\n\""
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "289-299",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Hardware protection timed-out. Trying forced poweroff\\n\""
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic DECLARE_DELAYED_WORK(hw_failure_emergency_poweroff_work,\n\t\t\t    hw_failure_emergency_poweroff_func);\n\nstatic void hw_failure_emergency_poweroff_func(struct work_struct *work)\n{\n\t/*\n\t * We have reached here after the emergency shutdown waiting period has\n\t * expired. This means orderly_poweroff has not been able to shut off\n\t * the system for some reason.\n\t *\n\t * Try to shut down the system immediately using kernel_power_off\n\t * if populated\n\t */\n\tpr_emerg(\"Hardware protection timed-out. Trying forced poweroff\\n\");\n\tkernel_power_off();\n\n\t/*\n\t * Worst of the worst case trigger emergency restart\n\t */\n\tpr_emerg(\"Hardware protection shutdown failed. Trying emergency restart\\n\");\n\temergency_restart();\n}"
  },
  {
    "function_name": "orderly_reboot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "516-519",
    "snippet": "void orderly_reboot(void)\n{\n\tschedule_work(&reboot_work);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&reboot_work"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid orderly_reboot(void)\n{\n\tschedule_work(&reboot_work);\n}"
  },
  {
    "function_name": "reboot_work_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "503-506",
    "snippet": "static void reboot_work_func(struct work_struct *work)\n{\n\t__orderly_reboot();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WORK(reboot_work, reboot_work_func);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__orderly_reboot",
          "args": [],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "__orderly_reboot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "443-456",
          "snippet": "static int __orderly_reboot(void)\n{\n\tint ret;\n\n\tret = run_cmd(reboot_cmd);\n\n\tif (ret) {\n\t\tpr_warn(\"Failed to start orderly reboot: forcing the issue\\n\");\n\t\temergency_sync();\n\t\tkernel_restart(NULL);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char reboot_cmd[] = \"/sbin/reboot\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic const char reboot_cmd[] = \"/sbin/reboot\";\n\nstatic int __orderly_reboot(void)\n{\n\tint ret;\n\n\tret = run_cmd(reboot_cmd);\n\n\tif (ret) {\n\t\tpr_warn(\"Failed to start orderly reboot: forcing the issue\\n\");\n\t\temergency_sync();\n\t\tkernel_restart(NULL);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic DECLARE_WORK(reboot_work, reboot_work_func);\n\nstatic void reboot_work_func(struct work_struct *work)\n{\n\t__orderly_reboot();\n}"
  },
  {
    "function_name": "orderly_poweroff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "495-500",
    "snippet": "void orderly_poweroff(bool force)\n{\n\tif (force) /* do not override the pending \"true\" */\n\t\tpoweroff_force = true;\n\tschedule_work(&poweroff_work);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool poweroff_force;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&poweroff_work"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic bool poweroff_force;\n\nvoid orderly_poweroff(bool force)\n{\n\tif (force) /* do not override the pending \"true\" */\n\t\tpoweroff_force = true;\n\tschedule_work(&poweroff_work);\n}"
  },
  {
    "function_name": "poweroff_work_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "481-484",
    "snippet": "static void poweroff_work_func(struct work_struct *work)\n{\n\t__orderly_poweroff(poweroff_force);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool poweroff_force;",
      "static DECLARE_WORK(poweroff_work, poweroff_work_func);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__orderly_poweroff",
          "args": [
            "poweroff_force"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "__orderly_poweroff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "458-477",
          "snippet": "static int __orderly_poweroff(bool force)\n{\n\tint ret;\n\n\tret = run_cmd(poweroff_cmd);\n\n\tif (ret && force) {\n\t\tpr_warn(\"Failed to start orderly shutdown: forcing the issue\\n\");\n\n\t\t/*\n\t\t * I guess this should try to kick off some daemon to sync and\n\t\t * poweroff asap.  Or not even bother syncing if we're doing an\n\t\t * emergency shutdown?\n\t\t */\n\t\temergency_sync();\n\t\tkernel_power_off();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char poweroff_cmd[POWEROFF_CMD_PATH_LEN] = \"/sbin/poweroff\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nchar poweroff_cmd[POWEROFF_CMD_PATH_LEN] = \"/sbin/poweroff\";\n\nstatic int __orderly_poweroff(bool force)\n{\n\tint ret;\n\n\tret = run_cmd(poweroff_cmd);\n\n\tif (ret && force) {\n\t\tpr_warn(\"Failed to start orderly shutdown: forcing the issue\\n\");\n\n\t\t/*\n\t\t * I guess this should try to kick off some daemon to sync and\n\t\t * poweroff asap.  Or not even bother syncing if we're doing an\n\t\t * emergency shutdown?\n\t\t */\n\t\temergency_sync();\n\t\tkernel_power_off();\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic bool poweroff_force;\nstatic DECLARE_WORK(poweroff_work, poweroff_work_func);\n\nstatic void poweroff_work_func(struct work_struct *work)\n{\n\t__orderly_poweroff(poweroff_force);\n}"
  },
  {
    "function_name": "__orderly_poweroff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "458-477",
    "snippet": "static int __orderly_poweroff(bool force)\n{\n\tint ret;\n\n\tret = run_cmd(poweroff_cmd);\n\n\tif (ret && force) {\n\t\tpr_warn(\"Failed to start orderly shutdown: forcing the issue\\n\");\n\n\t\t/*\n\t\t * I guess this should try to kick off some daemon to sync and\n\t\t * poweroff asap.  Or not even bother syncing if we're doing an\n\t\t * emergency shutdown?\n\t\t */\n\t\temergency_sync();\n\t\tkernel_power_off();\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char poweroff_cmd[POWEROFF_CMD_PATH_LEN] = \"/sbin/poweroff\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "289-299",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "emergency_sync",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to start orderly shutdown: forcing the issue\\n\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_cmd",
          "args": [
            "poweroff_cmd"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "run_cmd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "423-441",
          "snippet": "static int run_cmd(const char *cmd)\n{\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tNULL\n\t};\n\tint ret;\n\targv = argv_split(GFP_KERNEL, cmd, NULL);\n\tif (argv) {\n\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\t\targv_free(argv);\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic int run_cmd(const char *cmd)\n{\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tNULL\n\t};\n\tint ret;\n\targv = argv_split(GFP_KERNEL, cmd, NULL);\n\tif (argv) {\n\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\t\targv_free(argv);\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nchar poweroff_cmd[POWEROFF_CMD_PATH_LEN] = \"/sbin/poweroff\";\n\nstatic int __orderly_poweroff(bool force)\n{\n\tint ret;\n\n\tret = run_cmd(poweroff_cmd);\n\n\tif (ret && force) {\n\t\tpr_warn(\"Failed to start orderly shutdown: forcing the issue\\n\");\n\n\t\t/*\n\t\t * I guess this should try to kick off some daemon to sync and\n\t\t * poweroff asap.  Or not even bother syncing if we're doing an\n\t\t * emergency shutdown?\n\t\t */\n\t\temergency_sync();\n\t\tkernel_power_off();\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__orderly_reboot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "443-456",
    "snippet": "static int __orderly_reboot(void)\n{\n\tint ret;\n\n\tret = run_cmd(reboot_cmd);\n\n\tif (ret) {\n\t\tpr_warn(\"Failed to start orderly reboot: forcing the issue\\n\");\n\t\temergency_sync();\n\t\tkernel_restart(NULL);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char reboot_cmd[] = \"/sbin/reboot\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_restart",
          "args": [
            "NULL"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_restart",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "246-257",
          "snippet": "void kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tif (!cmd)\n\t\tpr_emerg(\"Restarting system\\n\");\n\telse\n\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_restart(cmd);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tif (!cmd)\n\t\tpr_emerg(\"Restarting system\\n\");\n\telse\n\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_restart(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emergency_sync",
          "args": [],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to start orderly reboot: forcing the issue\\n\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_cmd",
          "args": [
            "reboot_cmd"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "run_cmd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "423-441",
          "snippet": "static int run_cmd(const char *cmd)\n{\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tNULL\n\t};\n\tint ret;\n\targv = argv_split(GFP_KERNEL, cmd, NULL);\n\tif (argv) {\n\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\t\targv_free(argv);\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic int run_cmd(const char *cmd)\n{\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tNULL\n\t};\n\tint ret;\n\targv = argv_split(GFP_KERNEL, cmd, NULL);\n\tif (argv) {\n\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\t\targv_free(argv);\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic const char reboot_cmd[] = \"/sbin/reboot\";\n\nstatic int __orderly_reboot(void)\n{\n\tint ret;\n\n\tret = run_cmd(reboot_cmd);\n\n\tif (ret) {\n\t\tpr_warn(\"Failed to start orderly reboot: forcing the issue\\n\");\n\t\temergency_sync();\n\t\tkernel_restart(NULL);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "run_cmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "423-441",
    "snippet": "static int run_cmd(const char *cmd)\n{\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tNULL\n\t};\n\tint ret;\n\targv = argv_split(GFP_KERNEL, cmd, NULL);\n\tif (argv) {\n\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\t\targv_free(argv);\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "argv"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_usermodehelper",
          "args": [
            "argv[0]",
            "argv",
            "envp",
            "UMH_WAIT_EXEC"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "474-485",
          "snippet": "int call_usermodehelper(const char *path, char **argv, char **envp, int wait)\n{\n\tstruct subprocess_info *info;\n\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\n\t\t\t\t\t NULL, NULL, NULL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\treturn call_usermodehelper_exec(info, wait);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint call_usermodehelper(const char *path, char **argv, char **envp, int wait)\n{\n\tstruct subprocess_info *info;\n\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\n\t\t\t\t\t NULL, NULL, NULL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\treturn call_usermodehelper_exec(info, wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_split",
          "args": [
            "GFP_KERNEL",
            "cmd",
            "NULL"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic int run_cmd(const char *cmd)\n{\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tNULL\n\t};\n\tint ret;\n\targv = argv_split(GFP_KERNEL, cmd, NULL);\n\tif (argv) {\n\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\t\targv_free(argv);\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ctrl_alt_del",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "410-418",
    "snippet": "void ctrl_alt_del(void)\n{\n\tstatic DECLARE_WORK(cad_work, deferred_cad);\n\n\tif (C_A_D)\n\t\tschedule_work(&cad_work);\n\telse\n\t\tkill_cad_pid(SIGINT, 1);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int C_A_D = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_cad_pid",
          "args": [
            "SIGINT",
            "1"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&cad_work"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint C_A_D = 1;\n\nvoid ctrl_alt_del(void)\n{\n\tstatic DECLARE_WORK(cad_work, deferred_cad);\n\n\tif (C_A_D)\n\t\tschedule_work(&cad_work);\n\telse\n\t\tkill_cad_pid(SIGINT, 1);\n}"
  },
  {
    "function_name": "deferred_cad",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "400-403",
    "snippet": "static void deferred_cad(struct work_struct *dummy)\n{\n\tkernel_restart(NULL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_restart",
          "args": [
            "NULL"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_restart",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "246-257",
          "snippet": "void kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tif (!cmd)\n\t\tpr_emerg(\"Restarting system\\n\");\n\telse\n\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_restart(cmd);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tif (!cmd)\n\t\tpr_emerg(\"Restarting system\\n\");\n\telse\n\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_restart(cmd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic void deferred_cad(struct work_struct *dummy)\n{\n\tkernel_restart(NULL);\n}"
  },
  {
    "function_name": "kernel_power_off",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "289-299",
    "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void (*pm_power_off_prepare)(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "machine_power_off",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump",
          "args": [
            "KMSG_DUMP_SHUTDOWN"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_rewind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3593-3597",
          "snippet": "void kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Power down\\n\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_shutdown",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_to_reboot_cpu",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_to_reboot_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "220-236",
          "snippet": "void migrate_to_reboot_cpu(void)\n{\n\t/* The boot cpu is always logical cpu 0 */\n\tint cpu = reboot_cpu;\n\n\tcpu_hotplug_disable();\n\n\t/* Make certain the cpu I'm about to reboot on is online */\n\tif (!cpu_online(cpu))\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t/* Prevent races with other tasks migrating this task */\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\t/* Make certain I only run on the appropriate processor */\n\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reboot_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint reboot_cpu;\n\nvoid migrate_to_reboot_cpu(void)\n{\n\t/* The boot cpu is always logical cpu 0 */\n\tint cpu = reboot_cpu;\n\n\tcpu_hotplug_disable();\n\n\t/* Make certain the cpu I'm about to reboot on is online */\n\tif (!cpu_online(cpu))\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t/* Prevent races with other tasks migrating this task */\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\t/* Make certain I only run on the appropriate processor */\n\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_power_off_prepare",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_shutdown_prepare",
          "args": [
            "SYSTEM_POWER_OFF"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_shutdown_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "260-267",
          "snippet": "static void kernel_shutdown_prepare(enum system_states state)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list,\n\t\t(state == SYSTEM_HALT) ? SYS_HALT : SYS_POWER_OFF, NULL);\n\tsystem_state = state;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic void kernel_shutdown_prepare(enum system_states state)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list,\n\t\t(state == SYSTEM_HALT) ? SYS_HALT : SYS_POWER_OFF, NULL);\n\tsystem_state = state;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
  },
  {
    "function_name": "kernel_halt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "273-281",
    "snippet": "void kernel_halt(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_HALT);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"System halted\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_halt();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "machine_halt",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump",
          "args": [
            "KMSG_DUMP_SHUTDOWN"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_rewind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3593-3597",
          "snippet": "void kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"System halted\\n\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_shutdown",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_to_reboot_cpu",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_to_reboot_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "220-236",
          "snippet": "void migrate_to_reboot_cpu(void)\n{\n\t/* The boot cpu is always logical cpu 0 */\n\tint cpu = reboot_cpu;\n\n\tcpu_hotplug_disable();\n\n\t/* Make certain the cpu I'm about to reboot on is online */\n\tif (!cpu_online(cpu))\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t/* Prevent races with other tasks migrating this task */\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\t/* Make certain I only run on the appropriate processor */\n\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reboot_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint reboot_cpu;\n\nvoid migrate_to_reboot_cpu(void)\n{\n\t/* The boot cpu is always logical cpu 0 */\n\tint cpu = reboot_cpu;\n\n\tcpu_hotplug_disable();\n\n\t/* Make certain the cpu I'm about to reboot on is online */\n\tif (!cpu_online(cpu))\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t/* Prevent races with other tasks migrating this task */\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\t/* Make certain I only run on the appropriate processor */\n\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_shutdown_prepare",
          "args": [
            "SYSTEM_HALT"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_shutdown_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "260-267",
          "snippet": "static void kernel_shutdown_prepare(enum system_states state)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list,\n\t\t(state == SYSTEM_HALT) ? SYS_HALT : SYS_POWER_OFF, NULL);\n\tsystem_state = state;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic void kernel_shutdown_prepare(enum system_states state)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list,\n\t\t(state == SYSTEM_HALT) ? SYS_HALT : SYS_POWER_OFF, NULL);\n\tsystem_state = state;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid kernel_halt(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_HALT);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"System halted\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_halt();\n}"
  },
  {
    "function_name": "kernel_shutdown_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "260-267",
    "snippet": "static void kernel_shutdown_prepare(enum system_states state)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list,\n\t\t(state == SYSTEM_HALT) ? SYS_HALT : SYS_POWER_OFF, NULL);\n\tsystem_state = state;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_shutdown",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usermodehelper_disable",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&reboot_notifier_list",
            "(state == SYSTEM_HALT) ? SYS_HALT : SYS_POWER_OFF",
            "NULL"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "307-323",
          "snippet": "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic void kernel_shutdown_prepare(enum system_states state)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list,\n\t\t(state == SYSTEM_HALT) ? SYS_HALT : SYS_POWER_OFF, NULL);\n\tsystem_state = state;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}"
  },
  {
    "function_name": "kernel_restart",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "246-257",
    "snippet": "void kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tif (!cmd)\n\t\tpr_emerg(\"Restarting system\\n\");\n\telse\n\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_restart(cmd);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "machine_restart",
          "args": [
            "cmd"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump",
          "args": [
            "KMSG_DUMP_SHUTDOWN"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_rewind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3593-3597",
          "snippet": "void kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Restarting system with command '%s'\\n\"",
            "cmd"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Restarting system\\n\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_shutdown",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_to_reboot_cpu",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_to_reboot_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "220-236",
          "snippet": "void migrate_to_reboot_cpu(void)\n{\n\t/* The boot cpu is always logical cpu 0 */\n\tint cpu = reboot_cpu;\n\n\tcpu_hotplug_disable();\n\n\t/* Make certain the cpu I'm about to reboot on is online */\n\tif (!cpu_online(cpu))\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t/* Prevent races with other tasks migrating this task */\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\t/* Make certain I only run on the appropriate processor */\n\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reboot_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint reboot_cpu;\n\nvoid migrate_to_reboot_cpu(void)\n{\n\t/* The boot cpu is always logical cpu 0 */\n\tint cpu = reboot_cpu;\n\n\tcpu_hotplug_disable();\n\n\t/* Make certain the cpu I'm about to reboot on is online */\n\tif (!cpu_online(cpu))\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t/* Prevent races with other tasks migrating this task */\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\t/* Make certain I only run on the appropriate processor */\n\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_restart_prepare",
          "args": [
            "cmd"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_restart_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "73-79",
          "snippet": "void kernel_restart_prepare(char *cmd)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);\n\tsystem_state = SYSTEM_RESTART;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid kernel_restart_prepare(char *cmd)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);\n\tsystem_state = SYSTEM_RESTART;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tif (!cmd)\n\t\tpr_emerg(\"Restarting system\\n\");\n\telse\n\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_restart(cmd);\n}"
  },
  {
    "function_name": "migrate_to_reboot_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "220-236",
    "snippet": "void migrate_to_reboot_cpu(void)\n{\n\t/* The boot cpu is always logical cpu 0 */\n\tint cpu = reboot_cpu;\n\n\tcpu_hotplug_disable();\n\n\t/* Make certain the cpu I'm about to reboot on is online */\n\tif (!cpu_online(cpu))\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t/* Prevent races with other tasks migrating this task */\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\t/* Make certain I only run on the appropriate processor */\n\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int reboot_cpu;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "current",
            "cpumask_of(cpu)"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_hotplug_disable",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_hotplug_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "373-378",
          "snippet": "void cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled++;\n\tcpu_maps_update_done();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled++;\n\tcpu_maps_update_done();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint reboot_cpu;\n\nvoid migrate_to_reboot_cpu(void)\n{\n\t/* The boot cpu is always logical cpu 0 */\n\tint cpu = reboot_cpu;\n\n\tcpu_hotplug_disable();\n\n\t/* Make certain the cpu I'm about to reboot on is online */\n\tif (!cpu_online(cpu))\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t/* Prevent races with other tasks migrating this task */\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\t/* Make certain I only run on the appropriate processor */\n\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n}"
  },
  {
    "function_name": "do_kernel_restart",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "215-218",
    "snippet": "void do_kernel_restart(char *cmd)\n{\n\tatomic_notifier_call_chain(&restart_handler_list, reboot_mode, cmd);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum reboot_mode reboot_mode",
      "static ATOMIC_NOTIFIER_HEAD(restart_handler_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_notifier_call_chain",
          "args": [
            "&restart_handler_list",
            "reboot_mode",
            "cmd"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "193-203",
          "snippet": "int atomic_notifier_call_chain(struct atomic_notifier_head *nh,\n\t\t\t       unsigned long val, void *v)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_call_chain(struct atomic_notifier_head *nh,\n\t\t\t       unsigned long val, void *v)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nenum reboot_mode reboot_mode;\nstatic ATOMIC_NOTIFIER_HEAD(restart_handler_list);\n\nvoid do_kernel_restart(char *cmd)\n{\n\tatomic_notifier_call_chain(&restart_handler_list, reboot_mode, cmd);\n}"
  },
  {
    "function_name": "unregister_restart_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "198-201",
    "snippet": "int unregister_restart_handler(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&restart_handler_list, nb);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ATOMIC_NOTIFIER_HEAD(restart_handler_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_notifier_chain_unregister",
          "args": [
            "&restart_handler_list",
            "nb"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_chain_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "162-173",
          "snippet": "int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\tsynchronize_rcu();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\tsynchronize_rcu();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(restart_handler_list);\n\nint unregister_restart_handler(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&restart_handler_list, nb);\n}"
  },
  {
    "function_name": "register_restart_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "183-186",
    "snippet": "int register_restart_handler(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&restart_handler_list, nb);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ATOMIC_NOTIFIER_HEAD(restart_handler_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_notifier_chain_register",
          "args": [
            "&restart_handler_list",
            "nb"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "140-150",
          "snippet": "int atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(restart_handler_list);\n\nint register_restart_handler(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&restart_handler_list, nb);\n}"
  },
  {
    "function_name": "devm_register_reboot_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "117-136",
    "snippet": "int devm_register_reboot_notifier(struct device *dev, struct notifier_block *nb)\n{\n\tstruct notifier_block **rcnb;\n\tint ret;\n\n\trcnb = devres_alloc(devm_unregister_reboot_notifier,\n\t\t\t    sizeof(*rcnb), GFP_KERNEL);\n\tif (!rcnb)\n\t\treturn -ENOMEM;\n\n\tret = register_reboot_notifier(nb);\n\tif (!ret) {\n\t\t*rcnb = nb;\n\t\tdevres_add(dev, rcnb);\n\t} else {\n\t\tdevres_free(rcnb);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "rcnb"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "rcnb"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_reboot_notifier",
          "args": [
            "nb"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_reboot_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "106-109",
          "snippet": "int unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "devm_unregister_reboot_notifier",
            "sizeof(*rcnb)",
            "GFP_KERNEL"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint devm_register_reboot_notifier(struct device *dev, struct notifier_block *nb)\n{\n\tstruct notifier_block **rcnb;\n\tint ret;\n\n\trcnb = devres_alloc(devm_unregister_reboot_notifier,\n\t\t\t    sizeof(*rcnb), GFP_KERNEL);\n\tif (!rcnb)\n\t\treturn -ENOMEM;\n\n\tret = register_reboot_notifier(nb);\n\tif (!ret) {\n\t\t*rcnb = nb;\n\t\tdevres_add(dev, rcnb);\n\t} else {\n\t\tdevres_free(rcnb);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "devm_unregister_reboot_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "112-115",
    "snippet": "static void devm_unregister_reboot_notifier(struct device *dev, void *res)\n{\n\tWARN_ON(unregister_reboot_notifier(*(struct notifier_block **)res));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "unregister_reboot_notifier(*(struct notifier_block **)res)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_reboot_notifier",
          "args": [
            "*(struct notifier_block **)res"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_reboot_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "106-109",
          "snippet": "int unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nstatic void devm_unregister_reboot_notifier(struct device *dev, void *res)\n{\n\tWARN_ON(unregister_reboot_notifier(*(struct notifier_block **)res));\n}"
  },
  {
    "function_name": "unregister_reboot_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "106-109",
    "snippet": "int unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_unregister",
          "args": [
            "&reboot_notifier_list",
            "nb"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "252-269",
          "snippet": "int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}"
  },
  {
    "function_name": "register_reboot_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "91-94",
    "snippet": "int register_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&reboot_notifier_list, nb);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_register",
          "args": [
            "&reboot_notifier_list",
            "nb"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "222-239",
          "snippet": "int blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint register_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&reboot_notifier_list, nb);\n}"
  },
  {
    "function_name": "kernel_restart_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "73-79",
    "snippet": "void kernel_restart_prepare(char *cmd)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);\n\tsystem_state = SYSTEM_RESTART;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_shutdown",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usermodehelper_disable",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&reboot_notifier_list",
            "SYS_RESTART",
            "cmd"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "307-323",
          "snippet": "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid kernel_restart_prepare(char *cmd)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);\n\tsystem_state = SYSTEM_RESTART;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}"
  },
  {
    "function_name": "emergency_restart",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "66-70",
    "snippet": "void emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "machine_emergency_restart",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump",
          "args": [
            "KMSG_DUMP_EMERG"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_rewind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3593-3597",
          "snippet": "void kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}"
  },
  {
    "function_name": "reboot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
    "lines": "312-398",
    "snippet": "SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,\n\t\tvoid __user *, arg)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(current);\n\tchar buffer[256];\n\tint ret = 0;\n\n\t/* We only trust the superuser with rebooting the system. */\n\tif (!ns_capable(pid_ns->user_ns, CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\t/* For safety, we require \"magic\" arguments. */\n\tif (magic1 != LINUX_REBOOT_MAGIC1 ||\n\t\t\t(magic2 != LINUX_REBOOT_MAGIC2 &&\n\t\t\tmagic2 != LINUX_REBOOT_MAGIC2A &&\n\t\t\tmagic2 != LINUX_REBOOT_MAGIC2B &&\n\t\t\tmagic2 != LINUX_REBOOT_MAGIC2C))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If pid namespaces are enabled and the current task is in a child\n\t * pid_namespace, the command is handled by reboot_pid_ns() which will\n\t * call do_exit().\n\t */\n\tret = reboot_pid_ns(pid_ns, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Instead of trying to make the power_off code look like\n\t * halt when pm_power_off is not set do it the easy way.\n\t */\n\tif ((cmd == LINUX_REBOOT_CMD_POWER_OFF) && !pm_power_off)\n\t\tcmd = LINUX_REBOOT_CMD_HALT;\n\n\tmutex_lock(&system_transition_mutex);\n\tswitch (cmd) {\n\tcase LINUX_REBOOT_CMD_RESTART:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_CAD_ON:\n\t\tC_A_D = 1;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_CAD_OFF:\n\t\tC_A_D = 0;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_HALT:\n\t\tkernel_halt();\n\t\tdo_exit(0);\n\n\tcase LINUX_REBOOT_CMD_POWER_OFF:\n\t\tkernel_power_off();\n\t\tdo_exit(0);\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_RESTART2:\n\t\tret = strncpy_from_user(&buffer[0], arg, sizeof(buffer) - 1);\n\t\tif (ret < 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\n\t\tkernel_restart(buffer);\n\t\tbreak;\n\n#ifdef CONFIG_KEXEC_CORE\n\tcase LINUX_REBOOT_CMD_KEXEC:\n\t\tret = kernel_kexec();\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_HIBERNATION\n\tcase LINUX_REBOOT_CMD_SW_SUSPEND:\n\t\tret = hibernate();\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&system_transition_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/ctype.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int C_A_D = 1;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint C_A_D = 1;\n\nSYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,\n\t\tvoid __user *, arg)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(current);\n\tchar buffer[256];\n\tint ret = 0;\n\n\t/* We only trust the superuser with rebooting the system. */\n\tif (!ns_capable(pid_ns->user_ns, CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\t/* For safety, we require \"magic\" arguments. */\n\tif (magic1 != LINUX_REBOOT_MAGIC1 ||\n\t\t\t(magic2 != LINUX_REBOOT_MAGIC2 &&\n\t\t\tmagic2 != LINUX_REBOOT_MAGIC2A &&\n\t\t\tmagic2 != LINUX_REBOOT_MAGIC2B &&\n\t\t\tmagic2 != LINUX_REBOOT_MAGIC2C))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If pid namespaces are enabled and the current task is in a child\n\t * pid_namespace, the command is handled by reboot_pid_ns() which will\n\t * call do_exit().\n\t */\n\tret = reboot_pid_ns(pid_ns, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Instead of trying to make the power_off code look like\n\t * halt when pm_power_off is not set do it the easy way.\n\t */\n\tif ((cmd == LINUX_REBOOT_CMD_POWER_OFF) && !pm_power_off)\n\t\tcmd = LINUX_REBOOT_CMD_HALT;\n\n\tmutex_lock(&system_transition_mutex);\n\tswitch (cmd) {\n\tcase LINUX_REBOOT_CMD_RESTART:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_CAD_ON:\n\t\tC_A_D = 1;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_CAD_OFF:\n\t\tC_A_D = 0;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_HALT:\n\t\tkernel_halt();\n\t\tdo_exit(0);\n\n\tcase LINUX_REBOOT_CMD_POWER_OFF:\n\t\tkernel_power_off();\n\t\tdo_exit(0);\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_RESTART2:\n\t\tret = strncpy_from_user(&buffer[0], arg, sizeof(buffer) - 1);\n\t\tif (ret < 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\n\t\tkernel_restart(buffer);\n\t\tbreak;\n\n#ifdef CONFIG_KEXEC_CORE\n\tcase LINUX_REBOOT_CMD_KEXEC:\n\t\tret = kernel_kexec();\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_HIBERNATION\n\tcase LINUX_REBOOT_CMD_SW_SUSPEND:\n\t\tret = hibernate();\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&system_transition_mutex);\n\treturn ret;\n}"
  }
]