[
  {
    "function_name": "dma_free_from_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "283-295",
    "snippet": "bool dma_free_from_pool(struct device *dev, void *start, size_t size)\n{\n\tstruct gen_pool *pool = NULL;\n\n\twhile ((pool = dma_guess_pool(pool, 0))) {\n\t\tif (!gen_pool_has_addr(pool, (unsigned long)start, size))\n\t\t\tcontinue;\n\t\tgen_pool_free(pool, (unsigned long)start, size);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gen_pool_free",
          "args": [
            "pool",
            "(unsigned long)start",
            "size"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_pool_has_addr",
          "args": [
            "pool",
            "(unsigned long)start",
            "size"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_guess_pool",
          "args": [
            "pool",
            "0"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "dma_guess_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "224-238",
          "snippet": "static inline struct gen_pool *dma_guess_pool(struct gen_pool *prev, gfp_t gfp)\n{\n\tif (prev == NULL) {\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) && (gfp & GFP_DMA32))\n\t\t\treturn atomic_pool_dma32;\n\t\tif (atomic_pool_dma && (gfp & GFP_DMA))\n\t\t\treturn atomic_pool_dma;\n\t\treturn atomic_pool_kernel;\n\t}\n\tif (prev == atomic_pool_kernel)\n\t\treturn atomic_pool_dma32 ? atomic_pool_dma32 : atomic_pool_dma;\n\tif (prev == atomic_pool_dma32)\n\t\treturn atomic_pool_dma;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gen_pool *atomic_pool_dma",
            "static struct gen_pool *atomic_pool_dma32",
            "static struct gen_pool *atomic_pool_kernel",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic struct gen_pool *atomic_pool_dma;\nstatic struct gen_pool *atomic_pool_dma32;\nstatic struct gen_pool *atomic_pool_kernel;\nstatic __init struct;\n\nstatic inline struct gen_pool *dma_guess_pool(struct gen_pool *prev, gfp_t gfp)\n{\n\tif (prev == NULL) {\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) && (gfp & GFP_DMA32))\n\t\t\treturn atomic_pool_dma32;\n\t\tif (atomic_pool_dma && (gfp & GFP_DMA))\n\t\t\treturn atomic_pool_dma;\n\t\treturn atomic_pool_kernel;\n\t}\n\tif (prev == atomic_pool_kernel)\n\t\treturn atomic_pool_dma32 ? atomic_pool_dma32 : atomic_pool_dma;\n\tif (prev == atomic_pool_dma32)\n\t\treturn atomic_pool_dma;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\nbool dma_free_from_pool(struct device *dev, void *start, size_t size)\n{\n\tstruct gen_pool *pool = NULL;\n\n\twhile ((pool = dma_guess_pool(pool, 0))) {\n\t\tif (!gen_pool_has_addr(pool, (unsigned long)start, size))\n\t\t\tcontinue;\n\t\tgen_pool_free(pool, (unsigned long)start, size);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "dma_alloc_from_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "265-281",
    "snippet": "struct page *dma_alloc_from_pool(struct device *dev, size_t size,\n\t\tvoid **cpu_addr, gfp_t gfp,\n\t\tbool (*phys_addr_ok)(struct device *, phys_addr_t, size_t))\n{\n\tstruct gen_pool *pool = NULL;\n\tstruct page *page;\n\n\twhile ((pool = dma_guess_pool(pool, gfp))) {\n\t\tpage = __dma_alloc_from_pool(dev, size, pool, cpu_addr,\n\t\t\t\t\t     phys_addr_ok);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\n\tWARN(1, \"Failed to get suitable pool for %s\\n\", dev_name(dev));\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Failed to get suitable pool for %s\\n\"",
            "dev_name(dev)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dma_alloc_from_pool",
          "args": [
            "dev",
            "size",
            "pool",
            "cpu_addr",
            "phys_addr_ok"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_alloc_from_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "240-263",
          "snippet": "static struct page *__dma_alloc_from_pool(struct device *dev, size_t size,\n\t\tstruct gen_pool *pool, void **cpu_addr,\n\t\tbool (*phys_addr_ok)(struct device *, phys_addr_t, size_t))\n{\n\tunsigned long addr;\n\tphys_addr_t phys;\n\n\taddr = gen_pool_alloc(pool, size);\n\tif (!addr)\n\t\treturn NULL;\n\n\tphys = gen_pool_virt_to_phys(pool, addr);\n\tif (phys_addr_ok && !phys_addr_ok(dev, phys, size)) {\n\t\tgen_pool_free(pool, addr, size);\n\t\treturn NULL;\n\t}\n\n\tif (gen_pool_avail(pool) < atomic_pool_size)\n\t\tschedule_work(&atomic_pool_work);\n\n\t*cpu_addr = (void *)addr;\n\tmemset(*cpu_addr, 0, size);\n\treturn pfn_to_page(__phys_to_pfn(phys));\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t atomic_pool_size;",
            "static struct work_struct atomic_pool_work;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic size_t atomic_pool_size;\nstatic struct work_struct atomic_pool_work;\nstatic __init struct;\n\nstatic struct page *__dma_alloc_from_pool(struct device *dev, size_t size,\n\t\tstruct gen_pool *pool, void **cpu_addr,\n\t\tbool (*phys_addr_ok)(struct device *, phys_addr_t, size_t))\n{\n\tunsigned long addr;\n\tphys_addr_t phys;\n\n\taddr = gen_pool_alloc(pool, size);\n\tif (!addr)\n\t\treturn NULL;\n\n\tphys = gen_pool_virt_to_phys(pool, addr);\n\tif (phys_addr_ok && !phys_addr_ok(dev, phys, size)) {\n\t\tgen_pool_free(pool, addr, size);\n\t\treturn NULL;\n\t}\n\n\tif (gen_pool_avail(pool) < atomic_pool_size)\n\t\tschedule_work(&atomic_pool_work);\n\n\t*cpu_addr = (void *)addr;\n\tmemset(*cpu_addr, 0, size);\n\treturn pfn_to_page(__phys_to_pfn(phys));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_guess_pool",
          "args": [
            "pool",
            "gfp"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "dma_guess_pool",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "224-238",
          "snippet": "static inline struct gen_pool *dma_guess_pool(struct gen_pool *prev, gfp_t gfp)\n{\n\tif (prev == NULL) {\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) && (gfp & GFP_DMA32))\n\t\t\treturn atomic_pool_dma32;\n\t\tif (atomic_pool_dma && (gfp & GFP_DMA))\n\t\t\treturn atomic_pool_dma;\n\t\treturn atomic_pool_kernel;\n\t}\n\tif (prev == atomic_pool_kernel)\n\t\treturn atomic_pool_dma32 ? atomic_pool_dma32 : atomic_pool_dma;\n\tif (prev == atomic_pool_dma32)\n\t\treturn atomic_pool_dma;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct gen_pool *atomic_pool_dma",
            "static struct gen_pool *atomic_pool_dma32",
            "static struct gen_pool *atomic_pool_kernel",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic struct gen_pool *atomic_pool_dma;\nstatic struct gen_pool *atomic_pool_dma32;\nstatic struct gen_pool *atomic_pool_kernel;\nstatic __init struct;\n\nstatic inline struct gen_pool *dma_guess_pool(struct gen_pool *prev, gfp_t gfp)\n{\n\tif (prev == NULL) {\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) && (gfp & GFP_DMA32))\n\t\t\treturn atomic_pool_dma32;\n\t\tif (atomic_pool_dma && (gfp & GFP_DMA))\n\t\t\treturn atomic_pool_dma;\n\t\treturn atomic_pool_kernel;\n\t}\n\tif (prev == atomic_pool_kernel)\n\t\treturn atomic_pool_dma32 ? atomic_pool_dma32 : atomic_pool_dma;\n\tif (prev == atomic_pool_dma32)\n\t\treturn atomic_pool_dma;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\nstruct page *dma_alloc_from_pool(struct device *dev, size_t size,\n\t\tvoid **cpu_addr, gfp_t gfp,\n\t\tbool (*phys_addr_ok)(struct device *, phys_addr_t, size_t))\n{\n\tstruct gen_pool *pool = NULL;\n\tstruct page *page;\n\n\twhile ((pool = dma_guess_pool(pool, gfp))) {\n\t\tpage = __dma_alloc_from_pool(dev, size, pool, cpu_addr,\n\t\t\t\t\t     phys_addr_ok);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\n\tWARN(1, \"Failed to get suitable pool for %s\\n\", dev_name(dev));\n\treturn NULL;\n}"
  },
  {
    "function_name": "__dma_alloc_from_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "240-263",
    "snippet": "static struct page *__dma_alloc_from_pool(struct device *dev, size_t size,\n\t\tstruct gen_pool *pool, void **cpu_addr,\n\t\tbool (*phys_addr_ok)(struct device *, phys_addr_t, size_t))\n{\n\tunsigned long addr;\n\tphys_addr_t phys;\n\n\taddr = gen_pool_alloc(pool, size);\n\tif (!addr)\n\t\treturn NULL;\n\n\tphys = gen_pool_virt_to_phys(pool, addr);\n\tif (phys_addr_ok && !phys_addr_ok(dev, phys, size)) {\n\t\tgen_pool_free(pool, addr, size);\n\t\treturn NULL;\n\t}\n\n\tif (gen_pool_avail(pool) < atomic_pool_size)\n\t\tschedule_work(&atomic_pool_work);\n\n\t*cpu_addr = (void *)addr;\n\tmemset(*cpu_addr, 0, size);\n\treturn pfn_to_page(__phys_to_pfn(phys));\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t atomic_pool_size;",
      "static struct work_struct atomic_pool_work;",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "__phys_to_pfn(phys)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__phys_to_pfn",
          "args": [
            "phys"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*cpu_addr",
            "0",
            "size"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&atomic_pool_work"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_pool_avail",
          "args": [
            "pool"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_pool_free",
          "args": [
            "pool",
            "addr",
            "size"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_addr_ok",
          "args": [
            "dev",
            "phys",
            "size"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_pool_virt_to_phys",
          "args": [
            "pool",
            "addr"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_pool_alloc",
          "args": [
            "pool",
            "size"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic size_t atomic_pool_size;\nstatic struct work_struct atomic_pool_work;\nstatic __init struct;\n\nstatic struct page *__dma_alloc_from_pool(struct device *dev, size_t size,\n\t\tstruct gen_pool *pool, void **cpu_addr,\n\t\tbool (*phys_addr_ok)(struct device *, phys_addr_t, size_t))\n{\n\tunsigned long addr;\n\tphys_addr_t phys;\n\n\taddr = gen_pool_alloc(pool, size);\n\tif (!addr)\n\t\treturn NULL;\n\n\tphys = gen_pool_virt_to_phys(pool, addr);\n\tif (phys_addr_ok && !phys_addr_ok(dev, phys, size)) {\n\t\tgen_pool_free(pool, addr, size);\n\t\treturn NULL;\n\t}\n\n\tif (gen_pool_avail(pool) < atomic_pool_size)\n\t\tschedule_work(&atomic_pool_work);\n\n\t*cpu_addr = (void *)addr;\n\tmemset(*cpu_addr, 0, size);\n\treturn pfn_to_page(__phys_to_pfn(phys));\n}"
  },
  {
    "function_name": "dma_guess_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "224-238",
    "snippet": "static inline struct gen_pool *dma_guess_pool(struct gen_pool *prev, gfp_t gfp)\n{\n\tif (prev == NULL) {\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) && (gfp & GFP_DMA32))\n\t\t\treturn atomic_pool_dma32;\n\t\tif (atomic_pool_dma && (gfp & GFP_DMA))\n\t\t\treturn atomic_pool_dma;\n\t\treturn atomic_pool_kernel;\n\t}\n\tif (prev == atomic_pool_kernel)\n\t\treturn atomic_pool_dma32 ? atomic_pool_dma32 : atomic_pool_dma;\n\tif (prev == atomic_pool_dma32)\n\t\treturn atomic_pool_dma;\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gen_pool *atomic_pool_dma",
      "static struct gen_pool *atomic_pool_dma32",
      "static struct gen_pool *atomic_pool_kernel",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA32"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic struct gen_pool *atomic_pool_dma;\nstatic struct gen_pool *atomic_pool_dma32;\nstatic struct gen_pool *atomic_pool_kernel;\nstatic __init struct;\n\nstatic inline struct gen_pool *dma_guess_pool(struct gen_pool *prev, gfp_t gfp)\n{\n\tif (prev == NULL) {\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) && (gfp & GFP_DMA32))\n\t\t\treturn atomic_pool_dma32;\n\t\tif (atomic_pool_dma && (gfp & GFP_DMA))\n\t\t\treturn atomic_pool_dma;\n\t\treturn atomic_pool_kernel;\n\t}\n\tif (prev == atomic_pool_kernel)\n\t\treturn atomic_pool_dma32 ? atomic_pool_dma32 : atomic_pool_dma;\n\tif (prev == atomic_pool_dma32)\n\t\treturn atomic_pool_dma;\n\treturn NULL;\n}"
  },
  {
    "function_name": "dma_atomic_pool_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "187-221",
    "snippet": "static int __init dma_atomic_pool_init(void)\n{\n\tint ret = 0;\n\n\t/*\n\t * If coherent_pool was not used on the command line, default the pool\n\t * sizes to 128KB per 1GB of memory, min 128KB, max MAX_ORDER-1.\n\t */\n\tif (!atomic_pool_size) {\n\t\tunsigned long pages = totalram_pages() / (SZ_1G / SZ_128K);\n\t\tpages = min_t(unsigned long, pages, MAX_ORDER_NR_PAGES);\n\t\tatomic_pool_size = max_t(size_t, pages << PAGE_SHIFT, SZ_128K);\n\t}\n\tINIT_WORK(&atomic_pool_work, atomic_pool_work_fn);\n\n\tatomic_pool_kernel = __dma_atomic_pool_init(atomic_pool_size,\n\t\t\t\t\t\t    GFP_KERNEL);\n\tif (!atomic_pool_kernel)\n\t\tret = -ENOMEM;\n\tif (has_managed_dma()) {\n\t\tatomic_pool_dma = __dma_atomic_pool_init(atomic_pool_size,\n\t\t\t\t\t\tGFP_KERNEL | GFP_DMA);\n\t\tif (!atomic_pool_dma)\n\t\t\tret = -ENOMEM;\n\t}\n\tif (IS_ENABLED(CONFIG_ZONE_DMA32)) {\n\t\tatomic_pool_dma32 = __dma_atomic_pool_init(atomic_pool_size,\n\t\t\t\t\t\tGFP_KERNEL | GFP_DMA32);\n\t\tif (!atomic_pool_dma32)\n\t\t\tret = -ENOMEM;\n\t}\n\n\tdma_atomic_pool_debugfs_init();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gen_pool *atomic_pool_dma",
      "static struct gen_pool *atomic_pool_dma32",
      "static struct gen_pool *atomic_pool_kernel",
      "static size_t atomic_pool_size;",
      "static struct work_struct atomic_pool_work;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_atomic_pool_debugfs_init",
          "args": [],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "dma_atomic_pool_debugfs_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "36-44",
          "snippet": "static void __init dma_atomic_pool_debugfs_init(void)\n{\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(\"dma_pools\", NULL);\n\tdebugfs_create_ulong(\"pool_size_dma\", 0400, root, &pool_size_dma);\n\tdebugfs_create_ulong(\"pool_size_dma32\", 0400, root, &pool_size_dma32);\n\tdebugfs_create_ulong(\"pool_size_kernel\", 0400, root, &pool_size_kernel);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long pool_size_dma;",
            "static unsigned long pool_size_dma32;",
            "static unsigned long pool_size_kernel;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic unsigned long pool_size_dma;\nstatic unsigned long pool_size_dma32;\nstatic unsigned long pool_size_kernel;\nstatic __init struct;\n\nstatic void __init dma_atomic_pool_debugfs_init(void)\n{\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(\"dma_pools\", NULL);\n\tdebugfs_create_ulong(\"pool_size_dma\", 0400, root, &pool_size_dma);\n\tdebugfs_create_ulong(\"pool_size_dma32\", 0400, root, &pool_size_dma32);\n\tdebugfs_create_ulong(\"pool_size_kernel\", 0400, root, &pool_size_kernel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dma_atomic_pool_init",
          "args": [
            "atomic_pool_size",
            "GFP_KERNEL | GFP_DMA32"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_atomic_pool_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "162-185",
          "snippet": "gen_pool *__dma_atomic_pool_init(size_t pool_size,\n\t\t\t\t\t\t      gfp_t gfp)\n{\n\tstruct gen_pool *pool;\n\tint ret;\n\n\tpool = gen_pool_create(PAGE_SHIFT, NUMA_NO_NODE);\n\tif (!pool)\n\t\treturn NULL;\n\n\tgen_pool_set_algo(pool, gen_pool_first_fit_order_align, NULL);\n\n\tret = atomic_pool_expand(pool, pool_size, gfp);\n\tif (ret) {\n\t\tgen_pool_destroy(pool);\n\t\tpr_err(\"DMA: failed to allocate %zu KiB %pGg pool for atomic allocation\\n\",\n\t\t       pool_size >> 10, &gfp);\n\t\treturn NULL;\n\t}\n\n\tpr_info(\"DMA: preallocated %zu KiB %pGg pool for atomic allocations\\n\",\n\t\tgen_pool_size(pool) >> 10, &gfp);\n\treturn pool;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\ngen_pool *__dma_atomic_pool_init(size_t pool_size,\n\t\t\t\t\t\t      gfp_t gfp)\n{\n\tstruct gen_pool *pool;\n\tint ret;\n\n\tpool = gen_pool_create(PAGE_SHIFT, NUMA_NO_NODE);\n\tif (!pool)\n\t\treturn NULL;\n\n\tgen_pool_set_algo(pool, gen_pool_first_fit_order_align, NULL);\n\n\tret = atomic_pool_expand(pool, pool_size, gfp);\n\tif (ret) {\n\t\tgen_pool_destroy(pool);\n\t\tpr_err(\"DMA: failed to allocate %zu KiB %pGg pool for atomic allocation\\n\",\n\t\t       pool_size >> 10, &gfp);\n\t\treturn NULL;\n\t}\n\n\tpr_info(\"DMA: preallocated %zu KiB %pGg pool for atomic allocations\\n\",\n\t\tgen_pool_size(pool) >> 10, &gfp);\n\treturn pool;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA32"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_managed_dma",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&atomic_pool_work",
            "atomic_pool_work_fn"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "pages << PAGE_SHIFT",
            "SZ_128K"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1831-1865",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "pages",
            "MAX_ORDER_NR_PAGES"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "totalram_pages",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic struct gen_pool *atomic_pool_dma;\nstatic struct gen_pool *atomic_pool_dma32;\nstatic struct gen_pool *atomic_pool_kernel;\nstatic size_t atomic_pool_size;\nstatic struct work_struct atomic_pool_work;\n\nstatic int __init dma_atomic_pool_init(void)\n{\n\tint ret = 0;\n\n\t/*\n\t * If coherent_pool was not used on the command line, default the pool\n\t * sizes to 128KB per 1GB of memory, min 128KB, max MAX_ORDER-1.\n\t */\n\tif (!atomic_pool_size) {\n\t\tunsigned long pages = totalram_pages() / (SZ_1G / SZ_128K);\n\t\tpages = min_t(unsigned long, pages, MAX_ORDER_NR_PAGES);\n\t\tatomic_pool_size = max_t(size_t, pages << PAGE_SHIFT, SZ_128K);\n\t}\n\tINIT_WORK(&atomic_pool_work, atomic_pool_work_fn);\n\n\tatomic_pool_kernel = __dma_atomic_pool_init(atomic_pool_size,\n\t\t\t\t\t\t    GFP_KERNEL);\n\tif (!atomic_pool_kernel)\n\t\tret = -ENOMEM;\n\tif (has_managed_dma()) {\n\t\tatomic_pool_dma = __dma_atomic_pool_init(atomic_pool_size,\n\t\t\t\t\t\tGFP_KERNEL | GFP_DMA);\n\t\tif (!atomic_pool_dma)\n\t\t\tret = -ENOMEM;\n\t}\n\tif (IS_ENABLED(CONFIG_ZONE_DMA32)) {\n\t\tatomic_pool_dma32 = __dma_atomic_pool_init(atomic_pool_size,\n\t\t\t\t\t\tGFP_KERNEL | GFP_DMA32);\n\t\tif (!atomic_pool_dma32)\n\t\t\tret = -ENOMEM;\n\t}\n\n\tdma_atomic_pool_debugfs_init();\n\treturn ret;\n}"
  },
  {
    "function_name": "__dma_atomic_pool_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "162-185",
    "snippet": "gen_pool *__dma_atomic_pool_init(size_t pool_size,\n\t\t\t\t\t\t      gfp_t gfp)\n{\n\tstruct gen_pool *pool;\n\tint ret;\n\n\tpool = gen_pool_create(PAGE_SHIFT, NUMA_NO_NODE);\n\tif (!pool)\n\t\treturn NULL;\n\n\tgen_pool_set_algo(pool, gen_pool_first_fit_order_align, NULL);\n\n\tret = atomic_pool_expand(pool, pool_size, gfp);\n\tif (ret) {\n\t\tgen_pool_destroy(pool);\n\t\tpr_err(\"DMA: failed to allocate %zu KiB %pGg pool for atomic allocation\\n\",\n\t\t       pool_size >> 10, &gfp);\n\t\treturn NULL;\n\t}\n\n\tpr_info(\"DMA: preallocated %zu KiB %pGg pool for atomic allocations\\n\",\n\t\tgen_pool_size(pool) >> 10, &gfp);\n\treturn pool;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"DMA: preallocated %zu KiB %pGg pool for atomic allocations\\n\"",
            "gen_pool_size(pool) >> 10",
            "&gfp"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_pool_size",
          "args": [
            "pool"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"DMA: failed to allocate %zu KiB %pGg pool for atomic allocation\\n\"",
            "pool_size >> 10",
            "&gfp"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_pool_destroy",
          "args": [
            "pool"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_pool_expand",
          "args": [
            "pool",
            "pool_size",
            "gfp"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_pool_expand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "79-143",
          "snippet": "static int atomic_pool_expand(struct gen_pool *pool, size_t pool_size,\n\t\t\t      gfp_t gfp)\n{\n\tunsigned int order;\n\tstruct page *page = NULL;\n\tvoid *addr;\n\tint ret = -ENOMEM;\n\n\t/* Cannot allocate larger than MAX_ORDER-1 */\n\torder = min(get_order(pool_size), MAX_ORDER-1);\n\n\tdo {\n\t\tpool_size = 1 << (PAGE_SHIFT + order);\n\t\tif (cma_in_zone(gfp))\n\t\t\tpage = dma_alloc_from_contiguous(NULL, 1 << order,\n\t\t\t\t\t\t\t order, false);\n\t\tif (!page)\n\t\t\tpage = alloc_pages(gfp, order);\n\t} while (!page && order-- > 0);\n\tif (!page)\n\t\tgoto out;\n\n\tarch_dma_prep_coherent(page, pool_size);\n\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\taddr = dma_common_contiguous_remap(page, pool_size,\n\t\t\t\t\t   pgprot_dmacoherent(PAGE_KERNEL),\n\t\t\t\t\t   __builtin_return_address(0));\n\tif (!addr)\n\t\tgoto free_page;\n#else\n\taddr = page_to_virt(page);\n#endif\n\t/*\n\t * Memory in the atomic DMA pools must be unencrypted, the pools do not\n\t * shrink so no re-encryption occurs in dma_direct_free().\n\t */\n\tret = set_memory_decrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (ret)\n\t\tgoto remove_mapping;\n\tret = gen_pool_add_virt(pool, (unsigned long)addr, page_to_phys(page),\n\t\t\t\tpool_size, NUMA_NO_NODE);\n\tif (ret)\n\t\tgoto encrypt_mapping;\n\n\tdma_atomic_pool_size_add(gfp, pool_size);\n\treturn 0;\n\nencrypt_mapping:\n\tret = set_memory_encrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (WARN_ON_ONCE(ret)) {\n\t\t/* Decrypt succeeded but encrypt failed, purposely leak */\n\t\tgoto out;\n\t}\nremove_mapping:\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\tdma_common_free_remap(addr, pool_size);\n#endif\nfree_page: __maybe_unused\n\t__free_pages(page, order);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\nstatic int atomic_pool_expand(struct gen_pool *pool, size_t pool_size,\n\t\t\t      gfp_t gfp)\n{\n\tunsigned int order;\n\tstruct page *page = NULL;\n\tvoid *addr;\n\tint ret = -ENOMEM;\n\n\t/* Cannot allocate larger than MAX_ORDER-1 */\n\torder = min(get_order(pool_size), MAX_ORDER-1);\n\n\tdo {\n\t\tpool_size = 1 << (PAGE_SHIFT + order);\n\t\tif (cma_in_zone(gfp))\n\t\t\tpage = dma_alloc_from_contiguous(NULL, 1 << order,\n\t\t\t\t\t\t\t order, false);\n\t\tif (!page)\n\t\t\tpage = alloc_pages(gfp, order);\n\t} while (!page && order-- > 0);\n\tif (!page)\n\t\tgoto out;\n\n\tarch_dma_prep_coherent(page, pool_size);\n\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\taddr = dma_common_contiguous_remap(page, pool_size,\n\t\t\t\t\t   pgprot_dmacoherent(PAGE_KERNEL),\n\t\t\t\t\t   __builtin_return_address(0));\n\tif (!addr)\n\t\tgoto free_page;\n#else\n\taddr = page_to_virt(page);\n#endif\n\t/*\n\t * Memory in the atomic DMA pools must be unencrypted, the pools do not\n\t * shrink so no re-encryption occurs in dma_direct_free().\n\t */\n\tret = set_memory_decrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (ret)\n\t\tgoto remove_mapping;\n\tret = gen_pool_add_virt(pool, (unsigned long)addr, page_to_phys(page),\n\t\t\t\tpool_size, NUMA_NO_NODE);\n\tif (ret)\n\t\tgoto encrypt_mapping;\n\n\tdma_atomic_pool_size_add(gfp, pool_size);\n\treturn 0;\n\nencrypt_mapping:\n\tret = set_memory_encrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (WARN_ON_ONCE(ret)) {\n\t\t/* Decrypt succeeded but encrypt failed, purposely leak */\n\t\tgoto out;\n\t}\nremove_mapping:\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\tdma_common_free_remap(addr, pool_size);\n#endif\nfree_page: __maybe_unused\n\t__free_pages(page, order);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_pool_set_algo",
          "args": [
            "pool",
            "gen_pool_first_fit_order_align",
            "NULL"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_pool_create",
          "args": [
            "PAGE_SHIFT",
            "NUMA_NO_NODE"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\ngen_pool *__dma_atomic_pool_init(size_t pool_size,\n\t\t\t\t\t\t      gfp_t gfp)\n{\n\tstruct gen_pool *pool;\n\tint ret;\n\n\tpool = gen_pool_create(PAGE_SHIFT, NUMA_NO_NODE);\n\tif (!pool)\n\t\treturn NULL;\n\n\tgen_pool_set_algo(pool, gen_pool_first_fit_order_align, NULL);\n\n\tret = atomic_pool_expand(pool, pool_size, gfp);\n\tif (ret) {\n\t\tgen_pool_destroy(pool);\n\t\tpr_err(\"DMA: failed to allocate %zu KiB %pGg pool for atomic allocation\\n\",\n\t\t       pool_size >> 10, &gfp);\n\t\treturn NULL;\n\t}\n\n\tpr_info(\"DMA: preallocated %zu KiB %pGg pool for atomic allocations\\n\",\n\t\tgen_pool_size(pool) >> 10, &gfp);\n\treturn pool;\n}"
  },
  {
    "function_name": "atomic_pool_work_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "151-160",
    "snippet": "static void atomic_pool_work_fn(struct work_struct *work)\n{\n\tif (IS_ENABLED(CONFIG_ZONE_DMA))\n\t\tatomic_pool_resize(atomic_pool_dma,\n\t\t\t\t   GFP_KERNEL | GFP_DMA);\n\tif (IS_ENABLED(CONFIG_ZONE_DMA32))\n\t\tatomic_pool_resize(atomic_pool_dma32,\n\t\t\t\t   GFP_KERNEL | GFP_DMA32);\n\tatomic_pool_resize(atomic_pool_kernel, GFP_KERNEL);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gen_pool *atomic_pool_dma",
      "static struct gen_pool *atomic_pool_dma32",
      "static struct gen_pool *atomic_pool_kernel",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_pool_resize",
          "args": [
            "atomic_pool_kernel",
            "GFP_KERNEL"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_pool_resize",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "145-149",
          "snippet": "static void atomic_pool_resize(struct gen_pool *pool, gfp_t gfp)\n{\n\tif (pool && gen_pool_avail(pool) < atomic_pool_size)\n\t\tatomic_pool_expand(pool, gen_pool_size(pool), gfp);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t atomic_pool_size;",
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic size_t atomic_pool_size;\nstatic __init struct;\n\nstatic void atomic_pool_resize(struct gen_pool *pool, gfp_t gfp)\n{\n\tif (pool && gen_pool_avail(pool) < atomic_pool_size)\n\t\tatomic_pool_expand(pool, gen_pool_size(pool), gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA32"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic struct gen_pool *atomic_pool_dma;\nstatic struct gen_pool *atomic_pool_dma32;\nstatic struct gen_pool *atomic_pool_kernel;\nstatic __init struct;\n\nstatic void atomic_pool_work_fn(struct work_struct *work)\n{\n\tif (IS_ENABLED(CONFIG_ZONE_DMA))\n\t\tatomic_pool_resize(atomic_pool_dma,\n\t\t\t\t   GFP_KERNEL | GFP_DMA);\n\tif (IS_ENABLED(CONFIG_ZONE_DMA32))\n\t\tatomic_pool_resize(atomic_pool_dma32,\n\t\t\t\t   GFP_KERNEL | GFP_DMA32);\n\tatomic_pool_resize(atomic_pool_kernel, GFP_KERNEL);\n}"
  },
  {
    "function_name": "atomic_pool_resize",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "145-149",
    "snippet": "static void atomic_pool_resize(struct gen_pool *pool, gfp_t gfp)\n{\n\tif (pool && gen_pool_avail(pool) < atomic_pool_size)\n\t\tatomic_pool_expand(pool, gen_pool_size(pool), gfp);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t atomic_pool_size;",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_pool_expand",
          "args": [
            "pool",
            "gen_pool_size(pool)",
            "gfp"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_pool_expand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "79-143",
          "snippet": "static int atomic_pool_expand(struct gen_pool *pool, size_t pool_size,\n\t\t\t      gfp_t gfp)\n{\n\tunsigned int order;\n\tstruct page *page = NULL;\n\tvoid *addr;\n\tint ret = -ENOMEM;\n\n\t/* Cannot allocate larger than MAX_ORDER-1 */\n\torder = min(get_order(pool_size), MAX_ORDER-1);\n\n\tdo {\n\t\tpool_size = 1 << (PAGE_SHIFT + order);\n\t\tif (cma_in_zone(gfp))\n\t\t\tpage = dma_alloc_from_contiguous(NULL, 1 << order,\n\t\t\t\t\t\t\t order, false);\n\t\tif (!page)\n\t\t\tpage = alloc_pages(gfp, order);\n\t} while (!page && order-- > 0);\n\tif (!page)\n\t\tgoto out;\n\n\tarch_dma_prep_coherent(page, pool_size);\n\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\taddr = dma_common_contiguous_remap(page, pool_size,\n\t\t\t\t\t   pgprot_dmacoherent(PAGE_KERNEL),\n\t\t\t\t\t   __builtin_return_address(0));\n\tif (!addr)\n\t\tgoto free_page;\n#else\n\taddr = page_to_virt(page);\n#endif\n\t/*\n\t * Memory in the atomic DMA pools must be unencrypted, the pools do not\n\t * shrink so no re-encryption occurs in dma_direct_free().\n\t */\n\tret = set_memory_decrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (ret)\n\t\tgoto remove_mapping;\n\tret = gen_pool_add_virt(pool, (unsigned long)addr, page_to_phys(page),\n\t\t\t\tpool_size, NUMA_NO_NODE);\n\tif (ret)\n\t\tgoto encrypt_mapping;\n\n\tdma_atomic_pool_size_add(gfp, pool_size);\n\treturn 0;\n\nencrypt_mapping:\n\tret = set_memory_encrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (WARN_ON_ONCE(ret)) {\n\t\t/* Decrypt succeeded but encrypt failed, purposely leak */\n\t\tgoto out;\n\t}\nremove_mapping:\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\tdma_common_free_remap(addr, pool_size);\n#endif\nfree_page: __maybe_unused\n\t__free_pages(page, order);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\nstatic int atomic_pool_expand(struct gen_pool *pool, size_t pool_size,\n\t\t\t      gfp_t gfp)\n{\n\tunsigned int order;\n\tstruct page *page = NULL;\n\tvoid *addr;\n\tint ret = -ENOMEM;\n\n\t/* Cannot allocate larger than MAX_ORDER-1 */\n\torder = min(get_order(pool_size), MAX_ORDER-1);\n\n\tdo {\n\t\tpool_size = 1 << (PAGE_SHIFT + order);\n\t\tif (cma_in_zone(gfp))\n\t\t\tpage = dma_alloc_from_contiguous(NULL, 1 << order,\n\t\t\t\t\t\t\t order, false);\n\t\tif (!page)\n\t\t\tpage = alloc_pages(gfp, order);\n\t} while (!page && order-- > 0);\n\tif (!page)\n\t\tgoto out;\n\n\tarch_dma_prep_coherent(page, pool_size);\n\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\taddr = dma_common_contiguous_remap(page, pool_size,\n\t\t\t\t\t   pgprot_dmacoherent(PAGE_KERNEL),\n\t\t\t\t\t   __builtin_return_address(0));\n\tif (!addr)\n\t\tgoto free_page;\n#else\n\taddr = page_to_virt(page);\n#endif\n\t/*\n\t * Memory in the atomic DMA pools must be unencrypted, the pools do not\n\t * shrink so no re-encryption occurs in dma_direct_free().\n\t */\n\tret = set_memory_decrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (ret)\n\t\tgoto remove_mapping;\n\tret = gen_pool_add_virt(pool, (unsigned long)addr, page_to_phys(page),\n\t\t\t\tpool_size, NUMA_NO_NODE);\n\tif (ret)\n\t\tgoto encrypt_mapping;\n\n\tdma_atomic_pool_size_add(gfp, pool_size);\n\treturn 0;\n\nencrypt_mapping:\n\tret = set_memory_encrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (WARN_ON_ONCE(ret)) {\n\t\t/* Decrypt succeeded but encrypt failed, purposely leak */\n\t\tgoto out;\n\t}\nremove_mapping:\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\tdma_common_free_remap(addr, pool_size);\n#endif\nfree_page: __maybe_unused\n\t__free_pages(page, order);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_pool_size",
          "args": [
            "pool"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_pool_avail",
          "args": [
            "pool"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic size_t atomic_pool_size;\nstatic __init struct;\n\nstatic void atomic_pool_resize(struct gen_pool *pool, gfp_t gfp)\n{\n\tif (pool && gen_pool_avail(pool) < atomic_pool_size)\n\t\tatomic_pool_expand(pool, gen_pool_size(pool), gfp);\n}"
  },
  {
    "function_name": "atomic_pool_expand",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "79-143",
    "snippet": "static int atomic_pool_expand(struct gen_pool *pool, size_t pool_size,\n\t\t\t      gfp_t gfp)\n{\n\tunsigned int order;\n\tstruct page *page = NULL;\n\tvoid *addr;\n\tint ret = -ENOMEM;\n\n\t/* Cannot allocate larger than MAX_ORDER-1 */\n\torder = min(get_order(pool_size), MAX_ORDER-1);\n\n\tdo {\n\t\tpool_size = 1 << (PAGE_SHIFT + order);\n\t\tif (cma_in_zone(gfp))\n\t\t\tpage = dma_alloc_from_contiguous(NULL, 1 << order,\n\t\t\t\t\t\t\t order, false);\n\t\tif (!page)\n\t\t\tpage = alloc_pages(gfp, order);\n\t} while (!page && order-- > 0);\n\tif (!page)\n\t\tgoto out;\n\n\tarch_dma_prep_coherent(page, pool_size);\n\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\taddr = dma_common_contiguous_remap(page, pool_size,\n\t\t\t\t\t   pgprot_dmacoherent(PAGE_KERNEL),\n\t\t\t\t\t   __builtin_return_address(0));\n\tif (!addr)\n\t\tgoto free_page;\n#else\n\taddr = page_to_virt(page);\n#endif\n\t/*\n\t * Memory in the atomic DMA pools must be unencrypted, the pools do not\n\t * shrink so no re-encryption occurs in dma_direct_free().\n\t */\n\tret = set_memory_decrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (ret)\n\t\tgoto remove_mapping;\n\tret = gen_pool_add_virt(pool, (unsigned long)addr, page_to_phys(page),\n\t\t\t\tpool_size, NUMA_NO_NODE);\n\tif (ret)\n\t\tgoto encrypt_mapping;\n\n\tdma_atomic_pool_size_add(gfp, pool_size);\n\treturn 0;\n\nencrypt_mapping:\n\tret = set_memory_encrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (WARN_ON_ONCE(ret)) {\n\t\t/* Decrypt succeeded but encrypt failed, purposely leak */\n\t\tgoto out;\n\t}\nremove_mapping:\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\tdma_common_free_remap(addr, pool_size);\n#endif\nfree_page: __maybe_unused\n\t__free_pages(page, order);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_encrypted",
          "args": [
            "(unsigned long)page_to_virt(page)",
            "1 << order"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_virt",
          "args": [
            "page"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_atomic_pool_size_add",
          "args": [
            "gfp",
            "pool_size"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "dma_atomic_pool_size_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "46-54",
          "snippet": "static void dma_atomic_pool_size_add(gfp_t gfp, size_t size)\n{\n\tif (gfp & __GFP_DMA)\n\t\tpool_size_dma += size;\n\telse if (gfp & __GFP_DMA32)\n\t\tpool_size_dma32 += size;\n\telse\n\t\tpool_size_kernel += size;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long pool_size_dma;",
            "static unsigned long pool_size_dma32;",
            "static unsigned long pool_size_kernel;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic unsigned long pool_size_dma;\nstatic unsigned long pool_size_dma32;\nstatic unsigned long pool_size_kernel;\n\nstatic void dma_atomic_pool_size_add(gfp_t gfp, size_t size)\n{\n\tif (gfp & __GFP_DMA)\n\t\tpool_size_dma += size;\n\telse if (gfp & __GFP_DMA32)\n\t\tpool_size_dma32 += size;\n\telse\n\t\tpool_size_kernel += size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_pool_add_virt",
          "args": [
            "pool",
            "(unsigned long)addr",
            "page_to_phys(page)",
            "pool_size",
            "NUMA_NO_NODE"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_memory_decrypted",
          "args": [
            "(unsigned long)page_to_virt(page)",
            "1 << order"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_virt",
          "args": [
            "page"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_virt",
          "args": [
            "page"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_common_contiguous_remap",
          "args": [
            "page",
            "pool_size",
            "pgprot_dmacoherent(PAGE_KERNEL)",
            "__builtin_return_address(0)"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "dma_common_contiguous_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/remap.c",
          "lines": "38-55",
          "snippet": "void *dma_common_contiguous_remap(struct page *page, size_t size,\n\t\t\tpgprot_t prot, const void *caller)\n{\n\tint count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tstruct page **pages;\n\tvoid *vaddr;\n\tint i;\n\n\tpages = kmalloc_array(count, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn NULL;\n\tfor (i = 0; i < count; i++)\n\t\tpages[i] = nth_page(page, i);\n\tvaddr = vmap(pages, count, VM_DMA_COHERENT, prot);\n\tkfree(pages);\n\n\treturn vaddr;\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/dma-map-ops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/dma-map-ops.h>\n\nvoid *dma_common_contiguous_remap(struct page *page, size_t size,\n\t\t\tpgprot_t prot, const void *caller)\n{\n\tint count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tstruct page **pages;\n\tvoid *vaddr;\n\tint i;\n\n\tpages = kmalloc_array(count, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn NULL;\n\tfor (i = 0; i < count; i++)\n\t\tpages[i] = nth_page(page, i);\n\tvaddr = vmap(pages, count, VM_DMA_COHERENT, prot);\n\tkfree(pages);\n\n\treturn vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_dmacoherent",
          "args": [
            "PAGE_KERNEL"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_dma_prep_coherent",
          "args": [
            "page",
            "pool_size"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "gfp",
            "order"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "300-325",
          "snippet": "static struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *pages;\n\n\tif (fatal_signal_pending(current))\n\t\treturn NULL;\n\tpages = alloc_pages(gfp_mask & ~__GFP_ZERO, order);\n\tif (pages) {\n\t\tunsigned int count, i;\n\n\t\tpages->mapping = NULL;\n\t\tset_page_private(pages, order);\n\t\tcount = 1 << order;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tSetPageReserved(pages + i);\n\n\t\tarch_kexec_post_alloc_pages(page_address(pages), count,\n\t\t\t\t\t    gfp_mask);\n\n\t\tif (gfp_mask & __GFP_ZERO)\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tclear_highpage(pages + i);\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *pages;\n\n\tif (fatal_signal_pending(current))\n\t\treturn NULL;\n\tpages = alloc_pages(gfp_mask & ~__GFP_ZERO, order);\n\tif (pages) {\n\t\tunsigned int count, i;\n\n\t\tpages->mapping = NULL;\n\t\tset_page_private(pages, order);\n\t\tcount = 1 << order;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tSetPageReserved(pages + i);\n\n\t\tarch_kexec_post_alloc_pages(page_address(pages), count,\n\t\t\t\t\t    gfp_mask);\n\n\t\tif (gfp_mask & __GFP_ZERO)\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tclear_highpage(pages + i);\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_alloc_from_contiguous",
          "args": [
            "NULL",
            "1 << order",
            "order",
            "false"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_from_contiguous",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/contiguous.c",
          "lines": "257-264",
          "snippet": "struct page *dma_alloc_from_contiguous(struct device *dev, size_t count,\n\t\t\t\t       unsigned int align, bool no_warn)\n{\n\tif (align > CONFIG_CMA_ALIGNMENT)\n\t\talign = CONFIG_CMA_ALIGNMENT;\n\n\treturn cma_alloc(dev_get_cma_area(dev), count, align, no_warn);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-map-ops.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/page.h>\n\nstruct page *dma_alloc_from_contiguous(struct device *dev, size_t count,\n\t\t\t\t       unsigned int align, bool no_warn)\n{\n\tif (align > CONFIG_CMA_ALIGNMENT)\n\t\talign = CONFIG_CMA_ALIGNMENT;\n\n\treturn cma_alloc(dev_get_cma_area(dev), count, align, no_warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cma_in_zone",
          "args": [
            "gfp"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "cma_in_zone",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
          "lines": "56-77",
          "snippet": "static bool cma_in_zone(gfp_t gfp)\n{\n\tunsigned long size;\n\tphys_addr_t end;\n\tstruct cma *cma;\n\n\tcma = dev_get_cma_area(NULL);\n\tif (!cma)\n\t\treturn false;\n\n\tsize = cma_get_size(cma);\n\tif (!size)\n\t\treturn false;\n\n\t/* CMA can't cross zone boundaries, see cma_activate_area() */\n\tend = cma_get_base(cma) + size - 1;\n\tif (IS_ENABLED(CONFIG_ZONE_DMA) && (gfp & GFP_DMA))\n\t\treturn end <= DMA_BIT_MASK(zone_dma_bits);\n\tif (IS_ENABLED(CONFIG_ZONE_DMA32) && (gfp & GFP_DMA32))\n\t\treturn end <= DMA_BIT_MASK(32);\n\treturn true;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/genalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cma.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\nstatic bool cma_in_zone(gfp_t gfp)\n{\n\tunsigned long size;\n\tphys_addr_t end;\n\tstruct cma *cma;\n\n\tcma = dev_get_cma_area(NULL);\n\tif (!cma)\n\t\treturn false;\n\n\tsize = cma_get_size(cma);\n\tif (!size)\n\t\treturn false;\n\n\t/* CMA can't cross zone boundaries, see cma_activate_area() */\n\tend = cma_get_base(cma) + size - 1;\n\tif (IS_ENABLED(CONFIG_ZONE_DMA) && (gfp & GFP_DMA))\n\t\treturn end <= DMA_BIT_MASK(zone_dma_bits);\n\tif (IS_ENABLED(CONFIG_ZONE_DMA32) && (gfp & GFP_DMA32))\n\t\treturn end <= DMA_BIT_MASK(32);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "get_order(pool_size)",
            "MAX_ORDER-1"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "pool_size"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\nstatic int atomic_pool_expand(struct gen_pool *pool, size_t pool_size,\n\t\t\t      gfp_t gfp)\n{\n\tunsigned int order;\n\tstruct page *page = NULL;\n\tvoid *addr;\n\tint ret = -ENOMEM;\n\n\t/* Cannot allocate larger than MAX_ORDER-1 */\n\torder = min(get_order(pool_size), MAX_ORDER-1);\n\n\tdo {\n\t\tpool_size = 1 << (PAGE_SHIFT + order);\n\t\tif (cma_in_zone(gfp))\n\t\t\tpage = dma_alloc_from_contiguous(NULL, 1 << order,\n\t\t\t\t\t\t\t order, false);\n\t\tif (!page)\n\t\t\tpage = alloc_pages(gfp, order);\n\t} while (!page && order-- > 0);\n\tif (!page)\n\t\tgoto out;\n\n\tarch_dma_prep_coherent(page, pool_size);\n\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\taddr = dma_common_contiguous_remap(page, pool_size,\n\t\t\t\t\t   pgprot_dmacoherent(PAGE_KERNEL),\n\t\t\t\t\t   __builtin_return_address(0));\n\tif (!addr)\n\t\tgoto free_page;\n#else\n\taddr = page_to_virt(page);\n#endif\n\t/*\n\t * Memory in the atomic DMA pools must be unencrypted, the pools do not\n\t * shrink so no re-encryption occurs in dma_direct_free().\n\t */\n\tret = set_memory_decrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (ret)\n\t\tgoto remove_mapping;\n\tret = gen_pool_add_virt(pool, (unsigned long)addr, page_to_phys(page),\n\t\t\t\tpool_size, NUMA_NO_NODE);\n\tif (ret)\n\t\tgoto encrypt_mapping;\n\n\tdma_atomic_pool_size_add(gfp, pool_size);\n\treturn 0;\n\nencrypt_mapping:\n\tret = set_memory_encrypted((unsigned long)page_to_virt(page),\n\t\t\t\t   1 << order);\n\tif (WARN_ON_ONCE(ret)) {\n\t\t/* Decrypt succeeded but encrypt failed, purposely leak */\n\t\tgoto out;\n\t}\nremove_mapping:\n#ifdef CONFIG_DMA_DIRECT_REMAP\n\tdma_common_free_remap(addr, pool_size);\n#endif\nfree_page: __maybe_unused\n\t__free_pages(page, order);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "cma_in_zone",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "56-77",
    "snippet": "static bool cma_in_zone(gfp_t gfp)\n{\n\tunsigned long size;\n\tphys_addr_t end;\n\tstruct cma *cma;\n\n\tcma = dev_get_cma_area(NULL);\n\tif (!cma)\n\t\treturn false;\n\n\tsize = cma_get_size(cma);\n\tif (!size)\n\t\treturn false;\n\n\t/* CMA can't cross zone boundaries, see cma_activate_area() */\n\tend = cma_get_base(cma) + size - 1;\n\tif (IS_ENABLED(CONFIG_ZONE_DMA) && (gfp & GFP_DMA))\n\t\treturn end <= DMA_BIT_MASK(zone_dma_bits);\n\tif (IS_ENABLED(CONFIG_ZONE_DMA32) && (gfp & GFP_DMA32))\n\t\treturn end <= DMA_BIT_MASK(32);\n\treturn true;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "32"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA32"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMA_BIT_MASK",
          "args": [
            "zone_dma_bits"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ZONE_DMA"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_get_base",
          "args": [
            "cma"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_get_size",
          "args": [
            "cma"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_get_cma_area",
          "args": [
            "NULL"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic __init struct;\n\nstatic bool cma_in_zone(gfp_t gfp)\n{\n\tunsigned long size;\n\tphys_addr_t end;\n\tstruct cma *cma;\n\n\tcma = dev_get_cma_area(NULL);\n\tif (!cma)\n\t\treturn false;\n\n\tsize = cma_get_size(cma);\n\tif (!size)\n\t\treturn false;\n\n\t/* CMA can't cross zone boundaries, see cma_activate_area() */\n\tend = cma_get_base(cma) + size - 1;\n\tif (IS_ENABLED(CONFIG_ZONE_DMA) && (gfp & GFP_DMA))\n\t\treturn end <= DMA_BIT_MASK(zone_dma_bits);\n\tif (IS_ENABLED(CONFIG_ZONE_DMA32) && (gfp & GFP_DMA32))\n\t\treturn end <= DMA_BIT_MASK(32);\n\treturn true;\n}"
  },
  {
    "function_name": "dma_atomic_pool_size_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "46-54",
    "snippet": "static void dma_atomic_pool_size_add(gfp_t gfp, size_t size)\n{\n\tif (gfp & __GFP_DMA)\n\t\tpool_size_dma += size;\n\telse if (gfp & __GFP_DMA32)\n\t\tpool_size_dma32 += size;\n\telse\n\t\tpool_size_kernel += size;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long pool_size_dma;",
      "static unsigned long pool_size_dma32;",
      "static unsigned long pool_size_kernel;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic unsigned long pool_size_dma;\nstatic unsigned long pool_size_dma32;\nstatic unsigned long pool_size_kernel;\n\nstatic void dma_atomic_pool_size_add(gfp_t gfp, size_t size)\n{\n\tif (gfp & __GFP_DMA)\n\t\tpool_size_dma += size;\n\telse if (gfp & __GFP_DMA32)\n\t\tpool_size_dma32 += size;\n\telse\n\t\tpool_size_kernel += size;\n}"
  },
  {
    "function_name": "dma_atomic_pool_debugfs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "36-44",
    "snippet": "static void __init dma_atomic_pool_debugfs_init(void)\n{\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(\"dma_pools\", NULL);\n\tdebugfs_create_ulong(\"pool_size_dma\", 0400, root, &pool_size_dma);\n\tdebugfs_create_ulong(\"pool_size_dma32\", 0400, root, &pool_size_dma32);\n\tdebugfs_create_ulong(\"pool_size_kernel\", 0400, root, &pool_size_kernel);\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long pool_size_dma;",
      "static unsigned long pool_size_dma32;",
      "static unsigned long pool_size_kernel;",
      "static __init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_ulong",
          "args": [
            "\"pool_size_kernel\"",
            "0400",
            "root",
            "&pool_size_kernel"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_ulong",
          "args": [
            "\"pool_size_dma32\"",
            "0400",
            "root",
            "&pool_size_dma32"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_ulong",
          "args": [
            "\"pool_size_dma\"",
            "0400",
            "root",
            "&pool_size_dma"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"dma_pools\"",
            "NULL"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic unsigned long pool_size_dma;\nstatic unsigned long pool_size_dma32;\nstatic unsigned long pool_size_kernel;\nstatic __init struct;\n\nstatic void __init dma_atomic_pool_debugfs_init(void)\n{\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(\"dma_pools\", NULL);\n\tdebugfs_create_ulong(\"pool_size_dma\", 0400, root, &pool_size_dma);\n\tdebugfs_create_ulong(\"pool_size_dma32\", 0400, root, &pool_size_dma32);\n\tdebugfs_create_ulong(\"pool_size_kernel\", 0400, root, &pool_size_kernel);\n}"
  },
  {
    "function_name": "early_coherent_pool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/pool.c",
    "lines": "29-33",
    "snippet": "static int __init early_coherent_pool(char *p)\n{\n\tatomic_pool_size = memparse(p, &p);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/set_memory.h>",
      "#include <linux/genalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/dma-direct.h>",
      "#include <linux/dma-map-ops.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cma.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static size_t atomic_pool_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "p",
            "&p"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/genalloc.h>\n#include <linux/init.h>\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/debugfs.h>\n#include <linux/cma.h>\n\nstatic size_t atomic_pool_size;\n\nstatic int __init early_coherent_pool(char *p)\n{\n\tatomic_pool_size = memparse(p, &p);\n\treturn 0;\n}"
  }
]