[
  {
    "function_name": "tracing_stop_tgid_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
    "lines": "146-149",
    "snippet": "void tracing_stop_tgid_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_TGID);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RECORD_TGID\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_stop_sched_switch",
          "args": [
            "RECORD_TGID"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_sched_switch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "112-129",
          "snippet": "static void tracing_stop_sched_switch(int ops)\n{\n\tmutex_lock(&sched_register_mutex);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref--;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref--;\n\t\tbreak;\n\t}\n\n\tif (!sched_cmdline_ref && !sched_tgid_ref)\n\t\ttracing_sched_unregister();\n\tmutex_unlock(&sched_register_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2",
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [
            "static int\t\tsched_cmdline_ref;",
            "static int\t\tsched_tgid_ref;",
            "static DEFINE_MUTEX(sched_register_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n#define RECORD_CMDLINE\t1\n\nstatic int\t\tsched_cmdline_ref;\nstatic int\t\tsched_tgid_ref;\nstatic DEFINE_MUTEX(sched_register_mutex);\n\nstatic void tracing_stop_sched_switch(int ops)\n{\n\tmutex_lock(&sched_register_mutex);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref--;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref--;\n\t\tbreak;\n\t}\n\n\tif (!sched_cmdline_ref && !sched_tgid_ref)\n\t\ttracing_sched_unregister();\n\tmutex_unlock(&sched_register_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n\nvoid tracing_stop_tgid_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_TGID);\n}"
  },
  {
    "function_name": "tracing_start_tgid_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
    "lines": "141-144",
    "snippet": "void tracing_start_tgid_record(void)\n{\n\ttracing_start_sched_switch(RECORD_TGID);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RECORD_TGID\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_start_sched_switch",
          "args": [
            "RECORD_TGID"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_sched_switch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "90-110",
          "snippet": "static void tracing_start_sched_switch(int ops)\n{\n\tbool sched_register;\n\n\tmutex_lock(&sched_register_mutex);\n\tsched_register = (!sched_cmdline_ref && !sched_tgid_ref);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref++;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref++;\n\t\tbreak;\n\t}\n\n\tif (sched_register && (sched_cmdline_ref || sched_tgid_ref))\n\t\ttracing_sched_register();\n\tmutex_unlock(&sched_register_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2",
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [
            "static int\t\tsched_cmdline_ref;",
            "static int\t\tsched_tgid_ref;",
            "static DEFINE_MUTEX(sched_register_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n#define RECORD_CMDLINE\t1\n\nstatic int\t\tsched_cmdline_ref;\nstatic int\t\tsched_tgid_ref;\nstatic DEFINE_MUTEX(sched_register_mutex);\n\nstatic void tracing_start_sched_switch(int ops)\n{\n\tbool sched_register;\n\n\tmutex_lock(&sched_register_mutex);\n\tsched_register = (!sched_cmdline_ref && !sched_tgid_ref);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref++;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref++;\n\t\tbreak;\n\t}\n\n\tif (sched_register && (sched_cmdline_ref || sched_tgid_ref))\n\t\ttracing_sched_register();\n\tmutex_unlock(&sched_register_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n\nvoid tracing_start_tgid_record(void)\n{\n\ttracing_start_sched_switch(RECORD_TGID);\n}"
  },
  {
    "function_name": "tracing_stop_cmdline_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
    "lines": "136-139",
    "snippet": "void tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RECORD_CMDLINE\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_stop_sched_switch",
          "args": [
            "RECORD_CMDLINE"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_sched_switch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "112-129",
          "snippet": "static void tracing_stop_sched_switch(int ops)\n{\n\tmutex_lock(&sched_register_mutex);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref--;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref--;\n\t\tbreak;\n\t}\n\n\tif (!sched_cmdline_ref && !sched_tgid_ref)\n\t\ttracing_sched_unregister();\n\tmutex_unlock(&sched_register_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2",
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [
            "static int\t\tsched_cmdline_ref;",
            "static int\t\tsched_tgid_ref;",
            "static DEFINE_MUTEX(sched_register_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n#define RECORD_CMDLINE\t1\n\nstatic int\t\tsched_cmdline_ref;\nstatic int\t\tsched_tgid_ref;\nstatic DEFINE_MUTEX(sched_register_mutex);\n\nstatic void tracing_stop_sched_switch(int ops)\n{\n\tmutex_lock(&sched_register_mutex);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref--;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref--;\n\t\tbreak;\n\t}\n\n\tif (!sched_cmdline_ref && !sched_tgid_ref)\n\t\ttracing_sched_unregister();\n\tmutex_unlock(&sched_register_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}"
  },
  {
    "function_name": "tracing_start_cmdline_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
    "lines": "131-134",
    "snippet": "void tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RECORD_CMDLINE\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_start_sched_switch",
          "args": [
            "RECORD_CMDLINE"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_sched_switch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "90-110",
          "snippet": "static void tracing_start_sched_switch(int ops)\n{\n\tbool sched_register;\n\n\tmutex_lock(&sched_register_mutex);\n\tsched_register = (!sched_cmdline_ref && !sched_tgid_ref);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref++;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref++;\n\t\tbreak;\n\t}\n\n\tif (sched_register && (sched_cmdline_ref || sched_tgid_ref))\n\t\ttracing_sched_register();\n\tmutex_unlock(&sched_register_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2",
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [
            "static int\t\tsched_cmdline_ref;",
            "static int\t\tsched_tgid_ref;",
            "static DEFINE_MUTEX(sched_register_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n#define RECORD_CMDLINE\t1\n\nstatic int\t\tsched_cmdline_ref;\nstatic int\t\tsched_tgid_ref;\nstatic DEFINE_MUTEX(sched_register_mutex);\n\nstatic void tracing_start_sched_switch(int ops)\n{\n\tbool sched_register;\n\n\tmutex_lock(&sched_register_mutex);\n\tsched_register = (!sched_cmdline_ref && !sched_tgid_ref);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref++;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref++;\n\t\tbreak;\n\t}\n\n\tif (sched_register && (sched_cmdline_ref || sched_tgid_ref))\n\t\ttracing_sched_register();\n\tmutex_unlock(&sched_register_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}"
  },
  {
    "function_name": "tracing_stop_sched_switch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
    "lines": "112-129",
    "snippet": "static void tracing_stop_sched_switch(int ops)\n{\n\tmutex_lock(&sched_register_mutex);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref--;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref--;\n\t\tbreak;\n\t}\n\n\tif (!sched_cmdline_ref && !sched_tgid_ref)\n\t\ttracing_sched_unregister();\n\tmutex_unlock(&sched_register_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RECORD_TGID\t2",
      "#define RECORD_CMDLINE\t1"
    ],
    "globals_used": [
      "static int\t\tsched_cmdline_ref;",
      "static int\t\tsched_tgid_ref;",
      "static DEFINE_MUTEX(sched_register_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sched_register_mutex"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_sched_unregister",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_sched_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "83-88",
          "snippet": "static void tracing_sched_unregister(void)\n{\n\tunregister_trace_sched_switch(probe_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_sched_wakeup, NULL);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void tracing_sched_unregister(void)\n{\n\tunregister_trace_sched_switch(probe_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_sched_wakeup, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sched_register_mutex"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n#define RECORD_CMDLINE\t1\n\nstatic int\t\tsched_cmdline_ref;\nstatic int\t\tsched_tgid_ref;\nstatic DEFINE_MUTEX(sched_register_mutex);\n\nstatic void tracing_stop_sched_switch(int ops)\n{\n\tmutex_lock(&sched_register_mutex);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref--;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref--;\n\t\tbreak;\n\t}\n\n\tif (!sched_cmdline_ref && !sched_tgid_ref)\n\t\ttracing_sched_unregister();\n\tmutex_unlock(&sched_register_mutex);\n}"
  },
  {
    "function_name": "tracing_start_sched_switch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
    "lines": "90-110",
    "snippet": "static void tracing_start_sched_switch(int ops)\n{\n\tbool sched_register;\n\n\tmutex_lock(&sched_register_mutex);\n\tsched_register = (!sched_cmdline_ref && !sched_tgid_ref);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref++;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref++;\n\t\tbreak;\n\t}\n\n\tif (sched_register && (sched_cmdline_ref || sched_tgid_ref))\n\t\ttracing_sched_register();\n\tmutex_unlock(&sched_register_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RECORD_TGID\t2",
      "#define RECORD_CMDLINE\t1"
    ],
    "globals_used": [
      "static int\t\tsched_cmdline_ref;",
      "static int\t\tsched_tgid_ref;",
      "static DEFINE_MUTEX(sched_register_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sched_register_mutex"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_sched_register",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_sched_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "50-81",
          "snippet": "static int tracing_sched_register(void)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_sched_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn ret;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\treturn ret;\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_sched_wakeup, NULL);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int tracing_sched_register(void)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_sched_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn ret;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\treturn ret;\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_sched_wakeup, NULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sched_register_mutex"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n#define RECORD_CMDLINE\t1\n\nstatic int\t\tsched_cmdline_ref;\nstatic int\t\tsched_tgid_ref;\nstatic DEFINE_MUTEX(sched_register_mutex);\n\nstatic void tracing_start_sched_switch(int ops)\n{\n\tbool sched_register;\n\n\tmutex_lock(&sched_register_mutex);\n\tsched_register = (!sched_cmdline_ref && !sched_tgid_ref);\n\n\tswitch (ops) {\n\tcase RECORD_CMDLINE:\n\t\tsched_cmdline_ref++;\n\t\tbreak;\n\n\tcase RECORD_TGID:\n\t\tsched_tgid_ref++;\n\t\tbreak;\n\t}\n\n\tif (sched_register && (sched_cmdline_ref || sched_tgid_ref))\n\t\ttracing_sched_register();\n\tmutex_unlock(&sched_register_mutex);\n}"
  },
  {
    "function_name": "tracing_sched_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
    "lines": "83-88",
    "snippet": "static void tracing_sched_unregister(void)\n{\n\tunregister_trace_sched_switch(probe_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_sched_wakeup, NULL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup",
          "args": [
            "probe_sched_wakeup",
            "NULL"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup_new",
          "args": [
            "probe_sched_wakeup",
            "NULL"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "probe_sched_switch",
            "NULL"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void tracing_sched_unregister(void)\n{\n\tunregister_trace_sched_switch(probe_sched_switch, NULL);\n\tunregister_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\n\tunregister_trace_sched_wakeup(probe_sched_wakeup, NULL);\n}"
  },
  {
    "function_name": "tracing_sched_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
    "lines": "50-81",
    "snippet": "static int tracing_sched_register(void)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_sched_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn ret;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\treturn ret;\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_sched_wakeup, NULL);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup",
          "args": [
            "probe_sched_wakeup",
            "NULL"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup_new",
          "args": [
            "probe_sched_wakeup",
            "NULL"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_switch",
          "args": [
            "probe_sched_switch",
            "NULL"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_wakeup_new",
          "args": [
            "probe_sched_wakeup",
            "NULL"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_sched_wakeup",
          "args": [
            "probe_sched_wakeup",
            "NULL"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int tracing_sched_register(void)\n{\n\tint ret;\n\n\tret = register_trace_sched_wakeup(probe_sched_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup\\n\");\n\t\treturn ret;\n\t}\n\n\tret = register_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\n\tif (ret) {\n\t\tpr_info(\"wakeup trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_wakeup_new\\n\");\n\t\tgoto fail_deprobe;\n\t}\n\n\tret = register_trace_sched_switch(probe_sched_switch, NULL);\n\tif (ret) {\n\t\tpr_info(\"sched trace: Couldn't activate tracepoint\"\n\t\t\t\" probe to kernel_sched_switch\\n\");\n\t\tgoto fail_deprobe_wake_new;\n\t}\n\n\treturn ret;\nfail_deprobe_wake_new:\n\tunregister_trace_sched_wakeup_new(probe_sched_wakeup, NULL);\nfail_deprobe:\n\tunregister_trace_sched_wakeup(probe_sched_wakeup, NULL);\n\treturn ret;\n}"
  },
  {
    "function_name": "probe_sched_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
    "lines": "37-48",
    "snippet": "static void\nprobe_sched_wakeup(void *ignore, struct task_struct *wakee)\n{\n\tint flags;\n\n\tflags = (RECORD_TGID * !!sched_tgid_ref) +\n\t\t(RECORD_CMDLINE * !!sched_cmdline_ref);\n\n\tif (!flags)\n\t\treturn;\n\ttracing_record_taskinfo(current, flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RECORD_TGID\t2",
      "#define RECORD_CMDLINE\t1"
    ],
    "globals_used": [
      "static int\t\tsched_cmdline_ref;",
      "static int\t\tsched_tgid_ref;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_record_taskinfo",
          "args": [
            "current",
            "flags"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_record_taskinfo",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2508-2527",
          "snippet": "void tracing_record_taskinfo(struct task_struct *task, int flags)\n{\n\tbool done;\n\n\tif (tracing_record_taskinfo_skip(flags))\n\t\treturn;\n\n\t/*\n\t * Record as much task information as possible. If some fail, continue\n\t * to try to record the others.\n\t */\n\tdone = !(flags & TRACE_RECORD_CMDLINE) || trace_save_cmdline(task);\n\tdone &= !(flags & TRACE_RECORD_TGID) || trace_save_tgid(task);\n\n\t/* If recording any information failed, retry again soon. */\n\tif (!done)\n\t\treturn;\n\n\t__this_cpu_write(trace_taskinfo_save, false);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, trace_taskinfo_save);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic DEFINE_PER_CPU(bool, trace_taskinfo_save);\nstatic __always_inline struct;\n\nvoid tracing_record_taskinfo(struct task_struct *task, int flags)\n{\n\tbool done;\n\n\tif (tracing_record_taskinfo_skip(flags))\n\t\treturn;\n\n\t/*\n\t * Record as much task information as possible. If some fail, continue\n\t * to try to record the others.\n\t */\n\tdone = !(flags & TRACE_RECORD_CMDLINE) || trace_save_cmdline(task);\n\tdone &= !(flags & TRACE_RECORD_TGID) || trace_save_tgid(task);\n\n\t/* If recording any information failed, retry again soon. */\n\tif (!done)\n\t\treturn;\n\n\t__this_cpu_write(trace_taskinfo_save, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n#define RECORD_CMDLINE\t1\n\nstatic int\t\tsched_cmdline_ref;\nstatic int\t\tsched_tgid_ref;\n\nstatic void\nprobe_sched_wakeup(void *ignore, struct task_struct *wakee)\n{\n\tint flags;\n\n\tflags = (RECORD_TGID * !!sched_tgid_ref) +\n\t\t(RECORD_CMDLINE * !!sched_cmdline_ref);\n\n\tif (!flags)\n\t\treturn;\n\ttracing_record_taskinfo(current, flags);\n}"
  },
  {
    "function_name": "probe_sched_switch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
    "lines": "23-35",
    "snippet": "static void\nprobe_sched_switch(void *ignore, bool preempt,\n\t\t   struct task_struct *prev, struct task_struct *next)\n{\n\tint flags;\n\n\tflags = (RECORD_TGID * !!sched_tgid_ref) +\n\t\t(RECORD_CMDLINE * !!sched_cmdline_ref);\n\n\tif (!flags)\n\t\treturn;\n\ttracing_record_taskinfo_sched_switch(prev, next, flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <trace/events/sched.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RECORD_TGID\t2",
      "#define RECORD_CMDLINE\t1"
    ],
    "globals_used": [
      "static int\t\tsched_cmdline_ref;",
      "static int\t\tsched_tgid_ref;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_record_taskinfo_sched_switch",
          "args": [
            "prev",
            "next",
            "flags"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_record_taskinfo_sched_switch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2537-2559",
          "snippet": "void tracing_record_taskinfo_sched_switch(struct task_struct *prev,\n\t\t\t\t\t  struct task_struct *next, int flags)\n{\n\tbool done;\n\n\tif (tracing_record_taskinfo_skip(flags))\n\t\treturn;\n\n\t/*\n\t * Record as much task information as possible. If some fail, continue\n\t * to try to record the others.\n\t */\n\tdone  = !(flags & TRACE_RECORD_CMDLINE) || trace_save_cmdline(prev);\n\tdone &= !(flags & TRACE_RECORD_CMDLINE) || trace_save_cmdline(next);\n\tdone &= !(flags & TRACE_RECORD_TGID) || trace_save_tgid(prev);\n\tdone &= !(flags & TRACE_RECORD_TGID) || trace_save_tgid(next);\n\n\t/* If recording any information failed, retry again soon. */\n\tif (!done)\n\t\treturn;\n\n\t__this_cpu_write(trace_taskinfo_save, false);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, trace_taskinfo_save);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic DEFINE_PER_CPU(bool, trace_taskinfo_save);\nstatic __always_inline struct;\n\nvoid tracing_record_taskinfo_sched_switch(struct task_struct *prev,\n\t\t\t\t\t  struct task_struct *next, int flags)\n{\n\tbool done;\n\n\tif (tracing_record_taskinfo_skip(flags))\n\t\treturn;\n\n\t/*\n\t * Record as much task information as possible. If some fail, continue\n\t * to try to record the others.\n\t */\n\tdone  = !(flags & TRACE_RECORD_CMDLINE) || trace_save_cmdline(prev);\n\tdone &= !(flags & TRACE_RECORD_CMDLINE) || trace_save_cmdline(next);\n\tdone &= !(flags & TRACE_RECORD_TGID) || trace_save_tgid(prev);\n\tdone &= !(flags & TRACE_RECORD_TGID) || trace_save_tgid(next);\n\n\t/* If recording any information failed, retry again soon. */\n\tif (!done)\n\t\treturn;\n\n\t__this_cpu_write(trace_taskinfo_save, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n#define RECORD_CMDLINE\t1\n\nstatic int\t\tsched_cmdline_ref;\nstatic int\t\tsched_tgid_ref;\n\nstatic void\nprobe_sched_switch(void *ignore, bool preempt,\n\t\t   struct task_struct *prev, struct task_struct *next)\n{\n\tint flags;\n\n\tflags = (RECORD_TGID * !!sched_tgid_ref) +\n\t\t(RECORD_CMDLINE * !!sched_cmdline_ref);\n\n\tif (!flags)\n\t\treturn;\n\ttracing_record_taskinfo_sched_switch(prev, next, flags);\n}"
  }
]