[
  {
    "function_name": "kdb_kbd_cleanup_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_keyboard.c",
    "lines": "199-263",
    "snippet": "void kdb_kbd_cleanup_state(void)\n{\n\tint scancode, scanstatus;\n\n\t/*\n\t * Nothing to clean up, since either\n\t * ENTER was never pressed, or has already\n\t * gotten cleaned up.\n\t */\n\tif (!kbd_last_ret)\n\t\treturn;\n\n\tkbd_last_ret = 0;\n\t/*\n\t * Enter key. Need to absorb the break code here, lest it gets\n\t * leaked out if we exit KDB as the result of processing 'g'.\n\t *\n\t * This has several interesting implications:\n\t * + Need to handle KP ENTER, which has break code 0xe0 0x9c.\n\t * + Need to handle repeat ENTER and repeat KP ENTER. Repeats\n\t *   only get a break code at the end of the repeated\n\t *   sequence. This means we can't propagate the repeated key\n\t *   press, and must swallow it away.\n\t * + Need to handle possible PS/2 mouse input.\n\t * + Need to handle mashed keys.\n\t */\n\n\twhile (1) {\n\t\twhile ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)\n\t\t\tcpu_relax();\n\n\t\t/*\n\t\t * Fetch the scancode.\n\t\t */\n\t\tscancode = inb(KBD_DATA_REG);\n\t\tscanstatus = inb(KBD_STATUS_REG);\n\n\t\t/*\n\t\t * Skip mouse input.\n\t\t */\n\t\tif (scanstatus & KBD_STAT_MOUSE_OBF)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If we see 0xe0, this is either a break code for KP\n\t\t * ENTER, or a repeat make for KP ENTER. Either way,\n\t\t * since the second byte is equivalent to an ENTER,\n\t\t * skip the 0xe0 and try again.\n\t\t *\n\t\t * If we see 0x1c, this must be a repeat ENTER or KP\n\t\t * ENTER (and we swallowed 0xe0 before). Try again.\n\t\t *\n\t\t * We can also see make and break codes for other keys\n\t\t * mashed before or after pressing ENTER. Thus, if we\n\t\t * see anything other than 0x9c, we have to try again.\n\t\t *\n\t\t * Note, if you held some key as ENTER was depressed,\n\t\t * that break code would get leaked out.\n\t\t */\n\t\tif (scancode != 0x9c)\n\t\t\tcontinue;\n\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <linux/io.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/keyboard.h>",
      "#include <linux/kdb.h>"
    ],
    "macros_used": [
      "#define KBD_STAT_MOUSE_OBF\t0x20\t/* Mouse output buffer full */",
      "#define KBD_STAT_OBF \t\t0x01\t/* Keyboard output buffer full */",
      "#define KBD_DATA_REG\t\t0x60\t/* Keyboard data register (R/W) */",
      "#define KBD_STATUS_REG\t\t0x64\t/* Status register (R) */"
    ],
    "globals_used": [
      "static int kbd_last_ret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "KBD_STATUS_REG"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "KBD_DATA_REG"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "KBD_STATUS_REG"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/keyboard.h>\n#include <linux/kdb.h>\n\n#define KBD_STAT_MOUSE_OBF\t0x20\t/* Mouse output buffer full */\n#define KBD_STAT_OBF \t\t0x01\t/* Keyboard output buffer full */\n#define KBD_DATA_REG\t\t0x60\t/* Keyboard data register (R/W) */\n#define KBD_STATUS_REG\t\t0x64\t/* Status register (R) */\n\nstatic int kbd_last_ret;\n\nvoid kdb_kbd_cleanup_state(void)\n{\n\tint scancode, scanstatus;\n\n\t/*\n\t * Nothing to clean up, since either\n\t * ENTER was never pressed, or has already\n\t * gotten cleaned up.\n\t */\n\tif (!kbd_last_ret)\n\t\treturn;\n\n\tkbd_last_ret = 0;\n\t/*\n\t * Enter key. Need to absorb the break code here, lest it gets\n\t * leaked out if we exit KDB as the result of processing 'g'.\n\t *\n\t * This has several interesting implications:\n\t * + Need to handle KP ENTER, which has break code 0xe0 0x9c.\n\t * + Need to handle repeat ENTER and repeat KP ENTER. Repeats\n\t *   only get a break code at the end of the repeated\n\t *   sequence. This means we can't propagate the repeated key\n\t *   press, and must swallow it away.\n\t * + Need to handle possible PS/2 mouse input.\n\t * + Need to handle mashed keys.\n\t */\n\n\twhile (1) {\n\t\twhile ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)\n\t\t\tcpu_relax();\n\n\t\t/*\n\t\t * Fetch the scancode.\n\t\t */\n\t\tscancode = inb(KBD_DATA_REG);\n\t\tscanstatus = inb(KBD_STATUS_REG);\n\n\t\t/*\n\t\t * Skip mouse input.\n\t\t */\n\t\tif (scanstatus & KBD_STAT_MOUSE_OBF)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If we see 0xe0, this is either a break code for KP\n\t\t * ENTER, or a repeat make for KP ENTER. Either way,\n\t\t * since the second byte is equivalent to an ENTER,\n\t\t * skip the 0xe0 and try again.\n\t\t *\n\t\t * If we see 0x1c, this must be a repeat ENTER or KP\n\t\t * ENTER (and we swallowed 0xe0 before). Try again.\n\t\t *\n\t\t * We can also see make and break codes for other keys\n\t\t * mashed before or after pressing ENTER. Thus, if we\n\t\t * see anything other than 0x9c, we have to try again.\n\t\t *\n\t\t * Note, if you held some key as ENTER was depressed,\n\t\t * that break code would get leaked out.\n\t\t */\n\t\tif (scancode != 0x9c)\n\t\t\tcontinue;\n\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "kdb_get_kbd_char",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_keyboard.c",
    "lines": "35-191",
    "snippet": "int kdb_get_kbd_char(void)\n{\n\tint scancode, scanstatus;\n\tstatic int shift_lock;\t/* CAPS LOCK state (0-off, 1-on) */\n\tstatic int shift_key;\t/* Shift next keypress */\n\tstatic int ctrl_key;\n\tu_short keychar;\n\n\tif (KDB_FLAG(NO_I8042) || KDB_FLAG(NO_VT_CONSOLE) ||\n\t    (inb(KBD_STATUS_REG) == 0xff && inb(KBD_DATA_REG) == 0xff)) {\n\t\tkbd_exists = 0;\n\t\treturn -1;\n\t}\n\tkbd_exists = 1;\n\n\tif ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)\n\t\treturn -1;\n\n\t/*\n\t * Fetch the scancode\n\t */\n\tscancode = inb(KBD_DATA_REG);\n\tscanstatus = inb(KBD_STATUS_REG);\n\n\t/*\n\t * Ignore mouse events.\n\t */\n\tif (scanstatus & KBD_STAT_MOUSE_OBF)\n\t\treturn -1;\n\n\t/*\n\t * Ignore release, trigger on make\n\t * (except for shift keys, where we want to\n\t *  keep the shift state so long as the key is\n\t *  held down).\n\t */\n\n\tif (((scancode&0x7f) == 0x2a) || ((scancode&0x7f) == 0x36)) {\n\t\t/*\n\t\t * Next key may use shift table\n\t\t */\n\t\tif ((scancode & 0x80) == 0)\n\t\t\tshift_key = 1;\n\t\telse\n\t\t\tshift_key = 0;\n\t\treturn -1;\n\t}\n\n\tif ((scancode&0x7f) == 0x1d) {\n\t\t/*\n\t\t * Left ctrl key\n\t\t */\n\t\tif ((scancode & 0x80) == 0)\n\t\t\tctrl_key = 1;\n\t\telse\n\t\t\tctrl_key = 0;\n\t\treturn -1;\n\t}\n\n\tif ((scancode & 0x80) != 0) {\n\t\tif (scancode == 0x9c)\n\t\t\tkbd_last_ret = 0;\n\t\treturn -1;\n\t}\n\n\tscancode &= 0x7f;\n\n\t/*\n\t * Translate scancode\n\t */\n\n\tif (scancode == 0x3a) {\n\t\t/*\n\t\t * Toggle caps lock\n\t\t */\n\t\tshift_lock ^= 1;\n\n#ifdef\tKDB_BLINK_LED\n\t\tkdb_toggleled(0x4);\n#endif\n\t\treturn -1;\n\t}\n\n\tif (scancode == 0x0e) {\n\t\t/*\n\t\t * Backspace\n\t\t */\n\t\treturn 8;\n\t}\n\n\t/* Special Key */\n\tswitch (scancode) {\n\tcase 0xF: /* Tab */\n\t\treturn 9;\n\tcase 0x53: /* Del */\n\t\treturn 4;\n\tcase 0x47: /* Home */\n\t\treturn 1;\n\tcase 0x4F: /* End */\n\t\treturn 5;\n\tcase 0x4B: /* Left */\n\t\treturn 2;\n\tcase 0x48: /* Up */\n\t\treturn 16;\n\tcase 0x50: /* Down */\n\t\treturn 14;\n\tcase 0x4D: /* Right */\n\t\treturn 6;\n\t}\n\n\tif (scancode == 0xe0)\n\t\treturn -1;\n\n\t/*\n\t * For Japanese 86/106 keyboards\n\t * \tSee comment in drivers/char/pc_keyb.c.\n\t * \t- Masahiro Adegawa\n\t */\n\tif (scancode == 0x73)\n\t\tscancode = 0x59;\n\telse if (scancode == 0x7d)\n\t\tscancode = 0x7c;\n\n\tif (!shift_lock && !shift_key && !ctrl_key) {\n\t\tkeychar = plain_map[scancode];\n\t} else if ((shift_lock || shift_key) && key_maps[1]) {\n\t\tkeychar = key_maps[1][scancode];\n\t} else if (ctrl_key && key_maps[4]) {\n\t\tkeychar = key_maps[4][scancode];\n\t} else {\n\t\tkeychar = 0x0020;\n\t\tkdb_printf(\"Unknown state/scancode (%d)\\n\", scancode);\n\t}\n\tkeychar &= 0x0fff;\n\tif (keychar == '\\t')\n\t\tkeychar = ' ';\n\tswitch (KTYP(keychar)) {\n\tcase KT_LETTER:\n\tcase KT_LATIN:\n\t\tif (isprint(keychar))\n\t\t\tbreak;\t\t/* printable characters */\n\t\tfallthrough;\n\tcase KT_SPEC:\n\t\tif (keychar == K_ENTER)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn -1;\t/* ignore unprintables */\n\t}\n\n\tif (scancode == 0x1c) {\n\t\tkbd_last_ret = 1;\n\t\treturn 13;\n\t}\n\n\treturn keychar & 0xff;\n}",
    "includes": [
      "#include <linux/io.h>",
      "#include <linux/module.h>",
      "#include <linux/ctype.h>",
      "#include <linux/keyboard.h>",
      "#include <linux/kdb.h>"
    ],
    "macros_used": [
      "#define KBD_STAT_MOUSE_OBF\t0x20\t/* Mouse output buffer full */",
      "#define KBD_STAT_OBF \t\t0x01\t/* Keyboard output buffer full */",
      "#define KBD_DATA_REG\t\t0x60\t/* Keyboard data register (R/W) */",
      "#define KBD_STATUS_REG\t\t0x64\t/* Status register (R) */"
    ],
    "globals_used": [
      "static int kbd_exists;",
      "static int kbd_last_ret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "keychar"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KTYP",
          "args": [
            "keychar"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Unknown state/scancode (%d)\\n\"",
            "scancode"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_toggleled",
          "args": [
            "0x4"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "KBD_STATUS_REG"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "KBD_DATA_REG"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "KBD_STATUS_REG"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "KBD_DATA_REG"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "KBD_STATUS_REG"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "NO_VT_CONSOLE"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "NO_I8042"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/keyboard.h>\n#include <linux/kdb.h>\n\n#define KBD_STAT_MOUSE_OBF\t0x20\t/* Mouse output buffer full */\n#define KBD_STAT_OBF \t\t0x01\t/* Keyboard output buffer full */\n#define KBD_DATA_REG\t\t0x60\t/* Keyboard data register (R/W) */\n#define KBD_STATUS_REG\t\t0x64\t/* Status register (R) */\n\nstatic int kbd_exists;\nstatic int kbd_last_ret;\n\nint kdb_get_kbd_char(void)\n{\n\tint scancode, scanstatus;\n\tstatic int shift_lock;\t/* CAPS LOCK state (0-off, 1-on) */\n\tstatic int shift_key;\t/* Shift next keypress */\n\tstatic int ctrl_key;\n\tu_short keychar;\n\n\tif (KDB_FLAG(NO_I8042) || KDB_FLAG(NO_VT_CONSOLE) ||\n\t    (inb(KBD_STATUS_REG) == 0xff && inb(KBD_DATA_REG) == 0xff)) {\n\t\tkbd_exists = 0;\n\t\treturn -1;\n\t}\n\tkbd_exists = 1;\n\n\tif ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)\n\t\treturn -1;\n\n\t/*\n\t * Fetch the scancode\n\t */\n\tscancode = inb(KBD_DATA_REG);\n\tscanstatus = inb(KBD_STATUS_REG);\n\n\t/*\n\t * Ignore mouse events.\n\t */\n\tif (scanstatus & KBD_STAT_MOUSE_OBF)\n\t\treturn -1;\n\n\t/*\n\t * Ignore release, trigger on make\n\t * (except for shift keys, where we want to\n\t *  keep the shift state so long as the key is\n\t *  held down).\n\t */\n\n\tif (((scancode&0x7f) == 0x2a) || ((scancode&0x7f) == 0x36)) {\n\t\t/*\n\t\t * Next key may use shift table\n\t\t */\n\t\tif ((scancode & 0x80) == 0)\n\t\t\tshift_key = 1;\n\t\telse\n\t\t\tshift_key = 0;\n\t\treturn -1;\n\t}\n\n\tif ((scancode&0x7f) == 0x1d) {\n\t\t/*\n\t\t * Left ctrl key\n\t\t */\n\t\tif ((scancode & 0x80) == 0)\n\t\t\tctrl_key = 1;\n\t\telse\n\t\t\tctrl_key = 0;\n\t\treturn -1;\n\t}\n\n\tif ((scancode & 0x80) != 0) {\n\t\tif (scancode == 0x9c)\n\t\t\tkbd_last_ret = 0;\n\t\treturn -1;\n\t}\n\n\tscancode &= 0x7f;\n\n\t/*\n\t * Translate scancode\n\t */\n\n\tif (scancode == 0x3a) {\n\t\t/*\n\t\t * Toggle caps lock\n\t\t */\n\t\tshift_lock ^= 1;\n\n#ifdef\tKDB_BLINK_LED\n\t\tkdb_toggleled(0x4);\n#endif\n\t\treturn -1;\n\t}\n\n\tif (scancode == 0x0e) {\n\t\t/*\n\t\t * Backspace\n\t\t */\n\t\treturn 8;\n\t}\n\n\t/* Special Key */\n\tswitch (scancode) {\n\tcase 0xF: /* Tab */\n\t\treturn 9;\n\tcase 0x53: /* Del */\n\t\treturn 4;\n\tcase 0x47: /* Home */\n\t\treturn 1;\n\tcase 0x4F: /* End */\n\t\treturn 5;\n\tcase 0x4B: /* Left */\n\t\treturn 2;\n\tcase 0x48: /* Up */\n\t\treturn 16;\n\tcase 0x50: /* Down */\n\t\treturn 14;\n\tcase 0x4D: /* Right */\n\t\treturn 6;\n\t}\n\n\tif (scancode == 0xe0)\n\t\treturn -1;\n\n\t/*\n\t * For Japanese 86/106 keyboards\n\t * \tSee comment in drivers/char/pc_keyb.c.\n\t * \t- Masahiro Adegawa\n\t */\n\tif (scancode == 0x73)\n\t\tscancode = 0x59;\n\telse if (scancode == 0x7d)\n\t\tscancode = 0x7c;\n\n\tif (!shift_lock && !shift_key && !ctrl_key) {\n\t\tkeychar = plain_map[scancode];\n\t} else if ((shift_lock || shift_key) && key_maps[1]) {\n\t\tkeychar = key_maps[1][scancode];\n\t} else if (ctrl_key && key_maps[4]) {\n\t\tkeychar = key_maps[4][scancode];\n\t} else {\n\t\tkeychar = 0x0020;\n\t\tkdb_printf(\"Unknown state/scancode (%d)\\n\", scancode);\n\t}\n\tkeychar &= 0x0fff;\n\tif (keychar == '\\t')\n\t\tkeychar = ' ';\n\tswitch (KTYP(keychar)) {\n\tcase KT_LETTER:\n\tcase KT_LATIN:\n\t\tif (isprint(keychar))\n\t\t\tbreak;\t\t/* printable characters */\n\t\tfallthrough;\n\tcase KT_SPEC:\n\t\tif (keychar == K_ENTER)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn -1;\t/* ignore unprintables */\n\t}\n\n\tif (scancode == 0x1c) {\n\t\tkbd_last_ret = 1;\n\t\treturn 13;\n\t}\n\n\treturn keychar & 0xff;\n}"
  }
]