[
  {
    "function_name": "synchronize_rcu_expedited",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "816-865",
    "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_work_on_stack",
          "args": [
            "&rew.rew_work"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_work_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "522-525",
          "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!boottime"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_state.exp_mutex"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "rnp->exp_wq[rcu_seq_ctr(s) & 0x3]",
            "sync_exp_work_done(s)"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_exp_work_done",
          "args": [
            "s"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "sync_exp_work_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "263-271",
          "snippet": "static bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\tsmp_mb(); /* Ensure test happens before caller kfree(). */\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\tsmp_mb(); /* Ensure test happens before caller kfree(). */\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "s"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "30-33",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "rcu_gp_wq",
            "&rew.rew_work"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&rew.rew_work",
            "wait_rcu_exp_gp"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_sel_wait_wake",
          "args": [
            "s"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_sel_wait_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "615-622",
          "snippet": "static void rcu_exp_sel_wait_wake(unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus();\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_sel_wait_wake(unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus();\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "boottime"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_funnel_lock",
          "args": [
            "s"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "exp_funnel_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "280-331",
          "snippet": "static bool exp_funnel_lock(unsigned long s)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\t/* Low-contention fastpath. */\n\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s) &&\n\t    (rnp == rnp_root ||\n\t     ULONG_CMP_LT(READ_ONCE(rnp_root->exp_seq_rq), s)) &&\n\t    mutex_trylock(&rcu_state.exp_mutex))\n\t\tgoto fastpath;\n\n\t/*\n\t * Each pass through the following loop works its way up\n\t * the rcu_node tree, returning if others have done the work or\n\t * otherwise falls through to acquire ->exp_mutex.  The mapping\n\t * from CPU to rcu_node structure can be inexact, as it is just\n\t * promoting locality and is not strictly needed for correctness.\n\t */\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tif (sync_exp_work_done(s))\n\t\t\treturn true;\n\n\t\t/* Work not done, either wait here or go up. */\n\t\tspin_lock(&rnp->exp_lock);\n\t\tif (ULONG_CMP_GE(rnp->exp_seq_rq, s)) {\n\n\t\t\t/* Someone else doing GP, so wait for them. */\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t\t  rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t  TPS(\"wait\"));\n\t\t\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t\t\t   sync_exp_work_done(s));\n\t\t\treturn true;\n\t\t}\n\t\tWRITE_ONCE(rnp->exp_seq_rq, s); /* Followers can wait on us. */\n\t\tspin_unlock(&rnp->exp_lock);\n\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t  rnp->grplo, rnp->grphi, TPS(\"nxtlvl\"));\n\t}\n\tmutex_lock(&rcu_state.exp_mutex);\nfastpath:\n\tif (sync_exp_work_done(s)) {\n\t\tmutex_unlock(&rcu_state.exp_mutex);\n\t\treturn true;\n\t}\n\trcu_exp_gp_seq_start();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"start\"));\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic bool exp_funnel_lock(unsigned long s)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\t/* Low-contention fastpath. */\n\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s) &&\n\t    (rnp == rnp_root ||\n\t     ULONG_CMP_LT(READ_ONCE(rnp_root->exp_seq_rq), s)) &&\n\t    mutex_trylock(&rcu_state.exp_mutex))\n\t\tgoto fastpath;\n\n\t/*\n\t * Each pass through the following loop works its way up\n\t * the rcu_node tree, returning if others have done the work or\n\t * otherwise falls through to acquire ->exp_mutex.  The mapping\n\t * from CPU to rcu_node structure can be inexact, as it is just\n\t * promoting locality and is not strictly needed for correctness.\n\t */\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tif (sync_exp_work_done(s))\n\t\t\treturn true;\n\n\t\t/* Work not done, either wait here or go up. */\n\t\tspin_lock(&rnp->exp_lock);\n\t\tif (ULONG_CMP_GE(rnp->exp_seq_rq, s)) {\n\n\t\t\t/* Someone else doing GP, so wait for them. */\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t\t  rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t  TPS(\"wait\"));\n\t\t\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t\t\t   sync_exp_work_done(s));\n\t\t\treturn true;\n\t\t}\n\t\tWRITE_ONCE(rnp->exp_seq_rq, s); /* Followers can wait on us. */\n\t\tspin_unlock(&rnp->exp_lock);\n\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t  rnp->grplo, rnp->grphi, TPS(\"nxtlvl\"));\n\t}\n\tmutex_lock(&rcu_state.exp_mutex);\nfastpath:\n\tif (sync_exp_work_done(s)) {\n\t\tmutex_unlock(&rcu_state.exp_mutex);\n\t\treturn true;\n\t}\n\trcu_exp_gp_seq_start();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"start\"));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_snap",
          "args": [],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "46-54",
          "snippet": "static unsigned long rcu_exp_gp_seq_snap(void)\n{\n\tunsigned long s;\n\n\tsmp_mb(); /* Caller's modifications seen first by other CPUs. */\n\ts = rcu_seq_snap(&rcu_state.expedited_sequence);\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"snap\"));\n\treturn s;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic unsigned long rcu_exp_gp_seq_snap(void)\n{\n\tunsigned long s;\n\n\tsmp_mb(); /* Caller's modifications seen first by other CPUs. */\n\ts = rcu_seq_snap(&rcu_state.expedited_sequence);\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"snap\"));\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_rcu_gp",
          "args": [
            "call_rcu"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_normal",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "140-144",
          "snippet": "bool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_blocking_is_gp",
          "args": [],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_blocking_is_gp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3712-3736",
          "snippet": "static int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\treturn rcu_scheduler_active == RCU_SCHEDULER_INACTIVE;\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\t/*\n\t * If the rcu_state.n_online_cpus counter is equal to one,\n\t * there is only one CPU, and that CPU sees all prior accesses\n\t * made by any CPU that was online at the time of its access.\n\t * Furthermore, if this counter is equal to one, its value cannot\n\t * change until after the preempt_enable() below.\n\t *\n\t * Furthermore, if rcu_state.n_online_cpus is equal to one here,\n\t * all later CPUs (both this one and any that come online later\n\t * on) are guaranteed to see all accesses prior to this point\n\t * in the code, without the need for additional memory barriers.\n\t * Those memory barriers are provided by CPU-hotplug code.\n\t */\n\tret = READ_ONCE(rcu_state.n_online_cpus) <= 1;\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "int rcu_scheduler_active"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_scheduler_active;\n\nstatic int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\treturn rcu_scheduler_active == RCU_SCHEDULER_INACTIVE;\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\t/*\n\t * If the rcu_state.n_online_cpus counter is equal to one,\n\t * there is only one CPU, and that CPU sees all prior accesses\n\t * made by any CPU that was online at the time of its access.\n\t * Furthermore, if this counter is equal to one, its value cannot\n\t * change until after the preempt_enable() below.\n\t *\n\t * Furthermore, if rcu_state.n_online_cpus is equal to one here,\n\t * all later CPUs (both this one and any that come online later\n\t * on) are guaranteed to see all accesses prior to this point\n\t * in the code, without the need for additional memory barriers.\n\t * Those memory barriers are provided by CPU-hotplug code.\n\t */\n\tret = READ_ONCE(rcu_state.n_online_cpus) <= 1;\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map)",
            "\"Illegal synchronize_rcu_expedited() in RCU read-side critical section\""
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_sched_lock_map"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_lock_map"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_bh_lock_map"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
  },
  {
    "function_name": "rcu_print_task_exp_stall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "789-792",
    "snippet": "static int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "sync_sched_exp_online_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "753-782",
    "snippet": "static void sync_sched_exp_online_cleanup(int cpu)\n{\n\tunsigned long flags;\n\tint my_cpu;\n\tstruct rcu_data *rdp;\n\tint ret;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tmy_cpu = get_cpu();\n\t/* Quiescent state either not needed or already requested, leave. */\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask) ||\n\t    READ_ONCE(rdp->cpu_no_qs.b.exp)) {\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/* Quiescent state needed on current CPU, so set it up locally. */\n\tif (my_cpu == cpu) {\n\t\tlocal_irq_save(flags);\n\t\trcu_exp_need_qs();\n\t\tlocal_irq_restore(flags);\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/* Quiescent state needed on some other CPU, send IPI. */\n\tret = smp_call_function_single(cpu, rcu_exp_handler, NULL, 0);\n\tput_cpu();\n\tWARN_ON_ONCE(ret);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "rcu_exp_handler",
            "NULL",
            "0"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "12-25",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_need_qs",
          "args": [],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_need_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "727-734",
          "snippet": "static void rcu_exp_need_qs(void)\n{\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, true);\n\t/* Store .exp before .rcu_urgent_qs. */\n\tsmp_store_release(this_cpu_ptr(&rcu_data.rcu_urgent_qs), true);\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_need_qs(void)\n{\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, true);\n\t/* Store .exp before .rcu_urgent_qs. */\n\tsmp_store_release(this_cpu_ptr(&rcu_data.rcu_urgent_qs), true);\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->cpu_no_qs.b.exp"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->expmask"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "120-126",
          "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_kthread_data hwlat_single_cpu_data;",
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void sync_sched_exp_online_cleanup(int cpu)\n{\n\tunsigned long flags;\n\tint my_cpu;\n\tstruct rcu_data *rdp;\n\tint ret;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tmy_cpu = get_cpu();\n\t/* Quiescent state either not needed or already requested, leave. */\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask) ||\n\t    READ_ONCE(rdp->cpu_no_qs.b.exp)) {\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/* Quiescent state needed on current CPU, so set it up locally. */\n\tif (my_cpu == cpu) {\n\t\tlocal_irq_save(flags);\n\t\trcu_exp_need_qs();\n\t\tlocal_irq_restore(flags);\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t/* Quiescent state needed on some other CPU, send IPI. */\n\tret = smp_call_function_single(cpu, rcu_exp_handler, NULL, 0);\n\tput_cpu();\n\tWARN_ON_ONCE(ret);\n}"
  },
  {
    "function_name": "rcu_exp_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "737-750",
    "snippet": "static void rcu_exp_handler(void *unused)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask) ||\n\t    __this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\tif (rcu_is_cpu_rrupt_from_idle()) {\n\t\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n\t\treturn;\n\t}\n\trcu_exp_need_qs();\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_exp_handler(void *unused);",
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_exp_need_qs",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_need_qs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "727-734",
          "snippet": "static void rcu_exp_need_qs(void)\n{\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, true);\n\t/* Store .exp before .rcu_urgent_qs. */\n\tsmp_store_release(this_cpu_ptr(&rcu_data.rcu_urgent_qs), true);\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_need_qs(void)\n{\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, true);\n\t/* Store .exp before .rcu_urgent_qs. */\n\tsmp_store_release(this_cpu_ptr(&rcu_data.rcu_urgent_qs), true);\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_report_exp_rdp",
          "args": [
            "this_cpu_ptr(&rcu_data)"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_rdp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "256-260",
          "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_cpu_rrupt_from_idle",
          "args": [],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_cpu_rrupt_from_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "422-451",
          "snippet": "static int rcu_is_cpu_rrupt_from_idle(void)\n{\n\tlong nesting;\n\n\t/*\n\t * Usually called from the tick; but also used from smp_function_call()\n\t * for expedited grace periods. This latter can result in running from\n\t * the idle task, instead of an actual IPI.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for counter underflows */\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) < 0,\n\t\t\t \"RCU dynticks_nesting counter underflow!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 0,\n\t\t\t \"RCU dynticks_nmi_nesting counter underflow/zero!\");\n\n\t/* Are we at first interrupt nesting level? */\n\tnesting = __this_cpu_read(rcu_data.dynticks_nmi_nesting);\n\tif (nesting > 1)\n\t\treturn false;\n\n\t/*\n\t * If we're not in an interrupt, we must be in the idle task!\n\t */\n\tWARN_ON_ONCE(!nesting && !is_idle_task(current));\n\n\t/* Does CPU appear to be idle from an RCU standpoint? */\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) == 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nstatic int rcu_is_cpu_rrupt_from_idle(void)\n{\n\tlong nesting;\n\n\t/*\n\t * Usually called from the tick; but also used from smp_function_call()\n\t * for expedited grace periods. This latter can result in running from\n\t * the idle task, instead of an actual IPI.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for counter underflows */\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) < 0,\n\t\t\t \"RCU dynticks_nesting counter underflow!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 0,\n\t\t\t \"RCU dynticks_nmi_nesting counter underflow/zero!\");\n\n\t/* Are we at first interrupt nesting level? */\n\tnesting = __this_cpu_read(rcu_data.dynticks_nmi_nesting);\n\tif (nesting > 1)\n\t\treturn false;\n\n\t/*\n\t * If we're not in an interrupt, we must be in the idle task!\n\t */\n\tWARN_ON_ONCE(!nesting && !is_idle_task(current));\n\n\t/* Does CPU appear to be idle from an RCU standpoint? */\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.cpu_no_qs.b.exp"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->expmask"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_handler(void *unused);\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void rcu_exp_handler(void *unused)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask) ||\n\t    __this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\tif (rcu_is_cpu_rrupt_from_idle()) {\n\t\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n\t\treturn;\n\t}\n\trcu_exp_need_qs();\n}"
  },
  {
    "function_name": "rcu_exp_need_qs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "727-734",
    "snippet": "static void rcu_exp_need_qs(void)\n{\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, true);\n\t/* Store .exp before .rcu_urgent_qs. */\n\tsmp_store_release(this_cpu_ptr(&rcu_data.rcu_urgent_qs), true);\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "current"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "this_cpu_ptr(&rcu_data.rcu_urgent_qs)",
            "true"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data.rcu_urgent_qs"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "rcu_data.cpu_no_qs.b.exp",
            "true"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_need_qs(void)\n{\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, true);\n\t/* Store .exp before .rcu_urgent_qs. */\n\tsmp_store_release(this_cpu_ptr(&rcu_data.rcu_urgent_qs), true);\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}"
  },
  {
    "function_name": "rcu_print_task_exp_stall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "705-722",
    "snippet": "static int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tint ndetected = 0;\n\tstruct task_struct *t;\n\n\tif (!READ_ONCE(rnp->exp_tasks))\n\t\treturn 0;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tt = list_entry(rnp->exp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\tpr_cont(\" P%d\", t->pid);\n\t\tndetected++;\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\treturn ndetected;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" P%d\"",
            "t->pid"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "t",
            "&rnp->blkd_tasks",
            "rcu_node_entry"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "rnp->exp_tasks->prev",
            "structtask_struct",
            "rcu_node_entry"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->exp_tasks"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tint ndetected = 0;\n\tstruct task_struct *t;\n\n\tif (!READ_ONCE(rnp->exp_tasks))\n\t\treturn 0;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tt = list_entry(rnp->exp_tasks->prev,\n\t\t       struct task_struct, rcu_node_entry);\n\tlist_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry) {\n\t\tpr_cont(\" P%d\", t->pid);\n\t\tndetected++;\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\treturn ndetected;\n}"
  },
  {
    "function_name": "sync_sched_exp_online_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "696-698",
    "snippet": "static void sync_sched_exp_online_cleanup(int cpu)\n{\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu)\n{\n}"
  },
  {
    "function_name": "rcu_exp_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "644-693",
    "snippet": "static void rcu_exp_handler(void *unused)\n{\n\tint depth = rcu_preempt_depth();\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct task_struct *t = current;\n\n\t/*\n\t * First, the common case of not being in an RCU read-side\n\t * critical section.  If also enabled or idle, immediately\n\t * report the quiescent state, otherwise defer.\n\t */\n\tif (!depth) {\n\t\tif (!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK)) ||\n\t\t    rcu_dynticks_curr_cpu_in_eqs()) {\n\t\t\trcu_report_exp_rdp(rdp);\n\t\t} else {\n\t\t\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, true);\n\t\t\tset_tsk_need_resched(t);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * Second, the less-common case of being in an RCU read-side\n\t * critical section.  In this case we can count on a future\n\t * rcu_read_unlock().  However, this rcu_read_unlock() might\n\t * execute on some other CPU, but in that case there will be\n\t * a future context switch.  Either way, if the expedited\n\t * grace period is still waiting on this CPU, set ->deferred_qs\n\t * so that the eventual quiescent state will be reported.\n\t * Note that there is a large group of race conditions that\n\t * can have caused this quiescent state to already have been\n\t * reported, so we really do need to check ->expmask.\n\t */\n\tif (depth > 0) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmask & rdp->grpmask) {\n\t\t\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, true);\n\t\t\tt->rcu_read_unlock_special.b.exp_hint = true;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\n\t// Finally, negative nesting depth should not happen.\n\tWARN_ON_ONCE(1);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_exp_handler(void *unused);",
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->cpu_no_qs.b.exp",
            "true"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "t"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->cpu_no_qs.b.exp",
            "true"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_exp_rdp",
          "args": [
            "rdp"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_rdp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "256-260",
          "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_curr_cpu_in_eqs",
          "args": [],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_curr_cpu_in_eqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "328-331",
          "snippet": "static __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\n\nstatic __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\treturn !(arch_atomic_read(this_cpu_ptr(&rcu_data.dynticks)) & 0x1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_depth",
          "args": [],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_handler(void *unused);\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void rcu_exp_handler(void *unused)\n{\n\tint depth = rcu_preempt_depth();\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct task_struct *t = current;\n\n\t/*\n\t * First, the common case of not being in an RCU read-side\n\t * critical section.  If also enabled or idle, immediately\n\t * report the quiescent state, otherwise defer.\n\t */\n\tif (!depth) {\n\t\tif (!(preempt_count() & (PREEMPT_MASK | SOFTIRQ_MASK)) ||\n\t\t    rcu_dynticks_curr_cpu_in_eqs()) {\n\t\t\trcu_report_exp_rdp(rdp);\n\t\t} else {\n\t\t\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, true);\n\t\t\tset_tsk_need_resched(t);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * Second, the less-common case of being in an RCU read-side\n\t * critical section.  In this case we can count on a future\n\t * rcu_read_unlock().  However, this rcu_read_unlock() might\n\t * execute on some other CPU, but in that case there will be\n\t * a future context switch.  Either way, if the expedited\n\t * grace period is still waiting on this CPU, set ->deferred_qs\n\t * so that the eventual quiescent state will be reported.\n\t * Note that there is a large group of race conditions that\n\t * can have caused this quiescent state to already have been\n\t * reported, so we really do need to check ->expmask.\n\t */\n\tif (depth > 0) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmask & rdp->grpmask) {\n\t\t\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, true);\n\t\t\tt->rcu_read_unlock_special.b.exp_hint = true;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\n\t// Finally, negative nesting depth should not happen.\n\tWARN_ON_ONCE(1);\n}"
  },
  {
    "function_name": "wait_rcu_exp_gp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "627-633",
    "snippet": "static void wait_rcu_exp_gp(struct work_struct *wp)\n{\n\tstruct rcu_exp_work *rewp;\n\n\trewp = container_of(wp, struct rcu_exp_work, rew_work);\n\trcu_exp_sel_wait_wake(rewp->rew_s);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_exp_sel_wait_wake",
          "args": [
            "rewp->rew_s"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_sel_wait_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "615-622",
          "snippet": "static void rcu_exp_sel_wait_wake(unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus();\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_sel_wait_wake(unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus();\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wp",
            "structrcu_exp_work",
            "rew_work"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void wait_rcu_exp_gp(struct work_struct *wp)\n{\n\tstruct rcu_exp_work *rewp;\n\n\trewp = container_of(wp, struct rcu_exp_work, rew_work);\n\trcu_exp_sel_wait_wake(rewp->rew_s);\n}"
  },
  {
    "function_name": "rcu_exp_sel_wait_wake",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "615-622",
    "snippet": "static void rcu_exp_sel_wait_wake(unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus();\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_exp_wait_wake",
          "args": [
            "s"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_wait_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "583-609",
          "snippet": "static void rcu_exp_wait_wake(unsigned long s)\n{\n\tstruct rcu_node *rnp;\n\n\tsynchronize_rcu_expedited_wait();\n\n\t// Switch over to wakeup mode, allowing the next GP to proceed.\n\t// End the previous grace period only after acquiring the mutex\n\t// to ensure that only one GP runs concurrently with wakeups.\n\tmutex_lock(&rcu_state.exp_wake_mutex);\n\trcu_exp_gp_seq_end();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"end\"));\n\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s)) {\n\t\t\tspin_lock(&rnp->exp_lock);\n\t\t\t/* Recheck, avoid hang in case someone just arrived. */\n\t\t\tif (ULONG_CMP_LT(rnp->exp_seq_rq, s))\n\t\t\t\tWRITE_ONCE(rnp->exp_seq_rq, s);\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t}\n\t\tsmp_mb(); /* All above changes before wakeup. */\n\t\twake_up_all(&rnp->exp_wq[rcu_seq_ctr(s) & 0x3]);\n\t}\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"endwake\"));\n\tmutex_unlock(&rcu_state.exp_wake_mutex);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void rcu_exp_wait_wake(unsigned long s)\n{\n\tstruct rcu_node *rnp;\n\n\tsynchronize_rcu_expedited_wait();\n\n\t// Switch over to wakeup mode, allowing the next GP to proceed.\n\t// End the previous grace period only after acquiring the mutex\n\t// to ensure that only one GP runs concurrently with wakeups.\n\tmutex_lock(&rcu_state.exp_wake_mutex);\n\trcu_exp_gp_seq_end();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"end\"));\n\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s)) {\n\t\t\tspin_lock(&rnp->exp_lock);\n\t\t\t/* Recheck, avoid hang in case someone just arrived. */\n\t\t\tif (ULONG_CMP_LT(rnp->exp_seq_rq, s))\n\t\t\t\tWRITE_ONCE(rnp->exp_seq_rq, s);\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t}\n\t\tsmp_mb(); /* All above changes before wakeup. */\n\t\twake_up_all(&rnp->exp_wq[rcu_seq_ctr(s) & 0x3]);\n\t}\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"endwake\"));\n\tmutex_unlock(&rcu_state.exp_wake_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_rcu_exp_select_cpus",
          "args": [],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_exp_select_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "424-460",
          "snippet": "static void sync_rcu_exp_select_cpus(void)\n{\n\tint cpu;\n\tstruct rcu_node *rnp;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"reset\"));\n\tsync_exp_reset_tree();\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"select\"));\n\n\t/* Schedule work for each leaf rcu_node structure. */\n\trcu_for_each_leaf_node(rnp) {\n\t\trnp->exp_need_flush = false;\n\t\tif (!READ_ONCE(rnp->expmask))\n\t\t\tcontinue; /* Avoid early boot non-existent wq. */\n\t\tif (!READ_ONCE(rcu_par_gp_wq) ||\n\t\t    rcu_scheduler_active != RCU_SCHEDULER_RUNNING ||\n\t\t    rcu_is_last_leaf_node(rnp)) {\n\t\t\t/* No workqueues yet or last leaf, do direct call. */\n\t\t\tsync_rcu_exp_select_node_cpus(&rnp->rew.rew_work);\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_WORK(&rnp->rew.rew_work, sync_rcu_exp_select_node_cpus);\n\t\tcpu = find_next_bit(&rnp->ffmask, BITS_PER_LONG, -1);\n\t\t/* If all offline, queue the work on an unbound CPU. */\n\t\tif (unlikely(cpu > rnp->grphi - rnp->grplo))\n\t\t\tcpu = WORK_CPU_UNBOUND;\n\t\telse\n\t\t\tcpu += rnp->grplo;\n\t\tqueue_work_on(cpu, rcu_par_gp_wq, &rnp->rew.rew_work);\n\t\trnp->exp_need_flush = true;\n\t}\n\n\t/* Wait for workqueue jobs (if any) to complete. */\n\trcu_for_each_leaf_node(rnp)\n\t\tif (rnp->exp_need_flush)\n\t\t\tflush_work(&rnp->rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void sync_rcu_exp_select_cpus(void)\n{\n\tint cpu;\n\tstruct rcu_node *rnp;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"reset\"));\n\tsync_exp_reset_tree();\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"select\"));\n\n\t/* Schedule work for each leaf rcu_node structure. */\n\trcu_for_each_leaf_node(rnp) {\n\t\trnp->exp_need_flush = false;\n\t\tif (!READ_ONCE(rnp->expmask))\n\t\t\tcontinue; /* Avoid early boot non-existent wq. */\n\t\tif (!READ_ONCE(rcu_par_gp_wq) ||\n\t\t    rcu_scheduler_active != RCU_SCHEDULER_RUNNING ||\n\t\t    rcu_is_last_leaf_node(rnp)) {\n\t\t\t/* No workqueues yet or last leaf, do direct call. */\n\t\t\tsync_rcu_exp_select_node_cpus(&rnp->rew.rew_work);\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_WORK(&rnp->rew.rew_work, sync_rcu_exp_select_node_cpus);\n\t\tcpu = find_next_bit(&rnp->ffmask, BITS_PER_LONG, -1);\n\t\t/* If all offline, queue the work on an unbound CPU. */\n\t\tif (unlikely(cpu > rnp->grphi - rnp->grplo))\n\t\t\tcpu = WORK_CPU_UNBOUND;\n\t\telse\n\t\t\tcpu += rnp->grplo;\n\t\tqueue_work_on(cpu, rcu_par_gp_wq, &rnp->rew.rew_work);\n\t\trnp->exp_need_flush = true;\n\t}\n\n\t/* Wait for workqueue jobs (if any) to complete. */\n\trcu_for_each_leaf_node(rnp)\n\t\tif (rnp->exp_need_flush)\n\t\t\tflush_work(&rnp->rew.rew_work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_sel_wait_wake(unsigned long s)\n{\n\t/* Initialize the rcu_node tree in preparation for the wait. */\n\tsync_rcu_exp_select_cpus();\n\n\t/* Wait and clean up, including waking everyone. */\n\trcu_exp_wait_wake(s);\n}"
  },
  {
    "function_name": "rcu_exp_wait_wake",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "583-609",
    "snippet": "static void rcu_exp_wait_wake(unsigned long s)\n{\n\tstruct rcu_node *rnp;\n\n\tsynchronize_rcu_expedited_wait();\n\n\t// Switch over to wakeup mode, allowing the next GP to proceed.\n\t// End the previous grace period only after acquiring the mutex\n\t// to ensure that only one GP runs concurrently with wakeups.\n\tmutex_lock(&rcu_state.exp_wake_mutex);\n\trcu_exp_gp_seq_end();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"end\"));\n\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s)) {\n\t\t\tspin_lock(&rnp->exp_lock);\n\t\t\t/* Recheck, avoid hang in case someone just arrived. */\n\t\t\tif (ULONG_CMP_LT(rnp->exp_seq_rq, s))\n\t\t\t\tWRITE_ONCE(rnp->exp_seq_rq, s);\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t}\n\t\tsmp_mb(); /* All above changes before wakeup. */\n\t\twake_up_all(&rnp->exp_wq[rcu_seq_ctr(s) & 0x3]);\n\t}\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"endwake\"));\n\tmutex_unlock(&rcu_state.exp_wake_mutex);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_state.exp_wake_mutex"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "s",
            "TPS(\"endwake\")"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"endwake\""
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&rnp->exp_wq[rcu_seq_ctr(s) & 0x3]"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/swait.c",
          "lines": "62-82",
          "snippet": "void swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "s"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "30-33",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rnp->exp_lock"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->exp_seq_rq",
            "s"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rnp->exp_seq_rq",
            "s"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rnp->exp_lock"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "READ_ONCE(rnp->exp_seq_rq)",
            "s"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->exp_seq_rq"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "s",
            "TPS(\"end\")"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"end\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_end",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "35-39",
          "snippet": "static void rcu_exp_gp_seq_end(void)\n{\n\trcu_seq_end(&rcu_state.expedited_sequence);\n\tsmp_mb(); /* Ensure that consecutive grace periods serialize. */\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_gp_seq_end(void)\n{\n\trcu_seq_end(&rcu_state.expedited_sequence);\n\tsmp_mb(); /* Ensure that consecutive grace periods serialize. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_state.exp_wake_mutex"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_expedited_wait",
          "args": [],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "486-575",
          "snippet": "static void synchronize_rcu_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long j;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\tif (tick_nohz_full_enabled() && rcu_inkernel_boot_has_ended()) {\n\t\tif (synchronize_rcu_expedited_wait_once(1))\n\t\t\treturn;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tif (rdp->rcu_forced_tick_exp)\n\t\t\t\t\tcontinue;\n\t\t\t\trdp->rcu_forced_tick_exp = true;\n\t\t\t\tpreempt_disable();\n\t\t\t\tif (cpu_online(cpu))\n\t\t\t\t\ttick_dep_set_cpu(cpu, TICK_DEP_BIT_RCU_EXP);\n\t\t\t\tpreempt_enable();\n\t\t\t}\n\t\t}\n\t\tj = READ_ONCE(jiffies_till_first_fqs);\n\t\tif (synchronize_rcu_expedited_wait_once(j + HZ))\n\t\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tif (synchronize_rcu_expedited_wait_once(jiffies_stall))\n\t\t\treturn;\n\t\tif (rcu_stall_is_suppressed())\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"ExpeditedStall\"));\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(READ_ONCE(rnp->expmask) & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\tdata_race(rnp_root->expmask),\n\t\t\t\".T\"[!!data_race(rnp_root->exp_tasks)]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures (internal RCU debug):\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\tdata_race(rnp->expmask),\n\t\t\t\t\t\".T\"[!!data_race(rnp->exp_tasks)]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(READ_ONCE(rnp->expmask) & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void synchronize_rcu_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long j;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\tif (tick_nohz_full_enabled() && rcu_inkernel_boot_has_ended()) {\n\t\tif (synchronize_rcu_expedited_wait_once(1))\n\t\t\treturn;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tif (rdp->rcu_forced_tick_exp)\n\t\t\t\t\tcontinue;\n\t\t\t\trdp->rcu_forced_tick_exp = true;\n\t\t\t\tpreempt_disable();\n\t\t\t\tif (cpu_online(cpu))\n\t\t\t\t\ttick_dep_set_cpu(cpu, TICK_DEP_BIT_RCU_EXP);\n\t\t\t\tpreempt_enable();\n\t\t\t}\n\t\t}\n\t\tj = READ_ONCE(jiffies_till_first_fqs);\n\t\tif (synchronize_rcu_expedited_wait_once(j + HZ))\n\t\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tif (synchronize_rcu_expedited_wait_once(jiffies_stall))\n\t\t\treturn;\n\t\tif (rcu_stall_is_suppressed())\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"ExpeditedStall\"));\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(READ_ONCE(rnp->expmask) & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\tdata_race(rnp_root->expmask),\n\t\t\t\".T\"[!!data_race(rnp_root->exp_tasks)]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures (internal RCU debug):\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\tdata_race(rnp->expmask),\n\t\t\t\t\t\".T\"[!!data_race(rnp->exp_tasks)]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(READ_ONCE(rnp->expmask) & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void rcu_exp_wait_wake(unsigned long s)\n{\n\tstruct rcu_node *rnp;\n\n\tsynchronize_rcu_expedited_wait();\n\n\t// Switch over to wakeup mode, allowing the next GP to proceed.\n\t// End the previous grace period only after acquiring the mutex\n\t// to ensure that only one GP runs concurrently with wakeups.\n\tmutex_lock(&rcu_state.exp_wake_mutex);\n\trcu_exp_gp_seq_end();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"end\"));\n\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s)) {\n\t\t\tspin_lock(&rnp->exp_lock);\n\t\t\t/* Recheck, avoid hang in case someone just arrived. */\n\t\t\tif (ULONG_CMP_LT(rnp->exp_seq_rq, s))\n\t\t\t\tWRITE_ONCE(rnp->exp_seq_rq, s);\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t}\n\t\tsmp_mb(); /* All above changes before wakeup. */\n\t\twake_up_all(&rnp->exp_wq[rcu_seq_ctr(s) & 0x3]);\n\t}\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"endwake\"));\n\tmutex_unlock(&rcu_state.exp_wake_mutex);\n}"
  },
  {
    "function_name": "synchronize_rcu_expedited_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "486-575",
    "snippet": "static void synchronize_rcu_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long j;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\tif (tick_nohz_full_enabled() && rcu_inkernel_boot_has_ended()) {\n\t\tif (synchronize_rcu_expedited_wait_once(1))\n\t\t\treturn;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tif (rdp->rcu_forced_tick_exp)\n\t\t\t\t\tcontinue;\n\t\t\t\trdp->rcu_forced_tick_exp = true;\n\t\t\t\tpreempt_disable();\n\t\t\t\tif (cpu_online(cpu))\n\t\t\t\t\ttick_dep_set_cpu(cpu, TICK_DEP_BIT_RCU_EXP);\n\t\t\t\tpreempt_enable();\n\t\t\t}\n\t\t}\n\t\tj = READ_ONCE(jiffies_till_first_fqs);\n\t\tif (synchronize_rcu_expedited_wait_once(j + HZ))\n\t\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tif (synchronize_rcu_expedited_wait_once(jiffies_stall))\n\t\t\treturn;\n\t\tif (rcu_stall_is_suppressed())\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"ExpeditedStall\"));\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(READ_ONCE(rnp->expmask) & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\tdata_race(rnp_root->expmask),\n\t\t\t\".T\"[!!data_race(rnp_root->exp_tasks)]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures (internal RCU debug):\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\tdata_race(rnp->expmask),\n\t\t\t\t\t\".T\"[!!data_race(rnp->exp_tasks)]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(READ_ONCE(rnp->expmask) & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "29-45",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t\t0",
            "#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\n#define RCU_STALL_DELAY_DELTA\t\t0\n#define RCU_STALL_DELAY_DELTA\t\t(5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_cpu_task",
          "args": [
            "cpu"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cpu_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "10875-10879",
          "snippet": "void dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->expmask"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" l=%u:%d-%d:%#lx/%c\"",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "data_race(rnp->expmask)",
            "\".T\"[!!data_race(rnp->exp_tasks)]"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "rnp->exp_tasks"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_rcu_exp_done_unlocked",
          "args": [
            "rnp"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_exp_done_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "161-171",
          "snippet": "static bool sync_rcu_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic bool sync_rcu_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"blocking rcu_node structures (internal RCU debug):\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" } %lu jiffies s: %lu root: %#lx/%c\\n\"",
            "jiffies - jiffies_start",
            "rcu_state.expedited_sequence",
            "data_race(rnp_root->expmask)",
            "\".T\"[!!data_race(rnp_root->exp_tasks)]"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %d-%c%c%c\"",
            "cpu",
            "\"O.\"[!!cpu_online(cpu)]",
            "\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)]",
            "\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->expmask"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_print_task_exp_stall",
          "args": [
            "rnp"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_print_task_exp_stall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "789-792",
          "snippet": "static int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: %s detected expedited stalls on CPUs/tasks: {\"",
            "rcu_state.name"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_stall_warning",
          "args": [
            "rcu_state.name",
            "TPS(\"ExpeditedStall\")"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"ExpeditedStall\""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic_on_rcu_stall",
          "args": [],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "panic_on_rcu_stall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_stall.h",
          "lines": "110-119",
          "snippet": "static void panic_on_rcu_stall(void)\n{\n\tstatic int cpu_stall;\n\n\tif (++cpu_stall < sysctl_max_rcu_stall_to_panic)\n\t\treturn;\n\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}",
          "includes": [
            "#include <linux/kvm_para.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_panic_on_rcu_stall",
            "int sysctl_max_rcu_stall_to_panic"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n\nint sysctl_panic_on_rcu_stall;\nint sysctl_max_rcu_stall_to_panic;\n\nstatic void panic_on_rcu_stall(void)\n{\n\tstatic int cpu_stall;\n\n\tif (++cpu_stall < sysctl_max_rcu_stall_to_panic)\n\t\treturn;\n\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_stall_is_suppressed",
          "args": [],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_is_suppressed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "234-237",
          "snippet": "static inline bool rcu_stall_is_suppressed(void)\n{\n\treturn rcu_stall_is_suppressed_at_boot();\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_stall_is_suppressed(void)\n{\n\treturn rcu_stall_is_suppressed_at_boot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_expedited_wait_once",
          "args": [
            "jiffies_stall"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited_wait_once",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "467-480",
          "snippet": "static bool synchronize_rcu_expedited_wait_once(long tlimit)\n{\n\tint t;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\tt = swait_event_timeout_exclusive(rcu_state.expedited_wq,\n\t\t\t\t\t  sync_rcu_exp_done_unlocked(rnp_root),\n\t\t\t\t\t  tlimit);\n\t// Workqueues should not be signaled.\n\tif (t > 0 || sync_rcu_exp_done_unlocked(rnp_root))\n\t\treturn true;\n\tWARN_ON(t < 0);  /* workqueues should not be signaled. */\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool synchronize_rcu_expedited_wait_once(long tlimit)\n{\n\tint t;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\tt = swait_event_timeout_exclusive(rcu_state.expedited_wq,\n\t\t\t\t\t  sync_rcu_exp_done_unlocked(rnp_root),\n\t\t\t\t\t  tlimit);\n\t// Workqueues should not be signaled.\n\tif (t > 0 || sync_rcu_exp_done_unlocked(rnp_root))\n\t\treturn true;\n\tWARN_ON(t < 0);  /* workqueues should not be signaled. */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_till_first_fqs"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_dep_set_cpu",
          "args": [
            "cpu",
            "TICK_DEP_BIT_RCU_EXP"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_cpu_mask",
          "args": [
            "rnp",
            "cpu",
            "rnp->expmask"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_inkernel_boot_has_ended",
          "args": [],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_inkernel_boot_has_ended",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "206-209",
          "snippet": "bool rcu_inkernel_boot_has_ended(void)\n{\n\treturn rcu_boot_ended;\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_inkernel_boot_has_ended(void)\n{\n\treturn rcu_boot_ended;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_enabled",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_exp_gp_seq_endval()",
            "TPS(\"startwait\")"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"startwait\""
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_endval",
          "args": [],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_endval",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "27-30",
          "snippet": "static __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __maybe_unused"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __maybe_unused;\n\nstatic __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void synchronize_rcu_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long j;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\tif (tick_nohz_full_enabled() && rcu_inkernel_boot_has_ended()) {\n\t\tif (synchronize_rcu_expedited_wait_once(1))\n\t\t\treturn;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tif (rdp->rcu_forced_tick_exp)\n\t\t\t\t\tcontinue;\n\t\t\t\trdp->rcu_forced_tick_exp = true;\n\t\t\t\tpreempt_disable();\n\t\t\t\tif (cpu_online(cpu))\n\t\t\t\t\ttick_dep_set_cpu(cpu, TICK_DEP_BIT_RCU_EXP);\n\t\t\t\tpreempt_enable();\n\t\t\t}\n\t\t}\n\t\tj = READ_ONCE(jiffies_till_first_fqs);\n\t\tif (synchronize_rcu_expedited_wait_once(j + HZ))\n\t\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tif (synchronize_rcu_expedited_wait_once(jiffies_stall))\n\t\t\treturn;\n\t\tif (rcu_stall_is_suppressed())\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\ttrace_rcu_stall_warning(rcu_state.name, TPS(\"ExpeditedStall\"));\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(READ_ONCE(rnp->expmask) & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\tdata_race(rnp_root->expmask),\n\t\t\t\".T\"[!!data_race(rnp_root->exp_tasks)]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures (internal RCU debug):\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\tdata_race(rnp->expmask),\n\t\t\t\t\t\".T\"[!!data_race(rnp->exp_tasks)]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(READ_ONCE(rnp->expmask) & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
  },
  {
    "function_name": "synchronize_rcu_expedited_wait_once",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "467-480",
    "snippet": "static bool synchronize_rcu_expedited_wait_once(long tlimit)\n{\n\tint t;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\tt = swait_event_timeout_exclusive(rcu_state.expedited_wq,\n\t\t\t\t\t  sync_rcu_exp_done_unlocked(rnp_root),\n\t\t\t\t\t  tlimit);\n\t// Workqueues should not be signaled.\n\tif (t > 0 || sync_rcu_exp_done_unlocked(rnp_root))\n\t\treturn true;\n\tWARN_ON(t < 0);  /* workqueues should not be signaled. */\n\treturn false;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "t < 0"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_rcu_exp_done_unlocked",
          "args": [
            "rnp_root"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_exp_done_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "161-171",
          "snippet": "static bool sync_rcu_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic bool sync_rcu_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swait_event_timeout_exclusive",
          "args": [
            "rcu_state.expedited_wq",
            "sync_rcu_exp_done_unlocked(rnp_root)",
            "tlimit"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool synchronize_rcu_expedited_wait_once(long tlimit)\n{\n\tint t;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\tt = swait_event_timeout_exclusive(rcu_state.expedited_wq,\n\t\t\t\t\t  sync_rcu_exp_done_unlocked(rnp_root),\n\t\t\t\t\t  tlimit);\n\t// Workqueues should not be signaled.\n\tif (t > 0 || sync_rcu_exp_done_unlocked(rnp_root))\n\t\treturn true;\n\tWARN_ON(t < 0);  /* workqueues should not be signaled. */\n\treturn false;\n}"
  },
  {
    "function_name": "sync_rcu_exp_select_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "424-460",
    "snippet": "static void sync_rcu_exp_select_cpus(void)\n{\n\tint cpu;\n\tstruct rcu_node *rnp;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"reset\"));\n\tsync_exp_reset_tree();\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"select\"));\n\n\t/* Schedule work for each leaf rcu_node structure. */\n\trcu_for_each_leaf_node(rnp) {\n\t\trnp->exp_need_flush = false;\n\t\tif (!READ_ONCE(rnp->expmask))\n\t\t\tcontinue; /* Avoid early boot non-existent wq. */\n\t\tif (!READ_ONCE(rcu_par_gp_wq) ||\n\t\t    rcu_scheduler_active != RCU_SCHEDULER_RUNNING ||\n\t\t    rcu_is_last_leaf_node(rnp)) {\n\t\t\t/* No workqueues yet or last leaf, do direct call. */\n\t\t\tsync_rcu_exp_select_node_cpus(&rnp->rew.rew_work);\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_WORK(&rnp->rew.rew_work, sync_rcu_exp_select_node_cpus);\n\t\tcpu = find_next_bit(&rnp->ffmask, BITS_PER_LONG, -1);\n\t\t/* If all offline, queue the work on an unbound CPU. */\n\t\tif (unlikely(cpu > rnp->grphi - rnp->grplo))\n\t\t\tcpu = WORK_CPU_UNBOUND;\n\t\telse\n\t\t\tcpu += rnp->grplo;\n\t\tqueue_work_on(cpu, rcu_par_gp_wq, &rnp->rew.rew_work);\n\t\trnp->exp_need_flush = true;\n\t}\n\n\t/* Wait for workqueue jobs (if any) to complete. */\n\trcu_for_each_leaf_node(rnp)\n\t\tif (rnp->exp_need_flush)\n\t\t\tflush_work(&rnp->rew.rew_work);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&rnp->rew.rew_work"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3112-3115",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "cpu",
            "rcu_par_gp_wq",
            "&rnp->rew.rew_work"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1553-1568",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpu > rnp->grphi - rnp->grplo"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "&rnp->ffmask",
            "BITS_PER_LONG",
            "-1"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&rnp->rew.rew_work",
            "sync_rcu_exp_select_node_cpus"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_rcu_exp_select_node_cpus",
          "args": [
            "&rnp->rew.rew_work"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_exp_select_node_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "337-418",
          "snippet": "static void sync_rcu_exp_select_node_cpus(struct work_struct *wp)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask_ofl_test;\n\tunsigned long mask_ofl_ipi;\n\tint ret;\n\tstruct rcu_exp_work *rewp =\n\t\tcontainer_of(wp, struct rcu_exp_work, rew_work);\n\tstruct rcu_node *rnp = container_of(rewp, struct rcu_node, rew);\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\n\t/* Each pass checks a CPU for identity, offline, and idle. */\n\tmask_ofl_test = 0;\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tunsigned long mask = rdp->grpmask;\n\t\tint snap;\n\n\t\tif (raw_smp_processor_id() == cpu ||\n\t\t    !(rnp->qsmaskinitnext & mask)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t} else {\n\t\t\tsnap = rcu_dynticks_snap(rdp);\n\t\t\tif (rcu_dynticks_in_eqs(snap))\n\t\t\t\tmask_ofl_test |= mask;\n\t\t\telse\n\t\t\t\trdp->exp_dynticks_snap = snap;\n\t\t}\n\t}\n\tmask_ofl_ipi = rnp->expmask & ~mask_ofl_test;\n\n\t/*\n\t * Need to wait for any blocked tasks as well.\tNote that\n\t * additional blocking tasks will also block the expedited GP\n\t * until such time as the ->expmask bits are cleared.\n\t */\n\tif (rcu_preempt_has_tasks(rnp))\n\t\tWRITE_ONCE(rnp->exp_tasks, rnp->blkd_tasks.next);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t/* IPI the remaining CPUs for expedited quiescent state. */\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, mask_ofl_ipi) {\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tunsigned long mask = rdp->grpmask;\n\nretry_ipi:\n\t\tif (rcu_dynticks_in_eqs_since(rdp, rdp->exp_dynticks_snap)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tcontinue;\n\t\t}\n\t\tif (get_cpu() == cpu) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tput_cpu();\n\t\t\tcontinue;\n\t\t}\n\t\tret = smp_call_function_single(cpu, rcu_exp_handler, NULL, 0);\n\t\tput_cpu();\n\t\t/* The CPU will report the QS in response to the IPI. */\n\t\tif (!ret)\n\t\t\tcontinue;\n\n\t\t/* Failed, raced with CPU hotplug operation. */\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif ((rnp->qsmaskinitnext & mask) &&\n\t\t    (rnp->expmask & mask)) {\n\t\t\t/* Online, so delay for a bit and try again. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"selectofl\"));\n\t\t\tschedule_timeout_idle(1);\n\t\t\tgoto retry_ipi;\n\t\t}\n\t\t/* CPU really is offline, so we must report its QS. */\n\t\tif (rnp->expmask & mask)\n\t\t\tmask_ofl_test |= mask;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\t/* Report quiescent states for those that went offline. */\n\tif (mask_ofl_test)\n\t\trcu_report_exp_cpu_mult(rnp, mask_ofl_test, false);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void sync_rcu_exp_select_node_cpus(struct work_struct *wp)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask_ofl_test;\n\tunsigned long mask_ofl_ipi;\n\tint ret;\n\tstruct rcu_exp_work *rewp =\n\t\tcontainer_of(wp, struct rcu_exp_work, rew_work);\n\tstruct rcu_node *rnp = container_of(rewp, struct rcu_node, rew);\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\n\t/* Each pass checks a CPU for identity, offline, and idle. */\n\tmask_ofl_test = 0;\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tunsigned long mask = rdp->grpmask;\n\t\tint snap;\n\n\t\tif (raw_smp_processor_id() == cpu ||\n\t\t    !(rnp->qsmaskinitnext & mask)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t} else {\n\t\t\tsnap = rcu_dynticks_snap(rdp);\n\t\t\tif (rcu_dynticks_in_eqs(snap))\n\t\t\t\tmask_ofl_test |= mask;\n\t\t\telse\n\t\t\t\trdp->exp_dynticks_snap = snap;\n\t\t}\n\t}\n\tmask_ofl_ipi = rnp->expmask & ~mask_ofl_test;\n\n\t/*\n\t * Need to wait for any blocked tasks as well.\tNote that\n\t * additional blocking tasks will also block the expedited GP\n\t * until such time as the ->expmask bits are cleared.\n\t */\n\tif (rcu_preempt_has_tasks(rnp))\n\t\tWRITE_ONCE(rnp->exp_tasks, rnp->blkd_tasks.next);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t/* IPI the remaining CPUs for expedited quiescent state. */\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, mask_ofl_ipi) {\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tunsigned long mask = rdp->grpmask;\n\nretry_ipi:\n\t\tif (rcu_dynticks_in_eqs_since(rdp, rdp->exp_dynticks_snap)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tcontinue;\n\t\t}\n\t\tif (get_cpu() == cpu) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tput_cpu();\n\t\t\tcontinue;\n\t\t}\n\t\tret = smp_call_function_single(cpu, rcu_exp_handler, NULL, 0);\n\t\tput_cpu();\n\t\t/* The CPU will report the QS in response to the IPI. */\n\t\tif (!ret)\n\t\t\tcontinue;\n\n\t\t/* Failed, raced with CPU hotplug operation. */\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif ((rnp->qsmaskinitnext & mask) &&\n\t\t    (rnp->expmask & mask)) {\n\t\t\t/* Online, so delay for a bit and try again. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"selectofl\"));\n\t\t\tschedule_timeout_idle(1);\n\t\t\tgoto retry_ipi;\n\t\t}\n\t\t/* CPU really is offline, so we must report its QS. */\n\t\tif (rnp->expmask & mask)\n\t\t\tmask_ofl_test |= mask;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\t/* Report quiescent states for those that went offline. */\n\tif (mask_ofl_test)\n\t\trcu_report_exp_cpu_mult(rnp, mask_ofl_test, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_last_leaf_node",
          "args": [
            "rnp"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_par_gp_wq"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->expmask"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_exp_gp_seq_endval()",
            "TPS(\"select\")"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"select\""
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_endval",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_endval",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "27-30",
          "snippet": "static __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __maybe_unused"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __maybe_unused;\n\nstatic __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_exp_reset_tree",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "sync_exp_reset_tree_hotplug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "73-124",
          "snippet": "static void sync_exp_reset_tree_hotplug(void)\n{\n\tbool done;\n\tunsigned long flags;\n\tunsigned long mask;\n\tunsigned long oldmask;\n\tint ncpus = smp_load_acquire(&rcu_state.ncpus); /* Order vs. locking. */\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_up;\n\n\t/* If no new CPUs onlined since last time, nothing to do. */\n\tif (likely(ncpus == rcu_state.ncpus_snap))\n\t\treturn;\n\trcu_state.ncpus_snap = ncpus;\n\n\t/*\n\t * Each pass through the following loop propagates newly onlined\n\t * CPUs for the current rcu_node structure up the rcu_node tree.\n\t */\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmaskinit == rnp->expmaskinitnext) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;  /* No new CPUs, nothing to do. */\n\t\t}\n\n\t\t/* Update this node's mask, track old value for propagation. */\n\t\toldmask = rnp->expmaskinit;\n\t\trnp->expmaskinit = rnp->expmaskinitnext;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t\t/* If was already nonzero, nothing to propagate. */\n\t\tif (oldmask)\n\t\t\tcontinue;\n\n\t\t/* Propagate the new CPU up the tree. */\n\t\tmask = rnp->grpmask;\n\t\trnp_up = rnp->parent;\n\t\tdone = false;\n\t\twhile (rnp_up) {\n\t\t\traw_spin_lock_irqsave_rcu_node(rnp_up, flags);\n\t\t\tif (rnp_up->expmaskinit)\n\t\t\t\tdone = true;\n\t\t\trnp_up->expmaskinit |= mask;\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp_up, flags);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t\tmask = rnp_up->grpmask;\n\t\t\trnp_up = rnp_up->parent;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void sync_exp_reset_tree_hotplug(void)\n{\n\tbool done;\n\tunsigned long flags;\n\tunsigned long mask;\n\tunsigned long oldmask;\n\tint ncpus = smp_load_acquire(&rcu_state.ncpus); /* Order vs. locking. */\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_up;\n\n\t/* If no new CPUs onlined since last time, nothing to do. */\n\tif (likely(ncpus == rcu_state.ncpus_snap))\n\t\treturn;\n\trcu_state.ncpus_snap = ncpus;\n\n\t/*\n\t * Each pass through the following loop propagates newly onlined\n\t * CPUs for the current rcu_node structure up the rcu_node tree.\n\t */\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmaskinit == rnp->expmaskinitnext) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;  /* No new CPUs, nothing to do. */\n\t\t}\n\n\t\t/* Update this node's mask, track old value for propagation. */\n\t\toldmask = rnp->expmaskinit;\n\t\trnp->expmaskinit = rnp->expmaskinitnext;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t\t/* If was already nonzero, nothing to propagate. */\n\t\tif (oldmask)\n\t\t\tcontinue;\n\n\t\t/* Propagate the new CPU up the tree. */\n\t\tmask = rnp->grpmask;\n\t\trnp_up = rnp->parent;\n\t\tdone = false;\n\t\twhile (rnp_up) {\n\t\t\traw_spin_lock_irqsave_rcu_node(rnp_up, flags);\n\t\t\tif (rnp_up->expmaskinit)\n\t\t\t\tdone = true;\n\t\t\trnp_up->expmaskinit |= mask;\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp_up, flags);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t\tmask = rnp_up->grpmask;\n\t\t\trnp_up = rnp_up->parent;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_exp_gp_seq_endval()",
            "TPS(\"reset\")"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"reset\""
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void sync_rcu_exp_select_cpus(void)\n{\n\tint cpu;\n\tstruct rcu_node *rnp;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"reset\"));\n\tsync_exp_reset_tree();\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"select\"));\n\n\t/* Schedule work for each leaf rcu_node structure. */\n\trcu_for_each_leaf_node(rnp) {\n\t\trnp->exp_need_flush = false;\n\t\tif (!READ_ONCE(rnp->expmask))\n\t\t\tcontinue; /* Avoid early boot non-existent wq. */\n\t\tif (!READ_ONCE(rcu_par_gp_wq) ||\n\t\t    rcu_scheduler_active != RCU_SCHEDULER_RUNNING ||\n\t\t    rcu_is_last_leaf_node(rnp)) {\n\t\t\t/* No workqueues yet or last leaf, do direct call. */\n\t\t\tsync_rcu_exp_select_node_cpus(&rnp->rew.rew_work);\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_WORK(&rnp->rew.rew_work, sync_rcu_exp_select_node_cpus);\n\t\tcpu = find_next_bit(&rnp->ffmask, BITS_PER_LONG, -1);\n\t\t/* If all offline, queue the work on an unbound CPU. */\n\t\tif (unlikely(cpu > rnp->grphi - rnp->grplo))\n\t\t\tcpu = WORK_CPU_UNBOUND;\n\t\telse\n\t\t\tcpu += rnp->grplo;\n\t\tqueue_work_on(cpu, rcu_par_gp_wq, &rnp->rew.rew_work);\n\t\trnp->exp_need_flush = true;\n\t}\n\n\t/* Wait for workqueue jobs (if any) to complete. */\n\trcu_for_each_leaf_node(rnp)\n\t\tif (rnp->exp_need_flush)\n\t\t\tflush_work(&rnp->rew.rew_work);\n}"
  },
  {
    "function_name": "sync_rcu_exp_select_node_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "337-418",
    "snippet": "static void sync_rcu_exp_select_node_cpus(struct work_struct *wp)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask_ofl_test;\n\tunsigned long mask_ofl_ipi;\n\tint ret;\n\tstruct rcu_exp_work *rewp =\n\t\tcontainer_of(wp, struct rcu_exp_work, rew_work);\n\tstruct rcu_node *rnp = container_of(rewp, struct rcu_node, rew);\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\n\t/* Each pass checks a CPU for identity, offline, and idle. */\n\tmask_ofl_test = 0;\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tunsigned long mask = rdp->grpmask;\n\t\tint snap;\n\n\t\tif (raw_smp_processor_id() == cpu ||\n\t\t    !(rnp->qsmaskinitnext & mask)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t} else {\n\t\t\tsnap = rcu_dynticks_snap(rdp);\n\t\t\tif (rcu_dynticks_in_eqs(snap))\n\t\t\t\tmask_ofl_test |= mask;\n\t\t\telse\n\t\t\t\trdp->exp_dynticks_snap = snap;\n\t\t}\n\t}\n\tmask_ofl_ipi = rnp->expmask & ~mask_ofl_test;\n\n\t/*\n\t * Need to wait for any blocked tasks as well.\tNote that\n\t * additional blocking tasks will also block the expedited GP\n\t * until such time as the ->expmask bits are cleared.\n\t */\n\tif (rcu_preempt_has_tasks(rnp))\n\t\tWRITE_ONCE(rnp->exp_tasks, rnp->blkd_tasks.next);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t/* IPI the remaining CPUs for expedited quiescent state. */\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, mask_ofl_ipi) {\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tunsigned long mask = rdp->grpmask;\n\nretry_ipi:\n\t\tif (rcu_dynticks_in_eqs_since(rdp, rdp->exp_dynticks_snap)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tcontinue;\n\t\t}\n\t\tif (get_cpu() == cpu) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tput_cpu();\n\t\t\tcontinue;\n\t\t}\n\t\tret = smp_call_function_single(cpu, rcu_exp_handler, NULL, 0);\n\t\tput_cpu();\n\t\t/* The CPU will report the QS in response to the IPI. */\n\t\tif (!ret)\n\t\t\tcontinue;\n\n\t\t/* Failed, raced with CPU hotplug operation. */\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif ((rnp->qsmaskinitnext & mask) &&\n\t\t    (rnp->expmask & mask)) {\n\t\t\t/* Online, so delay for a bit and try again. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"selectofl\"));\n\t\t\tschedule_timeout_idle(1);\n\t\t\tgoto retry_ipi;\n\t\t}\n\t\t/* CPU really is offline, so we must report its QS. */\n\t\tif (rnp->expmask & mask)\n\t\t\tmask_ofl_test |= mask;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\t/* Report quiescent states for those that went offline. */\n\tif (mask_ofl_test)\n\t\trcu_report_exp_cpu_mult(rnp, mask_ofl_test, false);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_report_exp_cpu_mult",
          "args": [
            "rnp",
            "mask_ofl_test",
            "false"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_cpu_mult",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "230-251",
          "snippet": "static void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (!IS_ENABLED(CONFIG_NO_HZ_FULL) || !rdp->rcu_forced_tick_exp)\n\t\t\tcontinue;\n\t\trdp->rcu_forced_tick_exp = false;\n\t\ttick_dep_clear_cpu(cpu, TICK_DEP_BIT_RCU_EXP);\n\t}\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (!IS_ENABLED(CONFIG_NO_HZ_FULL) || !rdp->rcu_forced_tick_exp)\n\t\t\tcontinue;\n\t\trdp->rcu_forced_tick_exp = false;\n\t\ttick_dep_clear_cpu(cpu, TICK_DEP_BIT_RCU_EXP);\n\t}\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_idle",
          "args": [
            "1"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1923-1927",
          "snippet": "signed long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_exp_gp_seq_endval()",
            "TPS(\"selectofl\")"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"selectofl\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_endval",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_endval",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "27-30",
          "snippet": "static __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __maybe_unused"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __maybe_unused;\n\nstatic __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "rcu_exp_handler",
            "NULL",
            "0"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "12-25",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "120-126",
          "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_kthread_data hwlat_single_cpu_data;",
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs_since",
          "args": [
            "rdp",
            "rdp->exp_dynticks_snap"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs_since",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "365-368",
          "snippet": "static bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_cpu_mask",
          "args": [
            "rnp",
            "cpu",
            "mask_ofl_ipi"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->exp_tasks",
            "rnp->blkd_tasks.next"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_has_tasks",
          "args": [
            "rnp"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_has_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "915-918",
          "snippet": "static bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs",
          "args": [
            "snap"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "347-350",
          "snippet": "static bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & 0x1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_snap",
          "args": [
            "rdp"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "337-341",
          "snippet": "static int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_rdp_is_offloaded(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(1),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_RCU_CORE,\n#endif\n};\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tsmp_mb();  // Fundamental RCU ordering guarantee.\n\treturn atomic_read_acquire(&rdp->dynticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_cpu_mask",
          "args": [
            "rnp",
            "cpu",
            "rnp->expmask"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rewp",
            "structrcu_node",
            "rew"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wp",
            "structrcu_exp_work",
            "rew_work"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void sync_rcu_exp_select_node_cpus(struct work_struct *wp)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask_ofl_test;\n\tunsigned long mask_ofl_ipi;\n\tint ret;\n\tstruct rcu_exp_work *rewp =\n\t\tcontainer_of(wp, struct rcu_exp_work, rew_work);\n\tstruct rcu_node *rnp = container_of(rewp, struct rcu_node, rew);\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\n\t/* Each pass checks a CPU for identity, offline, and idle. */\n\tmask_ofl_test = 0;\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->expmask) {\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tunsigned long mask = rdp->grpmask;\n\t\tint snap;\n\n\t\tif (raw_smp_processor_id() == cpu ||\n\t\t    !(rnp->qsmaskinitnext & mask)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t} else {\n\t\t\tsnap = rcu_dynticks_snap(rdp);\n\t\t\tif (rcu_dynticks_in_eqs(snap))\n\t\t\t\tmask_ofl_test |= mask;\n\t\t\telse\n\t\t\t\trdp->exp_dynticks_snap = snap;\n\t\t}\n\t}\n\tmask_ofl_ipi = rnp->expmask & ~mask_ofl_test;\n\n\t/*\n\t * Need to wait for any blocked tasks as well.\tNote that\n\t * additional blocking tasks will also block the expedited GP\n\t * until such time as the ->expmask bits are cleared.\n\t */\n\tif (rcu_preempt_has_tasks(rnp))\n\t\tWRITE_ONCE(rnp->exp_tasks, rnp->blkd_tasks.next);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t/* IPI the remaining CPUs for expedited quiescent state. */\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, mask_ofl_ipi) {\n\t\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tunsigned long mask = rdp->grpmask;\n\nretry_ipi:\n\t\tif (rcu_dynticks_in_eqs_since(rdp, rdp->exp_dynticks_snap)) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tcontinue;\n\t\t}\n\t\tif (get_cpu() == cpu) {\n\t\t\tmask_ofl_test |= mask;\n\t\t\tput_cpu();\n\t\t\tcontinue;\n\t\t}\n\t\tret = smp_call_function_single(cpu, rcu_exp_handler, NULL, 0);\n\t\tput_cpu();\n\t\t/* The CPU will report the QS in response to the IPI. */\n\t\tif (!ret)\n\t\t\tcontinue;\n\n\t\t/* Failed, raced with CPU hotplug operation. */\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif ((rnp->qsmaskinitnext & mask) &&\n\t\t    (rnp->expmask & mask)) {\n\t\t\t/* Online, so delay for a bit and try again. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"selectofl\"));\n\t\t\tschedule_timeout_idle(1);\n\t\t\tgoto retry_ipi;\n\t\t}\n\t\t/* CPU really is offline, so we must report its QS. */\n\t\tif (rnp->expmask & mask)\n\t\t\tmask_ofl_test |= mask;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\t/* Report quiescent states for those that went offline. */\n\tif (mask_ofl_test)\n\t\trcu_report_exp_cpu_mult(rnp, mask_ofl_test, false);\n}"
  },
  {
    "function_name": "exp_funnel_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "280-331",
    "snippet": "static bool exp_funnel_lock(unsigned long s)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\t/* Low-contention fastpath. */\n\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s) &&\n\t    (rnp == rnp_root ||\n\t     ULONG_CMP_LT(READ_ONCE(rnp_root->exp_seq_rq), s)) &&\n\t    mutex_trylock(&rcu_state.exp_mutex))\n\t\tgoto fastpath;\n\n\t/*\n\t * Each pass through the following loop works its way up\n\t * the rcu_node tree, returning if others have done the work or\n\t * otherwise falls through to acquire ->exp_mutex.  The mapping\n\t * from CPU to rcu_node structure can be inexact, as it is just\n\t * promoting locality and is not strictly needed for correctness.\n\t */\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tif (sync_exp_work_done(s))\n\t\t\treturn true;\n\n\t\t/* Work not done, either wait here or go up. */\n\t\tspin_lock(&rnp->exp_lock);\n\t\tif (ULONG_CMP_GE(rnp->exp_seq_rq, s)) {\n\n\t\t\t/* Someone else doing GP, so wait for them. */\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t\t  rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t  TPS(\"wait\"));\n\t\t\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t\t\t   sync_exp_work_done(s));\n\t\t\treturn true;\n\t\t}\n\t\tWRITE_ONCE(rnp->exp_seq_rq, s); /* Followers can wait on us. */\n\t\tspin_unlock(&rnp->exp_lock);\n\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t  rnp->grplo, rnp->grphi, TPS(\"nxtlvl\"));\n\t}\n\tmutex_lock(&rcu_state.exp_mutex);\nfastpath:\n\tif (sync_exp_work_done(s)) {\n\t\tmutex_unlock(&rcu_state.exp_mutex);\n\t\treturn true;\n\t}\n\trcu_exp_gp_seq_start();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"start\"));\n\treturn false;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "s",
            "TPS(\"start\")"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"start\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_start",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "18-21",
          "snippet": "static void rcu_exp_gp_seq_start(void)\n{\n\trcu_seq_start(&rcu_state.expedited_sequence);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_gp_seq_start(void)\n{\n\trcu_seq_start(&rcu_state.expedited_sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_state.exp_mutex"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_exp_work_done",
          "args": [
            "s"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "sync_exp_work_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "263-271",
          "snippet": "static bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\tsmp_mb(); /* Ensure test happens before caller kfree(). */\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\tsmp_mb(); /* Ensure test happens before caller kfree(). */\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_state.exp_mutex"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_funnel_lock",
          "args": [
            "rcu_state.name",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "TPS(\"nxtlvl\")"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"nxtlvl\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rnp->exp_lock"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->exp_seq_rq",
            "s"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "rnp->exp_wq[rcu_seq_ctr(s) & 0x3]",
            "sync_exp_work_done(s)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "s"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "30-33",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_funnel_lock",
          "args": [
            "rcu_state.name",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "TPS(\"wait\")"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"wait\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rnp->exp_seq_rq",
            "s"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rnp->exp_lock"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&rcu_state.exp_mutex"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1278-1284",
          "snippet": "static __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "READ_ONCE(rnp_root->exp_seq_rq)",
            "s"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp_root->exp_seq_rq"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "READ_ONCE(rnp->exp_seq_rq)",
            "s"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->exp_seq_rq"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "579-582",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "raw_smp_processor_id()"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic bool exp_funnel_lock(unsigned long s)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, raw_smp_processor_id());\n\tstruct rcu_node *rnp = rdp->mynode;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\n\t/* Low-contention fastpath. */\n\tif (ULONG_CMP_LT(READ_ONCE(rnp->exp_seq_rq), s) &&\n\t    (rnp == rnp_root ||\n\t     ULONG_CMP_LT(READ_ONCE(rnp_root->exp_seq_rq), s)) &&\n\t    mutex_trylock(&rcu_state.exp_mutex))\n\t\tgoto fastpath;\n\n\t/*\n\t * Each pass through the following loop works its way up\n\t * the rcu_node tree, returning if others have done the work or\n\t * otherwise falls through to acquire ->exp_mutex.  The mapping\n\t * from CPU to rcu_node structure can be inexact, as it is just\n\t * promoting locality and is not strictly needed for correctness.\n\t */\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tif (sync_exp_work_done(s))\n\t\t\treturn true;\n\n\t\t/* Work not done, either wait here or go up. */\n\t\tspin_lock(&rnp->exp_lock);\n\t\tif (ULONG_CMP_GE(rnp->exp_seq_rq, s)) {\n\n\t\t\t/* Someone else doing GP, so wait for them. */\n\t\t\tspin_unlock(&rnp->exp_lock);\n\t\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t\t  rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t  TPS(\"wait\"));\n\t\t\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t\t\t   sync_exp_work_done(s));\n\t\t\treturn true;\n\t\t}\n\t\tWRITE_ONCE(rnp->exp_seq_rq, s); /* Followers can wait on us. */\n\t\tspin_unlock(&rnp->exp_lock);\n\t\ttrace_rcu_exp_funnel_lock(rcu_state.name, rnp->level,\n\t\t\t\t\t  rnp->grplo, rnp->grphi, TPS(\"nxtlvl\"));\n\t}\n\tmutex_lock(&rcu_state.exp_mutex);\nfastpath:\n\tif (sync_exp_work_done(s)) {\n\t\tmutex_unlock(&rcu_state.exp_mutex);\n\t\treturn true;\n\t}\n\trcu_exp_gp_seq_start();\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"start\"));\n\treturn false;\n}"
  },
  {
    "function_name": "sync_exp_work_done",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "263-271",
    "snippet": "static bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\tsmp_mb(); /* Ensure test happens before caller kfree(). */\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "s",
            "TPS(\"done\")"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"done\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_exp_gp_seq_done",
          "args": [
            "s"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_exp_gp_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "61-64",
          "snippet": "static bool rcu_exp_gp_seq_done(unsigned long s)\n{\n\treturn rcu_seq_done(&rcu_state.expedited_sequence, s);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool rcu_exp_gp_seq_done(unsigned long s)\n{\n\treturn rcu_seq_done(&rcu_state.expedited_sequence, s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool sync_exp_work_done(unsigned long s)\n{\n\tif (rcu_exp_gp_seq_done(s)) {\n\t\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"done\"));\n\t\tsmp_mb(); /* Ensure test happens before caller kfree(). */\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_report_exp_rdp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "256-260",
    "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_report_exp_cpu_mult",
          "args": [
            "rdp->mynode",
            "rdp->grpmask",
            "true"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_cpu_mult",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "230-251",
          "snippet": "static void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (!IS_ENABLED(CONFIG_NO_HZ_FULL) || !rdp->rcu_forced_tick_exp)\n\t\t\tcontinue;\n\t\trdp->rcu_forced_tick_exp = false;\n\t\ttick_dep_clear_cpu(cpu, TICK_DEP_BIT_RCU_EXP);\n\t}\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (!IS_ENABLED(CONFIG_NO_HZ_FULL) || !rdp->rcu_forced_tick_exp)\n\t\t\tcontinue;\n\t\trdp->rcu_forced_tick_exp = false;\n\t\ttick_dep_clear_cpu(cpu, TICK_DEP_BIT_RCU_EXP);\n\t}\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->cpu_no_qs.b.exp",
            "false"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->cpu_no_qs.b.exp, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
  },
  {
    "function_name": "rcu_report_exp_cpu_mult",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "230-251",
    "snippet": "static void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (!IS_ENABLED(CONFIG_NO_HZ_FULL) || !rdp->rcu_forced_tick_exp)\n\t\t\tcontinue;\n\t\trdp->rcu_forced_tick_exp = false;\n\t\ttick_dep_clear_cpu(cpu, TICK_DEP_BIT_RCU_EXP);\n\t}\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rcu_report_exp_rnp",
          "args": [
            "rnp",
            "wake",
            "flags"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_report_exp_rnp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "182-212",
          "snippet": "static void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tfor (;;) {\n\t\tif (!sync_rcu_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tfor (;;) {\n\t\tif (!sync_rcu_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_dep_clear_cpu",
          "args": [
            "cpu",
            "TICK_DEP_BIT_RCU_EXP"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NO_HZ_FULL"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_cpu_mask",
          "args": [
            "rnp",
            "cpu",
            "mask"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->expmask",
            "rnp->expmask & ~mask"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void rcu_report_exp_cpu_mult(struct rcu_node *rnp,\n\t\t\t\t    unsigned long mask, bool wake)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (!(rnp->expmask & mask)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\tfor_each_leaf_node_cpu_mask(rnp, cpu, mask) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (!IS_ENABLED(CONFIG_NO_HZ_FULL) || !rdp->rcu_forced_tick_exp)\n\t\t\tcontinue;\n\t\trdp->rcu_forced_tick_exp = false;\n\t\ttick_dep_clear_cpu(cpu, TICK_DEP_BIT_RCU_EXP);\n\t}\n\t__rcu_report_exp_rnp(rnp, wake, flags); /* Releases rnp->lock. */\n}"
  },
  {
    "function_name": "rcu_report_exp_rnp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "218-224",
    "snippet": "static void __maybe_unused rcu_report_exp_rnp(struct rcu_node *rnp, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t__rcu_report_exp_rnp(rnp, wake, flags);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);",
      "static void __maybe_unused"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rcu_report_exp_rnp",
          "args": [
            "rnp",
            "wake",
            "flags"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_report_exp_rnp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "182-212",
          "snippet": "static void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tfor (;;) {\n\t\tif (!sync_rcu_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tfor (;;) {\n\t\tif (!sync_rcu_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\nstatic void __maybe_unused;\n\nstatic void __maybe_unused rcu_report_exp_rnp(struct rcu_node *rnp, bool wake)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t__rcu_report_exp_rnp(rnp, wake, flags);\n}"
  },
  {
    "function_name": "__rcu_report_exp_rnp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "182-212",
    "snippet": "static void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tfor (;;) {\n\t\tif (!sync_rcu_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->expmask",
            "rnp->expmask & ~mask"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(rnp->expmask & mask)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swake_up_one",
          "args": [
            "&rcu_state.expedited_wq"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/swait.c",
          "lines": "48-55",
          "snippet": "void swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_initiate_boost",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_initiate_boost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "1238-1242",
          "snippet": "static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nstatic void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_rcu_exp_done",
          "args": [
            "rnp"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_exp_done_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "161-171",
          "snippet": "static bool sync_rcu_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic bool sync_rcu_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rnp->lock"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void __rcu_report_exp_rnp(struct rcu_node *rnp,\n\t\t\t\t bool wake, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long mask;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tfor (;;) {\n\t\tif (!sync_rcu_exp_done(rnp)) {\n\t\t\tif (!rnp->expmask)\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\telse\n\t\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (rnp->parent == NULL) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tif (wake) {\n\t\t\t\tsmp_mb(); /* EGP done before wake_up(). */\n\t\t\t\tswake_up_one(&rcu_state.expedited_wq);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmask = rnp->grpmask;\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled */\n\t\tWARN_ON_ONCE(!(rnp->expmask & mask));\n\t\tWRITE_ONCE(rnp->expmask, rnp->expmask & ~mask);\n\t}\n}"
  },
  {
    "function_name": "sync_rcu_exp_done_unlocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "161-171",
    "snippet": "static bool sync_rcu_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_rcu_exp_done",
          "args": [
            "rnp"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rcu_exp_done_unlocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "161-171",
          "snippet": "static bool sync_rcu_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic bool sync_rcu_exp_done_unlocked(struct rcu_node *rnp)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tret = sync_rcu_exp_done(rnp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sync_rcu_exp_done",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "150-155",
    "snippet": "static bool sync_rcu_exp_done(struct rcu_node *rnp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\treturn READ_ONCE(rnp->exp_tasks) == NULL &&\n\t       READ_ONCE(rnp->expmask) == 0;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->expmask"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->exp_tasks"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic bool sync_rcu_exp_done(struct rcu_node *rnp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\treturn READ_ONCE(rnp->exp_tasks) == NULL &&\n\t       READ_ONCE(rnp->expmask) == 0;\n}"
  },
  {
    "function_name": "sync_exp_reset_tree_hotplug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "73-124",
    "snippet": "static void sync_exp_reset_tree_hotplug(void)\n{\n\tbool done;\n\tunsigned long flags;\n\tunsigned long mask;\n\tunsigned long oldmask;\n\tint ncpus = smp_load_acquire(&rcu_state.ncpus); /* Order vs. locking. */\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_up;\n\n\t/* If no new CPUs onlined since last time, nothing to do. */\n\tif (likely(ncpus == rcu_state.ncpus_snap))\n\t\treturn;\n\trcu_state.ncpus_snap = ncpus;\n\n\t/*\n\t * Each pass through the following loop propagates newly onlined\n\t * CPUs for the current rcu_node structure up the rcu_node tree.\n\t */\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmaskinit == rnp->expmaskinitnext) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;  /* No new CPUs, nothing to do. */\n\t\t}\n\n\t\t/* Update this node's mask, track old value for propagation. */\n\t\toldmask = rnp->expmaskinit;\n\t\trnp->expmaskinit = rnp->expmaskinitnext;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t\t/* If was already nonzero, nothing to propagate. */\n\t\tif (oldmask)\n\t\t\tcontinue;\n\n\t\t/* Propagate the new CPU up the tree. */\n\t\tmask = rnp->grpmask;\n\t\trnp_up = rnp->parent;\n\t\tdone = false;\n\t\twhile (rnp_up) {\n\t\t\traw_spin_lock_irqsave_rcu_node(rnp_up, flags);\n\t\t\tif (rnp_up->expmaskinit)\n\t\t\t\tdone = true;\n\t\t\trnp_up->expmaskinit |= mask;\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp_up, flags);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t\tmask = rnp_up->grpmask;\n\t\t\trnp_up = rnp_up->parent;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp_up",
            "flags"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp_up",
            "flags"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ncpus == rcu_state.ncpus_snap"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rcu_state.ncpus"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nstatic void sync_exp_reset_tree_hotplug(void)\n{\n\tbool done;\n\tunsigned long flags;\n\tunsigned long mask;\n\tunsigned long oldmask;\n\tint ncpus = smp_load_acquire(&rcu_state.ncpus); /* Order vs. locking. */\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_up;\n\n\t/* If no new CPUs onlined since last time, nothing to do. */\n\tif (likely(ncpus == rcu_state.ncpus_snap))\n\t\treturn;\n\trcu_state.ncpus_snap = ncpus;\n\n\t/*\n\t * Each pass through the following loop propagates newly onlined\n\t * CPUs for the current rcu_node structure up the rcu_node tree.\n\t */\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->expmaskinit == rnp->expmaskinitnext) {\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;  /* No new CPUs, nothing to do. */\n\t\t}\n\n\t\t/* Update this node's mask, track old value for propagation. */\n\t\toldmask = rnp->expmaskinit;\n\t\trnp->expmaskinit = rnp->expmaskinitnext;\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\t\t/* If was already nonzero, nothing to propagate. */\n\t\tif (oldmask)\n\t\t\tcontinue;\n\n\t\t/* Propagate the new CPU up the tree. */\n\t\tmask = rnp->grpmask;\n\t\trnp_up = rnp->parent;\n\t\tdone = false;\n\t\twhile (rnp_up) {\n\t\t\traw_spin_lock_irqsave_rcu_node(rnp_up, flags);\n\t\t\tif (rnp_up->expmaskinit)\n\t\t\t\tdone = true;\n\t\t\trnp_up->expmaskinit |= mask;\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp_up, flags);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t\tmask = rnp_up->grpmask;\n\t\t\trnp_up = rnp_up->parent;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rcu_exp_gp_seq_done",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "61-64",
    "snippet": "static bool rcu_exp_gp_seq_done(unsigned long s)\n{\n\treturn rcu_seq_done(&rcu_state.expedited_sequence, s);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&rcu_state.expedited_sequence",
            "s"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic bool rcu_exp_gp_seq_done(unsigned long s)\n{\n\treturn rcu_seq_done(&rcu_state.expedited_sequence, s);\n}"
  },
  {
    "function_name": "rcu_exp_gp_seq_snap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "46-54",
    "snippet": "static unsigned long rcu_exp_gp_seq_snap(void)\n{\n\tunsigned long s;\n\n\tsmp_mb(); /* Caller's modifications seen first by other CPUs. */\n\ts = rcu_seq_snap(&rcu_state.expedited_sequence);\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"snap\"));\n\treturn s;\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_exp_grace_period",
          "args": [
            "rcu_state.name",
            "s",
            "TPS(\"snap\")"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"snap\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rcu_state.expedited_sequence"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "87-94",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic unsigned long rcu_exp_gp_seq_snap(void)\n{\n\tunsigned long s;\n\n\tsmp_mb(); /* Caller's modifications seen first by other CPUs. */\n\ts = rcu_seq_snap(&rcu_state.expedited_sequence);\n\ttrace_rcu_exp_grace_period(rcu_state.name, s, TPS(\"snap\"));\n\treturn s;\n}"
  },
  {
    "function_name": "rcu_exp_gp_seq_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "35-39",
    "snippet": "static void rcu_exp_gp_seq_end(void)\n{\n\trcu_seq_end(&rcu_state.expedited_sequence);\n\tsmp_mb(); /* Ensure that consecutive grace periods serialize. */\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_end",
          "args": [
            "&rcu_state.expedited_sequence"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "69-74",
          "snippet": "static inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_gp_seq_end(void)\n{\n\trcu_seq_end(&rcu_state.expedited_sequence);\n\tsmp_mb(); /* Ensure that consecutive grace periods serialize. */\n}"
  },
  {
    "function_name": "rcu_exp_gp_seq_endval",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "27-30",
    "snippet": "static __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __maybe_unused"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_endval",
          "args": [
            "&rcu_state.expedited_sequence"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_endval",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "63-66",
          "snippet": "static inline unsigned long rcu_seq_endval(unsigned long *sp)\n{\n\treturn (*sp | RCU_SEQ_STATE_MASK) + 1;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_endval(unsigned long *sp)\n{\n\treturn (*sp | RCU_SEQ_STATE_MASK) + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void __maybe_unused;\n\nstatic __maybe_unused unsigned long rcu_exp_gp_seq_endval(void)\n{\n\treturn rcu_seq_endval(&rcu_state.expedited_sequence);\n}"
  },
  {
    "function_name": "rcu_exp_gp_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
    "lines": "18-21",
    "snippet": "static void rcu_exp_gp_seq_start(void)\n{\n\trcu_seq_start(&rcu_state.expedited_sequence);\n}",
    "includes": [
      "#include <linux/lockdep.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_start",
          "args": [
            "&rcu_state.expedited_sequence"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "55-60",
          "snippet": "static inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_exp_gp_seq_start(void)\n{\n\trcu_seq_start(&rcu_state.expedited_sequence);\n}"
  }
]