[
  {
    "function_name": "user_namespaces_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1386-1390",
    "snippet": "static __init int user_namespaces_init(void)\n{\n\tuser_ns_cachep = KMEM_CACHE(user_namespace, SLAB_PANIC | SLAB_ACCOUNT);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *user_ns_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "user_namespace",
            "SLAB_PANIC | SLAB_ACCOUNT"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *user_ns_cachep;\n\nstatic __init int user_namespaces_init(void)\n{\n\tuser_ns_cachep = KMEM_CACHE(user_namespace, SLAB_PANIC | SLAB_ACCOUNT);\n\treturn 0;\n}"
  },
  {
    "function_name": "userns_owner",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1371-1374",
    "snippet": "static struct user_namespace *userns_owner(struct ns_common *ns)\n{\n\treturn to_user_ns(ns)->parent;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_user_ns",
          "args": [
            "ns"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "to_user_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "1298-1301",
          "snippet": "static inline struct user_namespace *to_user_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct user_namespace, ns);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic inline struct user_namespace *to_user_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct user_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic struct user_namespace *userns_owner(struct ns_common *ns)\n{\n\treturn to_user_ns(ns)->parent;\n}"
  },
  {
    "function_name": "ns_get_owner",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1353-1369",
    "snippet": "struct ns_common *ns_get_owner(struct ns_common *ns)\n{\n\tstruct user_namespace *my_user_ns = current_user_ns();\n\tstruct user_namespace *owner, *p;\n\n\t/* See if the owner is in the current user namespace */\n\towner = p = ns->ops->owner(ns);\n\tfor (;;) {\n\t\tif (!p)\n\t\t\treturn ERR_PTR(-EPERM);\n\t\tif (p == my_user_ns)\n\t\t\tbreak;\n\t\tp = p->parent;\n\t}\n\n\treturn &get_user_ns(owner)->ns;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "owner"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns->ops->owner",
          "args": [
            "ns"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstruct ns_common *ns_get_owner(struct ns_common *ns)\n{\n\tstruct user_namespace *my_user_ns = current_user_ns();\n\tstruct user_namespace *owner, *p;\n\n\t/* See if the owner is in the current user namespace */\n\towner = p = ns->ops->owner(ns);\n\tfor (;;) {\n\t\tif (!p)\n\t\t\treturn ERR_PTR(-EPERM);\n\t\tif (p == my_user_ns)\n\t\t\tbreak;\n\t\tp = p->parent;\n\t}\n\n\treturn &get_user_ns(owner)->ns;\n}"
  },
  {
    "function_name": "userns_install",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1319-1351",
    "snippet": "static int userns_install(struct nsset *nsset, struct ns_common *ns)\n{\n\tstruct user_namespace *user_ns = to_user_ns(ns);\n\tstruct cred *cred;\n\n\t/* Don't allow gaining capabilities by reentering\n\t * the same user namespace.\n\t */\n\tif (user_ns == current_user_ns())\n\t\treturn -EINVAL;\n\n\t/* Tasks that share a thread group must share a user namespace */\n\tif (!thread_group_empty(current))\n\t\treturn -EINVAL;\n\n\tif (current->fs->users != 1)\n\t\treturn -EINVAL;\n\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcred = nsset_cred(nsset);\n\tif (!cred)\n\t\treturn -EINVAL;\n\n\tput_user_ns(cred->user_ns);\n\tset_cred_user_ns(cred, get_user_ns(user_ns));\n\n\tif (set_cred_ucounts(cred) < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cred_ucounts",
          "args": [
            "cred"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "set_cred_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "666-689",
          "snippet": "int set_cred_ucounts(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\tstruct ucounts *new_ucounts, *old_ucounts = new->ucounts;\n\n\tif (new->user == old->user && new->user_ns == old->user_ns)\n\t\treturn 0;\n\n\t/*\n\t * This optimization is needed because alloc_ucounts() uses locks\n\t * for table lookups.\n\t */\n\tif (old_ucounts->ns == new->user_ns && uid_eq(old_ucounts->uid, new->euid))\n\t\treturn 0;\n\n\tif (!(new_ucounts = alloc_ucounts(new->user_ns, new->euid)))\n\t\treturn -EAGAIN;\n\n\tnew->ucounts = new_ucounts;\n\tput_ucounts(old_ucounts);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint set_cred_ucounts(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\tstruct ucounts *new_ucounts, *old_ucounts = new->ucounts;\n\n\tif (new->user == old->user && new->user_ns == old->user_ns)\n\t\treturn 0;\n\n\t/*\n\t * This optimization is needed because alloc_ucounts() uses locks\n\t * for table lookups.\n\t */\n\tif (old_ucounts->ns == new->user_ns && uid_eq(old_ucounts->uid, new->euid))\n\t\treturn 0;\n\n\tif (!(new_ucounts = alloc_ucounts(new->user_ns, new->euid)))\n\t\treturn -EAGAIN;\n\n\tnew->ucounts = new_ucounts;\n\tput_ucounts(old_ucounts);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cred_user_ns",
          "args": [
            "cred",
            "get_user_ns(user_ns)"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "set_cred_user_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "42-59",
          "snippet": "static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)\n{\n\t/* Start with the same capabilities as init but useless for doing\n\t * anything as the capabilities are bound to the new user namespace.\n\t */\n\tcred->securebits = SECUREBITS_DEFAULT;\n\tcred->cap_inheritable = CAP_EMPTY_SET;\n\tcred->cap_permitted = CAP_FULL_SET;\n\tcred->cap_effective = CAP_FULL_SET;\n\tcred->cap_ambient = CAP_EMPTY_SET;\n\tcred->cap_bset = CAP_FULL_SET;\n#ifdef CONFIG_KEYS\n\tkey_put(cred->request_key_auth);\n\tcred->request_key_auth = NULL;\n#endif\n\t/* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */\n\tcred->user_ns = user_ns;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)\n{\n\t/* Start with the same capabilities as init but useless for doing\n\t * anything as the capabilities are bound to the new user namespace.\n\t */\n\tcred->securebits = SECUREBITS_DEFAULT;\n\tcred->cap_inheritable = CAP_EMPTY_SET;\n\tcred->cap_permitted = CAP_FULL_SET;\n\tcred->cap_effective = CAP_FULL_SET;\n\tcred->cap_ambient = CAP_EMPTY_SET;\n\tcred->cap_bset = CAP_FULL_SET;\n#ifdef CONFIG_KEYS\n\tkey_put(cred->request_key_auth);\n\tcred->request_key_auth = NULL;\n#endif\n\t/* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */\n\tcred->user_ns = user_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "user_ns"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "cred->user_ns"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "__put_user_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "208-211",
          "snippet": "void __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_user_ns(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void free_user_ns(struct work_struct *work);\n\nvoid __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsset_cred",
          "args": [
            "nsset"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_setid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "431-434",
          "snippet": "bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "current"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_user_ns",
          "args": [
            "ns"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "to_user_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "1298-1301",
          "snippet": "static inline struct user_namespace *to_user_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct user_namespace, ns);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic inline struct user_namespace *to_user_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct user_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic int userns_install(struct nsset *nsset, struct ns_common *ns)\n{\n\tstruct user_namespace *user_ns = to_user_ns(ns);\n\tstruct cred *cred;\n\n\t/* Don't allow gaining capabilities by reentering\n\t * the same user namespace.\n\t */\n\tif (user_ns == current_user_ns())\n\t\treturn -EINVAL;\n\n\t/* Tasks that share a thread group must share a user namespace */\n\tif (!thread_group_empty(current))\n\t\treturn -EINVAL;\n\n\tif (current->fs->users != 1)\n\t\treturn -EINVAL;\n\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcred = nsset_cred(nsset);\n\tif (!cred)\n\t\treturn -EINVAL;\n\n\tput_user_ns(cred->user_ns);\n\tset_cred_user_ns(cred, get_user_ns(user_ns));\n\n\tif (set_cred_ucounts(cred) < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "userns_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1314-1317",
    "snippet": "static void userns_put(struct ns_common *ns)\n{\n\tput_user_ns(to_user_ns(ns));\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "to_user_ns(ns)"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "__put_user_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "208-211",
          "snippet": "void __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_user_ns(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void free_user_ns(struct work_struct *work);\n\nvoid __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_user_ns",
          "args": [
            "ns"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "to_user_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "1298-1301",
          "snippet": "static inline struct user_namespace *to_user_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct user_namespace, ns);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic inline struct user_namespace *to_user_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct user_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void userns_put(struct ns_common *ns)\n{\n\tput_user_ns(to_user_ns(ns));\n}"
  },
  {
    "function_name": "userns_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1303-1312",
    "snippet": "static struct ns_common *userns_get(struct task_struct *task)\n{\n\tstruct user_namespace *user_ns;\n\n\trcu_read_lock();\n\tuser_ns = get_user_ns(__task_cred(task)->user_ns);\n\trcu_read_unlock();\n\n\treturn user_ns ? &user_ns->ns : NULL;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "__task_cred(task)->user_ns"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "task"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic struct ns_common *userns_get(struct task_struct *task)\n{\n\tstruct user_namespace *user_ns;\n\n\trcu_read_lock();\n\tuser_ns = get_user_ns(__task_cred(task)->user_ns);\n\trcu_read_unlock();\n\n\treturn user_ns ? &user_ns->ns : NULL;\n}"
  },
  {
    "function_name": "to_user_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1298-1301",
    "snippet": "static inline struct user_namespace *to_user_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct user_namespace, ns);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ns",
            "structuser_namespace",
            "ns"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic inline struct user_namespace *to_user_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct user_namespace, ns);\n}"
  },
  {
    "function_name": "current_in_userns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1292-1295",
    "snippet": "bool current_in_userns(const struct user_namespace *target_ns)\n{\n\treturn in_userns(target_ns, current_user_ns());\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_userns",
          "args": [
            "target_ns",
            "current_user_ns()"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "in_userns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "1283-1290",
          "snippet": "bool in_userns(const struct user_namespace *ancestor,\n\t       const struct user_namespace *child)\n{\n\tconst struct user_namespace *ns;\n\tfor (ns = child; ns->level > ancestor->level; ns = ns->parent)\n\t\t;\n\treturn (ns == ancestor);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nbool in_userns(const struct user_namespace *ancestor,\n\t       const struct user_namespace *child)\n{\n\tconst struct user_namespace *ns;\n\tfor (ns = child; ns->level > ancestor->level; ns = ns->parent)\n\t\t;\n\treturn (ns == ancestor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nbool current_in_userns(const struct user_namespace *target_ns)\n{\n\treturn in_userns(target_ns, current_user_ns());\n}"
  },
  {
    "function_name": "in_userns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1283-1290",
    "snippet": "bool in_userns(const struct user_namespace *ancestor,\n\t       const struct user_namespace *child)\n{\n\tconst struct user_namespace *ns;\n\tfor (ns = child; ns->level > ancestor->level; ns = ns->parent)\n\t\t;\n\treturn (ns == ancestor);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nbool in_userns(const struct user_namespace *ancestor,\n\t       const struct user_namespace *child)\n{\n\tconst struct user_namespace *ns;\n\tfor (ns = child; ns->level > ancestor->level; ns = ns->parent)\n\t\t;\n\treturn (ns == ancestor);\n}"
  },
  {
    "function_name": "userns_may_setgroups",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1263-1277",
    "snippet": "bool userns_may_setgroups(const struct user_namespace *ns)\n{\n\tbool allowed;\n\n\tmutex_lock(&userns_state_mutex);\n\t/* It is not safe to use setgroups until a gid mapping in\n\t * the user namespace has been established.\n\t */\n\tallowed = ns->gid_map.nr_extents != 0;\n\t/* Is setgroups allowed? */\n\tallowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);\n\tmutex_unlock(&userns_state_mutex);\n\n\treturn allowed;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(userns_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&userns_state_mutex"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&userns_state_mutex"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(userns_state_mutex);\n\nbool userns_may_setgroups(const struct user_namespace *ns)\n{\n\tbool allowed;\n\n\tmutex_lock(&userns_state_mutex);\n\t/* It is not safe to use setgroups until a gid mapping in\n\t * the user namespace has been established.\n\t */\n\tallowed = ns->gid_map.nr_extents != 0;\n\t/* Is setgroups allowed? */\n\tallowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);\n\tmutex_unlock(&userns_state_mutex);\n\n\treturn allowed;\n}"
  },
  {
    "function_name": "proc_setgroups_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1196-1261",
    "snippet": "ssize_t proc_setgroups_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tchar kbuf[8], *pos;\n\tbool setgroups_allowed;\n\tssize_t ret;\n\n\t/* Only allow a very narrow range of strings to be written */\n\tret = -EINVAL;\n\tif ((*ppos != 0) || (count >= sizeof(kbuf)))\n\t\tgoto out;\n\n\t/* What was written? */\n\tret = -EFAULT;\n\tif (copy_from_user(kbuf, buf, count))\n\t\tgoto out;\n\tkbuf[count] = '\\0';\n\tpos = kbuf;\n\n\t/* What is being requested? */\n\tret = -EINVAL;\n\tif (strncmp(pos, \"allow\", 5) == 0) {\n\t\tpos += 5;\n\t\tsetgroups_allowed = true;\n\t}\n\telse if (strncmp(pos, \"deny\", 4) == 0) {\n\t\tpos += 4;\n\t\tsetgroups_allowed = false;\n\t}\n\telse\n\t\tgoto out;\n\n\t/* Verify there is not trailing junk on the line */\n\tpos = skip_spaces(pos);\n\tif (*pos != '\\0')\n\t\tgoto out;\n\n\tret = -EPERM;\n\tmutex_lock(&userns_state_mutex);\n\tif (setgroups_allowed) {\n\t\t/* Enabling setgroups after setgroups has been disabled\n\t\t * is not allowed.\n\t\t */\n\t\tif (!(ns->flags & USERNS_SETGROUPS_ALLOWED))\n\t\t\tgoto out_unlock;\n\t} else {\n\t\t/* Permanently disabling setgroups after setgroups has\n\t\t * been enabled by writing the gid_map is not allowed.\n\t\t */\n\t\tif (ns->gid_map.nr_extents != 0)\n\t\t\tgoto out_unlock;\n\t\tns->flags &= ~USERNS_SETGROUPS_ALLOWED;\n\t}\n\tmutex_unlock(&userns_state_mutex);\n\n\t/* Report a successful write */\n\t*ppos = count;\n\tret = count;\nout:\n\treturn ret;\nout_unlock:\n\tmutex_unlock(&userns_state_mutex);\n\tgoto out;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(userns_state_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&userns_state_mutex"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&userns_state_mutex"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "pos"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "proc_skip_spaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "333-340",
          "snippet": "static size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "pos",
            "\"deny\"",
            "4"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "pos",
            "\"allow\"",
            "5"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kbuf",
            "buf",
            "count"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(userns_state_mutex);\n\nssize_t proc_setgroups_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tchar kbuf[8], *pos;\n\tbool setgroups_allowed;\n\tssize_t ret;\n\n\t/* Only allow a very narrow range of strings to be written */\n\tret = -EINVAL;\n\tif ((*ppos != 0) || (count >= sizeof(kbuf)))\n\t\tgoto out;\n\n\t/* What was written? */\n\tret = -EFAULT;\n\tif (copy_from_user(kbuf, buf, count))\n\t\tgoto out;\n\tkbuf[count] = '\\0';\n\tpos = kbuf;\n\n\t/* What is being requested? */\n\tret = -EINVAL;\n\tif (strncmp(pos, \"allow\", 5) == 0) {\n\t\tpos += 5;\n\t\tsetgroups_allowed = true;\n\t}\n\telse if (strncmp(pos, \"deny\", 4) == 0) {\n\t\tpos += 4;\n\t\tsetgroups_allowed = false;\n\t}\n\telse\n\t\tgoto out;\n\n\t/* Verify there is not trailing junk on the line */\n\tpos = skip_spaces(pos);\n\tif (*pos != '\\0')\n\t\tgoto out;\n\n\tret = -EPERM;\n\tmutex_lock(&userns_state_mutex);\n\tif (setgroups_allowed) {\n\t\t/* Enabling setgroups after setgroups has been disabled\n\t\t * is not allowed.\n\t\t */\n\t\tif (!(ns->flags & USERNS_SETGROUPS_ALLOWED))\n\t\t\tgoto out_unlock;\n\t} else {\n\t\t/* Permanently disabling setgroups after setgroups has\n\t\t * been enabled by writing the gid_map is not allowed.\n\t\t */\n\t\tif (ns->gid_map.nr_extents != 0)\n\t\t\tgoto out_unlock;\n\t\tns->flags &= ~USERNS_SETGROUPS_ALLOWED;\n\t}\n\tmutex_unlock(&userns_state_mutex);\n\n\t/* Report a successful write */\n\t*ppos = count;\n\tret = count;\nout:\n\treturn ret;\nout_unlock:\n\tmutex_unlock(&userns_state_mutex);\n\tgoto out;\n}"
  },
  {
    "function_name": "proc_setgroups_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1185-1194",
    "snippet": "int proc_setgroups_show(struct seq_file *seq, void *v)\n{\n\tstruct user_namespace *ns = seq->private;\n\tunsigned long userns_flags = READ_ONCE(ns->flags);\n\n\tseq_printf(seq, \"%s\\n\",\n\t\t   (userns_flags & USERNS_SETGROUPS_ALLOWED) ?\n\t\t   \"allow\" : \"deny\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s\\n\"",
            "(userns_flags & USERNS_SETGROUPS_ALLOWED) ?\n\t\t   \"allow\" : \"deny\""
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ns->flags"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nint proc_setgroups_show(struct seq_file *seq, void *v)\n{\n\tstruct user_namespace *ns = seq->private;\n\tunsigned long userns_flags = READ_ONCE(ns->flags);\n\n\tseq_printf(seq, \"%s\\n\",\n\t\t   (userns_flags & USERNS_SETGROUPS_ALLOWED) ?\n\t\t   \"allow\" : \"deny\");\n\treturn 0;\n}"
  },
  {
    "function_name": "new_idmap_permitted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1143-1183",
    "snippet": "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tconst struct cred *cred = file->f_cred;\n\n\tif (cap_setid == CAP_SETUID && !verify_root_map(file, ns, new_map))\n\t\treturn false;\n\n\t/* Don't allow mappings that would allow anything that wouldn't\n\t * be allowed without the establishment of unprivileged mappings.\n\t */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1) &&\n\t    uid_eq(ns->owner, cred->euid)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, cred->euid))\n\t\t\t\treturn true;\n\t\t} else if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (!(ns->flags & USERNS_SETGROUPS_ALLOWED) &&\n\t\t\t    gid_eq(gid, cred->egid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.\n\t * And the opener of the id file also has the appropriate capability.\n\t */\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_ns_capable",
          "args": [
            "file",
            "ns->parent",
            "cap_setid"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "file_ns_capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "466-477",
          "snippet": "bool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "ns->parent",
            "cap_setid"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_setid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "431-434",
          "snippet": "bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_valid",
          "args": [
            "cap_setid"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "gid",
            "cred->egid"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "ns->parent",
            "id"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "make_kgid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "459-463",
          "snippet": "kgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "uid",
            "cred->euid"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "ns->parent",
            "id"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "make_kuid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "391-395",
          "snippet": "kuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "ns->owner",
            "cred->euid"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_root_map",
          "args": [
            "file",
            "ns",
            "new_map"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "verify_root_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "861-901",
          "snippet": "static bool verify_root_map(const struct file *file,\n\t\t\t    struct user_namespace *map_ns,\n\t\t\t    struct uid_gid_map *new_map)\n{\n\tint idx;\n\tconst struct user_namespace *file_ns = file->f_cred->user_ns;\n\tstruct uid_gid_extent *extent0 = NULL;\n\n\tfor (idx = 0; idx < new_map->nr_extents; idx++) {\n\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\textent0 = &new_map->extent[idx];\n\t\telse\n\t\t\textent0 = &new_map->forward[idx];\n\t\tif (extent0->lower_first == 0)\n\t\t\tbreak;\n\n\t\textent0 = NULL;\n\t}\n\n\tif (!extent0)\n\t\treturn true;\n\n\tif (map_ns == file_ns) {\n\t\t/* The process unshared its ns and is writing to its own\n\t\t * /proc/self/uid_map.  User already has full capabilites in\n\t\t * the new namespace.  Verify that the parent had CAP_SETFCAP\n\t\t * when it unshared.\n\t\t * */\n\t\tif (!file_ns->parent_could_setfcap)\n\t\t\treturn false;\n\t} else {\n\t\t/* Process p1 is writing to uid_map of p2, who is in a child\n\t\t * user namespace to p1's.  Verify that the opener of the map\n\t\t * file has CAP_SETFCAP against the parent of the new map\n\t\t * namespace */\n\t\tif (!file_ns_capable(file, map_ns->parent, CAP_SETFCAP))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic bool verify_root_map(const struct file *file,\n\t\t\t    struct user_namespace *map_ns,\n\t\t\t    struct uid_gid_map *new_map)\n{\n\tint idx;\n\tconst struct user_namespace *file_ns = file->f_cred->user_ns;\n\tstruct uid_gid_extent *extent0 = NULL;\n\n\tfor (idx = 0; idx < new_map->nr_extents; idx++) {\n\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\textent0 = &new_map->extent[idx];\n\t\telse\n\t\t\textent0 = &new_map->forward[idx];\n\t\tif (extent0->lower_first == 0)\n\t\t\tbreak;\n\n\t\textent0 = NULL;\n\t}\n\n\tif (!extent0)\n\t\treturn true;\n\n\tif (map_ns == file_ns) {\n\t\t/* The process unshared its ns and is writing to its own\n\t\t * /proc/self/uid_map.  User already has full capabilites in\n\t\t * the new namespace.  Verify that the parent had CAP_SETFCAP\n\t\t * when it unshared.\n\t\t * */\n\t\tif (!file_ns->parent_could_setfcap)\n\t\t\treturn false;\n\t} else {\n\t\t/* Process p1 is writing to uid_map of p2, who is in a child\n\t\t * user namespace to p1's.  Verify that the opener of the map\n\t\t * file has CAP_SETFCAP against the parent of the new map\n\t\t * namespace */\n\t\tif (!file_ns_capable(file, map_ns->parent, CAP_SETFCAP))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tconst struct cred *cred = file->f_cred;\n\n\tif (cap_setid == CAP_SETUID && !verify_root_map(file, ns, new_map))\n\t\treturn false;\n\n\t/* Don't allow mappings that would allow anything that wouldn't\n\t * be allowed without the establishment of unprivileged mappings.\n\t */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1) &&\n\t    uid_eq(ns->owner, cred->euid)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, cred->euid))\n\t\t\t\treturn true;\n\t\t} else if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (!(ns->flags & USERNS_SETGROUPS_ALLOWED) &&\n\t\t\t    gid_eq(gid, cred->egid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.\n\t * And the opener of the id file also has the appropriate capability.\n\t */\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "proc_projid_map_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1125-1141",
    "snippet": "ssize_t proc_projid_map_write(struct file *file, const char __user *buf,\n\t\t\t      size_t size, loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct user_namespace *seq_ns = seq_user_ns(seq);\n\n\tif (!ns->parent)\n\t\treturn -EPERM;\n\n\tif ((seq_ns != ns) && (seq_ns != ns->parent))\n\t\treturn -EPERM;\n\n\t/* Anyone can set any valid project id no capability needed */\n\treturn map_write(file, buf, size, ppos, -1,\n\t\t\t &ns->projid_map, &ns->parent->projid_map);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_write",
          "args": [
            "file",
            "buf",
            "size",
            "ppos",
            "-1",
            "&ns->projid_map",
            "&ns->parent->projid_map"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "map_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "903-1089",
          "snippet": "static ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *map_ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent extent;\n\tchar *kbuf = NULL, *pos, *next_line;\n\tssize_t ret;\n\n\t/* Only allow < page size writes at the beginning of the file */\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t/* Slurp in the user data */\n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t/*\n\t * The userns_state_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_rmb() is guaranteed that we don't have crazy\n\t * architectures returning stale data.\n\t */\n\tmutex_lock(&userns_state_mutex);\n\n\tmemset(&new_map, 0, sizeof(struct uid_gid_map));\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/*\n\t * Adjusting namespace settings requires capabilities on the target.\n\t */\n\tif (cap_valid(cap_setid) && !file_ns_capable(file, map_ns, CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tfor (; pos; pos = next_line) {\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent.first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent.first == (u32) -1) ||\n\t\t    (extent.lower_first == (u32) -1))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the\n\t\t * extent to wrap\n\t\t */\n\t\tif ((extent.first + extent.count) <= extent.first)\n\t\t\tgoto out;\n\t\tif ((extent.lower_first + extent.count) <=\n\t\t     extent.lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, &extent))\n\t\t\tgoto out;\n\n\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\n\t\tret = insert_extent(&new_map, &extent);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t}\n\t/* Be very certain the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Validate the user is allowed to use user id's mapped to. */\n\tif (!new_idmap_permitted(file, map_ns, cap_setid, &new_map))\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Map the lower ids from the parent user namespace to the\n\t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tstruct uid_gid_extent *e;\n\t\tu32 lower_first;\n\n\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\te = &new_map.extent[idx];\n\t\telse\n\t\t\te = &new_map.forward[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\te->lower_first,\n\t\t\t\t\t\te->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n\t\te->lower_first = lower_first;\n\t}\n\n\t/*\n\t * If we want to use binary search for lookup, this clones the extent\n\t * array and sorts both copies.\n\t */\n\tret = sort_idmaps(&new_map);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Install the map */\n\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tmemcpy(map->extent, new_map.extent,\n\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));\n\t} else {\n\t\tmap->forward = new_map.forward;\n\t\tmap->reverse = new_map.reverse;\n\t}\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tkfree(new_map.forward);\n\t\tkfree(new_map.reverse);\n\t\tmap->forward = NULL;\n\t\tmap->reverse = NULL;\n\t\tmap->nr_extents = 0;\n\t}\n\n\tmutex_unlock(&userns_state_mutex);\n\tkfree(kbuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(userns_state_mutex);",
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(userns_state_mutex);\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *map_ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent extent;\n\tchar *kbuf = NULL, *pos, *next_line;\n\tssize_t ret;\n\n\t/* Only allow < page size writes at the beginning of the file */\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t/* Slurp in the user data */\n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t/*\n\t * The userns_state_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_rmb() is guaranteed that we don't have crazy\n\t * architectures returning stale data.\n\t */\n\tmutex_lock(&userns_state_mutex);\n\n\tmemset(&new_map, 0, sizeof(struct uid_gid_map));\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/*\n\t * Adjusting namespace settings requires capabilities on the target.\n\t */\n\tif (cap_valid(cap_setid) && !file_ns_capable(file, map_ns, CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tfor (; pos; pos = next_line) {\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent.first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent.first == (u32) -1) ||\n\t\t    (extent.lower_first == (u32) -1))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the\n\t\t * extent to wrap\n\t\t */\n\t\tif ((extent.first + extent.count) <= extent.first)\n\t\t\tgoto out;\n\t\tif ((extent.lower_first + extent.count) <=\n\t\t     extent.lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, &extent))\n\t\t\tgoto out;\n\n\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\n\t\tret = insert_extent(&new_map, &extent);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t}\n\t/* Be very certain the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Validate the user is allowed to use user id's mapped to. */\n\tif (!new_idmap_permitted(file, map_ns, cap_setid, &new_map))\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Map the lower ids from the parent user namespace to the\n\t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tstruct uid_gid_extent *e;\n\t\tu32 lower_first;\n\n\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\te = &new_map.extent[idx];\n\t\telse\n\t\t\te = &new_map.forward[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\te->lower_first,\n\t\t\t\t\t\te->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n\t\te->lower_first = lower_first;\n\t}\n\n\t/*\n\t * If we want to use binary search for lookup, this clones the extent\n\t * array and sorts both copies.\n\t */\n\tret = sort_idmaps(&new_map);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Install the map */\n\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tmemcpy(map->extent, new_map.extent,\n\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));\n\t} else {\n\t\tmap->forward = new_map.forward;\n\t\tmap->reverse = new_map.reverse;\n\t}\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tkfree(new_map.forward);\n\t\tkfree(new_map.reverse);\n\t\tmap->forward = NULL;\n\t\tmap->reverse = NULL;\n\t\tmap->nr_extents = 0;\n\t}\n\n\tmutex_unlock(&userns_state_mutex);\n\tkfree(kbuf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "seq"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nssize_t proc_projid_map_write(struct file *file, const char __user *buf,\n\t\t\t      size_t size, loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct user_namespace *seq_ns = seq_user_ns(seq);\n\n\tif (!ns->parent)\n\t\treturn -EPERM;\n\n\tif ((seq_ns != ns) && (seq_ns != ns->parent))\n\t\treturn -EPERM;\n\n\t/* Anyone can set any valid project id no capability needed */\n\treturn map_write(file, buf, size, ppos, -1,\n\t\t\t &ns->projid_map, &ns->parent->projid_map);\n}"
  },
  {
    "function_name": "proc_gid_map_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1108-1123",
    "snippet": "ssize_t proc_gid_map_write(struct file *file, const char __user *buf,\n\t\t\t   size_t size, loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct user_namespace *seq_ns = seq_user_ns(seq);\n\n\tif (!ns->parent)\n\t\treturn -EPERM;\n\n\tif ((seq_ns != ns) && (seq_ns != ns->parent))\n\t\treturn -EPERM;\n\n\treturn map_write(file, buf, size, ppos, CAP_SETGID,\n\t\t\t &ns->gid_map, &ns->parent->gid_map);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_write",
          "args": [
            "file",
            "buf",
            "size",
            "ppos",
            "CAP_SETGID",
            "&ns->gid_map",
            "&ns->parent->gid_map"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "map_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "903-1089",
          "snippet": "static ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *map_ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent extent;\n\tchar *kbuf = NULL, *pos, *next_line;\n\tssize_t ret;\n\n\t/* Only allow < page size writes at the beginning of the file */\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t/* Slurp in the user data */\n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t/*\n\t * The userns_state_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_rmb() is guaranteed that we don't have crazy\n\t * architectures returning stale data.\n\t */\n\tmutex_lock(&userns_state_mutex);\n\n\tmemset(&new_map, 0, sizeof(struct uid_gid_map));\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/*\n\t * Adjusting namespace settings requires capabilities on the target.\n\t */\n\tif (cap_valid(cap_setid) && !file_ns_capable(file, map_ns, CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tfor (; pos; pos = next_line) {\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent.first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent.first == (u32) -1) ||\n\t\t    (extent.lower_first == (u32) -1))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the\n\t\t * extent to wrap\n\t\t */\n\t\tif ((extent.first + extent.count) <= extent.first)\n\t\t\tgoto out;\n\t\tif ((extent.lower_first + extent.count) <=\n\t\t     extent.lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, &extent))\n\t\t\tgoto out;\n\n\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\n\t\tret = insert_extent(&new_map, &extent);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t}\n\t/* Be very certain the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Validate the user is allowed to use user id's mapped to. */\n\tif (!new_idmap_permitted(file, map_ns, cap_setid, &new_map))\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Map the lower ids from the parent user namespace to the\n\t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tstruct uid_gid_extent *e;\n\t\tu32 lower_first;\n\n\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\te = &new_map.extent[idx];\n\t\telse\n\t\t\te = &new_map.forward[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\te->lower_first,\n\t\t\t\t\t\te->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n\t\te->lower_first = lower_first;\n\t}\n\n\t/*\n\t * If we want to use binary search for lookup, this clones the extent\n\t * array and sorts both copies.\n\t */\n\tret = sort_idmaps(&new_map);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Install the map */\n\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tmemcpy(map->extent, new_map.extent,\n\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));\n\t} else {\n\t\tmap->forward = new_map.forward;\n\t\tmap->reverse = new_map.reverse;\n\t}\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tkfree(new_map.forward);\n\t\tkfree(new_map.reverse);\n\t\tmap->forward = NULL;\n\t\tmap->reverse = NULL;\n\t\tmap->nr_extents = 0;\n\t}\n\n\tmutex_unlock(&userns_state_mutex);\n\tkfree(kbuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(userns_state_mutex);",
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(userns_state_mutex);\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *map_ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent extent;\n\tchar *kbuf = NULL, *pos, *next_line;\n\tssize_t ret;\n\n\t/* Only allow < page size writes at the beginning of the file */\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t/* Slurp in the user data */\n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t/*\n\t * The userns_state_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_rmb() is guaranteed that we don't have crazy\n\t * architectures returning stale data.\n\t */\n\tmutex_lock(&userns_state_mutex);\n\n\tmemset(&new_map, 0, sizeof(struct uid_gid_map));\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/*\n\t * Adjusting namespace settings requires capabilities on the target.\n\t */\n\tif (cap_valid(cap_setid) && !file_ns_capable(file, map_ns, CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tfor (; pos; pos = next_line) {\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent.first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent.first == (u32) -1) ||\n\t\t    (extent.lower_first == (u32) -1))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the\n\t\t * extent to wrap\n\t\t */\n\t\tif ((extent.first + extent.count) <= extent.first)\n\t\t\tgoto out;\n\t\tif ((extent.lower_first + extent.count) <=\n\t\t     extent.lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, &extent))\n\t\t\tgoto out;\n\n\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\n\t\tret = insert_extent(&new_map, &extent);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t}\n\t/* Be very certain the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Validate the user is allowed to use user id's mapped to. */\n\tif (!new_idmap_permitted(file, map_ns, cap_setid, &new_map))\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Map the lower ids from the parent user namespace to the\n\t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tstruct uid_gid_extent *e;\n\t\tu32 lower_first;\n\n\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\te = &new_map.extent[idx];\n\t\telse\n\t\t\te = &new_map.forward[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\te->lower_first,\n\t\t\t\t\t\te->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n\t\te->lower_first = lower_first;\n\t}\n\n\t/*\n\t * If we want to use binary search for lookup, this clones the extent\n\t * array and sorts both copies.\n\t */\n\tret = sort_idmaps(&new_map);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Install the map */\n\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tmemcpy(map->extent, new_map.extent,\n\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));\n\t} else {\n\t\tmap->forward = new_map.forward;\n\t\tmap->reverse = new_map.reverse;\n\t}\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tkfree(new_map.forward);\n\t\tkfree(new_map.reverse);\n\t\tmap->forward = NULL;\n\t\tmap->reverse = NULL;\n\t\tmap->nr_extents = 0;\n\t}\n\n\tmutex_unlock(&userns_state_mutex);\n\tkfree(kbuf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "seq"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nssize_t proc_gid_map_write(struct file *file, const char __user *buf,\n\t\t\t   size_t size, loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct user_namespace *seq_ns = seq_user_ns(seq);\n\n\tif (!ns->parent)\n\t\treturn -EPERM;\n\n\tif ((seq_ns != ns) && (seq_ns != ns->parent))\n\t\treturn -EPERM;\n\n\treturn map_write(file, buf, size, ppos, CAP_SETGID,\n\t\t\t &ns->gid_map, &ns->parent->gid_map);\n}"
  },
  {
    "function_name": "proc_uid_map_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "1091-1106",
    "snippet": "ssize_t proc_uid_map_write(struct file *file, const char __user *buf,\n\t\t\t   size_t size, loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct user_namespace *seq_ns = seq_user_ns(seq);\n\n\tif (!ns->parent)\n\t\treturn -EPERM;\n\n\tif ((seq_ns != ns) && (seq_ns != ns->parent))\n\t\treturn -EPERM;\n\n\treturn map_write(file, buf, size, ppos, CAP_SETUID,\n\t\t\t &ns->uid_map, &ns->parent->uid_map);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_write",
          "args": [
            "file",
            "buf",
            "size",
            "ppos",
            "CAP_SETUID",
            "&ns->uid_map",
            "&ns->parent->uid_map"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "map_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "903-1089",
          "snippet": "static ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *map_ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent extent;\n\tchar *kbuf = NULL, *pos, *next_line;\n\tssize_t ret;\n\n\t/* Only allow < page size writes at the beginning of the file */\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t/* Slurp in the user data */\n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t/*\n\t * The userns_state_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_rmb() is guaranteed that we don't have crazy\n\t * architectures returning stale data.\n\t */\n\tmutex_lock(&userns_state_mutex);\n\n\tmemset(&new_map, 0, sizeof(struct uid_gid_map));\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/*\n\t * Adjusting namespace settings requires capabilities on the target.\n\t */\n\tif (cap_valid(cap_setid) && !file_ns_capable(file, map_ns, CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tfor (; pos; pos = next_line) {\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent.first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent.first == (u32) -1) ||\n\t\t    (extent.lower_first == (u32) -1))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the\n\t\t * extent to wrap\n\t\t */\n\t\tif ((extent.first + extent.count) <= extent.first)\n\t\t\tgoto out;\n\t\tif ((extent.lower_first + extent.count) <=\n\t\t     extent.lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, &extent))\n\t\t\tgoto out;\n\n\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\n\t\tret = insert_extent(&new_map, &extent);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t}\n\t/* Be very certain the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Validate the user is allowed to use user id's mapped to. */\n\tif (!new_idmap_permitted(file, map_ns, cap_setid, &new_map))\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Map the lower ids from the parent user namespace to the\n\t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tstruct uid_gid_extent *e;\n\t\tu32 lower_first;\n\n\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\te = &new_map.extent[idx];\n\t\telse\n\t\t\te = &new_map.forward[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\te->lower_first,\n\t\t\t\t\t\te->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n\t\te->lower_first = lower_first;\n\t}\n\n\t/*\n\t * If we want to use binary search for lookup, this clones the extent\n\t * array and sorts both copies.\n\t */\n\tret = sort_idmaps(&new_map);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Install the map */\n\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tmemcpy(map->extent, new_map.extent,\n\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));\n\t} else {\n\t\tmap->forward = new_map.forward;\n\t\tmap->reverse = new_map.reverse;\n\t}\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tkfree(new_map.forward);\n\t\tkfree(new_map.reverse);\n\t\tmap->forward = NULL;\n\t\tmap->reverse = NULL;\n\t\tmap->nr_extents = 0;\n\t}\n\n\tmutex_unlock(&userns_state_mutex);\n\tkfree(kbuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(userns_state_mutex);",
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(userns_state_mutex);\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *map_ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent extent;\n\tchar *kbuf = NULL, *pos, *next_line;\n\tssize_t ret;\n\n\t/* Only allow < page size writes at the beginning of the file */\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t/* Slurp in the user data */\n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t/*\n\t * The userns_state_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_rmb() is guaranteed that we don't have crazy\n\t * architectures returning stale data.\n\t */\n\tmutex_lock(&userns_state_mutex);\n\n\tmemset(&new_map, 0, sizeof(struct uid_gid_map));\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/*\n\t * Adjusting namespace settings requires capabilities on the target.\n\t */\n\tif (cap_valid(cap_setid) && !file_ns_capable(file, map_ns, CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tfor (; pos; pos = next_line) {\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent.first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent.first == (u32) -1) ||\n\t\t    (extent.lower_first == (u32) -1))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the\n\t\t * extent to wrap\n\t\t */\n\t\tif ((extent.first + extent.count) <= extent.first)\n\t\t\tgoto out;\n\t\tif ((extent.lower_first + extent.count) <=\n\t\t     extent.lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, &extent))\n\t\t\tgoto out;\n\n\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\n\t\tret = insert_extent(&new_map, &extent);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t}\n\t/* Be very certain the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Validate the user is allowed to use user id's mapped to. */\n\tif (!new_idmap_permitted(file, map_ns, cap_setid, &new_map))\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Map the lower ids from the parent user namespace to the\n\t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tstruct uid_gid_extent *e;\n\t\tu32 lower_first;\n\n\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\te = &new_map.extent[idx];\n\t\telse\n\t\t\te = &new_map.forward[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\te->lower_first,\n\t\t\t\t\t\te->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n\t\te->lower_first = lower_first;\n\t}\n\n\t/*\n\t * If we want to use binary search for lookup, this clones the extent\n\t * array and sorts both copies.\n\t */\n\tret = sort_idmaps(&new_map);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Install the map */\n\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tmemcpy(map->extent, new_map.extent,\n\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));\n\t} else {\n\t\tmap->forward = new_map.forward;\n\t\tmap->reverse = new_map.reverse;\n\t}\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tkfree(new_map.forward);\n\t\tkfree(new_map.reverse);\n\t\tmap->forward = NULL;\n\t\tmap->reverse = NULL;\n\t\tmap->nr_extents = 0;\n\t}\n\n\tmutex_unlock(&userns_state_mutex);\n\tkfree(kbuf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "seq"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nssize_t proc_uid_map_write(struct file *file, const char __user *buf,\n\t\t\t   size_t size, loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct user_namespace *seq_ns = seq_user_ns(seq);\n\n\tif (!ns->parent)\n\t\treturn -EPERM;\n\n\tif ((seq_ns != ns) && (seq_ns != ns->parent))\n\t\treturn -EPERM;\n\n\treturn map_write(file, buf, size, ppos, CAP_SETUID,\n\t\t\t &ns->uid_map, &ns->parent->uid_map);\n}"
  },
  {
    "function_name": "map_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "903-1089",
    "snippet": "static ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *map_ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent extent;\n\tchar *kbuf = NULL, *pos, *next_line;\n\tssize_t ret;\n\n\t/* Only allow < page size writes at the beginning of the file */\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t/* Slurp in the user data */\n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t/*\n\t * The userns_state_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_rmb() is guaranteed that we don't have crazy\n\t * architectures returning stale data.\n\t */\n\tmutex_lock(&userns_state_mutex);\n\n\tmemset(&new_map, 0, sizeof(struct uid_gid_map));\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/*\n\t * Adjusting namespace settings requires capabilities on the target.\n\t */\n\tif (cap_valid(cap_setid) && !file_ns_capable(file, map_ns, CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tfor (; pos; pos = next_line) {\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent.first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent.first == (u32) -1) ||\n\t\t    (extent.lower_first == (u32) -1))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the\n\t\t * extent to wrap\n\t\t */\n\t\tif ((extent.first + extent.count) <= extent.first)\n\t\t\tgoto out;\n\t\tif ((extent.lower_first + extent.count) <=\n\t\t     extent.lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, &extent))\n\t\t\tgoto out;\n\n\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\n\t\tret = insert_extent(&new_map, &extent);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t}\n\t/* Be very certain the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Validate the user is allowed to use user id's mapped to. */\n\tif (!new_idmap_permitted(file, map_ns, cap_setid, &new_map))\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Map the lower ids from the parent user namespace to the\n\t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tstruct uid_gid_extent *e;\n\t\tu32 lower_first;\n\n\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\te = &new_map.extent[idx];\n\t\telse\n\t\t\te = &new_map.forward[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\te->lower_first,\n\t\t\t\t\t\te->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n\t\te->lower_first = lower_first;\n\t}\n\n\t/*\n\t * If we want to use binary search for lookup, this clones the extent\n\t * array and sorts both copies.\n\t */\n\tret = sort_idmaps(&new_map);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Install the map */\n\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tmemcpy(map->extent, new_map.extent,\n\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));\n\t} else {\n\t\tmap->forward = new_map.forward;\n\t\tmap->reverse = new_map.reverse;\n\t}\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tkfree(new_map.forward);\n\t\tkfree(new_map.reverse);\n\t\tmap->forward = NULL;\n\t\tmap->reverse = NULL;\n\t\tmap->nr_extents = 0;\n\t}\n\n\tmutex_unlock(&userns_state_mutex);\n\tkfree(kbuf);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(userns_state_mutex);",
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kbuf"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&userns_state_mutex"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "map->extent",
            "new_map.extent",
            "new_map.nr_extents * sizeof(new_map.extent[0])"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort_idmaps",
          "args": [
            "&new_map"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "sort_idmaps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "826-847",
          "snippet": "static int sort_idmaps(struct uid_gid_map *map)\n{\n\tif (map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn 0;\n\n\t/* Sort forward array. */\n\tsort(map->forward, map->nr_extents, sizeof(struct uid_gid_extent),\n\t     cmp_extents_forward, NULL);\n\n\t/* Only copy the memory from forward we actually need. */\n\tmap->reverse = kmemdup(map->forward,\n\t\t\t       map->nr_extents * sizeof(struct uid_gid_extent),\n\t\t\t       GFP_KERNEL);\n\tif (!map->reverse)\n\t\treturn -ENOMEM;\n\n\t/* Sort reverse array. */\n\tsort(map->reverse, map->nr_extents, sizeof(struct uid_gid_extent),\n\t     cmp_extents_reverse, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic int sort_idmaps(struct uid_gid_map *map)\n{\n\tif (map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn 0;\n\n\t/* Sort forward array. */\n\tsort(map->forward, map->nr_extents, sizeof(struct uid_gid_extent),\n\t     cmp_extents_forward, NULL);\n\n\t/* Only copy the memory from forward we actually need. */\n\tmap->reverse = kmemdup(map->forward,\n\t\t\t       map->nr_extents * sizeof(struct uid_gid_extent),\n\t\t\t       GFP_KERNEL);\n\tif (!map->reverse)\n\t\treturn -ENOMEM;\n\n\t/* Sort reverse array. */\n\tsort(map->reverse, map->nr_extents, sizeof(struct uid_gid_extent),\n\t     cmp_extents_reverse, NULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_id_range_down",
          "args": [
            "parent_map",
            "e->lower_first",
            "e->count"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_range_down",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "295-313",
          "snippet": "static u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_range_down_base(extents, map, id, count);\n\telse\n\t\textent = map_id_range_down_max(extents, map, id, count);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->first) + extent->lower_first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_range_down_base(extents, map, id, count);\n\telse\n\t\textent = map_id_range_down_max(extents, map, id, count);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->first) + extent->lower_first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_idmap_permitted",
          "args": [
            "file",
            "map_ns",
            "cap_setid",
            "&new_map"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "new_idmap_permitted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "1143-1183",
          "snippet": "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tconst struct cred *cred = file->f_cred;\n\n\tif (cap_setid == CAP_SETUID && !verify_root_map(file, ns, new_map))\n\t\treturn false;\n\n\t/* Don't allow mappings that would allow anything that wouldn't\n\t * be allowed without the establishment of unprivileged mappings.\n\t */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1) &&\n\t    uid_eq(ns->owner, cred->euid)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, cred->euid))\n\t\t\t\treturn true;\n\t\t} else if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (!(ns->flags & USERNS_SETGROUPS_ALLOWED) &&\n\t\t\t    gid_eq(gid, cred->egid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.\n\t * And the opener of the id file also has the appropriate capability.\n\t */\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tconst struct cred *cred = file->f_cred;\n\n\tif (cap_setid == CAP_SETUID && !verify_root_map(file, ns, new_map))\n\t\treturn false;\n\n\t/* Don't allow mappings that would allow anything that wouldn't\n\t * be allowed without the establishment of unprivileged mappings.\n\t */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1) &&\n\t    uid_eq(ns->owner, cred->euid)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, cred->euid))\n\t\t\t\treturn true;\n\t\t} else if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (!(ns->flags & USERNS_SETGROUPS_ALLOWED) &&\n\t\t\t    gid_eq(gid, cred->egid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.\n\t * And the opener of the id file also has the appropriate capability.\n\t */\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_extent",
          "args": [
            "&new_map",
            "&extent"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "insert_extent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "758-790",
          "snippet": "static int insert_extent(struct uid_gid_map *map, struct uid_gid_extent *extent)\n{\n\tstruct uid_gid_extent *dest;\n\n\tif (map->nr_extents == UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tstruct uid_gid_extent *forward;\n\n\t\t/* Allocate memory for 340 mappings. */\n\t\tforward = kmalloc_array(UID_GID_MAP_MAX_EXTENTS,\n\t\t\t\t\tsizeof(struct uid_gid_extent),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!forward)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Copy over memory. Only set up memory for the forward pointer.\n\t\t * Defer the memory setup for the reverse pointer.\n\t\t */\n\t\tmemcpy(forward, map->extent,\n\t\t       map->nr_extents * sizeof(map->extent[0]));\n\n\t\tmap->forward = forward;\n\t\tmap->reverse = NULL;\n\t}\n\n\tif (map->nr_extents < UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\tdest = &map->extent[map->nr_extents];\n\telse\n\t\tdest = &map->forward[map->nr_extents];\n\n\t*dest = *extent;\n\tmap->nr_extents++;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic int insert_extent(struct uid_gid_map *map, struct uid_gid_extent *extent)\n{\n\tstruct uid_gid_extent *dest;\n\n\tif (map->nr_extents == UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tstruct uid_gid_extent *forward;\n\n\t\t/* Allocate memory for 340 mappings. */\n\t\tforward = kmalloc_array(UID_GID_MAP_MAX_EXTENTS,\n\t\t\t\t\tsizeof(struct uid_gid_extent),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!forward)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Copy over memory. Only set up memory for the forward pointer.\n\t\t * Defer the memory setup for the reverse pointer.\n\t\t */\n\t\tmemcpy(forward, map->extent,\n\t\t       map->nr_extents * sizeof(map->extent[0]));\n\n\t\tmap->forward = forward;\n\t\tmap->reverse = NULL;\n\t}\n\n\tif (map->nr_extents < UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\tdest = &map->extent[map->nr_extents];\n\telse\n\t\tdest = &map->forward[map->nr_extents];\n\n\t*dest = *extent;\n\tmap->nr_extents++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mappings_overlap",
          "args": [
            "&new_map",
            "&extent"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "mappings_overlap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "714-751",
          "snippet": "static bool mappings_overlap(struct uid_gid_map *new_map,\n\t\t\t     struct uid_gid_extent *extent)\n{\n\tu32 upper_first, lower_first, upper_last, lower_last;\n\tunsigned idx;\n\n\tupper_first = extent->first;\n\tlower_first = extent->lower_first;\n\tupper_last = upper_first + extent->count - 1;\n\tlower_last = lower_first + extent->count - 1;\n\n\tfor (idx = 0; idx < new_map->nr_extents; idx++) {\n\t\tu32 prev_upper_first, prev_lower_first;\n\t\tu32 prev_upper_last, prev_lower_last;\n\t\tstruct uid_gid_extent *prev;\n\n\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\tprev = &new_map->extent[idx];\n\t\telse\n\t\t\tprev = &new_map->forward[idx];\n\n\t\tprev_upper_first = prev->first;\n\t\tprev_lower_first = prev->lower_first;\n\t\tprev_upper_last = prev_upper_first + prev->count - 1;\n\t\tprev_lower_last = prev_lower_first + prev->count - 1;\n\n\t\t/* Does the upper range intersect a previous extent? */\n\t\tif ((prev_upper_first <= upper_last) &&\n\t\t    (prev_upper_last >= upper_first))\n\t\t\treturn true;\n\n\t\t/* Does the lower range intersect a previous extent? */\n\t\tif ((prev_lower_first <= lower_last) &&\n\t\t    (prev_lower_last >= lower_first))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool mappings_overlap(struct uid_gid_map *new_map,\n\t\t\t     struct uid_gid_extent *extent)\n{\n\tu32 upper_first, lower_first, upper_last, lower_last;\n\tunsigned idx;\n\n\tupper_first = extent->first;\n\tlower_first = extent->lower_first;\n\tupper_last = upper_first + extent->count - 1;\n\tlower_last = lower_first + extent->count - 1;\n\n\tfor (idx = 0; idx < new_map->nr_extents; idx++) {\n\t\tu32 prev_upper_first, prev_lower_first;\n\t\tu32 prev_upper_last, prev_lower_last;\n\t\tstruct uid_gid_extent *prev;\n\n\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\tprev = &new_map->extent[idx];\n\t\telse\n\t\t\tprev = &new_map->forward[idx];\n\n\t\tprev_upper_first = prev->first;\n\t\tprev_lower_first = prev->lower_first;\n\t\tprev_upper_last = prev_upper_first + prev->count - 1;\n\t\tprev_lower_last = prev_lower_first + prev->count - 1;\n\n\t\t/* Does the upper range intersect a previous extent? */\n\t\tif ((prev_upper_first <= upper_last) &&\n\t\t    (prev_upper_last >= upper_first))\n\t\t\treturn true;\n\n\t\t/* Does the lower range intersect a previous extent? */\n\t\tif ((prev_lower_first <= lower_last) &&\n\t\t    (prev_lower_last >= lower_first))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "pos"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "proc_skip_spaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "333-340",
          "snippet": "static size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*pos"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "pos",
            "&pos",
            "10"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*pos"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "pos",
            "&pos",
            "10"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*pos"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "pos",
            "&pos",
            "10"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "pos",
            "'\\n'"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_ns_capable",
          "args": [
            "file",
            "map_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "file_ns_capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "466-477",
          "snippet": "bool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_valid",
          "args": [
            "cap_setid"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new_map",
            "0",
            "sizeof(struct uid_gid_map)"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&userns_state_mutex"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kbuf"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kbuf"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(userns_state_mutex);\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *map_ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent extent;\n\tchar *kbuf = NULL, *pos, *next_line;\n\tssize_t ret;\n\n\t/* Only allow < page size writes at the beginning of the file */\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t/* Slurp in the user data */\n\tkbuf = memdup_user_nul(buf, count);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\t/*\n\t * The userns_state_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_rmb() is guaranteed that we don't have crazy\n\t * architectures returning stale data.\n\t */\n\tmutex_lock(&userns_state_mutex);\n\n\tmemset(&new_map, 0, sizeof(struct uid_gid_map));\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/*\n\t * Adjusting namespace settings requires capabilities on the target.\n\t */\n\tif (cap_valid(cap_setid) && !file_ns_capable(file, map_ns, CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tfor (; pos; pos = next_line) {\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent.first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent.count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent.first == (u32) -1) ||\n\t\t    (extent.lower_first == (u32) -1))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the\n\t\t * extent to wrap\n\t\t */\n\t\tif ((extent.first + extent.count) <= extent.first)\n\t\t\tgoto out;\n\t\tif ((extent.lower_first + extent.count) <=\n\t\t     extent.lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, &extent))\n\t\t\tgoto out;\n\n\t\tif ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\n\t\tret = insert_extent(&new_map, &extent);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t}\n\t/* Be very certain the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Validate the user is allowed to use user id's mapped to. */\n\tif (!new_idmap_permitted(file, map_ns, cap_setid, &new_map))\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Map the lower ids from the parent user namespace to the\n\t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tstruct uid_gid_extent *e;\n\t\tu32 lower_first;\n\n\t\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\te = &new_map.extent[idx];\n\t\telse\n\t\t\te = &new_map.forward[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\te->lower_first,\n\t\t\t\t\t\te->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n\t\te->lower_first = lower_first;\n\t}\n\n\t/*\n\t * If we want to use binary search for lookup, this clones the extent\n\t * array and sorts both copies.\n\t */\n\tret = sort_idmaps(&new_map);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Install the map */\n\tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tmemcpy(map->extent, new_map.extent,\n\t\t       new_map.nr_extents * sizeof(new_map.extent[0]));\n\t} else {\n\t\tmap->forward = new_map.forward;\n\t\tmap->reverse = new_map.reverse;\n\t}\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tif (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tkfree(new_map.forward);\n\t\tkfree(new_map.reverse);\n\t\tmap->forward = NULL;\n\t\tmap->reverse = NULL;\n\t\tmap->nr_extents = 0;\n\t}\n\n\tmutex_unlock(&userns_state_mutex);\n\tkfree(kbuf);\n\treturn ret;\n}"
  },
  {
    "function_name": "verify_root_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "861-901",
    "snippet": "static bool verify_root_map(const struct file *file,\n\t\t\t    struct user_namespace *map_ns,\n\t\t\t    struct uid_gid_map *new_map)\n{\n\tint idx;\n\tconst struct user_namespace *file_ns = file->f_cred->user_ns;\n\tstruct uid_gid_extent *extent0 = NULL;\n\n\tfor (idx = 0; idx < new_map->nr_extents; idx++) {\n\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\textent0 = &new_map->extent[idx];\n\t\telse\n\t\t\textent0 = &new_map->forward[idx];\n\t\tif (extent0->lower_first == 0)\n\t\t\tbreak;\n\n\t\textent0 = NULL;\n\t}\n\n\tif (!extent0)\n\t\treturn true;\n\n\tif (map_ns == file_ns) {\n\t\t/* The process unshared its ns and is writing to its own\n\t\t * /proc/self/uid_map.  User already has full capabilites in\n\t\t * the new namespace.  Verify that the parent had CAP_SETFCAP\n\t\t * when it unshared.\n\t\t * */\n\t\tif (!file_ns->parent_could_setfcap)\n\t\t\treturn false;\n\t} else {\n\t\t/* Process p1 is writing to uid_map of p2, who is in a child\n\t\t * user namespace to p1's.  Verify that the opener of the map\n\t\t * file has CAP_SETFCAP against the parent of the new map\n\t\t * namespace */\n\t\tif (!file_ns_capable(file, map_ns->parent, CAP_SETFCAP))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_ns_capable",
          "args": [
            "file",
            "map_ns->parent",
            "CAP_SETFCAP"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "file_ns_capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "466-477",
          "snippet": "bool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic bool verify_root_map(const struct file *file,\n\t\t\t    struct user_namespace *map_ns,\n\t\t\t    struct uid_gid_map *new_map)\n{\n\tint idx;\n\tconst struct user_namespace *file_ns = file->f_cred->user_ns;\n\tstruct uid_gid_extent *extent0 = NULL;\n\n\tfor (idx = 0; idx < new_map->nr_extents; idx++) {\n\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\textent0 = &new_map->extent[idx];\n\t\telse\n\t\t\textent0 = &new_map->forward[idx];\n\t\tif (extent0->lower_first == 0)\n\t\t\tbreak;\n\n\t\textent0 = NULL;\n\t}\n\n\tif (!extent0)\n\t\treturn true;\n\n\tif (map_ns == file_ns) {\n\t\t/* The process unshared its ns and is writing to its own\n\t\t * /proc/self/uid_map.  User already has full capabilites in\n\t\t * the new namespace.  Verify that the parent had CAP_SETFCAP\n\t\t * when it unshared.\n\t\t * */\n\t\tif (!file_ns->parent_could_setfcap)\n\t\t\treturn false;\n\t} else {\n\t\t/* Process p1 is writing to uid_map of p2, who is in a child\n\t\t * user namespace to p1's.  Verify that the opener of the map\n\t\t * file has CAP_SETFCAP against the parent of the new map\n\t\t * namespace */\n\t\tif (!file_ns_capable(file, map_ns->parent, CAP_SETFCAP))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "sort_idmaps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "826-847",
    "snippet": "static int sort_idmaps(struct uid_gid_map *map)\n{\n\tif (map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn 0;\n\n\t/* Sort forward array. */\n\tsort(map->forward, map->nr_extents, sizeof(struct uid_gid_extent),\n\t     cmp_extents_forward, NULL);\n\n\t/* Only copy the memory from forward we actually need. */\n\tmap->reverse = kmemdup(map->forward,\n\t\t\t       map->nr_extents * sizeof(struct uid_gid_extent),\n\t\t\t       GFP_KERNEL);\n\tif (!map->reverse)\n\t\treturn -ENOMEM;\n\n\t/* Sort reverse array. */\n\tsort(map->reverse, map->nr_extents, sizeof(struct uid_gid_extent),\n\t     cmp_extents_reverse, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "map->reverse",
            "map->nr_extents",
            "sizeof(struct uid_gid_extent)",
            "cmp_extents_reverse",
            "NULL"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "map->forward",
            "map->nr_extents * sizeof(struct uid_gid_extent)",
            "GFP_KERNEL"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic int sort_idmaps(struct uid_gid_map *map)\n{\n\tif (map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn 0;\n\n\t/* Sort forward array. */\n\tsort(map->forward, map->nr_extents, sizeof(struct uid_gid_extent),\n\t     cmp_extents_forward, NULL);\n\n\t/* Only copy the memory from forward we actually need. */\n\tmap->reverse = kmemdup(map->forward,\n\t\t\t       map->nr_extents * sizeof(struct uid_gid_extent),\n\t\t\t       GFP_KERNEL);\n\tif (!map->reverse)\n\t\treturn -ENOMEM;\n\n\t/* Sort reverse array. */\n\tsort(map->reverse, map->nr_extents, sizeof(struct uid_gid_extent),\n\t     cmp_extents_reverse, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cmp_extents_reverse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "808-820",
    "snippet": "static int cmp_extents_reverse(const void *a, const void *b)\n{\n\tconst struct uid_gid_extent *e1 = a;\n\tconst struct uid_gid_extent *e2 = b;\n\n\tif (e1->lower_first < e2->lower_first)\n\t\treturn -1;\n\n\tif (e1->lower_first > e2->lower_first)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic int cmp_extents_reverse(const void *a, const void *b)\n{\n\tconst struct uid_gid_extent *e1 = a;\n\tconst struct uid_gid_extent *e2 = b;\n\n\tif (e1->lower_first < e2->lower_first)\n\t\treturn -1;\n\n\tif (e1->lower_first > e2->lower_first)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cmp_extents_forward",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "793-805",
    "snippet": "static int cmp_extents_forward(const void *a, const void *b)\n{\n\tconst struct uid_gid_extent *e1 = a;\n\tconst struct uid_gid_extent *e2 = b;\n\n\tif (e1->first < e2->first)\n\t\treturn -1;\n\n\tif (e1->first > e2->first)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic int cmp_extents_forward(const void *a, const void *b)\n{\n\tconst struct uid_gid_extent *e1 = a;\n\tconst struct uid_gid_extent *e2 = b;\n\n\tif (e1->first < e2->first)\n\t\treturn -1;\n\n\tif (e1->first > e2->first)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "insert_extent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "758-790",
    "snippet": "static int insert_extent(struct uid_gid_map *map, struct uid_gid_extent *extent)\n{\n\tstruct uid_gid_extent *dest;\n\n\tif (map->nr_extents == UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tstruct uid_gid_extent *forward;\n\n\t\t/* Allocate memory for 340 mappings. */\n\t\tforward = kmalloc_array(UID_GID_MAP_MAX_EXTENTS,\n\t\t\t\t\tsizeof(struct uid_gid_extent),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!forward)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Copy over memory. Only set up memory for the forward pointer.\n\t\t * Defer the memory setup for the reverse pointer.\n\t\t */\n\t\tmemcpy(forward, map->extent,\n\t\t       map->nr_extents * sizeof(map->extent[0]));\n\n\t\tmap->forward = forward;\n\t\tmap->reverse = NULL;\n\t}\n\n\tif (map->nr_extents < UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\tdest = &map->extent[map->nr_extents];\n\telse\n\t\tdest = &map->forward[map->nr_extents];\n\n\t*dest = *extent;\n\tmap->nr_extents++;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "forward",
            "map->extent",
            "map->nr_extents * sizeof(map->extent[0])"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "UID_GID_MAP_MAX_EXTENTS",
            "sizeof(struct uid_gid_extent)",
            "GFP_KERNEL"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic int insert_extent(struct uid_gid_map *map, struct uid_gid_extent *extent)\n{\n\tstruct uid_gid_extent *dest;\n\n\tif (map->nr_extents == UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\tstruct uid_gid_extent *forward;\n\n\t\t/* Allocate memory for 340 mappings. */\n\t\tforward = kmalloc_array(UID_GID_MAP_MAX_EXTENTS,\n\t\t\t\t\tsizeof(struct uid_gid_extent),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!forward)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Copy over memory. Only set up memory for the forward pointer.\n\t\t * Defer the memory setup for the reverse pointer.\n\t\t */\n\t\tmemcpy(forward, map->extent,\n\t\t       map->nr_extents * sizeof(map->extent[0]));\n\n\t\tmap->forward = forward;\n\t\tmap->reverse = NULL;\n\t}\n\n\tif (map->nr_extents < UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\tdest = &map->extent[map->nr_extents];\n\telse\n\t\tdest = &map->forward[map->nr_extents];\n\n\t*dest = *extent;\n\tmap->nr_extents++;\n\treturn 0;\n}"
  },
  {
    "function_name": "mappings_overlap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "714-751",
    "snippet": "static bool mappings_overlap(struct uid_gid_map *new_map,\n\t\t\t     struct uid_gid_extent *extent)\n{\n\tu32 upper_first, lower_first, upper_last, lower_last;\n\tunsigned idx;\n\n\tupper_first = extent->first;\n\tlower_first = extent->lower_first;\n\tupper_last = upper_first + extent->count - 1;\n\tlower_last = lower_first + extent->count - 1;\n\n\tfor (idx = 0; idx < new_map->nr_extents; idx++) {\n\t\tu32 prev_upper_first, prev_lower_first;\n\t\tu32 prev_upper_last, prev_lower_last;\n\t\tstruct uid_gid_extent *prev;\n\n\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\tprev = &new_map->extent[idx];\n\t\telse\n\t\t\tprev = &new_map->forward[idx];\n\n\t\tprev_upper_first = prev->first;\n\t\tprev_lower_first = prev->lower_first;\n\t\tprev_upper_last = prev_upper_first + prev->count - 1;\n\t\tprev_lower_last = prev_lower_first + prev->count - 1;\n\n\t\t/* Does the upper range intersect a previous extent? */\n\t\tif ((prev_upper_first <= upper_last) &&\n\t\t    (prev_upper_last >= upper_first))\n\t\t\treturn true;\n\n\t\t/* Does the lower range intersect a previous extent? */\n\t\tif ((prev_lower_first <= lower_last) &&\n\t\t    (prev_lower_last >= lower_first))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool mappings_overlap(struct uid_gid_map *new_map,\n\t\t\t     struct uid_gid_extent *extent)\n{\n\tu32 upper_first, lower_first, upper_last, lower_last;\n\tunsigned idx;\n\n\tupper_first = extent->first;\n\tlower_first = extent->lower_first;\n\tupper_last = upper_first + extent->count - 1;\n\tlower_last = lower_first + extent->count - 1;\n\n\tfor (idx = 0; idx < new_map->nr_extents; idx++) {\n\t\tu32 prev_upper_first, prev_lower_first;\n\t\tu32 prev_upper_last, prev_lower_last;\n\t\tstruct uid_gid_extent *prev;\n\n\t\tif (new_map->nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\t\tprev = &new_map->extent[idx];\n\t\telse\n\t\t\tprev = &new_map->forward[idx];\n\n\t\tprev_upper_first = prev->first;\n\t\tprev_lower_first = prev->lower_first;\n\t\tprev_upper_last = prev_upper_first + prev->count - 1;\n\t\tprev_lower_last = prev_lower_first + prev->count - 1;\n\n\t\t/* Does the upper range intersect a previous extent? */\n\t\tif ((prev_upper_first <= upper_last) &&\n\t\t    (prev_upper_last >= upper_first))\n\t\t\treturn true;\n\n\t\t/* Does the lower range intersect a previous extent? */\n\t\tif ((prev_lower_first <= lower_last) &&\n\t\t    (prev_lower_last >= lower_first))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "m_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "688-691",
    "snippet": "static void m_stop(struct seq_file *seq, void *v)\n{\n\treturn;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void m_stop(struct seq_file *seq, void *v)\n{\n\treturn;\n}"
  },
  {
    "function_name": "m_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "682-686",
    "snippet": "static void *m_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn seq->op->start(seq, pos);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq->op->start",
          "args": [
            "seq",
            "pos"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void *m_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn seq->op->start(seq, pos);\n}"
  },
  {
    "function_name": "projid_m_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "675-680",
    "snippet": "static void *projid_m_start(struct seq_file *seq, loff_t *ppos)\n{\n\tstruct user_namespace *ns = seq->private;\n\n\treturn m_start(seq, ppos, &ns->projid_map);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_start",
          "args": [
            "seq",
            "ppos",
            "&ns->projid_map"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "m_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "645-659",
          "snippet": "static void *m_start(struct seq_file *seq, loff_t *ppos,\n\t\t     struct uid_gid_map *map)\n{\n\tloff_t pos = *ppos;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (pos >= extents)\n\t\treturn NULL;\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn &map->extent[pos];\n\n\treturn &map->forward[pos];\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic void *m_start(struct seq_file *seq, loff_t *ppos,\n\t\t     struct uid_gid_map *map)\n{\n\tloff_t pos = *ppos;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (pos >= extents)\n\t\treturn NULL;\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn &map->extent[pos];\n\n\treturn &map->forward[pos];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void *projid_m_start(struct seq_file *seq, loff_t *ppos)\n{\n\tstruct user_namespace *ns = seq->private;\n\n\treturn m_start(seq, ppos, &ns->projid_map);\n}"
  },
  {
    "function_name": "gid_m_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "668-673",
    "snippet": "static void *gid_m_start(struct seq_file *seq, loff_t *ppos)\n{\n\tstruct user_namespace *ns = seq->private;\n\n\treturn m_start(seq, ppos, &ns->gid_map);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_start",
          "args": [
            "seq",
            "ppos",
            "&ns->gid_map"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "m_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "645-659",
          "snippet": "static void *m_start(struct seq_file *seq, loff_t *ppos,\n\t\t     struct uid_gid_map *map)\n{\n\tloff_t pos = *ppos;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (pos >= extents)\n\t\treturn NULL;\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn &map->extent[pos];\n\n\treturn &map->forward[pos];\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic void *m_start(struct seq_file *seq, loff_t *ppos,\n\t\t     struct uid_gid_map *map)\n{\n\tloff_t pos = *ppos;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (pos >= extents)\n\t\treturn NULL;\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn &map->extent[pos];\n\n\treturn &map->forward[pos];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void *gid_m_start(struct seq_file *seq, loff_t *ppos)\n{\n\tstruct user_namespace *ns = seq->private;\n\n\treturn m_start(seq, ppos, &ns->gid_map);\n}"
  },
  {
    "function_name": "uid_m_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "661-666",
    "snippet": "static void *uid_m_start(struct seq_file *seq, loff_t *ppos)\n{\n\tstruct user_namespace *ns = seq->private;\n\n\treturn m_start(seq, ppos, &ns->uid_map);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_start",
          "args": [
            "seq",
            "ppos",
            "&ns->uid_map"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "m_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "645-659",
          "snippet": "static void *m_start(struct seq_file *seq, loff_t *ppos,\n\t\t     struct uid_gid_map *map)\n{\n\tloff_t pos = *ppos;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (pos >= extents)\n\t\treturn NULL;\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn &map->extent[pos];\n\n\treturn &map->forward[pos];\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic void *m_start(struct seq_file *seq, loff_t *ppos,\n\t\t     struct uid_gid_map *map)\n{\n\tloff_t pos = *ppos;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (pos >= extents)\n\t\treturn NULL;\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn &map->extent[pos];\n\n\treturn &map->forward[pos];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void *uid_m_start(struct seq_file *seq, loff_t *ppos)\n{\n\tstruct user_namespace *ns = seq->private;\n\n\treturn m_start(seq, ppos, &ns->uid_map);\n}"
  },
  {
    "function_name": "m_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "645-659",
    "snippet": "static void *m_start(struct seq_file *seq, loff_t *ppos,\n\t\t     struct uid_gid_map *map)\n{\n\tloff_t pos = *ppos;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (pos >= extents)\n\t\treturn NULL;\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn &map->extent[pos];\n\n\treturn &map->forward[pos];\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic void *m_start(struct seq_file *seq, loff_t *ppos,\n\t\t     struct uid_gid_map *map)\n{\n\tloff_t pos = *ppos;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (pos >= extents)\n\t\treturn NULL;\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\treturn &map->extent[pos];\n\n\treturn &map->forward[pos];\n}"
  },
  {
    "function_name": "projid_m_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "624-643",
    "snippet": "static int projid_m_show(struct seq_file *seq, void *v)\n{\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_extent *extent = v;\n\tstruct user_namespace *lower_ns;\n\tprojid_t lower;\n\n\tlower_ns = seq_user_ns(seq);\n\tif ((lower_ns == ns) && lower_ns->parent)\n\t\tlower_ns = lower_ns->parent;\n\n\tlower = from_kprojid(lower_ns, KPROJIDT_INIT(extent->lower_first));\n\n\tseq_printf(seq, \"%10u %10u %10u\\n\",\n\t\textent->first,\n\t\tlower,\n\t\textent->count);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%10u %10u %10u\\n\"",
            "extent->first",
            "lower",
            "extent->count"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kprojid",
          "args": [
            "lower_ns",
            "KPROJIDT_INIT(extent->lower_first)"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "from_kprojid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "570-578",
          "snippet": "projid_t from_kprojid_munged(struct user_namespace *targ, kprojid_t kprojid)\n{\n\tprojid_t projid;\n\tprojid = from_kprojid(targ, kprojid);\n\n\tif (projid == (projid_t) -1)\n\t\tprojid = OVERFLOW_PROJID;\n\treturn projid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nprojid_t from_kprojid_munged(struct user_namespace *targ, kprojid_t kprojid)\n{\n\tprojid_t projid;\n\tprojid = from_kprojid(targ, kprojid);\n\n\tif (projid == (projid_t) -1)\n\t\tprojid = OVERFLOW_PROJID;\n\treturn projid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KPROJIDT_INIT",
          "args": [
            "extent->lower_first"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "seq"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic int projid_m_show(struct seq_file *seq, void *v)\n{\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_extent *extent = v;\n\tstruct user_namespace *lower_ns;\n\tprojid_t lower;\n\n\tlower_ns = seq_user_ns(seq);\n\tif ((lower_ns == ns) && lower_ns->parent)\n\t\tlower_ns = lower_ns->parent;\n\n\tlower = from_kprojid(lower_ns, KPROJIDT_INIT(extent->lower_first));\n\n\tseq_printf(seq, \"%10u %10u %10u\\n\",\n\t\textent->first,\n\t\tlower,\n\t\textent->count);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gid_m_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "603-622",
    "snippet": "static int gid_m_show(struct seq_file *seq, void *v)\n{\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_extent *extent = v;\n\tstruct user_namespace *lower_ns;\n\tgid_t lower;\n\n\tlower_ns = seq_user_ns(seq);\n\tif ((lower_ns == ns) && lower_ns->parent)\n\t\tlower_ns = lower_ns->parent;\n\n\tlower = from_kgid(lower_ns, KGIDT_INIT(extent->lower_first));\n\n\tseq_printf(seq, \"%10u %10u %10u\\n\",\n\t\textent->first,\n\t\tlower,\n\t\textent->count);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%10u %10u %10u\\n\"",
            "extent->first",
            "lower",
            "extent->count"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "lower_ns",
            "KGIDT_INIT(extent->lower_first)"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "502-510",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KGIDT_INIT",
          "args": [
            "extent->lower_first"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "seq"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic int gid_m_show(struct seq_file *seq, void *v)\n{\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_extent *extent = v;\n\tstruct user_namespace *lower_ns;\n\tgid_t lower;\n\n\tlower_ns = seq_user_ns(seq);\n\tif ((lower_ns == ns) && lower_ns->parent)\n\t\tlower_ns = lower_ns->parent;\n\n\tlower = from_kgid(lower_ns, KGIDT_INIT(extent->lower_first));\n\n\tseq_printf(seq, \"%10u %10u %10u\\n\",\n\t\textent->first,\n\t\tlower,\n\t\textent->count);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "uid_m_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "582-601",
    "snippet": "static int uid_m_show(struct seq_file *seq, void *v)\n{\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_extent *extent = v;\n\tstruct user_namespace *lower_ns;\n\tuid_t lower;\n\n\tlower_ns = seq_user_ns(seq);\n\tif ((lower_ns == ns) && lower_ns->parent)\n\t\tlower_ns = lower_ns->parent;\n\n\tlower = from_kuid(lower_ns, KUIDT_INIT(extent->lower_first));\n\n\tseq_printf(seq, \"%10u %10u %10u\\n\",\n\t\textent->first,\n\t\tlower,\n\t\textent->count);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%10u %10u %10u\\n\"",
            "extent->first",
            "lower",
            "extent->count"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "lower_ns",
            "KUIDT_INIT(extent->lower_first)"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KUIDT_INIT",
          "args": [
            "extent->lower_first"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "seq"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic int uid_m_show(struct seq_file *seq, void *v)\n{\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_extent *extent = v;\n\tstruct user_namespace *lower_ns;\n\tuid_t lower;\n\n\tlower_ns = seq_user_ns(seq);\n\tif ((lower_ns == ns) && lower_ns->parent)\n\t\tlower_ns = lower_ns->parent;\n\n\tlower = from_kuid(lower_ns, KUIDT_INIT(extent->lower_first));\n\n\tseq_printf(seq, \"%10u %10u %10u\\n\",\n\t\textent->first,\n\t\tlower,\n\t\textent->count);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "from_kprojid_munged",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "570-578",
    "snippet": "projid_t from_kprojid_munged(struct user_namespace *targ, kprojid_t kprojid)\n{\n\tprojid_t projid;\n\tprojid = from_kprojid(targ, kprojid);\n\n\tif (projid == (projid_t) -1)\n\t\tprojid = OVERFLOW_PROJID;\n\treturn projid;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_kprojid",
          "args": [
            "targ",
            "kprojid"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "from_kprojid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "570-578",
          "snippet": "projid_t from_kprojid_munged(struct user_namespace *targ, kprojid_t kprojid)\n{\n\tprojid_t projid;\n\tprojid = from_kprojid(targ, kprojid);\n\n\tif (projid == (projid_t) -1)\n\t\tprojid = OVERFLOW_PROJID;\n\treturn projid;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nprojid_t from_kprojid_munged(struct user_namespace *targ, kprojid_t kprojid)\n{\n\tprojid_t projid;\n\tprojid = from_kprojid(targ, kprojid);\n\n\tif (projid == (projid_t) -1)\n\t\tprojid = OVERFLOW_PROJID;\n\treturn projid;\n}"
  },
  {
    "function_name": "from_kprojid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "545-549",
    "snippet": "projid_t from_kprojid(struct user_namespace *targ, kprojid_t kprojid)\n{\n\t/* Map the uid from a global kernel uid */\n\treturn map_id_up(&targ->projid_map, __kprojid_val(kprojid));\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_id_up",
          "args": [
            "&targ->projid_map",
            "__kprojid_val(kprojid)"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "358-376",
          "snippet": "static u32 map_id_up(struct uid_gid_map *map, u32 id)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_up_base(extents, map, id);\n\telse\n\t\textent = map_id_up_max(extents, map, id);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->lower_first) + extent->first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic u32 map_id_up(struct uid_gid_map *map, u32 id)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_up_base(extents, map, id);\n\telse\n\t\textent = map_id_up_max(extents, map, id);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->lower_first) + extent->first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kprojid_val",
          "args": [
            "kprojid"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nprojid_t from_kprojid(struct user_namespace *targ, kprojid_t kprojid)\n{\n\t/* Map the uid from a global kernel uid */\n\treturn map_id_up(&targ->projid_map, __kprojid_val(kprojid));\n}"
  },
  {
    "function_name": "make_kprojid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "526-530",
    "snippet": "kprojid_t make_kprojid(struct user_namespace *ns, projid_t projid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KPROJIDT_INIT(map_id_down(&ns->projid_map, projid));\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KPROJIDT_INIT",
          "args": [
            "map_id_down(&ns->projid_map, projid)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_id_down",
          "args": [
            "&ns->projid_map",
            "projid"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_down",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "315-318",
          "snippet": "static u32 map_id_down(struct uid_gid_map *map, u32 id)\n{\n\treturn map_id_range_down(map, id, 1);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic u32 map_id_down(struct uid_gid_map *map, u32 id)\n{\n\treturn map_id_range_down(map, id, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkprojid_t make_kprojid(struct user_namespace *ns, projid_t projid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KPROJIDT_INIT(map_id_down(&ns->projid_map, projid));\n}"
  },
  {
    "function_name": "from_kgid_munged",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "502-510",
    "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "targ",
            "kgid"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "502-510",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
  },
  {
    "function_name": "from_kgid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "478-482",
    "snippet": "gid_t from_kgid(struct user_namespace *targ, kgid_t kgid)\n{\n\t/* Map the gid from a global kernel gid */\n\treturn map_id_up(&targ->gid_map, __kgid_val(kgid));\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_id_up",
          "args": [
            "&targ->gid_map",
            "__kgid_val(kgid)"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "358-376",
          "snippet": "static u32 map_id_up(struct uid_gid_map *map, u32 id)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_up_base(extents, map, id);\n\telse\n\t\textent = map_id_up_max(extents, map, id);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->lower_first) + extent->first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic u32 map_id_up(struct uid_gid_map *map, u32 id)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_up_base(extents, map, id);\n\telse\n\t\textent = map_id_up_max(extents, map, id);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->lower_first) + extent->first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kgid_val",
          "args": [
            "kgid"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid(struct user_namespace *targ, kgid_t kgid)\n{\n\t/* Map the gid from a global kernel gid */\n\treturn map_id_up(&targ->gid_map, __kgid_val(kgid));\n}"
  },
  {
    "function_name": "make_kgid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "459-463",
    "snippet": "kgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KGIDT_INIT",
          "args": [
            "map_id_down(&ns->gid_map, gid)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_id_down",
          "args": [
            "&ns->gid_map",
            "gid"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_down",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "315-318",
          "snippet": "static u32 map_id_down(struct uid_gid_map *map, u32 id)\n{\n\treturn map_id_range_down(map, id, 1);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic u32 map_id_down(struct uid_gid_map *map, u32 id)\n{\n\treturn map_id_range_down(map, id, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\t/* Map the gid to a global kernel gid */\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}"
  },
  {
    "function_name": "from_kuid_munged",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "435-443",
    "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "targ",
            "kuid"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
  },
  {
    "function_name": "from_kuid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "410-414",
    "snippet": "uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)\n{\n\t/* Map the uid from a global kernel uid */\n\treturn map_id_up(&targ->uid_map, __kuid_val(kuid));\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_id_up",
          "args": [
            "&targ->uid_map",
            "__kuid_val(kuid)"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_up",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "358-376",
          "snippet": "static u32 map_id_up(struct uid_gid_map *map, u32 id)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_up_base(extents, map, id);\n\telse\n\t\textent = map_id_up_max(extents, map, id);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->lower_first) + extent->first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic u32 map_id_up(struct uid_gid_map *map, u32 id)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_up_base(extents, map, id);\n\telse\n\t\textent = map_id_up_max(extents, map, id);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->lower_first) + extent->first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kuid_val",
          "args": [
            "kuid"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid(struct user_namespace *targ, kuid_t kuid)\n{\n\t/* Map the uid from a global kernel uid */\n\treturn map_id_up(&targ->uid_map, __kuid_val(kuid));\n}"
  },
  {
    "function_name": "make_kuid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "391-395",
    "snippet": "kuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KUIDT_INIT",
          "args": [
            "map_id_down(&ns->uid_map, uid)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_id_down",
          "args": [
            "&ns->uid_map",
            "uid"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_down",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "315-318",
          "snippet": "static u32 map_id_down(struct uid_gid_map *map, u32 id)\n{\n\treturn map_id_range_down(map, id, 1);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic u32 map_id_down(struct uid_gid_map *map, u32 id)\n{\n\treturn map_id_range_down(map, id, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}"
  },
  {
    "function_name": "map_id_up",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "358-376",
    "snippet": "static u32 map_id_up(struct uid_gid_map *map, u32 id)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_up_base(extents, map, id);\n\telse\n\t\textent = map_id_up_max(extents, map, id);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->lower_first) + extent->first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_id_up_max",
          "args": [
            "extents",
            "map",
            "id"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_up_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "345-356",
          "snippet": "static struct uid_gid_extent *\nmap_id_up_max(unsigned extents, struct uid_gid_map *map, u32 id)\n{\n\tstruct idmap_key key;\n\n\tkey.map_up = true;\n\tkey.count = 1;\n\tkey.id = id;\n\n\treturn bsearch(&key, map->reverse, extents,\n\t\t       sizeof(struct uid_gid_extent), cmp_map_id);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic struct uid_gid_extent *\nmap_id_up_max(unsigned extents, struct uid_gid_map *map, u32 id)\n{\n\tstruct idmap_key key;\n\n\tkey.map_up = true;\n\tkey.count = 1;\n\tkey.id = id;\n\n\treturn bsearch(&key, map->reverse, extents,\n\t\t       sizeof(struct uid_gid_extent), cmp_map_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_id_up_base",
          "args": [
            "extents",
            "map",
            "id"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_up_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "325-339",
          "snippet": "static struct uid_gid_extent *\nmap_id_up_base(unsigned extents, struct uid_gid_map *map, u32 id)\n{\n\tunsigned idx;\n\tu32 first, last;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].lower_first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last)\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic struct uid_gid_extent *\nmap_id_up_base(unsigned extents, struct uid_gid_map *map, u32 id)\n{\n\tunsigned idx;\n\tu32 first, last;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].lower_first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last)\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic u32 map_id_up(struct uid_gid_map *map, u32 id)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_up_base(extents, map, id);\n\telse\n\t\textent = map_id_up_max(extents, map, id);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->lower_first) + extent->first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}"
  },
  {
    "function_name": "map_id_up_max",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "345-356",
    "snippet": "static struct uid_gid_extent *\nmap_id_up_max(unsigned extents, struct uid_gid_map *map, u32 id)\n{\n\tstruct idmap_key key;\n\n\tkey.map_up = true;\n\tkey.count = 1;\n\tkey.id = id;\n\n\treturn bsearch(&key, map->reverse, extents,\n\t\t       sizeof(struct uid_gid_extent), cmp_map_id);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&key",
            "map->reverse",
            "extents",
            "sizeof(struct uid_gid_extent)",
            "cmp_map_id"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic struct uid_gid_extent *\nmap_id_up_max(unsigned extents, struct uid_gid_map *map, u32 id)\n{\n\tstruct idmap_key key;\n\n\tkey.map_up = true;\n\tkey.count = 1;\n\tkey.id = id;\n\n\treturn bsearch(&key, map->reverse, extents,\n\t\t       sizeof(struct uid_gid_extent), cmp_map_id);\n}"
  },
  {
    "function_name": "map_id_up_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "325-339",
    "snippet": "static struct uid_gid_extent *\nmap_id_up_base(unsigned extents, struct uid_gid_map *map, u32 id)\n{\n\tunsigned idx;\n\tu32 first, last;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].lower_first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last)\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic struct uid_gid_extent *\nmap_id_up_base(unsigned extents, struct uid_gid_map *map, u32 id)\n{\n\tunsigned idx;\n\tu32 first, last;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].lower_first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last)\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "map_id_down",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "315-318",
    "snippet": "static u32 map_id_down(struct uid_gid_map *map, u32 id)\n{\n\treturn map_id_range_down(map, id, 1);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_id_range_down",
          "args": [
            "map",
            "id",
            "1"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_range_down",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "295-313",
          "snippet": "static u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_range_down_base(extents, map, id, count);\n\telse\n\t\textent = map_id_range_down_max(extents, map, id, count);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->first) + extent->lower_first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_range_down_base(extents, map, id, count);\n\telse\n\t\textent = map_id_range_down_max(extents, map, id, count);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->first) + extent->lower_first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic u32 map_id_down(struct uid_gid_map *map, u32 id)\n{\n\treturn map_id_range_down(map, id, 1);\n}"
  },
  {
    "function_name": "map_id_range_down",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "295-313",
    "snippet": "static u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_range_down_base(extents, map, id, count);\n\telse\n\t\textent = map_id_range_down_max(extents, map, id, count);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->first) + extent->lower_first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_id_range_down_max",
          "args": [
            "extents",
            "map",
            "id",
            "count"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_range_down_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "258-269",
          "snippet": "static struct uid_gid_extent *\nmap_id_range_down_max(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct idmap_key key;\n\n\tkey.map_up = false;\n\tkey.count = count;\n\tkey.id = id;\n\n\treturn bsearch(&key, map->forward, extents,\n\t\t       sizeof(struct uid_gid_extent), cmp_map_id);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic struct uid_gid_extent *\nmap_id_range_down_max(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct idmap_key key;\n\n\tkey.map_up = false;\n\tkey.count = count;\n\tkey.id = id;\n\n\treturn bsearch(&key, map->forward, extents,\n\t\t       sizeof(struct uid_gid_extent), cmp_map_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_id_range_down_base",
          "args": [
            "extents",
            "map",
            "id",
            "count"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "map_id_range_down_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "276-293",
          "snippet": "static struct uid_gid_extent *\nmap_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tunsigned idx;\n\tu32 first, last, id2;\n\n\tid2 = id + count - 1;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last &&\n\t\t    (id2 >= first && id2 <= last))\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic struct uid_gid_extent *\nmap_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tunsigned idx;\n\tu32 first, last, id2;\n\n\tid2 = id + count - 1;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last &&\n\t\t    (id2 >= first && id2 <= last))\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_range_down_base(extents, map, id, count);\n\telse\n\t\textent = map_id_range_down_max(extents, map, id, count);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->first) + extent->lower_first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}"
  },
  {
    "function_name": "map_id_range_down_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "276-293",
    "snippet": "static struct uid_gid_extent *\nmap_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tunsigned idx;\n\tu32 first, last, id2;\n\n\tid2 = id + count - 1;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last &&\n\t\t    (id2 >= first && id2 <= last))\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic struct uid_gid_extent *\nmap_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tunsigned idx;\n\tu32 first, last, id2;\n\n\tid2 = id + count - 1;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last &&\n\t\t    (id2 >= first && id2 <= last))\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "map_id_range_down_max",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "258-269",
    "snippet": "static struct uid_gid_extent *\nmap_id_range_down_max(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct idmap_key key;\n\n\tkey.map_up = false;\n\tkey.count = count;\n\tkey.id = id;\n\n\treturn bsearch(&key, map->forward, extents,\n\t\t       sizeof(struct uid_gid_extent), cmp_map_id);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&key",
            "map->forward",
            "extents",
            "sizeof(struct uid_gid_extent)",
            "cmp_map_id"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *map);\n\nstatic struct uid_gid_extent *\nmap_id_range_down_max(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct idmap_key key;\n\n\tkey.map_up = false;\n\tkey.count = count;\n\tkey.id = id;\n\n\treturn bsearch(&key, map->forward, extents,\n\t\t       sizeof(struct uid_gid_extent), cmp_map_id);\n}"
  },
  {
    "function_name": "cmp_map_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "228-252",
    "snippet": "static int cmp_map_id(const void *k, const void *e)\n{\n\tu32 first, last, id2;\n\tconst struct idmap_key *key = k;\n\tconst struct uid_gid_extent *el = e;\n\n\tid2 = key->id + key->count - 1;\n\n\t/* handle map_id_{down,up}() */\n\tif (key->map_up)\n\t\tfirst = el->lower_first;\n\telse\n\t\tfirst = el->first;\n\n\tlast = first + el->count - 1;\n\n\tif (key->id >= first && key->id <= last &&\n\t    (id2 >= first && id2 <= last))\n\t\treturn 0;\n\n\tif (key->id < first || id2 < first)\n\t\treturn -1;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic int cmp_map_id(const void *k, const void *e)\n{\n\tu32 first, last, id2;\n\tconst struct idmap_key *key = k;\n\tconst struct uid_gid_extent *el = e;\n\n\tid2 = key->id + key->count - 1;\n\n\t/* handle map_id_{down,up}() */\n\tif (key->map_up)\n\t\tfirst = el->lower_first;\n\telse\n\t\tfirst = el->first;\n\n\tlast = first + el->count - 1;\n\n\tif (key->id >= first && key->id <= last &&\n\t    (id2 >= first && id2 <= last))\n\t\treturn 0;\n\n\tif (key->id < first || id2 < first)\n\t\treturn -1;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "__put_user_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "208-211",
    "snippet": "void __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_user_ns(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&ns->work"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void free_user_ns(struct work_struct *work);\n\nvoid __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}"
  },
  {
    "function_name": "free_user_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "179-206",
    "snippet": "static void free_user_ns(struct work_struct *work)\n{\n\tstruct user_namespace *parent, *ns =\n\t\tcontainer_of(work, struct user_namespace, work);\n\n\tdo {\n\t\tstruct ucounts *ucounts = ns->ucounts;\n\t\tparent = ns->parent;\n\t\tif (ns->gid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\t\tkfree(ns->gid_map.forward);\n\t\t\tkfree(ns->gid_map.reverse);\n\t\t}\n\t\tif (ns->uid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\t\tkfree(ns->uid_map.forward);\n\t\t\tkfree(ns->uid_map.reverse);\n\t\t}\n\t\tif (ns->projid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\t\tkfree(ns->projid_map.forward);\n\t\t\tkfree(ns->projid_map.reverse);\n\t\t}\n\t\tretire_userns_sysctls(ns);\n\t\tkey_free_user_ns(ns);\n\t\tns_free_inum(&ns->ns);\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\tdec_user_namespaces(ucounts);\n\t\tns = parent;\n\t} while (refcount_dec_and_test(&parent->ns.count));\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *user_ns_cachep",
      "static void free_user_ns(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&parent->ns.count"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_user_namespaces",
          "args": [
            "ucounts"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "dec_user_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "37-40",
          "snippet": "static void dec_user_namespaces(struct ucounts *ucounts)\n{\n\treturn dec_ucount(ucounts, UCOUNT_USER_NAMESPACES);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void dec_user_namespaces(struct ucounts *ucounts)\n{\n\treturn dec_ucount(ucounts, UCOUNT_USER_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "user_ns_cachep",
            "ns"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_free_inum",
          "args": [
            "&ns->ns"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_free_user_ns",
          "args": [
            "ns"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retire_userns_sysctls",
          "args": [
            "ns"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "retire_userns_sysctls",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "122-132",
          "snippet": "void retire_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\ttbl = ns->sysctls->ctl_table_arg;\n\tunregister_sysctl_table(ns->sysctls);\n\tretire_sysctl_set(&ns->set);\n\tkfree(tbl);\n#endif\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid retire_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\ttbl = ns->sysctls->ctl_table_arg;\n\tunregister_sysctl_table(ns->sysctls);\n\tretire_sysctl_set(&ns->set);\n\tkfree(tbl);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ns->projid_map.reverse"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structuser_namespace",
            "work"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *user_ns_cachep;\nstatic void free_user_ns(struct work_struct *work);\n\nstatic void free_user_ns(struct work_struct *work)\n{\n\tstruct user_namespace *parent, *ns =\n\t\tcontainer_of(work, struct user_namespace, work);\n\n\tdo {\n\t\tstruct ucounts *ucounts = ns->ucounts;\n\t\tparent = ns->parent;\n\t\tif (ns->gid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\t\tkfree(ns->gid_map.forward);\n\t\t\tkfree(ns->gid_map.reverse);\n\t\t}\n\t\tif (ns->uid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\t\tkfree(ns->uid_map.forward);\n\t\t\tkfree(ns->uid_map.reverse);\n\t\t}\n\t\tif (ns->projid_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {\n\t\t\tkfree(ns->projid_map.forward);\n\t\t\tkfree(ns->projid_map.reverse);\n\t\t}\n\t\tretire_userns_sysctls(ns);\n\t\tkey_free_user_ns(ns);\n\t\tns_free_inum(&ns->ns);\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\tdec_user_namespaces(ucounts);\n\t\tns = parent;\n\t} while (refcount_dec_and_test(&parent->ns.count));\n}"
  },
  {
    "function_name": "unshare_userns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "159-177",
    "snippet": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tint err = -ENOMEM;\n\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\n\tcred = prepare_creds();\n\tif (cred) {\n\t\terr = create_user_ns(cred);\n\t\tif (err)\n\t\t\tput_cred(cred);\n\t\telse\n\t\t\t*new_cred = cred;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "cred"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "135-154",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_user_ns",
          "args": [
            "cred"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "create_user_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "69-157",
          "snippet": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tstruct ucounts *ucounts;\n\tint ret, i;\n\n\tret = -ENOSPC;\n\tif (parent_ns->level > 32)\n\t\tgoto fail;\n\n\tucounts = inc_user_namespaces(parent_ns, owner);\n\tif (!ucounts)\n\t\tgoto fail;\n\n\t/*\n\t * Verify that we can not violate the policy of which files\n\t * may be accessed that is specified by the root directory,\n\t * by verifying that the root directory is at the root of the\n\t * mount namespace which allows all files to be accessed.\n\t */\n\tret = -EPERM;\n\tif (current_chrooted())\n\t\tgoto fail_dec;\n\n\t/* The creator needs a mapping in the parent user namespace\n\t * or else we won't be able to reasonably tell userspace who\n\t * created a user_namespace.\n\t */\n\tret = -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\tgoto fail_dec;\n\n\tret = -ENOMEM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\tgoto fail_dec;\n\n\tns->parent_could_setfcap = cap_raised(new->cap_effective, CAP_SETFCAP);\n\tret = ns_alloc_inum(&ns->ns);\n\tif (ret)\n\t\tgoto fail_free;\n\tns->ns.ops = &userns_operations;\n\n\trefcount_set(&ns->ns.count, 1);\n\t/* Leave the new->user_ns reference with the new user namespace. */\n\tns->parent = parent_ns;\n\tns->level = parent_ns->level + 1;\n\tns->owner = owner;\n\tns->group = group;\n\tINIT_WORK(&ns->work, free_user_ns);\n\tfor (i = 0; i < MAX_PER_NAMESPACE_UCOUNTS; i++) {\n\t\tns->ucount_max[i] = INT_MAX;\n\t}\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_MSGQUEUE, rlimit(RLIMIT_MSGQUEUE));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_SIGPENDING, rlimit(RLIMIT_SIGPENDING));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_MEMLOCK, rlimit(RLIMIT_MEMLOCK));\n\tns->ucounts = ucounts;\n\n\t/* Inherit USERNS_SETGROUPS_ALLOWED from our parent */\n\tmutex_lock(&userns_state_mutex);\n\tns->flags = parent_ns->flags;\n\tmutex_unlock(&userns_state_mutex);\n\n#ifdef CONFIG_KEYS\n\tINIT_LIST_HEAD(&ns->keyring_name_list);\n\tinit_rwsem(&ns->keyring_sem);\n#endif\n\tret = -ENOMEM;\n\tif (!setup_userns_sysctls(ns))\n\t\tgoto fail_keyring;\n\n\tset_cred_user_ns(new, ns);\n\treturn 0;\nfail_keyring:\n#ifdef CONFIG_PERSISTENT_KEYRINGS\n\tkey_put(ns->persistent_keyring_register);\n#endif\n\tns_free_inum(&ns->ns);\nfail_free:\n\tkmem_cache_free(user_ns_cachep, ns);\nfail_dec:\n\tdec_user_namespaces(ucounts);\nfail:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *user_ns_cachep",
            "static DEFINE_MUTEX(userns_state_mutex);",
            "static void free_user_ns(struct work_struct *work);",
            "const struct proc_ns_operations userns_operations = {\n\t.name\t\t= \"user\",\n\t.type\t\t= CLONE_NEWUSER,\n\t.get\t\t= userns_get,\n\t.put\t\t= userns_put,\n\t.install\t= userns_install,\n\t.owner\t\t= userns_owner,\n\t.get_parent\t= ns_get_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *user_ns_cachep;\nstatic DEFINE_MUTEX(userns_state_mutex);\nstatic void free_user_ns(struct work_struct *work);\nconst struct proc_ns_operations userns_operations = {\n\t.name\t\t= \"user\",\n\t.type\t\t= CLONE_NEWUSER,\n\t.get\t\t= userns_get,\n\t.put\t\t= userns_put,\n\t.install\t= userns_install,\n\t.owner\t\t= userns_owner,\n\t.get_parent\t= ns_get_owner,\n};\n\nint create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tstruct ucounts *ucounts;\n\tint ret, i;\n\n\tret = -ENOSPC;\n\tif (parent_ns->level > 32)\n\t\tgoto fail;\n\n\tucounts = inc_user_namespaces(parent_ns, owner);\n\tif (!ucounts)\n\t\tgoto fail;\n\n\t/*\n\t * Verify that we can not violate the policy of which files\n\t * may be accessed that is specified by the root directory,\n\t * by verifying that the root directory is at the root of the\n\t * mount namespace which allows all files to be accessed.\n\t */\n\tret = -EPERM;\n\tif (current_chrooted())\n\t\tgoto fail_dec;\n\n\t/* The creator needs a mapping in the parent user namespace\n\t * or else we won't be able to reasonably tell userspace who\n\t * created a user_namespace.\n\t */\n\tret = -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\tgoto fail_dec;\n\n\tret = -ENOMEM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\tgoto fail_dec;\n\n\tns->parent_could_setfcap = cap_raised(new->cap_effective, CAP_SETFCAP);\n\tret = ns_alloc_inum(&ns->ns);\n\tif (ret)\n\t\tgoto fail_free;\n\tns->ns.ops = &userns_operations;\n\n\trefcount_set(&ns->ns.count, 1);\n\t/* Leave the new->user_ns reference with the new user namespace. */\n\tns->parent = parent_ns;\n\tns->level = parent_ns->level + 1;\n\tns->owner = owner;\n\tns->group = group;\n\tINIT_WORK(&ns->work, free_user_ns);\n\tfor (i = 0; i < MAX_PER_NAMESPACE_UCOUNTS; i++) {\n\t\tns->ucount_max[i] = INT_MAX;\n\t}\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_MSGQUEUE, rlimit(RLIMIT_MSGQUEUE));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_SIGPENDING, rlimit(RLIMIT_SIGPENDING));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_MEMLOCK, rlimit(RLIMIT_MEMLOCK));\n\tns->ucounts = ucounts;\n\n\t/* Inherit USERNS_SETGROUPS_ALLOWED from our parent */\n\tmutex_lock(&userns_state_mutex);\n\tns->flags = parent_ns->flags;\n\tmutex_unlock(&userns_state_mutex);\n\n#ifdef CONFIG_KEYS\n\tINIT_LIST_HEAD(&ns->keyring_name_list);\n\tinit_rwsem(&ns->keyring_sem);\n#endif\n\tret = -ENOMEM;\n\tif (!setup_userns_sysctls(ns))\n\t\tgoto fail_keyring;\n\n\tset_cred_user_ns(new, ns);\n\treturn 0;\nfail_keyring:\n#ifdef CONFIG_PERSISTENT_KEYRINGS\n\tkey_put(ns->persistent_keyring_register);\n#endif\n\tns_free_inum(&ns->ns);\nfail_free:\n\tkmem_cache_free(user_ns_cachep, ns);\nfail_dec:\n\tdec_user_namespaces(ucounts);\nfail:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "252-300",
          "snippet": "struct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cred_jar;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nint unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tint err = -ENOMEM;\n\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\n\tcred = prepare_creds();\n\tif (cred) {\n\t\terr = create_user_ns(cred);\n\t\tif (err)\n\t\t\tput_cred(cred);\n\t\telse\n\t\t\t*new_cred = cred;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "create_user_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "69-157",
    "snippet": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tstruct ucounts *ucounts;\n\tint ret, i;\n\n\tret = -ENOSPC;\n\tif (parent_ns->level > 32)\n\t\tgoto fail;\n\n\tucounts = inc_user_namespaces(parent_ns, owner);\n\tif (!ucounts)\n\t\tgoto fail;\n\n\t/*\n\t * Verify that we can not violate the policy of which files\n\t * may be accessed that is specified by the root directory,\n\t * by verifying that the root directory is at the root of the\n\t * mount namespace which allows all files to be accessed.\n\t */\n\tret = -EPERM;\n\tif (current_chrooted())\n\t\tgoto fail_dec;\n\n\t/* The creator needs a mapping in the parent user namespace\n\t * or else we won't be able to reasonably tell userspace who\n\t * created a user_namespace.\n\t */\n\tret = -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\tgoto fail_dec;\n\n\tret = -ENOMEM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\tgoto fail_dec;\n\n\tns->parent_could_setfcap = cap_raised(new->cap_effective, CAP_SETFCAP);\n\tret = ns_alloc_inum(&ns->ns);\n\tif (ret)\n\t\tgoto fail_free;\n\tns->ns.ops = &userns_operations;\n\n\trefcount_set(&ns->ns.count, 1);\n\t/* Leave the new->user_ns reference with the new user namespace. */\n\tns->parent = parent_ns;\n\tns->level = parent_ns->level + 1;\n\tns->owner = owner;\n\tns->group = group;\n\tINIT_WORK(&ns->work, free_user_ns);\n\tfor (i = 0; i < MAX_PER_NAMESPACE_UCOUNTS; i++) {\n\t\tns->ucount_max[i] = INT_MAX;\n\t}\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_MSGQUEUE, rlimit(RLIMIT_MSGQUEUE));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_SIGPENDING, rlimit(RLIMIT_SIGPENDING));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_MEMLOCK, rlimit(RLIMIT_MEMLOCK));\n\tns->ucounts = ucounts;\n\n\t/* Inherit USERNS_SETGROUPS_ALLOWED from our parent */\n\tmutex_lock(&userns_state_mutex);\n\tns->flags = parent_ns->flags;\n\tmutex_unlock(&userns_state_mutex);\n\n#ifdef CONFIG_KEYS\n\tINIT_LIST_HEAD(&ns->keyring_name_list);\n\tinit_rwsem(&ns->keyring_sem);\n#endif\n\tret = -ENOMEM;\n\tif (!setup_userns_sysctls(ns))\n\t\tgoto fail_keyring;\n\n\tset_cred_user_ns(new, ns);\n\treturn 0;\nfail_keyring:\n#ifdef CONFIG_PERSISTENT_KEYRINGS\n\tkey_put(ns->persistent_keyring_register);\n#endif\n\tns_free_inum(&ns->ns);\nfail_free:\n\tkmem_cache_free(user_ns_cachep, ns);\nfail_dec:\n\tdec_user_namespaces(ucounts);\nfail:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *user_ns_cachep",
      "static DEFINE_MUTEX(userns_state_mutex);",
      "static void free_user_ns(struct work_struct *work);",
      "const struct proc_ns_operations userns_operations = {\n\t.name\t\t= \"user\",\n\t.type\t\t= CLONE_NEWUSER,\n\t.get\t\t= userns_get,\n\t.put\t\t= userns_put,\n\t.install\t= userns_install,\n\t.owner\t\t= userns_owner,\n\t.get_parent\t= ns_get_owner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_user_namespaces",
          "args": [
            "ucounts"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "dec_user_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "37-40",
          "snippet": "static void dec_user_namespaces(struct ucounts *ucounts)\n{\n\treturn dec_ucount(ucounts, UCOUNT_USER_NAMESPACES);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void dec_user_namespaces(struct ucounts *ucounts)\n{\n\treturn dec_ucount(ucounts, UCOUNT_USER_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "user_ns_cachep",
            "ns"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_free_inum",
          "args": [
            "&ns->ns"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "ns->persistent_keyring_register"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cred_user_ns",
          "args": [
            "new",
            "ns"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "set_cred_user_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "42-59",
          "snippet": "static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)\n{\n\t/* Start with the same capabilities as init but useless for doing\n\t * anything as the capabilities are bound to the new user namespace.\n\t */\n\tcred->securebits = SECUREBITS_DEFAULT;\n\tcred->cap_inheritable = CAP_EMPTY_SET;\n\tcred->cap_permitted = CAP_FULL_SET;\n\tcred->cap_effective = CAP_FULL_SET;\n\tcred->cap_ambient = CAP_EMPTY_SET;\n\tcred->cap_bset = CAP_FULL_SET;\n#ifdef CONFIG_KEYS\n\tkey_put(cred->request_key_auth);\n\tcred->request_key_auth = NULL;\n#endif\n\t/* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */\n\tcred->user_ns = user_ns;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)\n{\n\t/* Start with the same capabilities as init but useless for doing\n\t * anything as the capabilities are bound to the new user namespace.\n\t */\n\tcred->securebits = SECUREBITS_DEFAULT;\n\tcred->cap_inheritable = CAP_EMPTY_SET;\n\tcred->cap_permitted = CAP_FULL_SET;\n\tcred->cap_effective = CAP_FULL_SET;\n\tcred->cap_ambient = CAP_EMPTY_SET;\n\tcred->cap_bset = CAP_FULL_SET;\n#ifdef CONFIG_KEYS\n\tkey_put(cred->request_key_auth);\n\tcred->request_key_auth = NULL;\n#endif\n\t/* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */\n\tcred->user_ns = user_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_userns_sysctls",
          "args": [
            "ns"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "setup_userns_sysctls",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "98-120",
          "snippet": "bool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(user_table) != UCOUNT_COUNTS + 1);\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nbool setup_userns_sysctls(struct user_namespace *ns)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(user_table) != UCOUNT_COUNTS + 1);\n\tsetup_sysctl_set(&ns->set, &set_root, set_is_seen);\n\ttbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\t\tfor (i = 0; i < UCOUNT_COUNTS; i++) {\n\t\t\ttbl[i].data = &ns->ucount_max[i];\n\t\t}\n\t\tns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);\n\t}\n\tif (!ns->sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->set);\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ns->keyring_sem"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ns->keyring_name_list"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&userns_state_mutex"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&userns_state_mutex"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_rlimit_ucount_max",
          "args": [
            "ns",
            "UCOUNT_RLIMIT_MEMLOCK",
            "rlimit(RLIMIT_MEMLOCK)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MEMLOCK"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_rlimit_ucount_max",
          "args": [
            "ns",
            "UCOUNT_RLIMIT_SIGPENDING",
            "rlimit(RLIMIT_SIGPENDING)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_SIGPENDING"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_rlimit_ucount_max",
          "args": [
            "ns",
            "UCOUNT_RLIMIT_MSGQUEUE",
            "rlimit(RLIMIT_MSGQUEUE)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MSGQUEUE"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_rlimit_ucount_max",
          "args": [
            "ns",
            "UCOUNT_RLIMIT_NPROC",
            "rlimit(RLIMIT_NPROC)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NPROC"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ns->work",
            "free_user_ns"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&ns->ns.count",
            "1"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_alloc_inum",
          "args": [
            "&ns->ns"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "new->cap_effective",
            "CAP_SETFCAP"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "user_ns_cachep",
            "GFP_KERNEL"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgid_has_mapping",
          "args": [
            "parent_ns",
            "group"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "parent_ns",
            "owner"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_chrooted",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_user_namespaces",
          "args": [
            "parent_ns",
            "owner"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "inc_user_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "32-35",
          "snippet": "static struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid)\n{\n\treturn inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid)\n{\n\treturn inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *user_ns_cachep;\nstatic DEFINE_MUTEX(userns_state_mutex);\nstatic void free_user_ns(struct work_struct *work);\nconst struct proc_ns_operations userns_operations = {\n\t.name\t\t= \"user\",\n\t.type\t\t= CLONE_NEWUSER,\n\t.get\t\t= userns_get,\n\t.put\t\t= userns_put,\n\t.install\t= userns_install,\n\t.owner\t\t= userns_owner,\n\t.get_parent\t= ns_get_owner,\n};\n\nint create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tstruct ucounts *ucounts;\n\tint ret, i;\n\n\tret = -ENOSPC;\n\tif (parent_ns->level > 32)\n\t\tgoto fail;\n\n\tucounts = inc_user_namespaces(parent_ns, owner);\n\tif (!ucounts)\n\t\tgoto fail;\n\n\t/*\n\t * Verify that we can not violate the policy of which files\n\t * may be accessed that is specified by the root directory,\n\t * by verifying that the root directory is at the root of the\n\t * mount namespace which allows all files to be accessed.\n\t */\n\tret = -EPERM;\n\tif (current_chrooted())\n\t\tgoto fail_dec;\n\n\t/* The creator needs a mapping in the parent user namespace\n\t * or else we won't be able to reasonably tell userspace who\n\t * created a user_namespace.\n\t */\n\tret = -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\tgoto fail_dec;\n\n\tret = -ENOMEM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\tgoto fail_dec;\n\n\tns->parent_could_setfcap = cap_raised(new->cap_effective, CAP_SETFCAP);\n\tret = ns_alloc_inum(&ns->ns);\n\tif (ret)\n\t\tgoto fail_free;\n\tns->ns.ops = &userns_operations;\n\n\trefcount_set(&ns->ns.count, 1);\n\t/* Leave the new->user_ns reference with the new user namespace. */\n\tns->parent = parent_ns;\n\tns->level = parent_ns->level + 1;\n\tns->owner = owner;\n\tns->group = group;\n\tINIT_WORK(&ns->work, free_user_ns);\n\tfor (i = 0; i < MAX_PER_NAMESPACE_UCOUNTS; i++) {\n\t\tns->ucount_max[i] = INT_MAX;\n\t}\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_MSGQUEUE, rlimit(RLIMIT_MSGQUEUE));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_SIGPENDING, rlimit(RLIMIT_SIGPENDING));\n\tset_rlimit_ucount_max(ns, UCOUNT_RLIMIT_MEMLOCK, rlimit(RLIMIT_MEMLOCK));\n\tns->ucounts = ucounts;\n\n\t/* Inherit USERNS_SETGROUPS_ALLOWED from our parent */\n\tmutex_lock(&userns_state_mutex);\n\tns->flags = parent_ns->flags;\n\tmutex_unlock(&userns_state_mutex);\n\n#ifdef CONFIG_KEYS\n\tINIT_LIST_HEAD(&ns->keyring_name_list);\n\tinit_rwsem(&ns->keyring_sem);\n#endif\n\tret = -ENOMEM;\n\tif (!setup_userns_sysctls(ns))\n\t\tgoto fail_keyring;\n\n\tset_cred_user_ns(new, ns);\n\treturn 0;\nfail_keyring:\n#ifdef CONFIG_PERSISTENT_KEYRINGS\n\tkey_put(ns->persistent_keyring_register);\n#endif\n\tns_free_inum(&ns->ns);\nfail_free:\n\tkmem_cache_free(user_ns_cachep, ns);\nfail_dec:\n\tdec_user_namespaces(ucounts);\nfail:\n\treturn ret;\n}"
  },
  {
    "function_name": "set_cred_user_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "42-59",
    "snippet": "static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)\n{\n\t/* Start with the same capabilities as init but useless for doing\n\t * anything as the capabilities are bound to the new user namespace.\n\t */\n\tcred->securebits = SECUREBITS_DEFAULT;\n\tcred->cap_inheritable = CAP_EMPTY_SET;\n\tcred->cap_permitted = CAP_FULL_SET;\n\tcred->cap_effective = CAP_FULL_SET;\n\tcred->cap_ambient = CAP_EMPTY_SET;\n\tcred->cap_bset = CAP_FULL_SET;\n#ifdef CONFIG_KEYS\n\tkey_put(cred->request_key_auth);\n\tcred->request_key_auth = NULL;\n#endif\n\t/* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */\n\tcred->user_ns = user_ns;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "cred->request_key_auth"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)\n{\n\t/* Start with the same capabilities as init but useless for doing\n\t * anything as the capabilities are bound to the new user namespace.\n\t */\n\tcred->securebits = SECUREBITS_DEFAULT;\n\tcred->cap_inheritable = CAP_EMPTY_SET;\n\tcred->cap_permitted = CAP_FULL_SET;\n\tcred->cap_effective = CAP_FULL_SET;\n\tcred->cap_ambient = CAP_EMPTY_SET;\n\tcred->cap_bset = CAP_FULL_SET;\n#ifdef CONFIG_KEYS\n\tkey_put(cred->request_key_auth);\n\tcred->request_key_auth = NULL;\n#endif\n\t/* tgcred will be cleared in our caller bc CLONE_THREAD won't be set */\n\tcred->user_ns = user_ns;\n}"
  },
  {
    "function_name": "dec_user_namespaces",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "37-40",
    "snippet": "static void dec_user_namespaces(struct ucounts *ucounts)\n{\n\treturn dec_ucount(ucounts, UCOUNT_USER_NAMESPACES);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_ucount",
          "args": [
            "ucounts",
            "UCOUNT_USER_NAMESPACES"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "dec_ucount",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "254-262",
          "snippet": "void dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void dec_user_namespaces(struct ucounts *ucounts)\n{\n\treturn dec_ucount(ucounts, UCOUNT_USER_NAMESPACES);\n}"
  },
  {
    "function_name": "inc_user_namespaces",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
    "lines": "32-35",
    "snippet": "static struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid)\n{\n\treturn inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/bsearch.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/projid.h>",
      "#include <linux/ctype.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/securebits.h>",
      "#include <linux/cred.h>",
      "#include <linux/highuid.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_ucount",
          "args": [
            "ns",
            "uid",
            "UCOUNT_USER_NAMESPACES"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "inc_ucount",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "231-252",
          "snippet": "struct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = alloc_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tlong max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_long_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_long_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = alloc_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tlong max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_long_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_long_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid)\n{\n\treturn inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);\n}"
  }
]