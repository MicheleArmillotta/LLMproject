[
  {
    "function_name": "acct_clear_integrals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tsacct.c",
    "lines": "170-175",
    "snippet": "void acct_clear_integrals(struct task_struct *tsk)\n{\n\ttsk->acct_timexpd = 0;\n\ttsk->acct_rss_mem1 = 0;\n\ttsk->acct_vm_mem1 = 0;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/acct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid acct_clear_integrals(struct task_struct *tsk)\n{\n\ttsk->acct_timexpd = 0;\n\ttsk->acct_rss_mem1 = 0;\n\ttsk->acct_vm_mem1 = 0;\n}"
  },
  {
    "function_name": "acct_account_cputime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tsacct.c",
    "lines": "161-164",
    "snippet": "void acct_account_cputime(struct task_struct *tsk)\n{\n\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/acct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__acct_update_integrals",
          "args": [
            "tsk",
            "tsk->utime",
            "tsk->stime"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__acct_update_integrals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tsacct.c",
          "lines": "118-140",
          "snippet": "static void __acct_update_integrals(struct task_struct *tsk,\n\t\t\t\t    u64 utime, u64 stime)\n{\n\tu64 time, delta;\n\n\tif (!likely(tsk->mm))\n\t\treturn;\n\n\ttime = stime + utime;\n\tdelta = time - tsk->acct_timexpd;\n\n\tif (delta < TICK_NSEC)\n\t\treturn;\n\n\ttsk->acct_timexpd = time;\n\t/*\n\t * Divide by 1024 to avoid overflow, and to avoid division.\n\t * The final unit reported to userspace is Mbyte-usecs,\n\t * the rest of the math is done in xacct_add_tsk.\n\t */\n\ttsk->acct_rss_mem1 += delta * get_mm_rss(tsk->mm) >> 10;\n\ttsk->acct_vm_mem1 += delta * READ_ONCE(tsk->mm->total_vm) >> 10;\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/acct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __acct_update_integrals(struct task_struct *tsk,\n\t\t\t\t    u64 utime, u64 stime)\n{\n\tu64 time, delta;\n\n\tif (!likely(tsk->mm))\n\t\treturn;\n\n\ttime = stime + utime;\n\tdelta = time - tsk->acct_timexpd;\n\n\tif (delta < TICK_NSEC)\n\t\treturn;\n\n\ttsk->acct_timexpd = time;\n\t/*\n\t * Divide by 1024 to avoid overflow, and to avoid division.\n\t * The final unit reported to userspace is Mbyte-usecs,\n\t * the rest of the math is done in xacct_add_tsk.\n\t */\n\ttsk->acct_rss_mem1 += delta * get_mm_rss(tsk->mm) >> 10;\n\ttsk->acct_vm_mem1 += delta * READ_ONCE(tsk->mm->total_vm) >> 10;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid acct_account_cputime(struct task_struct *tsk)\n{\n\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);\n}"
  },
  {
    "function_name": "acct_update_integrals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tsacct.c",
    "lines": "146-155",
    "snippet": "void acct_update_integrals(struct task_struct *tsk)\n{\n\tu64 utime, stime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\ttask_cputime(tsk, &utime, &stime);\n\t__acct_update_integrals(tsk, utime, stime);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/acct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acct_update_integrals",
          "args": [
            "tsk",
            "utime",
            "stime"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "__acct_update_integrals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tsacct.c",
          "lines": "118-140",
          "snippet": "static void __acct_update_integrals(struct task_struct *tsk,\n\t\t\t\t    u64 utime, u64 stime)\n{\n\tu64 time, delta;\n\n\tif (!likely(tsk->mm))\n\t\treturn;\n\n\ttime = stime + utime;\n\tdelta = time - tsk->acct_timexpd;\n\n\tif (delta < TICK_NSEC)\n\t\treturn;\n\n\ttsk->acct_timexpd = time;\n\t/*\n\t * Divide by 1024 to avoid overflow, and to avoid division.\n\t * The final unit reported to userspace is Mbyte-usecs,\n\t * the rest of the math is done in xacct_add_tsk.\n\t */\n\ttsk->acct_rss_mem1 += delta * get_mm_rss(tsk->mm) >> 10;\n\ttsk->acct_vm_mem1 += delta * READ_ONCE(tsk->mm->total_vm) >> 10;\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/acct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __acct_update_integrals(struct task_struct *tsk,\n\t\t\t\t    u64 utime, u64 stime)\n{\n\tu64 time, delta;\n\n\tif (!likely(tsk->mm))\n\t\treturn;\n\n\ttime = stime + utime;\n\tdelta = time - tsk->acct_timexpd;\n\n\tif (delta < TICK_NSEC)\n\t\treturn;\n\n\ttsk->acct_timexpd = time;\n\t/*\n\t * Divide by 1024 to avoid overflow, and to avoid division.\n\t * The final unit reported to userspace is Mbyte-usecs,\n\t * the rest of the math is done in xacct_add_tsk.\n\t */\n\ttsk->acct_rss_mem1 += delta * get_mm_rss(tsk->mm) >> 10;\n\ttsk->acct_vm_mem1 += delta * READ_ONCE(tsk->mm->total_vm) >> 10;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "tsk",
            "&utime",
            "&stime"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "832-870",
          "snippet": "bool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid acct_update_integrals(struct task_struct *tsk)\n{\n\tu64 utime, stime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\ttask_cputime(tsk, &utime, &stime);\n\t__acct_update_integrals(tsk, utime, stime);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__acct_update_integrals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tsacct.c",
    "lines": "118-140",
    "snippet": "static void __acct_update_integrals(struct task_struct *tsk,\n\t\t\t\t    u64 utime, u64 stime)\n{\n\tu64 time, delta;\n\n\tif (!likely(tsk->mm))\n\t\treturn;\n\n\ttime = stime + utime;\n\tdelta = time - tsk->acct_timexpd;\n\n\tif (delta < TICK_NSEC)\n\t\treturn;\n\n\ttsk->acct_timexpd = time;\n\t/*\n\t * Divide by 1024 to avoid overflow, and to avoid division.\n\t * The final unit reported to userspace is Mbyte-usecs,\n\t * the rest of the math is done in xacct_add_tsk.\n\t */\n\ttsk->acct_rss_mem1 += delta * get_mm_rss(tsk->mm) >> 10;\n\ttsk->acct_vm_mem1 += delta * READ_ONCE(tsk->mm->total_vm) >> 10;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/acct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "tsk->mm->total_vm"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_rss",
          "args": [
            "tsk->mm"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "tsk->mm"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __acct_update_integrals(struct task_struct *tsk,\n\t\t\t\t    u64 utime, u64 stime)\n{\n\tu64 time, delta;\n\n\tif (!likely(tsk->mm))\n\t\treturn;\n\n\ttime = stime + utime;\n\tdelta = time - tsk->acct_timexpd;\n\n\tif (delta < TICK_NSEC)\n\t\treturn;\n\n\ttsk->acct_timexpd = time;\n\t/*\n\t * Divide by 1024 to avoid overflow, and to avoid division.\n\t * The final unit reported to userspace is Mbyte-usecs,\n\t * the rest of the math is done in xacct_add_tsk.\n\t */\n\ttsk->acct_rss_mem1 += delta * get_mm_rss(tsk->mm) >> 10;\n\ttsk->acct_vm_mem1 += delta * READ_ONCE(tsk->mm->total_vm) >> 10;\n}"
  },
  {
    "function_name": "xacct_add_tsk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tsacct.c",
    "lines": "85-114",
    "snippet": "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n\tstruct mm_struct *mm;\n\n\t/* convert pages-nsec/1024 to Mbyte-usec, see __acct_update_integrals */\n\tstats->coremem = p->acct_rss_mem1 * PAGE_SIZE;\n\tdo_div(stats->coremem, 1000 * KB);\n\tstats->virtmem = p->acct_vm_mem1 * PAGE_SIZE;\n\tdo_div(stats->virtmem, 1000 * KB);\n\tmm = get_task_mm(p);\n\tif (mm) {\n\t\t/* adjust to KB unit */\n\t\tstats->hiwater_rss   = get_mm_hiwater_rss(mm) * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = get_mm_hiwater_vm(mm)  * PAGE_SIZE / KB;\n\t\tmmput(mm);\n\t}\n\tstats->read_char\t= p->ioac.rchar & KB_MASK;\n\tstats->write_char\t= p->ioac.wchar & KB_MASK;\n\tstats->read_syscalls\t= p->ioac.syscr & KB_MASK;\n\tstats->write_syscalls\t= p->ioac.syscw & KB_MASK;\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tstats->read_bytes\t= p->ioac.read_bytes & KB_MASK;\n\tstats->write_bytes\t= p->ioac.write_bytes & KB_MASK;\n\tstats->cancelled_write_bytes = p->ioac.cancelled_write_bytes & KB_MASK;\n#else\n\tstats->read_bytes\t= 0;\n\tstats->write_bytes\t= 0;\n\tstats->cancelled_write_bytes = 0;\n#endif\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/acct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define KB_MASK (~(KB-1))",
      "#define KB 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1148-1154",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mm_hiwater_vm",
          "args": [
            "mm"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_hiwater_rss",
          "args": [
            "mm"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "p"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_mm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1297-1311",
          "snippet": "struct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stats->virtmem",
            "1000 * KB"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stats->coremem",
            "1000 * KB"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define KB_MASK (~(KB-1))\n#define KB 1024\n\nvoid xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n\tstruct mm_struct *mm;\n\n\t/* convert pages-nsec/1024 to Mbyte-usec, see __acct_update_integrals */\n\tstats->coremem = p->acct_rss_mem1 * PAGE_SIZE;\n\tdo_div(stats->coremem, 1000 * KB);\n\tstats->virtmem = p->acct_vm_mem1 * PAGE_SIZE;\n\tdo_div(stats->virtmem, 1000 * KB);\n\tmm = get_task_mm(p);\n\tif (mm) {\n\t\t/* adjust to KB unit */\n\t\tstats->hiwater_rss   = get_mm_hiwater_rss(mm) * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = get_mm_hiwater_vm(mm)  * PAGE_SIZE / KB;\n\t\tmmput(mm);\n\t}\n\tstats->read_char\t= p->ioac.rchar & KB_MASK;\n\tstats->write_char\t= p->ioac.wchar & KB_MASK;\n\tstats->read_syscalls\t= p->ioac.syscr & KB_MASK;\n\tstats->write_syscalls\t= p->ioac.syscw & KB_MASK;\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tstats->read_bytes\t= p->ioac.read_bytes & KB_MASK;\n\tstats->write_bytes\t= p->ioac.write_bytes & KB_MASK;\n\tstats->cancelled_write_bytes = p->ioac.cancelled_write_bytes & KB_MASK;\n#else\n\tstats->read_bytes\t= 0;\n\tstats->write_bytes\t= 0;\n\tstats->cancelled_write_bytes = 0;\n#endif\n}"
  },
  {
    "function_name": "bacct_add_tsk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tsacct.c",
    "lines": "20-74",
    "snippet": "void bacct_add_tsk(struct user_namespace *user_ns,\n\t\t   struct pid_namespace *pid_ns,\n\t\t   struct taskstats *stats, struct task_struct *tsk)\n{\n\tconst struct cred *tcred;\n\tu64 utime, stime, utimescaled, stimescaled;\n\tu64 delta;\n\ttime64_t btime;\n\n\tBUILD_BUG_ON(TS_COMM_LEN < TASK_COMM_LEN);\n\n\t/* calculate task elapsed time in nsec */\n\tdelta = ktime_get_ns() - tsk->start_time;\n\t/* Convert to micro seconds */\n\tdo_div(delta, NSEC_PER_USEC);\n\tstats->ac_etime = delta;\n\t/* Convert to seconds for btime (note y2106 limit) */\n\tbtime = ktime_get_real_seconds() - div_u64(delta, USEC_PER_SEC);\n\tstats->ac_btime = clamp_t(time64_t, btime, 0, U32_MAX);\n\tstats->ac_btime64 = btime;\n\n\tif (tsk->flags & PF_EXITING)\n\t\tstats->ac_exitcode = tsk->exit_code;\n\tif (thread_group_leader(tsk) && (tsk->flags & PF_FORKNOEXEC))\n\t\tstats->ac_flag |= AFORK;\n\tif (tsk->flags & PF_SUPERPRIV)\n\t\tstats->ac_flag |= ASU;\n\tif (tsk->flags & PF_DUMPCORE)\n\t\tstats->ac_flag |= ACORE;\n\tif (tsk->flags & PF_SIGNALED)\n\t\tstats->ac_flag |= AXSIG;\n\tstats->ac_nice\t = task_nice(tsk);\n\tstats->ac_sched\t = tsk->policy;\n\tstats->ac_pid\t = task_pid_nr_ns(tsk, pid_ns);\n\trcu_read_lock();\n\ttcred = __task_cred(tsk);\n\tstats->ac_uid\t = from_kuid_munged(user_ns, tcred->uid);\n\tstats->ac_gid\t = from_kgid_munged(user_ns, tcred->gid);\n\tstats->ac_ppid\t = pid_alive(tsk) ?\n\t\ttask_tgid_nr_ns(rcu_dereference(tsk->real_parent), pid_ns) : 0;\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tstats->ac_utime = div_u64(utime, NSEC_PER_USEC);\n\tstats->ac_stime = div_u64(stime, NSEC_PER_USEC);\n\n\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);\n\tstats->ac_utimescaled = div_u64(utimescaled, NSEC_PER_USEC);\n\tstats->ac_stimescaled = div_u64(stimescaled, NSEC_PER_USEC);\n\n\tstats->ac_minflt = tsk->min_flt;\n\tstats->ac_majflt = tsk->maj_flt;\n\n\tstrncpy(stats->ac_comm, tsk->comm, sizeof(stats->ac_comm));\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/acct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "stats->ac_comm",
            "tsk->comm",
            "sizeof(stats->ac_comm)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "stimescaled",
            "NSEC_PER_USEC"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "utimescaled",
            "NSEC_PER_USEC"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime_scaled",
          "args": [
            "tsk",
            "&utimescaled",
            "&stimescaled"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "stime",
            "NSEC_PER_USEC"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "utime",
            "NSEC_PER_USEC"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "tsk",
            "&utime",
            "&stime"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "832-870",
          "snippet": "bool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr_ns",
          "args": [
            "rcu_dereference(tsk->real_parent)",
            "pid_ns"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "tsk->real_parent"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_alive",
          "args": [
            "tsk"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "user_ns",
            "tcred->gid"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "502-510",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "user_ns",
            "tcred->uid"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "tsk"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "tsk",
            "pid_ns"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "tsk"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_t",
          "args": [
            "time64_t",
            "btime",
            "0",
            "U32_MAX"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "delta",
            "USEC_PER_SEC"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "delta",
            "NSEC_PER_USEC"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ns",
          "args": [],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TS_COMM_LEN < TASK_COMM_LEN"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid bacct_add_tsk(struct user_namespace *user_ns,\n\t\t   struct pid_namespace *pid_ns,\n\t\t   struct taskstats *stats, struct task_struct *tsk)\n{\n\tconst struct cred *tcred;\n\tu64 utime, stime, utimescaled, stimescaled;\n\tu64 delta;\n\ttime64_t btime;\n\n\tBUILD_BUG_ON(TS_COMM_LEN < TASK_COMM_LEN);\n\n\t/* calculate task elapsed time in nsec */\n\tdelta = ktime_get_ns() - tsk->start_time;\n\t/* Convert to micro seconds */\n\tdo_div(delta, NSEC_PER_USEC);\n\tstats->ac_etime = delta;\n\t/* Convert to seconds for btime (note y2106 limit) */\n\tbtime = ktime_get_real_seconds() - div_u64(delta, USEC_PER_SEC);\n\tstats->ac_btime = clamp_t(time64_t, btime, 0, U32_MAX);\n\tstats->ac_btime64 = btime;\n\n\tif (tsk->flags & PF_EXITING)\n\t\tstats->ac_exitcode = tsk->exit_code;\n\tif (thread_group_leader(tsk) && (tsk->flags & PF_FORKNOEXEC))\n\t\tstats->ac_flag |= AFORK;\n\tif (tsk->flags & PF_SUPERPRIV)\n\t\tstats->ac_flag |= ASU;\n\tif (tsk->flags & PF_DUMPCORE)\n\t\tstats->ac_flag |= ACORE;\n\tif (tsk->flags & PF_SIGNALED)\n\t\tstats->ac_flag |= AXSIG;\n\tstats->ac_nice\t = task_nice(tsk);\n\tstats->ac_sched\t = tsk->policy;\n\tstats->ac_pid\t = task_pid_nr_ns(tsk, pid_ns);\n\trcu_read_lock();\n\ttcred = __task_cred(tsk);\n\tstats->ac_uid\t = from_kuid_munged(user_ns, tcred->uid);\n\tstats->ac_gid\t = from_kgid_munged(user_ns, tcred->gid);\n\tstats->ac_ppid\t = pid_alive(tsk) ?\n\t\ttask_tgid_nr_ns(rcu_dereference(tsk->real_parent), pid_ns) : 0;\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tstats->ac_utime = div_u64(utime, NSEC_PER_USEC);\n\tstats->ac_stime = div_u64(stime, NSEC_PER_USEC);\n\n\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);\n\tstats->ac_utimescaled = div_u64(utimescaled, NSEC_PER_USEC);\n\tstats->ac_stimescaled = div_u64(stimescaled, NSEC_PER_USEC);\n\n\tstats->ac_minflt = tsk->min_flt;\n\tstats->ac_majflt = tsk->maj_flt;\n\n\tstrncpy(stats->ac_comm, tsk->comm, sizeof(stats->ac_comm));\n}"
  }
]