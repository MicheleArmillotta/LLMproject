[
  {
    "function_name": "em_dev_unregister_perf_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "405-425",
    "snippet": "void em_dev_unregister_perf_domain(struct device *dev)\n{\n\tif (IS_ERR_OR_NULL(dev) || !dev->em_pd)\n\t\treturn;\n\n\tif (_is_cpu_device(dev))\n\t\treturn;\n\n\t/*\n\t * The mutex separates all register/unregister requests and protects\n\t * from potential clean-up/setup issues in the debugfs directories.\n\t * The debugfs directory name is the same as device's name.\n\t */\n\tmutex_lock(&em_pd_mutex);\n\tem_debug_remove_pd(dev);\n\n\tkfree(dev->em_pd->table);\n\tkfree(dev->em_pd);\n\tdev->em_pd = NULL;\n\tmutex_unlock(&em_pd_mutex);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(em_pd_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&em_pd_mutex"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dev->em_pd"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "em_debug_remove_pd",
          "args": [
            "dev"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "em_debug_remove_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "120-120",
          "snippet": "static void em_debug_remove_pd(struct device *dev) {}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic void em_debug_remove_pd(struct device *dev) {}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&em_pd_mutex"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_is_cpu_device",
          "args": [
            "dev"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "_is_cpu_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "26-29",
          "snippet": "static bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "dev"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_MUTEX(em_pd_mutex);\n\nvoid em_dev_unregister_perf_domain(struct device *dev)\n{\n\tif (IS_ERR_OR_NULL(dev) || !dev->em_pd)\n\t\treturn;\n\n\tif (_is_cpu_device(dev))\n\t\treturn;\n\n\t/*\n\t * The mutex separates all register/unregister requests and protects\n\t * from potential clean-up/setup issues in the debugfs directories.\n\t * The debugfs directory name is the same as device's name.\n\t */\n\tmutex_lock(&em_pd_mutex);\n\tem_debug_remove_pd(dev);\n\n\tkfree(dev->em_pd->table);\n\tkfree(dev->em_pd);\n\tdev->em_pd = NULL;\n\tmutex_unlock(&em_pd_mutex);\n}"
  },
  {
    "function_name": "em_dev_register_perf_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "330-396",
    "snippet": "int em_dev_register_perf_domain(struct device *dev, unsigned int nr_states,\n\t\t\t\tstruct em_data_callback *cb, cpumask_t *cpus,\n\t\t\t\tbool milliwatts)\n{\n\tunsigned long cap, prev_cap = 0;\n\tint cpu, ret;\n\n\tif (!dev || !nr_states || !cb)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Use a mutex to serialize the registration of performance domains and\n\t * let the driver-defined callback functions sleep.\n\t */\n\tmutex_lock(&em_pd_mutex);\n\n\tif (dev->em_pd) {\n\t\tret = -EEXIST;\n\t\tgoto unlock;\n\t}\n\n\tif (_is_cpu_device(dev)) {\n\t\tif (!cpus) {\n\t\t\tdev_err(dev, \"EM: invalid CPU mask\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tfor_each_cpu(cpu, cpus) {\n\t\t\tif (em_cpu_get(cpu)) {\n\t\t\t\tdev_err(dev, \"EM: exists for CPU%d\\n\", cpu);\n\t\t\t\tret = -EEXIST;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\t/*\n\t\t\t * All CPUs of a domain must have the same\n\t\t\t * micro-architecture since they all share the same\n\t\t\t * table.\n\t\t\t */\n\t\t\tcap = arch_scale_cpu_capacity(cpu);\n\t\t\tif (prev_cap && prev_cap != cap) {\n\t\t\t\tdev_err(dev, \"EM: CPUs of %*pbl must have the same capacity\\n\",\n\t\t\t\t\tcpumask_pr_args(cpus));\n\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tprev_cap = cap;\n\t\t}\n\t}\n\n\tret = em_create_pd(dev, nr_states, cb, cpus);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (milliwatts)\n\t\tdev->em_pd->flags |= EM_PERF_DOMAIN_MILLIWATTS;\n\n\tem_cpufreq_update_efficiencies(dev);\n\n\tem_debug_create_pd(dev);\n\tdev_info(dev, \"EM: created perf domain\\n\");\n\nunlock:\n\tmutex_unlock(&em_pd_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(em_pd_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&em_pd_mutex"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"EM: created perf domain\\n\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em_debug_create_pd",
          "args": [
            "dev"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "em_debug_create_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "119-119",
          "snippet": "static void em_debug_create_pd(struct device *dev) {}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic void em_debug_create_pd(struct device *dev) {}"
        }
      },
      {
        "call_info": {
          "callee": "em_cpufreq_update_efficiencies",
          "args": [
            "dev"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "em_cpufreq_update_efficiencies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "235-270",
          "snippet": "static void em_cpufreq_update_efficiencies(struct device *dev)\n{\n\tstruct em_perf_domain *pd = dev->em_pd;\n\tstruct em_perf_state *table;\n\tstruct cpufreq_policy *policy;\n\tint found = 0;\n\tint i;\n\n\tif (!_is_cpu_device(dev) || !pd)\n\t\treturn;\n\n\tpolicy = cpufreq_cpu_get(cpumask_first(em_span_cpus(pd)));\n\tif (!policy) {\n\t\tdev_warn(dev, \"EM: Access to CPUFreq policy failed\");\n\t\treturn;\n\t}\n\n\ttable = pd->table;\n\n\tfor (i = 0; i < pd->nr_perf_states; i++) {\n\t\tif (!(table[i].flags & EM_PERF_STATE_INEFFICIENT))\n\t\t\tcontinue;\n\n\t\tif (!cpufreq_table_set_inefficient(policy, table[i].frequency))\n\t\t\tfound++;\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\t/*\n\t * Efficiencies have been installed in CPUFreq, inefficient frequencies\n\t * will be skipped. The EM can do the same.\n\t */\n\tpd->flags |= EM_PERF_DOMAIN_SKIP_INEFFICIENCIES;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic void em_cpufreq_update_efficiencies(struct device *dev)\n{\n\tstruct em_perf_domain *pd = dev->em_pd;\n\tstruct em_perf_state *table;\n\tstruct cpufreq_policy *policy;\n\tint found = 0;\n\tint i;\n\n\tif (!_is_cpu_device(dev) || !pd)\n\t\treturn;\n\n\tpolicy = cpufreq_cpu_get(cpumask_first(em_span_cpus(pd)));\n\tif (!policy) {\n\t\tdev_warn(dev, \"EM: Access to CPUFreq policy failed\");\n\t\treturn;\n\t}\n\n\ttable = pd->table;\n\n\tfor (i = 0; i < pd->nr_perf_states; i++) {\n\t\tif (!(table[i].flags & EM_PERF_STATE_INEFFICIENT))\n\t\t\tcontinue;\n\n\t\tif (!cpufreq_table_set_inefficient(policy, table[i].frequency))\n\t\t\tfound++;\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\t/*\n\t * Efficiencies have been installed in CPUFreq, inefficient frequencies\n\t * will be skipped. The EM can do the same.\n\t */\n\tpd->flags |= EM_PERF_DOMAIN_SKIP_INEFFICIENCIES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "em_create_pd",
          "args": [
            "dev",
            "nr_states",
            "cb",
            "cpus"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "em_create_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "199-233",
          "snippet": "static int em_create_pd(struct device *dev, int nr_states,\n\t\t\tstruct em_data_callback *cb, cpumask_t *cpus)\n{\n\tstruct em_perf_domain *pd;\n\tstruct device *cpu_dev;\n\tint cpu, ret;\n\n\tif (_is_cpu_device(dev)) {\n\t\tpd = kzalloc(sizeof(*pd) + cpumask_size(), GFP_KERNEL);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tcpumask_copy(em_span_cpus(pd), cpus);\n\t} else {\n\t\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = em_create_perf_table(dev, pd, nr_states, cb);\n\tif (ret) {\n\t\tkfree(pd);\n\t\treturn ret;\n\t}\n\n\tif (_is_cpu_device(dev))\n\t\tfor_each_cpu(cpu, cpus) {\n\t\t\tcpu_dev = get_cpu_device(cpu);\n\t\t\tcpu_dev->em_pd = pd;\n\t\t}\n\n\tdev->em_pd = pd;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic int em_create_pd(struct device *dev, int nr_states,\n\t\t\tstruct em_data_callback *cb, cpumask_t *cpus)\n{\n\tstruct em_perf_domain *pd;\n\tstruct device *cpu_dev;\n\tint cpu, ret;\n\n\tif (_is_cpu_device(dev)) {\n\t\tpd = kzalloc(sizeof(*pd) + cpumask_size(), GFP_KERNEL);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tcpumask_copy(em_span_cpus(pd), cpus);\n\t} else {\n\t\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = em_create_perf_table(dev, pd, nr_states, cb);\n\tif (ret) {\n\t\tkfree(pd);\n\t\treturn ret;\n\t}\n\n\tif (_is_cpu_device(dev))\n\t\tfor_each_cpu(cpu, cpus) {\n\t\t\tcpu_dev = get_cpu_device(cpu);\n\t\t\tcpu_dev->em_pd = pd;\n\t\t}\n\n\tdev->em_pd = pd;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"EM: CPUs of %*pbl must have the same capacity\\n\"",
            "cpumask_pr_args(cpus)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cpus"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_scale_cpu_capacity",
          "args": [
            "cpu"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"EM: exists for CPU%d\\n\"",
            "cpu"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em_cpu_get",
          "args": [
            "cpu"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "em_cpu_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "295-304",
          "snippet": "struct em_perf_domain *em_cpu_get(int cpu)\n{\n\tstruct device *cpu_dev;\n\n\tcpu_dev = get_cpu_device(cpu);\n\tif (!cpu_dev)\n\t\treturn NULL;\n\n\treturn em_pd_get(cpu_dev);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstruct em_perf_domain *em_cpu_get(int cpu)\n{\n\tstruct device *cpu_dev;\n\n\tcpu_dev = get_cpu_device(cpu);\n\tif (!cpu_dev)\n\t\treturn NULL;\n\n\treturn em_pd_get(cpu_dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cpus"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"EM: invalid CPU mask\\n\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_is_cpu_device",
          "args": [
            "dev"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "_is_cpu_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "26-29",
          "snippet": "static bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&em_pd_mutex"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_MUTEX(em_pd_mutex);\n\nint em_dev_register_perf_domain(struct device *dev, unsigned int nr_states,\n\t\t\t\tstruct em_data_callback *cb, cpumask_t *cpus,\n\t\t\t\tbool milliwatts)\n{\n\tunsigned long cap, prev_cap = 0;\n\tint cpu, ret;\n\n\tif (!dev || !nr_states || !cb)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Use a mutex to serialize the registration of performance domains and\n\t * let the driver-defined callback functions sleep.\n\t */\n\tmutex_lock(&em_pd_mutex);\n\n\tif (dev->em_pd) {\n\t\tret = -EEXIST;\n\t\tgoto unlock;\n\t}\n\n\tif (_is_cpu_device(dev)) {\n\t\tif (!cpus) {\n\t\t\tdev_err(dev, \"EM: invalid CPU mask\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tfor_each_cpu(cpu, cpus) {\n\t\t\tif (em_cpu_get(cpu)) {\n\t\t\t\tdev_err(dev, \"EM: exists for CPU%d\\n\", cpu);\n\t\t\t\tret = -EEXIST;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\t/*\n\t\t\t * All CPUs of a domain must have the same\n\t\t\t * micro-architecture since they all share the same\n\t\t\t * table.\n\t\t\t */\n\t\t\tcap = arch_scale_cpu_capacity(cpu);\n\t\t\tif (prev_cap && prev_cap != cap) {\n\t\t\t\tdev_err(dev, \"EM: CPUs of %*pbl must have the same capacity\\n\",\n\t\t\t\t\tcpumask_pr_args(cpus));\n\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tprev_cap = cap;\n\t\t}\n\t}\n\n\tret = em_create_pd(dev, nr_states, cb, cpus);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (milliwatts)\n\t\tdev->em_pd->flags |= EM_PERF_DOMAIN_MILLIWATTS;\n\n\tem_cpufreq_update_efficiencies(dev);\n\n\tem_debug_create_pd(dev);\n\tdev_info(dev, \"EM: created perf domain\\n\");\n\nunlock:\n\tmutex_unlock(&em_pd_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "em_cpu_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "295-304",
    "snippet": "struct em_perf_domain *em_cpu_get(int cpu)\n{\n\tstruct device *cpu_dev;\n\n\tcpu_dev = get_cpu_device(cpu);\n\tif (!cpu_dev)\n\t\treturn NULL;\n\n\treturn em_pd_get(cpu_dev);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "em_pd_get",
          "args": [
            "cpu_dev"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "em_pd_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "279-285",
          "snippet": "struct em_perf_domain *em_pd_get(struct device *dev)\n{\n\tif (IS_ERR_OR_NULL(dev))\n\t\treturn NULL;\n\n\treturn dev->em_pd;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstruct em_perf_domain *em_pd_get(struct device *dev)\n{\n\tif (IS_ERR_OR_NULL(dev))\n\t\treturn NULL;\n\n\treturn dev->em_pd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstruct em_perf_domain *em_cpu_get(int cpu)\n{\n\tstruct device *cpu_dev;\n\n\tcpu_dev = get_cpu_device(cpu);\n\tif (!cpu_dev)\n\t\treturn NULL;\n\n\treturn em_pd_get(cpu_dev);\n}"
  },
  {
    "function_name": "em_pd_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "279-285",
    "snippet": "struct em_perf_domain *em_pd_get(struct device *dev)\n{\n\tif (IS_ERR_OR_NULL(dev))\n\t\treturn NULL;\n\n\treturn dev->em_pd;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "dev"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstruct em_perf_domain *em_pd_get(struct device *dev)\n{\n\tif (IS_ERR_OR_NULL(dev))\n\t\treturn NULL;\n\n\treturn dev->em_pd;\n}"
  },
  {
    "function_name": "em_cpufreq_update_efficiencies",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "235-270",
    "snippet": "static void em_cpufreq_update_efficiencies(struct device *dev)\n{\n\tstruct em_perf_domain *pd = dev->em_pd;\n\tstruct em_perf_state *table;\n\tstruct cpufreq_policy *policy;\n\tint found = 0;\n\tint i;\n\n\tif (!_is_cpu_device(dev) || !pd)\n\t\treturn;\n\n\tpolicy = cpufreq_cpu_get(cpumask_first(em_span_cpus(pd)));\n\tif (!policy) {\n\t\tdev_warn(dev, \"EM: Access to CPUFreq policy failed\");\n\t\treturn;\n\t}\n\n\ttable = pd->table;\n\n\tfor (i = 0; i < pd->nr_perf_states; i++) {\n\t\tif (!(table[i].flags & EM_PERF_STATE_INEFFICIENT))\n\t\t\tcontinue;\n\n\t\tif (!cpufreq_table_set_inefficient(policy, table[i].frequency))\n\t\t\tfound++;\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\t/*\n\t * Efficiencies have been installed in CPUFreq, inefficient frequencies\n\t * will be skipped. The EM can do the same.\n\t */\n\tpd->flags |= EM_PERF_DOMAIN_SKIP_INEFFICIENCIES;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpufreq_table_set_inefficient",
          "args": [
            "policy",
            "table[i].frequency"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_warn",
          "args": [
            "dev",
            "\"EM: Access to CPUFreq policy failed\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpufreq_cpu_get",
          "args": [
            "cpumask_first(em_span_cpus(pd))"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "em_span_cpus(pd)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em_span_cpus",
          "args": [
            "pd"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_is_cpu_device",
          "args": [
            "dev"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "_is_cpu_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "26-29",
          "snippet": "static bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic void em_cpufreq_update_efficiencies(struct device *dev)\n{\n\tstruct em_perf_domain *pd = dev->em_pd;\n\tstruct em_perf_state *table;\n\tstruct cpufreq_policy *policy;\n\tint found = 0;\n\tint i;\n\n\tif (!_is_cpu_device(dev) || !pd)\n\t\treturn;\n\n\tpolicy = cpufreq_cpu_get(cpumask_first(em_span_cpus(pd)));\n\tif (!policy) {\n\t\tdev_warn(dev, \"EM: Access to CPUFreq policy failed\");\n\t\treturn;\n\t}\n\n\ttable = pd->table;\n\n\tfor (i = 0; i < pd->nr_perf_states; i++) {\n\t\tif (!(table[i].flags & EM_PERF_STATE_INEFFICIENT))\n\t\t\tcontinue;\n\n\t\tif (!cpufreq_table_set_inefficient(policy, table[i].frequency))\n\t\t\tfound++;\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\t/*\n\t * Efficiencies have been installed in CPUFreq, inefficient frequencies\n\t * will be skipped. The EM can do the same.\n\t */\n\tpd->flags |= EM_PERF_DOMAIN_SKIP_INEFFICIENCIES;\n}"
  },
  {
    "function_name": "em_create_pd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "199-233",
    "snippet": "static int em_create_pd(struct device *dev, int nr_states,\n\t\t\tstruct em_data_callback *cb, cpumask_t *cpus)\n{\n\tstruct em_perf_domain *pd;\n\tstruct device *cpu_dev;\n\tint cpu, ret;\n\n\tif (_is_cpu_device(dev)) {\n\t\tpd = kzalloc(sizeof(*pd) + cpumask_size(), GFP_KERNEL);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tcpumask_copy(em_span_cpus(pd), cpus);\n\t} else {\n\t\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = em_create_perf_table(dev, pd, nr_states, cb);\n\tif (ret) {\n\t\tkfree(pd);\n\t\treturn ret;\n\t}\n\n\tif (_is_cpu_device(dev))\n\t\tfor_each_cpu(cpu, cpus) {\n\t\t\tcpu_dev = get_cpu_device(cpu);\n\t\t\tcpu_dev->em_pd = pd;\n\t\t}\n\n\tdev->em_pd = pd;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_cpu_device",
          "args": [
            "cpu"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cpus"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_is_cpu_device",
          "args": [
            "dev"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "_is_cpu_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "26-29",
          "snippet": "static bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pd"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "em_create_perf_table",
          "args": [
            "dev",
            "pd",
            "nr_states",
            "cb"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "em_create_perf_table",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "123-197",
          "snippet": "static int em_create_perf_table(struct device *dev, struct em_perf_domain *pd,\n\t\t\t\tint nr_states, struct em_data_callback *cb)\n{\n\tunsigned long power, freq, prev_freq = 0, prev_cost = ULONG_MAX;\n\tstruct em_perf_state *table;\n\tint i, ret;\n\tu64 fmax;\n\n\ttable = kcalloc(nr_states, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\t/* Build the list of performance states for this performance domain */\n\tfor (i = 0, freq = 0; i < nr_states; i++, freq++) {\n\t\t/*\n\t\t * active_power() is a driver callback which ceils 'freq' to\n\t\t * lowest performance state of 'dev' above 'freq' and updates\n\t\t * 'power' and 'freq' accordingly.\n\t\t */\n\t\tret = cb->active_power(&power, &freq, dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"EM: invalid perf. state: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\t/*\n\t\t * We expect the driver callback to increase the frequency for\n\t\t * higher performance states.\n\t\t */\n\t\tif (freq <= prev_freq) {\n\t\t\tdev_err(dev, \"EM: non-increasing freq: %lu\\n\",\n\t\t\t\tfreq);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\t/*\n\t\t * The power returned by active_state() is expected to be\n\t\t * positive and to fit into 16 bits.\n\t\t */\n\t\tif (!power || power > EM_MAX_POWER) {\n\t\t\tdev_err(dev, \"EM: invalid power: %lu\\n\",\n\t\t\t\tpower);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\ttable[i].power = power;\n\t\ttable[i].frequency = prev_freq = freq;\n\t}\n\n\t/* Compute the cost of each performance state. */\n\tfmax = (u64) table[nr_states - 1].frequency;\n\tfor (i = nr_states - 1; i >= 0; i--) {\n\t\tunsigned long power_res = em_scale_power(table[i].power);\n\n\t\ttable[i].cost = div64_u64(fmax * power_res,\n\t\t\t\t\t  table[i].frequency);\n\t\tif (table[i].cost >= prev_cost) {\n\t\t\ttable[i].flags = EM_PERF_STATE_INEFFICIENT;\n\t\t\tdev_dbg(dev, \"EM: OPP:%lu is inefficient\\n\",\n\t\t\t\ttable[i].frequency);\n\t\t} else {\n\t\t\tprev_cost = table[i].cost;\n\t\t}\n\t}\n\n\tpd->table = table;\n\tpd->nr_perf_states = nr_states;\n\n\treturn 0;\n\nfree_ps_table:\n\tkfree(table);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic int em_create_perf_table(struct device *dev, struct em_perf_domain *pd,\n\t\t\t\tint nr_states, struct em_data_callback *cb)\n{\n\tunsigned long power, freq, prev_freq = 0, prev_cost = ULONG_MAX;\n\tstruct em_perf_state *table;\n\tint i, ret;\n\tu64 fmax;\n\n\ttable = kcalloc(nr_states, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\t/* Build the list of performance states for this performance domain */\n\tfor (i = 0, freq = 0; i < nr_states; i++, freq++) {\n\t\t/*\n\t\t * active_power() is a driver callback which ceils 'freq' to\n\t\t * lowest performance state of 'dev' above 'freq' and updates\n\t\t * 'power' and 'freq' accordingly.\n\t\t */\n\t\tret = cb->active_power(&power, &freq, dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"EM: invalid perf. state: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\t/*\n\t\t * We expect the driver callback to increase the frequency for\n\t\t * higher performance states.\n\t\t */\n\t\tif (freq <= prev_freq) {\n\t\t\tdev_err(dev, \"EM: non-increasing freq: %lu\\n\",\n\t\t\t\tfreq);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\t/*\n\t\t * The power returned by active_state() is expected to be\n\t\t * positive and to fit into 16 bits.\n\t\t */\n\t\tif (!power || power > EM_MAX_POWER) {\n\t\t\tdev_err(dev, \"EM: invalid power: %lu\\n\",\n\t\t\t\tpower);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\ttable[i].power = power;\n\t\ttable[i].frequency = prev_freq = freq;\n\t}\n\n\t/* Compute the cost of each performance state. */\n\tfmax = (u64) table[nr_states - 1].frequency;\n\tfor (i = nr_states - 1; i >= 0; i--) {\n\t\tunsigned long power_res = em_scale_power(table[i].power);\n\n\t\ttable[i].cost = div64_u64(fmax * power_res,\n\t\t\t\t\t  table[i].frequency);\n\t\tif (table[i].cost >= prev_cost) {\n\t\t\ttable[i].flags = EM_PERF_STATE_INEFFICIENT;\n\t\t\tdev_dbg(dev, \"EM: OPP:%lu is inefficient\\n\",\n\t\t\t\ttable[i].frequency);\n\t\t} else {\n\t\t\tprev_cost = table[i].cost;\n\t\t}\n\t}\n\n\tpd->table = table;\n\tpd->nr_perf_states = nr_states;\n\n\treturn 0;\n\nfree_ps_table:\n\tkfree(table);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pd)",
            "GFP_KERNEL"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "em_span_cpus(pd)",
            "cpus"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em_span_cpus",
          "args": [
            "pd"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pd) + cpumask_size()",
            "GFP_KERNEL"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic int em_create_pd(struct device *dev, int nr_states,\n\t\t\tstruct em_data_callback *cb, cpumask_t *cpus)\n{\n\tstruct em_perf_domain *pd;\n\tstruct device *cpu_dev;\n\tint cpu, ret;\n\n\tif (_is_cpu_device(dev)) {\n\t\tpd = kzalloc(sizeof(*pd) + cpumask_size(), GFP_KERNEL);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tcpumask_copy(em_span_cpus(pd), cpus);\n\t} else {\n\t\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = em_create_perf_table(dev, pd, nr_states, cb);\n\tif (ret) {\n\t\tkfree(pd);\n\t\treturn ret;\n\t}\n\n\tif (_is_cpu_device(dev))\n\t\tfor_each_cpu(cpu, cpus) {\n\t\t\tcpu_dev = get_cpu_device(cpu);\n\t\t\tcpu_dev->em_pd = pd;\n\t\t}\n\n\tdev->em_pd = pd;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "em_create_perf_table",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "123-197",
    "snippet": "static int em_create_perf_table(struct device *dev, struct em_perf_domain *pd,\n\t\t\t\tint nr_states, struct em_data_callback *cb)\n{\n\tunsigned long power, freq, prev_freq = 0, prev_cost = ULONG_MAX;\n\tstruct em_perf_state *table;\n\tint i, ret;\n\tu64 fmax;\n\n\ttable = kcalloc(nr_states, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\t/* Build the list of performance states for this performance domain */\n\tfor (i = 0, freq = 0; i < nr_states; i++, freq++) {\n\t\t/*\n\t\t * active_power() is a driver callback which ceils 'freq' to\n\t\t * lowest performance state of 'dev' above 'freq' and updates\n\t\t * 'power' and 'freq' accordingly.\n\t\t */\n\t\tret = cb->active_power(&power, &freq, dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"EM: invalid perf. state: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\t/*\n\t\t * We expect the driver callback to increase the frequency for\n\t\t * higher performance states.\n\t\t */\n\t\tif (freq <= prev_freq) {\n\t\t\tdev_err(dev, \"EM: non-increasing freq: %lu\\n\",\n\t\t\t\tfreq);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\t/*\n\t\t * The power returned by active_state() is expected to be\n\t\t * positive and to fit into 16 bits.\n\t\t */\n\t\tif (!power || power > EM_MAX_POWER) {\n\t\t\tdev_err(dev, \"EM: invalid power: %lu\\n\",\n\t\t\t\tpower);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\ttable[i].power = power;\n\t\ttable[i].frequency = prev_freq = freq;\n\t}\n\n\t/* Compute the cost of each performance state. */\n\tfmax = (u64) table[nr_states - 1].frequency;\n\tfor (i = nr_states - 1; i >= 0; i--) {\n\t\tunsigned long power_res = em_scale_power(table[i].power);\n\n\t\ttable[i].cost = div64_u64(fmax * power_res,\n\t\t\t\t\t  table[i].frequency);\n\t\tif (table[i].cost >= prev_cost) {\n\t\t\ttable[i].flags = EM_PERF_STATE_INEFFICIENT;\n\t\t\tdev_dbg(dev, \"EM: OPP:%lu is inefficient\\n\",\n\t\t\t\ttable[i].frequency);\n\t\t} else {\n\t\t\tprev_cost = table[i].cost;\n\t\t}\n\t}\n\n\tpd->table = table;\n\tpd->nr_perf_states = nr_states;\n\n\treturn 0;\n\nfree_ps_table:\n\tkfree(table);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "table"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_dbg",
          "args": [
            "dev",
            "\"EM: OPP:%lu is inefficient\\n\"",
            "table[i].frequency"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "fmax * power_res",
            "table[i].frequency"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em_scale_power",
          "args": [
            "table[i].power"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"EM: invalid power: %lu\\n\"",
            "power"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"EM: non-increasing freq: %lu\\n\"",
            "freq"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"EM: invalid perf. state: %d\\n\"",
            "ret"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb->active_power",
          "args": [
            "&power",
            "&freq",
            "dev"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_states",
            "sizeof(*table)",
            "GFP_KERNEL"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic int em_create_perf_table(struct device *dev, struct em_perf_domain *pd,\n\t\t\t\tint nr_states, struct em_data_callback *cb)\n{\n\tunsigned long power, freq, prev_freq = 0, prev_cost = ULONG_MAX;\n\tstruct em_perf_state *table;\n\tint i, ret;\n\tu64 fmax;\n\n\ttable = kcalloc(nr_states, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\t/* Build the list of performance states for this performance domain */\n\tfor (i = 0, freq = 0; i < nr_states; i++, freq++) {\n\t\t/*\n\t\t * active_power() is a driver callback which ceils 'freq' to\n\t\t * lowest performance state of 'dev' above 'freq' and updates\n\t\t * 'power' and 'freq' accordingly.\n\t\t */\n\t\tret = cb->active_power(&power, &freq, dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"EM: invalid perf. state: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\t/*\n\t\t * We expect the driver callback to increase the frequency for\n\t\t * higher performance states.\n\t\t */\n\t\tif (freq <= prev_freq) {\n\t\t\tdev_err(dev, \"EM: non-increasing freq: %lu\\n\",\n\t\t\t\tfreq);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\t/*\n\t\t * The power returned by active_state() is expected to be\n\t\t * positive and to fit into 16 bits.\n\t\t */\n\t\tif (!power || power > EM_MAX_POWER) {\n\t\t\tdev_err(dev, \"EM: invalid power: %lu\\n\",\n\t\t\t\tpower);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\ttable[i].power = power;\n\t\ttable[i].frequency = prev_freq = freq;\n\t}\n\n\t/* Compute the cost of each performance state. */\n\tfmax = (u64) table[nr_states - 1].frequency;\n\tfor (i = nr_states - 1; i >= 0; i--) {\n\t\tunsigned long power_res = em_scale_power(table[i].power);\n\n\t\ttable[i].cost = div64_u64(fmax * power_res,\n\t\t\t\t\t  table[i].frequency);\n\t\tif (table[i].cost >= prev_cost) {\n\t\t\ttable[i].flags = EM_PERF_STATE_INEFFICIENT;\n\t\t\tdev_dbg(dev, \"EM: OPP:%lu is inefficient\\n\",\n\t\t\t\ttable[i].frequency);\n\t\t} else {\n\t\t\tprev_cost = table[i].cost;\n\t\t}\n\t}\n\n\tpd->table = table;\n\tpd->nr_perf_states = nr_states;\n\n\treturn 0;\n\nfree_ps_table:\n\tkfree(table);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "em_debug_remove_pd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "120-120",
    "snippet": "static void em_debug_remove_pd(struct device *dev) {}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic void em_debug_remove_pd(struct device *dev) {}"
  },
  {
    "function_name": "em_debug_create_pd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "119-119",
    "snippet": "static void em_debug_create_pd(struct device *dev) {}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic void em_debug_create_pd(struct device *dev) {}"
  },
  {
    "function_name": "em_debug_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "110-116",
    "snippet": "static int __init em_debug_init(void)\n{\n\t/* Create /sys/kernel/debug/energy_model directory */\n\trootdir = debugfs_create_dir(\"energy_model\", NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"energy_model\"",
            "NULL"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic int __init em_debug_init(void)\n{\n\t/* Create /sys/kernel/debug/energy_model directory */\n\trootdir = debugfs_create_dir(\"energy_model\", NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "em_debug_remove_pd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "102-108",
    "snippet": "static void em_debug_remove_pd(struct device *dev)\n{\n\tstruct dentry *debug_dir;\n\n\tdebug_dir = debugfs_lookup(dev_name(dev), rootdir);\n\tdebugfs_remove_recursive(debug_dir);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "debug_dir"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_lookup",
          "args": [
            "dev_name(dev)",
            "rootdir"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic void em_debug_remove_pd(struct device *dev)\n{\n\tstruct dentry *debug_dir;\n\n\tdebug_dir = debugfs_lookup(dev_name(dev), rootdir);\n\tdebugfs_remove_recursive(debug_dir);\n}"
  },
  {
    "function_name": "em_debug_create_pd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "80-100",
    "snippet": "static void em_debug_create_pd(struct device *dev)\n{\n\tstruct dentry *d;\n\tint i;\n\n\t/* Create the directory of the performance domain */\n\td = debugfs_create_dir(dev_name(dev), rootdir);\n\n\tif (_is_cpu_device(dev))\n\t\tdebugfs_create_file(\"cpus\", 0444, d, dev->em_pd->cpus,\n\t\t\t\t    &em_debug_cpus_fops);\n\n\tdebugfs_create_file(\"units\", 0444, d, dev->em_pd, &em_debug_units_fops);\n\tdebugfs_create_file(\"skip-inefficiencies\", 0444, d, dev->em_pd,\n\t\t\t    &em_debug_skip_inefficiencies_fops);\n\n\t/* Create a sub-directory for each performance state */\n\tfor (i = 0; i < dev->em_pd->nr_perf_states; i++)\n\t\tem_debug_create_ps(&dev->em_pd->table[i], d);\n\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "em_debug_create_ps",
          "args": [
            "&dev->em_pd->table[i]",
            "d"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "em_debug_create_ps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "34-47",
          "snippet": "static void em_debug_create_ps(struct em_perf_state *ps, struct dentry *pd)\n{\n\tstruct dentry *d;\n\tchar name[24];\n\n\tsnprintf(name, sizeof(name), \"ps:%lu\", ps->frequency);\n\n\t/* Create per-ps directory */\n\td = debugfs_create_dir(name, pd);\n\tdebugfs_create_ulong(\"frequency\", 0444, d, &ps->frequency);\n\tdebugfs_create_ulong(\"power\", 0444, d, &ps->power);\n\tdebugfs_create_ulong(\"cost\", 0444, d, &ps->cost);\n\tdebugfs_create_ulong(\"inefficient\", 0444, d, &ps->flags);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic void em_debug_create_ps(struct em_perf_state *ps, struct dentry *pd)\n{\n\tstruct dentry *d;\n\tchar name[24];\n\n\tsnprintf(name, sizeof(name), \"ps:%lu\", ps->frequency);\n\n\t/* Create per-ps directory */\n\td = debugfs_create_dir(name, pd);\n\tdebugfs_create_ulong(\"frequency\", 0444, d, &ps->frequency);\n\tdebugfs_create_ulong(\"power\", 0444, d, &ps->power);\n\tdebugfs_create_ulong(\"cost\", 0444, d, &ps->cost);\n\tdebugfs_create_ulong(\"inefficient\", 0444, d, &ps->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"skip-inefficiencies\"",
            "0444",
            "d",
            "dev->em_pd",
            "&em_debug_skip_inefficiencies_fops"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"units\"",
            "0444",
            "d",
            "dev->em_pd",
            "&em_debug_units_fops"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"cpus\"",
            "0444",
            "d",
            "dev->em_pd->cpus",
            "&em_debug_cpus_fops"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_is_cpu_device",
          "args": [
            "dev"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "_is_cpu_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
          "lines": "26-29",
          "snippet": "static bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "dev_name(dev)",
            "rootdir"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic void em_debug_create_pd(struct device *dev)\n{\n\tstruct dentry *d;\n\tint i;\n\n\t/* Create the directory of the performance domain */\n\td = debugfs_create_dir(dev_name(dev), rootdir);\n\n\tif (_is_cpu_device(dev))\n\t\tdebugfs_create_file(\"cpus\", 0444, d, dev->em_pd->cpus,\n\t\t\t\t    &em_debug_cpus_fops);\n\n\tdebugfs_create_file(\"units\", 0444, d, dev->em_pd, &em_debug_units_fops);\n\tdebugfs_create_file(\"skip-inefficiencies\", 0444, d, dev->em_pd,\n\t\t\t    &em_debug_skip_inefficiencies_fops);\n\n\t/* Create a sub-directory for each performance state */\n\tfor (i = 0; i < dev->em_pd->nr_perf_states; i++)\n\t\tem_debug_create_ps(&dev->em_pd->table[i], d);\n\n}"
  },
  {
    "function_name": "em_debug_skip_inefficiencies_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "69-77",
    "snippet": "static int em_debug_skip_inefficiencies_show(struct seq_file *s, void *unused)\n{\n\tstruct em_perf_domain *pd = s->private;\n\tint enabled = (pd->flags & EM_PERF_DOMAIN_SKIP_INEFFICIENCIES) ? 1 : 0;\n\n\tseq_printf(s, \"%d\\n\", enabled);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%d\\n\"",
            "enabled"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic int em_debug_skip_inefficiencies_show(struct seq_file *s, void *unused)\n{\n\tstruct em_perf_domain *pd = s->private;\n\tint enabled = (pd->flags & EM_PERF_DOMAIN_SKIP_INEFFICIENCIES) ? 1 : 0;\n\n\tseq_printf(s, \"%d\\n\", enabled);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "em_debug_units_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "57-66",
    "snippet": "static int em_debug_units_show(struct seq_file *s, void *unused)\n{\n\tstruct em_perf_domain *pd = s->private;\n\tchar *units = (pd->flags & EM_PERF_DOMAIN_MILLIWATTS) ?\n\t\t\"milliWatts\" : \"bogoWatts\";\n\n\tseq_printf(s, \"%s\\n\", units);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%s\\n\"",
            "units"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic int em_debug_units_show(struct seq_file *s, void *unused)\n{\n\tstruct em_perf_domain *pd = s->private;\n\tchar *units = (pd->flags & EM_PERF_DOMAIN_MILLIWATTS) ?\n\t\t\"milliWatts\" : \"bogoWatts\";\n\n\tseq_printf(s, \"%s\\n\", units);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "em_debug_cpus_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "49-54",
    "snippet": "static int em_debug_cpus_show(struct seq_file *s, void *unused)\n{\n\tseq_printf(s, \"%*pbl\\n\", cpumask_pr_args(to_cpumask(s->private)));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%*pbl\\n\"",
            "cpumask_pr_args(to_cpumask(s->private))"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "to_cpumask(s->private)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cpumask",
          "args": [
            "s->private"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "build_node_to_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/affinity.c",
          "lines": "75-81",
          "snippet": "static void build_node_to_cpumask(cpumask_var_t *masks)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcpumask_set_cpu(cpu, masks[cpu_to_node(cpu)]);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nstatic void build_node_to_cpumask(cpumask_var_t *masks)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcpumask_set_cpu(cpu, masks[cpu_to_node(cpu)]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic int em_debug_cpus_show(struct seq_file *s, void *unused)\n{\n\tseq_printf(s, \"%*pbl\\n\", cpumask_pr_args(to_cpumask(s->private)));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "em_debug_create_ps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "34-47",
    "snippet": "static void em_debug_create_ps(struct em_perf_state *ps, struct dentry *pd)\n{\n\tstruct dentry *d;\n\tchar name[24];\n\n\tsnprintf(name, sizeof(name), \"ps:%lu\", ps->frequency);\n\n\t/* Create per-ps directory */\n\td = debugfs_create_dir(name, pd);\n\tdebugfs_create_ulong(\"frequency\", 0444, d, &ps->frequency);\n\tdebugfs_create_ulong(\"power\", 0444, d, &ps->power);\n\tdebugfs_create_ulong(\"cost\", 0444, d, &ps->cost);\n\tdebugfs_create_ulong(\"inefficient\", 0444, d, &ps->flags);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_ulong",
          "args": [
            "\"inefficient\"",
            "0444",
            "d",
            "&ps->flags"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_ulong",
          "args": [
            "\"cost\"",
            "0444",
            "d",
            "&ps->cost"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_ulong",
          "args": [
            "\"power\"",
            "0444",
            "d",
            "&ps->power"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_ulong",
          "args": [
            "\"frequency\"",
            "0444",
            "d",
            "&ps->frequency"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "name",
            "pd"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"ps:%lu\"",
            "ps->frequency"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic void em_debug_create_ps(struct em_perf_state *ps, struct dentry *pd)\n{\n\tstruct dentry *d;\n\tchar name[24];\n\n\tsnprintf(name, sizeof(name), \"ps:%lu\", ps->frequency);\n\n\t/* Create per-ps directory */\n\td = debugfs_create_dir(name, pd);\n\tdebugfs_create_ulong(\"frequency\", 0444, d, &ps->frequency);\n\tdebugfs_create_ulong(\"power\", 0444, d, &ps->power);\n\tdebugfs_create_ulong(\"cost\", 0444, d, &ps->cost);\n\tdebugfs_create_ulong(\"inefficient\", 0444, d, &ps->flags);\n}"
  },
  {
    "function_name": "_is_cpu_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/energy_model.c",
    "lines": "26-29",
    "snippet": "static bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched/topology.h>",
      "#include <linux/energy_model.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpufreq.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/topology.h>\n#include <linux/energy_model.h>\n#include <linux/debugfs.h>\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n\nstatic bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}"
  }
]