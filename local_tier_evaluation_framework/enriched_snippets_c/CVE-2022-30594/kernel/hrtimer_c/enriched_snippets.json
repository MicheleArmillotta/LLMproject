[
  {
    "function_name": "schedule_hrtimeout",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2381-2385",
    "snippet": "int __sched schedule_hrtimeout(ktime_t *expires,\n\t\t\t       const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range(expires, 0, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_hrtimeout_range",
          "args": [
            "expires",
            "0",
            "mode"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_hrtimeout_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2347-2352",
          "snippet": "int __sched schedule_hrtimeout_range(ktime_t *expires, u64 delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      CLOCK_MONOTONIC);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched schedule_hrtimeout_range(ktime_t *expires, u64 delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      CLOCK_MONOTONIC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched schedule_hrtimeout(ktime_t *expires,\n\t\t\t       const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range(expires, 0, mode);\n}"
  },
  {
    "function_name": "schedule_hrtimeout_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2347-2352",
    "snippet": "int __sched schedule_hrtimeout_range(ktime_t *expires, u64 delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      CLOCK_MONOTONIC);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_hrtimeout_range_clock",
          "args": [
            "expires",
            "delta",
            "mode",
            "CLOCK_MONOTONIC"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_hrtimeout_range_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2277-2313",
          "snippet": "int __sched\nschedule_hrtimeout_range_clock(ktime_t *expires, u64 delta,\n\t\t\t       const enum hrtimer_mode mode, clockid_t clock_id)\n{\n\tstruct hrtimer_sleeper t;\n\n\t/*\n\t * Optimize when a zero timeout value is given. It does not\n\t * matter whether this is an absolute or a relative time.\n\t */\n\tif (expires && *expires == 0) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * A NULL parameter means \"infinite\"\n\t */\n\tif (!expires) {\n\t\tschedule();\n\t\treturn -EINTR;\n\t}\n\n\thrtimer_init_sleeper_on_stack(&t, clock_id, mode);\n\thrtimer_set_expires_range_ns(&t.timer, *expires, delta);\n\thrtimer_sleeper_start_expires(&t, mode);\n\n\tif (likely(t.task))\n\t\tschedule();\n\n\thrtimer_cancel(&t.timer);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn !t.task ? 0 : -EINTR;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched\nschedule_hrtimeout_range_clock(ktime_t *expires, u64 delta,\n\t\t\t       const enum hrtimer_mode mode, clockid_t clock_id)\n{\n\tstruct hrtimer_sleeper t;\n\n\t/*\n\t * Optimize when a zero timeout value is given. It does not\n\t * matter whether this is an absolute or a relative time.\n\t */\n\tif (expires && *expires == 0) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * A NULL parameter means \"infinite\"\n\t */\n\tif (!expires) {\n\t\tschedule();\n\t\treturn -EINTR;\n\t}\n\n\thrtimer_init_sleeper_on_stack(&t, clock_id, mode);\n\thrtimer_set_expires_range_ns(&t.timer, *expires, delta);\n\thrtimer_sleeper_start_expires(&t, mode);\n\n\tif (likely(t.task))\n\t\tschedule();\n\n\thrtimer_cancel(&t.timer);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn !t.task ? 0 : -EINTR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched schedule_hrtimeout_range(ktime_t *expires, u64 delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      CLOCK_MONOTONIC);\n}"
  },
  {
    "function_name": "schedule_hrtimeout_range_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2277-2313",
    "snippet": "int __sched\nschedule_hrtimeout_range_clock(ktime_t *expires, u64 delta,\n\t\t\t       const enum hrtimer_mode mode, clockid_t clock_id)\n{\n\tstruct hrtimer_sleeper t;\n\n\t/*\n\t * Optimize when a zero timeout value is given. It does not\n\t * matter whether this is an absolute or a relative time.\n\t */\n\tif (expires && *expires == 0) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * A NULL parameter means \"infinite\"\n\t */\n\tif (!expires) {\n\t\tschedule();\n\t\treturn -EINTR;\n\t}\n\n\thrtimer_init_sleeper_on_stack(&t, clock_id, mode);\n\thrtimer_set_expires_range_ns(&t.timer, *expires, delta);\n\thrtimer_sleeper_start_expires(&t, mode);\n\n\tif (likely(t.task))\n\t\tschedule();\n\n\thrtimer_cancel(&t.timer);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn !t.task ? 0 : -EINTR;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hrtimer_on_stack",
          "args": [
            "&t.timer"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hrtimer_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "450-453",
          "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&t.timer"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "t.task"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_sleeper_start_expires",
          "args": [
            "&t",
            "mode"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_sleeper_start_expires",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1952-1966",
          "snippet": "void hrtimer_sleeper_start_expires(struct hrtimer_sleeper *sl,\n\t\t\t\t   enum hrtimer_mode mode)\n{\n\t/*\n\t * Make the enqueue delivery mode check work on RT. If the sleeper\n\t * was initialized for hard interrupt delivery, force the mode bit.\n\t * This is a special case for hrtimer_sleepers because\n\t * hrtimer_init_sleeper() determines the delivery mode on RT so the\n\t * fiddling with this decision is avoided at the call sites.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && sl->timer.is_hard)\n\t\tmode |= HRTIMER_MODE_HARD;\n\n\thrtimer_start_expires(&sl->timer, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_sleeper_start_expires(struct hrtimer_sleeper *sl,\n\t\t\t\t   enum hrtimer_mode mode)\n{\n\t/*\n\t * Make the enqueue delivery mode check work on RT. If the sleeper\n\t * was initialized for hard interrupt delivery, force the mode bit.\n\t * This is a special case for hrtimer_sleepers because\n\t * hrtimer_init_sleeper() determines the delivery mode on RT so the\n\t * fiddling with this decision is avoided at the call sites.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && sl->timer.is_hard)\n\t\tmode |= HRTIMER_MODE_HARD;\n\n\thrtimer_start_expires(&sl->timer, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires_range_ns",
          "args": [
            "&t.timer",
            "*expires",
            "delta"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_sleeper_on_stack",
          "args": [
            "&t",
            "clock_id",
            "mode"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "442-447",
          "snippet": "void hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(&sl->timer, &hrtimer_debug_descr);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(&sl->timer, &hrtimer_debug_descr);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched\nschedule_hrtimeout_range_clock(ktime_t *expires, u64 delta,\n\t\t\t       const enum hrtimer_mode mode, clockid_t clock_id)\n{\n\tstruct hrtimer_sleeper t;\n\n\t/*\n\t * Optimize when a zero timeout value is given. It does not\n\t * matter whether this is an absolute or a relative time.\n\t */\n\tif (expires && *expires == 0) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * A NULL parameter means \"infinite\"\n\t */\n\tif (!expires) {\n\t\tschedule();\n\t\treturn -EINTR;\n\t}\n\n\thrtimer_init_sleeper_on_stack(&t, clock_id, mode);\n\thrtimer_set_expires_range_ns(&t.timer, *expires, delta);\n\thrtimer_sleeper_start_expires(&t, mode);\n\n\tif (likely(t.task))\n\t\tschedule();\n\n\thrtimer_cancel(&t.timer);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn !t.task ? 0 : -EINTR;\n}"
  },
  {
    "function_name": "hrtimers_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2264-2268",
    "snippet": "void __init hrtimers_init(void)\n{\n\thrtimers_prepare_cpu(smp_processor_id());\n\topen_softirq(HRTIMER_SOFTIRQ, hrtimer_run_softirq);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "open_softirq",
          "args": [
            "HRTIMER_SOFTIRQ",
            "hrtimer_run_softirq"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "open_softirq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "703-706",
          "snippet": "void open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct softirq_action softirq_vec[NR_SOFTIRQS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic struct softirq_action softirq_vec[NR_SOFTIRQS];\n\nvoid open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimers_prepare_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimers_prepare_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2160-2183",
          "snippet": "int hrtimers_prepare_cpu(unsigned int cpu)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tstruct hrtimer_clock_base *clock_b = &cpu_base->clock_base[i];\n\n\t\tclock_b->cpu_base = cpu_base;\n\t\tseqcount_raw_spinlock_init(&clock_b->seq, &cpu_base->lock);\n\t\ttimerqueue_init_head(&clock_b->active);\n\t}\n\n\tcpu_base->cpu = cpu;\n\tcpu_base->active_bases = 0;\n\tcpu_base->hres_active = 0;\n\tcpu_base->hang_detected = 0;\n\tcpu_base->next_timer = NULL;\n\tcpu_base->softirq_next_timer = NULL;\n\tcpu_base->expires_next = KTIME_MAX;\n\tcpu_base->softirq_expires_next = KTIME_MAX;\n\thrtimer_cpu_base_init_expiry_lock(cpu_base);\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nint hrtimers_prepare_cpu(unsigned int cpu)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tstruct hrtimer_clock_base *clock_b = &cpu_base->clock_base[i];\n\n\t\tclock_b->cpu_base = cpu_base;\n\t\tseqcount_raw_spinlock_init(&clock_b->seq, &cpu_base->lock);\n\t\ttimerqueue_init_head(&clock_b->active);\n\t}\n\n\tcpu_base->cpu = cpu;\n\tcpu_base->active_bases = 0;\n\tcpu_base->hres_active = 0;\n\tcpu_base->hang_detected = 0;\n\tcpu_base->next_timer = NULL;\n\tcpu_base->softirq_next_timer = NULL;\n\tcpu_base->expires_next = KTIME_MAX;\n\tcpu_base->softirq_expires_next = KTIME_MAX;\n\thrtimer_cpu_base_init_expiry_lock(cpu_base);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid __init hrtimers_init(void)\n{\n\thrtimers_prepare_cpu(smp_processor_id());\n\topen_softirq(HRTIMER_SOFTIRQ, hrtimer_run_softirq);\n}"
  },
  {
    "function_name": "hrtimers_dead_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2217-2260",
    "snippet": "int hrtimers_dead_cpu(unsigned int scpu)\n{\n\tstruct hrtimer_cpu_base *old_base, *new_base;\n\tint i;\n\n\tBUG_ON(cpu_online(scpu));\n\ttick_cancel_sched_timer(scpu);\n\n\t/*\n\t * this BH disable ensures that raise_softirq_irqoff() does\n\t * not wakeup ksoftirqd (and acquire the pi-lock) while\n\t * holding the cpu_base lock\n\t */\n\tlocal_bh_disable();\n\tlocal_irq_disable();\n\told_base = &per_cpu(hrtimer_bases, scpu);\n\tnew_base = this_cpu_ptr(&hrtimer_bases);\n\t/*\n\t * The caller is globally serialized and nobody else\n\t * takes two locks at once, deadlock is not possible.\n\t */\n\traw_spin_lock(&new_base->lock);\n\traw_spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tmigrate_hrtimer_list(&old_base->clock_base[i],\n\t\t\t\t     &new_base->clock_base[i]);\n\t}\n\n\t/*\n\t * The migration might have changed the first expiring softirq\n\t * timer on this CPU. Update it.\n\t */\n\thrtimer_update_softirq_timer(new_base, false);\n\n\traw_spin_unlock(&old_base->lock);\n\traw_spin_unlock(&new_base->lock);\n\n\t/* Check, if we got expired work to do */\n\t__hrtimer_peek_ahead_timers();\n\tlocal_irq_enable();\n\tlocal_bh_enable();\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "353-357",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hrtimer_peek_ahead_timers",
          "args": [],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_peek_ahead_timers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1887-1887",
          "snippet": "static inline void __hrtimer_peek_ahead_timers(void) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void __hrtimer_peek_ahead_timers(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&new_base->lock"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_softirq_timer",
          "args": [
            "new_base",
            "false"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_softirq_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1187-1210",
          "snippet": "static void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nstatic void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_hrtimer_list",
          "args": [
            "&old_base->clock_base[i]",
            "&new_base->clock_base[i]"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_hrtimer_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2187-2215",
          "snippet": "static void migrate_hrtimer_list(struct hrtimer_clock_base *old_base,\n\t\t\t\tstruct hrtimer_clock_base *new_base)\n{\n\tstruct hrtimer *timer;\n\tstruct timerqueue_node *node;\n\n\twhile ((node = timerqueue_getnext(&old_base->active))) {\n\t\ttimer = container_of(node, struct hrtimer, node);\n\t\tBUG_ON(hrtimer_callback_running(timer));\n\t\tdebug_deactivate(timer);\n\n\t\t/*\n\t\t * Mark it as ENQUEUED not INACTIVE otherwise the\n\t\t * timer could be seen as !active and just vanish away\n\t\t * under us on another CPU\n\t\t */\n\t\t__remove_hrtimer(timer, old_base, HRTIMER_STATE_ENQUEUED, 0);\n\t\ttimer->base = new_base;\n\t\t/*\n\t\t * Enqueue the timers on the new cpu. This does not\n\t\t * reprogram the event device in case the timer\n\t\t * expires before the earliest on this CPU, but we run\n\t\t * hrtimer_interrupt after we migrated everything to\n\t\t * sort out already expired timers and reprogram the\n\t\t * event device.\n\t\t */\n\t\tenqueue_hrtimer(timer, new_base, HRTIMER_MODE_ABS);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void migrate_hrtimer_list(struct hrtimer_clock_base *old_base,\n\t\t\t\tstruct hrtimer_clock_base *new_base)\n{\n\tstruct hrtimer *timer;\n\tstruct timerqueue_node *node;\n\n\twhile ((node = timerqueue_getnext(&old_base->active))) {\n\t\ttimer = container_of(node, struct hrtimer, node);\n\t\tBUG_ON(hrtimer_callback_running(timer));\n\t\tdebug_deactivate(timer);\n\n\t\t/*\n\t\t * Mark it as ENQUEUED not INACTIVE otherwise the\n\t\t * timer could be seen as !active and just vanish away\n\t\t * under us on another CPU\n\t\t */\n\t\t__remove_hrtimer(timer, old_base, HRTIMER_STATE_ENQUEUED, 0);\n\t\ttimer->base = new_base;\n\t\t/*\n\t\t * Enqueue the timers on the new cpu. This does not\n\t\t * reprogram the event device in case the timer\n\t\t * expires before the earliest on this CPU, but we run\n\t\t * hrtimer_interrupt after we migrated everything to\n\t\t * sort out already expired timers and reprogram the\n\t\t * event device.\n\t\t */\n\t\tenqueue_hrtimer(timer, new_base, HRTIMER_MODE_ABS);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_nested",
          "args": [
            "&old_base->lock",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "375-380",
          "snippet": "void __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)\n{\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)\n{\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&new_base->lock"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "hrtimer_bases",
            "scpu"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_cancel_sched_timer",
          "args": [
            "scpu"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "tick_cancel_sched_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.h",
          "lines": "88-88",
          "snippet": "static inline void tick_cancel_sched_timer(int cpu) { }",
          "includes": [
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n\nstatic inline void tick_cancel_sched_timer(int cpu) { }"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpu_online(scpu)"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "scpu"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nint hrtimers_dead_cpu(unsigned int scpu)\n{\n\tstruct hrtimer_cpu_base *old_base, *new_base;\n\tint i;\n\n\tBUG_ON(cpu_online(scpu));\n\ttick_cancel_sched_timer(scpu);\n\n\t/*\n\t * this BH disable ensures that raise_softirq_irqoff() does\n\t * not wakeup ksoftirqd (and acquire the pi-lock) while\n\t * holding the cpu_base lock\n\t */\n\tlocal_bh_disable();\n\tlocal_irq_disable();\n\told_base = &per_cpu(hrtimer_bases, scpu);\n\tnew_base = this_cpu_ptr(&hrtimer_bases);\n\t/*\n\t * The caller is globally serialized and nobody else\n\t * takes two locks at once, deadlock is not possible.\n\t */\n\traw_spin_lock(&new_base->lock);\n\traw_spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tmigrate_hrtimer_list(&old_base->clock_base[i],\n\t\t\t\t     &new_base->clock_base[i]);\n\t}\n\n\t/*\n\t * The migration might have changed the first expiring softirq\n\t * timer on this CPU. Update it.\n\t */\n\thrtimer_update_softirq_timer(new_base, false);\n\n\traw_spin_unlock(&old_base->lock);\n\traw_spin_unlock(&new_base->lock);\n\n\t/* Check, if we got expired work to do */\n\t__hrtimer_peek_ahead_timers();\n\tlocal_irq_enable();\n\tlocal_bh_enable();\n\treturn 0;\n}"
  },
  {
    "function_name": "migrate_hrtimer_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2187-2215",
    "snippet": "static void migrate_hrtimer_list(struct hrtimer_clock_base *old_base,\n\t\t\t\tstruct hrtimer_clock_base *new_base)\n{\n\tstruct hrtimer *timer;\n\tstruct timerqueue_node *node;\n\n\twhile ((node = timerqueue_getnext(&old_base->active))) {\n\t\ttimer = container_of(node, struct hrtimer, node);\n\t\tBUG_ON(hrtimer_callback_running(timer));\n\t\tdebug_deactivate(timer);\n\n\t\t/*\n\t\t * Mark it as ENQUEUED not INACTIVE otherwise the\n\t\t * timer could be seen as !active and just vanish away\n\t\t * under us on another CPU\n\t\t */\n\t\t__remove_hrtimer(timer, old_base, HRTIMER_STATE_ENQUEUED, 0);\n\t\ttimer->base = new_base;\n\t\t/*\n\t\t * Enqueue the timers on the new cpu. This does not\n\t\t * reprogram the event device in case the timer\n\t\t * expires before the earliest on this CPU, but we run\n\t\t * hrtimer_interrupt after we migrated everything to\n\t\t * sort out already expired timers and reprogram the\n\t\t * event device.\n\t\t */\n\t\tenqueue_hrtimer(timer, new_base, HRTIMER_MODE_ABS);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enqueue_hrtimer",
          "args": [
            "timer",
            "new_base",
            "HRTIMER_MODE_ABS"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_hrtimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1080-1092",
          "snippet": "static int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, HRTIMER_STATE_ENQUEUED);\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, HRTIMER_STATE_ENQUEUED);\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_hrtimer",
          "args": [
            "timer",
            "old_base",
            "HRTIMER_STATE_ENQUEUED",
            "0"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_hrtimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1104-1129",
          "snippet": "static void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, newstate);\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superfluous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, newstate);\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superfluous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_deactivate",
          "args": [
            "timer"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "debug_deactivate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "479-483",
          "snippet": "static inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "hrtimer_callback_running(timer)"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_callback_running",
          "args": [
            "timer"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structhrtimer",
            "node"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "&old_base->active"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void migrate_hrtimer_list(struct hrtimer_clock_base *old_base,\n\t\t\t\tstruct hrtimer_clock_base *new_base)\n{\n\tstruct hrtimer *timer;\n\tstruct timerqueue_node *node;\n\n\twhile ((node = timerqueue_getnext(&old_base->active))) {\n\t\ttimer = container_of(node, struct hrtimer, node);\n\t\tBUG_ON(hrtimer_callback_running(timer));\n\t\tdebug_deactivate(timer);\n\n\t\t/*\n\t\t * Mark it as ENQUEUED not INACTIVE otherwise the\n\t\t * timer could be seen as !active and just vanish away\n\t\t * under us on another CPU\n\t\t */\n\t\t__remove_hrtimer(timer, old_base, HRTIMER_STATE_ENQUEUED, 0);\n\t\ttimer->base = new_base;\n\t\t/*\n\t\t * Enqueue the timers on the new cpu. This does not\n\t\t * reprogram the event device in case the timer\n\t\t * expires before the earliest on this CPU, but we run\n\t\t * hrtimer_interrupt after we migrated everything to\n\t\t * sort out already expired timers and reprogram the\n\t\t * event device.\n\t\t */\n\t\tenqueue_hrtimer(timer, new_base, HRTIMER_MODE_ABS);\n\t}\n}"
  },
  {
    "function_name": "hrtimers_prepare_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2160-2183",
    "snippet": "int hrtimers_prepare_cpu(unsigned int cpu)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tstruct hrtimer_clock_base *clock_b = &cpu_base->clock_base[i];\n\n\t\tclock_b->cpu_base = cpu_base;\n\t\tseqcount_raw_spinlock_init(&clock_b->seq, &cpu_base->lock);\n\t\ttimerqueue_init_head(&clock_b->active);\n\t}\n\n\tcpu_base->cpu = cpu;\n\tcpu_base->active_bases = 0;\n\tcpu_base->hres_active = 0;\n\tcpu_base->hang_detected = 0;\n\tcpu_base->next_timer = NULL;\n\tcpu_base->softirq_next_timer = NULL;\n\tcpu_base->expires_next = KTIME_MAX;\n\tcpu_base->softirq_expires_next = KTIME_MAX;\n\thrtimer_cpu_base_init_expiry_lock(cpu_base);\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_cpu_base_init_expiry_lock",
          "args": [
            "cpu_base"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cpu_base_init_expiry_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1420-1421",
          "snippet": "static inline void\nhrtimer_cpu_base_init_expiry_lock(struct hrtimer_cpu_base *base) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void\nhrtimer_cpu_base_init_expiry_lock(struct hrtimer_cpu_base *base) { }"
        }
      },
      {
        "call_info": {
          "callee": "timerqueue_init_head",
          "args": [
            "&clock_b->active"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seqcount_raw_spinlock_init",
          "args": [
            "&clock_b->seq",
            "&cpu_base->lock"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "hrtimer_bases",
            "cpu"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nint hrtimers_prepare_cpu(unsigned int cpu)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tstruct hrtimer_clock_base *clock_b = &cpu_base->clock_base[i];\n\n\t\tclock_b->cpu_base = cpu_base;\n\t\tseqcount_raw_spinlock_init(&clock_b->seq, &cpu_base->lock);\n\t\ttimerqueue_init_head(&clock_b->active);\n\t}\n\n\tcpu_base->cpu = cpu;\n\tcpu_base->active_bases = 0;\n\tcpu_base->hres_active = 0;\n\tcpu_base->hang_detected = 0;\n\tcpu_base->next_timer = NULL;\n\tcpu_base->softirq_next_timer = NULL;\n\tcpu_base->expires_next = KTIME_MAX;\n\tcpu_base->softirq_expires_next = KTIME_MAX;\n\thrtimer_cpu_base_init_expiry_lock(cpu_base);\n\treturn 0;\n}"
  },
  {
    "function_name": "hrtimer_nanosleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2083-2114",
    "snippet": "long hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,\n\t\t       const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tu64 slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_sleeper_on_stack(&t, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, rqtp, slack);\n\tret = do_nanosleep(&t, mode);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\tgoto out;\n\n\t/* Absolute timers do not update the rmtp value and restart: */\n\tif (mode == HRTIMER_MODE_ABS) {\n\t\tret = -ERESTARTNOHAND;\n\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\n\tset_restart_fn(restart, hrtimer_nanosleep_restart);\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hrtimer_on_stack",
          "args": [
            "&t.timer"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hrtimer_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "450-453",
          "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_restart_fn",
          "args": [
            "restart",
            "hrtimer_nanosleep_restart"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires_tv64",
          "args": [
            "&t.timer"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_nanosleep",
          "args": [
            "&t",
            "mode"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "do_nanosleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2035-2068",
          "snippet": "static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_sleeper_start_expires(t, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_sleeper_start_expires(t, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires_range_ns",
          "args": [
            "&t.timer",
            "rqtp",
            "slack"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_sleeper_on_stack",
          "args": [
            "&t",
            "clockid",
            "mode"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "442-447",
          "snippet": "void hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(&sl->timer, &hrtimer_debug_descr);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(&sl->timer, &hrtimer_debug_descr);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "current"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_task_sighand_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1417-1428",
          "snippet": "void lockdep_assert_task_sighand_held(struct task_struct *task)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tsighand = rcu_dereference(task->sighand);\n\tif (sighand)\n\t\tlockdep_assert_held(&sighand->siglock);\n\telse\n\t\tWARN_ON_ONCE(1);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid lockdep_assert_task_sighand_held(struct task_struct *task)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tsighand = rcu_dereference(task->sighand);\n\tif (sighand)\n\t\tlockdep_assert_held(&sighand->siglock);\n\telse\n\t\tWARN_ON_ONCE(1);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "current"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nlong hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,\n\t\t       const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tu64 slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_sleeper_on_stack(&t, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, rqtp, slack);\n\tret = do_nanosleep(&t, mode);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\tgoto out;\n\n\t/* Absolute timers do not update the rmtp value and restart: */\n\tif (mode == HRTIMER_MODE_ABS) {\n\t\tret = -ERESTARTNOHAND;\n\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\n\tset_restart_fn(restart, hrtimer_nanosleep_restart);\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}"
  },
  {
    "function_name": "hrtimer_nanosleep_restart",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2070-2081",
    "snippet": "static long __sched hrtimer_nanosleep_restart(struct restart_block *restart)\n{\n\tstruct hrtimer_sleeper t;\n\tint ret;\n\n\thrtimer_init_sleeper_on_stack(&t, restart->nanosleep.clockid,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\thrtimer_set_expires_tv64(&t.timer, restart->nanosleep.expires);\n\tret = do_nanosleep(&t, HRTIMER_MODE_ABS);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hrtimer_on_stack",
          "args": [
            "&t.timer"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hrtimer_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "450-453",
          "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_nanosleep",
          "args": [
            "&t",
            "HRTIMER_MODE_ABS"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "do_nanosleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2035-2068",
          "snippet": "static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_sleeper_start_expires(t, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_sleeper_start_expires(t, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires_tv64",
          "args": [
            "&t.timer",
            "restart->nanosleep.expires"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_sleeper_on_stack",
          "args": [
            "&t",
            "restart->nanosleep.clockid",
            "HRTIMER_MODE_ABS"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "442-447",
          "snippet": "void hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(&sl->timer, &hrtimer_debug_descr);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(&sl->timer, &hrtimer_debug_descr);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic long __sched hrtimer_nanosleep_restart(struct restart_block *restart)\n{\n\tstruct hrtimer_sleeper t;\n\tint ret;\n\n\thrtimer_init_sleeper_on_stack(&t, restart->nanosleep.clockid,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\thrtimer_set_expires_tv64(&t.timer, restart->nanosleep.expires);\n\tret = do_nanosleep(&t, HRTIMER_MODE_ABS);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_nanosleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2035-2068",
    "snippet": "static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_sleeper_start_expires(t, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nanosleep_copyout",
          "args": [
            "restart",
            "&rmt"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "nanosleep_copyout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2016-2033",
          "snippet": "int nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "rem"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_expires_remaining",
          "args": [
            "&t->timer"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&t->timer"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "t->task"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_sleeper_start_expires",
          "args": [
            "t",
            "mode"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_sleeper_start_expires",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1952-1966",
          "snippet": "void hrtimer_sleeper_start_expires(struct hrtimer_sleeper *sl,\n\t\t\t\t   enum hrtimer_mode mode)\n{\n\t/*\n\t * Make the enqueue delivery mode check work on RT. If the sleeper\n\t * was initialized for hard interrupt delivery, force the mode bit.\n\t * This is a special case for hrtimer_sleepers because\n\t * hrtimer_init_sleeper() determines the delivery mode on RT so the\n\t * fiddling with this decision is avoided at the call sites.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && sl->timer.is_hard)\n\t\tmode |= HRTIMER_MODE_HARD;\n\n\thrtimer_start_expires(&sl->timer, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_sleeper_start_expires(struct hrtimer_sleeper *sl,\n\t\t\t\t   enum hrtimer_mode mode)\n{\n\t/*\n\t * Make the enqueue delivery mode check work on RT. If the sleeper\n\t * was initialized for hard interrupt delivery, force the mode bit.\n\t * This is a special case for hrtimer_sleepers because\n\t * hrtimer_init_sleeper() determines the delivery mode on RT so the\n\t * fiddling with this decision is avoided at the call sites.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && sl->timer.is_hard)\n\t\tmode |= HRTIMER_MODE_HARD;\n\n\thrtimer_start_expires(&sl->timer, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\tstruct restart_block *restart;\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\thrtimer_sleeper_start_expires(t, mode);\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = HRTIMER_MODE_ABS;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!t->task)\n\t\treturn 0;\n\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tktime_t rem = hrtimer_expires_remaining(&t->timer);\n\t\tstruct timespec64 rmt;\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
  },
  {
    "function_name": "nanosleep_copyout",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2016-2033",
    "snippet": "int nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_timespec64",
          "args": [
            "ts",
            "restart->nanosleep.rmtp"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "put_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "804-813",
          "snippet": "int put_timespec64(const struct timespec64 *ts,\n\t\t   struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts = {\n\t\t.tv_sec = ts->tv_sec,\n\t\t.tv_nsec = ts->tv_nsec\n\t};\n\n\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint put_timespec64(const struct timespec64 *ts,\n\t\t   struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts = {\n\t\t.tv_sec = ts->tv_sec,\n\t\t.tv_nsec = ts->tv_nsec\n\t};\n\n\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_old_timespec32",
          "args": [
            "ts",
            "restart->nanosleep.compat_rmtp"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "put_old_timespec32",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "851-857",
          "snippet": "int put_old_timespec32(const struct timespec64 *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __put_old_timespec32(ts, uts);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint put_old_timespec32(const struct timespec64 *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __put_old_timespec32(ts, uts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
  },
  {
    "function_name": "hrtimer_init_sleeper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2007-2013",
    "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_init_sleeper",
          "args": [
            "sl",
            "clock_id",
            "mode"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1969-1999",
          "snippet": "static void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context either for latency reasons or because the\n\t * hrtimer callback takes regular spinlocks or invokes other\n\t * functions which are not suitable for hard interrupt context on\n\t * PREEMPT_RT.\n\t *\n\t * The hrtimer_sleeper callback is RT compatible in hard interrupt\n\t * context, but there is a latency concern: Untrusted userspace can\n\t * spawn many threads which arm timers for the same expiry time on\n\t * the same CPU. That causes a latency spike due to the wakeup of\n\t * a gazillion threads.\n\t *\n\t * OTOH, privileged real-time user space applications rely on the\n\t * low latency of hard interrupt wakeups. If the current task is in\n\t * a real-time scheduling class, mark the mode for hard interrupt\n\t * expiry.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tif (task_is_realtime(current) && !(mode & HRTIMER_MODE_SOFT))\n\t\t\tmode |= HRTIMER_MODE_HARD;\n\t}\n\n\t__hrtimer_init(&sl->timer, clock_id, mode);\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = current;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context either for latency reasons or because the\n\t * hrtimer callback takes regular spinlocks or invokes other\n\t * functions which are not suitable for hard interrupt context on\n\t * PREEMPT_RT.\n\t *\n\t * The hrtimer_sleeper callback is RT compatible in hard interrupt\n\t * context, but there is a latency concern: Untrusted userspace can\n\t * spawn many threads which arm timers for the same expiry time on\n\t * the same CPU. That causes a latency spike due to the wakeup of\n\t * a gazillion threads.\n\t *\n\t * OTOH, privileged real-time user space applications rely on the\n\t * low latency of hard interrupt wakeups. If the current task is in\n\t * a real-time scheduling class, mark the mode for hard interrupt\n\t * expiry.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tif (task_is_realtime(current) && !(mode & HRTIMER_MODE_SOFT))\n\t\t\tmode |= HRTIMER_MODE_HARD;\n\t}\n\n\t__hrtimer_init(&sl->timer, clock_id, mode);\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_init",
          "args": [
            "&sl->timer",
            "clock_id",
            "mode"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "debug_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "464-470",
          "snippet": "static inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
  },
  {
    "function_name": "__hrtimer_init_sleeper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1969-1999",
    "snippet": "static void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context either for latency reasons or because the\n\t * hrtimer callback takes regular spinlocks or invokes other\n\t * functions which are not suitable for hard interrupt context on\n\t * PREEMPT_RT.\n\t *\n\t * The hrtimer_sleeper callback is RT compatible in hard interrupt\n\t * context, but there is a latency concern: Untrusted userspace can\n\t * spawn many threads which arm timers for the same expiry time on\n\t * the same CPU. That causes a latency spike due to the wakeup of\n\t * a gazillion threads.\n\t *\n\t * OTOH, privileged real-time user space applications rely on the\n\t * low latency of hard interrupt wakeups. If the current task is in\n\t * a real-time scheduling class, mark the mode for hard interrupt\n\t * expiry.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tif (task_is_realtime(current) && !(mode & HRTIMER_MODE_SOFT))\n\t\t\tmode |= HRTIMER_MODE_HARD;\n\t}\n\n\t__hrtimer_init(&sl->timer, clock_id, mode);\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = current;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_init",
          "args": [
            "&sl->timer",
            "clock_id",
            "mode"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1969-1999",
          "snippet": "static void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context either for latency reasons or because the\n\t * hrtimer callback takes regular spinlocks or invokes other\n\t * functions which are not suitable for hard interrupt context on\n\t * PREEMPT_RT.\n\t *\n\t * The hrtimer_sleeper callback is RT compatible in hard interrupt\n\t * context, but there is a latency concern: Untrusted userspace can\n\t * spawn many threads which arm timers for the same expiry time on\n\t * the same CPU. That causes a latency spike due to the wakeup of\n\t * a gazillion threads.\n\t *\n\t * OTOH, privileged real-time user space applications rely on the\n\t * low latency of hard interrupt wakeups. If the current task is in\n\t * a real-time scheduling class, mark the mode for hard interrupt\n\t * expiry.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tif (task_is_realtime(current) && !(mode & HRTIMER_MODE_SOFT))\n\t\t\tmode |= HRTIMER_MODE_HARD;\n\t}\n\n\t__hrtimer_init(&sl->timer, clock_id, mode);\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = current;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "task_is_realtime",
          "args": [
            "current"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context either for latency reasons or because the\n\t * hrtimer callback takes regular spinlocks or invokes other\n\t * functions which are not suitable for hard interrupt context on\n\t * PREEMPT_RT.\n\t *\n\t * The hrtimer_sleeper callback is RT compatible in hard interrupt\n\t * context, but there is a latency concern: Untrusted userspace can\n\t * spawn many threads which arm timers for the same expiry time on\n\t * the same CPU. That causes a latency spike due to the wakeup of\n\t * a gazillion threads.\n\t *\n\t * OTOH, privileged real-time user space applications rely on the\n\t * low latency of hard interrupt wakeups. If the current task is in\n\t * a real-time scheduling class, mark the mode for hard interrupt\n\t * expiry.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tif (task_is_realtime(current) && !(mode & HRTIMER_MODE_SOFT))\n\t\t\tmode |= HRTIMER_MODE_HARD;\n\t}\n\n\t__hrtimer_init(&sl->timer, clock_id, mode);\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = current;\n}"
  },
  {
    "function_name": "hrtimer_sleeper_start_expires",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1952-1966",
    "snippet": "void hrtimer_sleeper_start_expires(struct hrtimer_sleeper *sl,\n\t\t\t\t   enum hrtimer_mode mode)\n{\n\t/*\n\t * Make the enqueue delivery mode check work on RT. If the sleeper\n\t * was initialized for hard interrupt delivery, force the mode bit.\n\t * This is a special case for hrtimer_sleepers because\n\t * hrtimer_init_sleeper() determines the delivery mode on RT so the\n\t * fiddling with this decision is avoided at the call sites.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && sl->timer.is_hard)\n\t\tmode |= HRTIMER_MODE_HARD;\n\n\thrtimer_start_expires(&sl->timer, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "&sl->timer",
            "mode"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_sleeper_start_expires(struct hrtimer_sleeper *sl,\n\t\t\t\t   enum hrtimer_mode mode)\n{\n\t/*\n\t * Make the enqueue delivery mode check work on RT. If the sleeper\n\t * was initialized for hard interrupt delivery, force the mode bit.\n\t * This is a special case for hrtimer_sleepers because\n\t * hrtimer_init_sleeper() determines the delivery mode on RT so the\n\t * fiddling with this decision is avoided at the call sites.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && sl->timer.is_hard)\n\t\tmode |= HRTIMER_MODE_HARD;\n\n\thrtimer_start_expires(&sl->timer, mode);\n}"
  },
  {
    "function_name": "hrtimer_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1931-1942",
    "snippet": "static enum hrtimer_restart hrtimer_wakeup(struct hrtimer *timer)\n{\n\tstruct hrtimer_sleeper *t =\n\t\tcontainer_of(timer, struct hrtimer_sleeper, timer);\n\tstruct task_struct *task = t->task;\n\n\tt->task = NULL;\n\tif (task)\n\t\twake_up_process(task);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "task"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structhrtimer_sleeper",
            "timer"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic enum hrtimer_restart hrtimer_wakeup(struct hrtimer *timer)\n{\n\tstruct hrtimer_sleeper *t =\n\t\tcontainer_of(timer, struct hrtimer_sleeper, timer);\n\tstruct task_struct *task = t->task;\n\n\tt->task = NULL;\n\tif (task)\n\t\twake_up_process(task);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "hrtimer_run_queues",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1894-1926",
    "snippet": "void hrtimer_run_queues(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tunsigned long flags;\n\tktime_t now;\n\n\tif (__hrtimer_hres_active(cpu_base))\n\t\treturn;\n\n\t/*\n\t * This _is_ ugly: We have to check periodically, whether we\n\t * can switch to highres and / or nohz mode. The clocksource\n\t * switch happens with xtime_lock held. Notification from\n\t * there only sets the check bit in the tick_oneshot code,\n\t * otherwise we might deadlock vs. xtime_lock.\n\t */\n\tif (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) {\n\t\thrtimer_switch_to_hres();\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_run_queues",
          "args": [
            "cpu_base",
            "now",
            "flags",
            "HRTIMER_ACTIVE_HARD"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_run_queues",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1717-1754",
          "snippet": "static void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing query for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t\tif (active_mask == HRTIMER_ACTIVE_SOFT)\n\t\t\t\thrtimer_sync_wait_running(cpu_base, flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nstatic void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing query for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t\tif (active_mask == HRTIMER_ACTIVE_SOFT)\n\t\t\t\thrtimer_sync_wait_running(cpu_base, flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raise_softirq_irqoff",
          "args": [
            "HRTIMER_SOFTIRQ"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "696-701",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "now",
            "cpu_base->softirq_expires_next"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_update_base",
          "args": [
            "cpu_base"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "625-639",
          "snippet": "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_switch_to_hres",
          "args": [],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_switch_to_hres",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "755-755",
          "snippet": "static inline void hrtimer_switch_to_hres(void) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void hrtimer_switch_to_hres(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_oneshot_change",
          "args": [
            "!hrtimer_is_hres_enabled()"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_oneshot_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1525-1543",
          "snippet": "int tick_check_oneshot_change(int allow_nohz)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (!test_and_clear_bit(0, &ts->check_clocks))\n\t\treturn 0;\n\n\tif (ts->nohz_mode != NOHZ_MODE_INACTIVE)\n\t\treturn 0;\n\n\tif (!timekeeping_valid_for_hres() || !tick_is_oneshot_available())\n\t\treturn 0;\n\n\tif (!allow_nohz)\n\t\treturn 1;\n\n\ttick_nohz_switch_to_nohz();\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nint tick_check_oneshot_change(int allow_nohz)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (!test_and_clear_bit(0, &ts->check_clocks))\n\t\treturn 0;\n\n\tif (ts->nohz_mode != NOHZ_MODE_INACTIVE)\n\t\treturn 0;\n\n\tif (!timekeeping_valid_for_hres() || !tick_is_oneshot_available())\n\t\treturn 0;\n\n\tif (!allow_nohz)\n\t\treturn 1;\n\n\ttick_nohz_switch_to_nohz();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_is_hres_enabled",
          "args": [],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_is_hres_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "754-754",
          "snippet": "static inline int hrtimer_is_hres_enabled(void) { return 0; }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int hrtimer_is_hres_enabled(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "cpu_base"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "644-648",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nvoid hrtimer_run_queues(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tunsigned long flags;\n\tktime_t now;\n\n\tif (__hrtimer_hres_active(cpu_base))\n\t\treturn;\n\n\t/*\n\t * This _is_ ugly: We have to check periodically, whether we\n\t * can switch to highres and / or nohz mode. The clocksource\n\t * switch happens with xtime_lock held. Notification from\n\t * there only sets the check bit in the tick_oneshot code,\n\t * otherwise we might deadlock vs. xtime_lock.\n\t */\n\tif (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) {\n\t\thrtimer_switch_to_hres();\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n}"
  },
  {
    "function_name": "__hrtimer_peek_ahead_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1887-1887",
    "snippet": "static inline void __hrtimer_peek_ahead_timers(void) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void __hrtimer_peek_ahead_timers(void) { }"
  },
  {
    "function_name": "__hrtimer_peek_ahead_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1873-1883",
    "snippet": "static inline void __hrtimer_peek_ahead_timers(void)\n{\n\tstruct tick_device *td;\n\n\tif (!hrtimer_hres_active())\n\t\treturn;\n\n\ttd = this_cpu_ptr(&tick_cpu_device);\n\tif (td && td->evtdev)\n\t\thrtimer_interrupt(td->evtdev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_interrupt",
          "args": [
            "td->evtdev"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_interrupt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1781-1870",
          "snippet": "void hrtimer_interrupt(struct clock_event_device *dev)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires_next, now, entry_time, delta;\n\tunsigned long flags;\n\tint retries = 0;\n\n\tBUG_ON(!cpu_base->hres_active);\n\tcpu_base->nr_events++;\n\tdev->next_event = KTIME_MAX;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tentry_time = now = hrtimer_update_base(cpu_base);\nretry:\n\tcpu_base->in_hrtirq = 1;\n\t/*\n\t * We set expires_next to KTIME_MAX here with cpu_base->lock\n\t * held to prevent that a timer is enqueued in our queue via\n\t * the migration code. This does not affect enqueueing of\n\t * timers which run their callback and need to be requeued on\n\t * this CPU.\n\t */\n\tcpu_base->expires_next = KTIME_MAX;\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\n\t/* Reevaluate the clock bases for the [soft] next expiry */\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\t/*\n\t * Store the new expiry value so the migration code can verify\n\t * against it.\n\t */\n\tcpu_base->expires_next = expires_next;\n\tcpu_base->in_hrtirq = 0;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\t/* Reprogramming necessary ? */\n\tif (!tick_program_event(expires_next, 0)) {\n\t\tcpu_base->hang_detected = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * The next timer was already expired due to:\n\t * - tracing\n\t * - long lasting callbacks\n\t * - being scheduled away when running in a VM\n\t *\n\t * We need to prevent that we loop forever in the hrtimer\n\t * interrupt routine. We give it 3 attempts to avoid\n\t * overreacting on some spurious event.\n\t *\n\t * Acquire base lock for updating the offsets and retrieving\n\t * the current time.\n\t */\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\tcpu_base->nr_retries++;\n\tif (++retries < 3)\n\t\tgoto retry;\n\t/*\n\t * Give the system a chance to do something else than looping\n\t * here. We stored the entry time, so we know exactly how long\n\t * we spent here. We schedule the next event this amount of\n\t * time away.\n\t */\n\tcpu_base->nr_hangs++;\n\tcpu_base->hang_detected = 1;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\tdelta = ktime_sub(now, entry_time);\n\tif ((unsigned int)delta > cpu_base->max_hang_time)\n\t\tcpu_base->max_hang_time = (unsigned int) delta;\n\t/*\n\t * Limit it to a sensible value as we enforce a longer\n\t * delay. Give the CPU at least 100ms to catch up.\n\t */\n\tif (delta > 100 * NSEC_PER_MSEC)\n\t\texpires_next = ktime_add_ns(now, 100 * NSEC_PER_MSEC);\n\telse\n\t\texpires_next = ktime_add(now, delta);\n\ttick_program_event(expires_next, 1);\n\tpr_warn_once(\"hrtimer: interrupt took %llu ns\\n\", ktime_to_ns(delta));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nvoid hrtimer_interrupt(struct clock_event_device *dev)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires_next, now, entry_time, delta;\n\tunsigned long flags;\n\tint retries = 0;\n\n\tBUG_ON(!cpu_base->hres_active);\n\tcpu_base->nr_events++;\n\tdev->next_event = KTIME_MAX;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tentry_time = now = hrtimer_update_base(cpu_base);\nretry:\n\tcpu_base->in_hrtirq = 1;\n\t/*\n\t * We set expires_next to KTIME_MAX here with cpu_base->lock\n\t * held to prevent that a timer is enqueued in our queue via\n\t * the migration code. This does not affect enqueueing of\n\t * timers which run their callback and need to be requeued on\n\t * this CPU.\n\t */\n\tcpu_base->expires_next = KTIME_MAX;\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\n\t/* Reevaluate the clock bases for the [soft] next expiry */\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\t/*\n\t * Store the new expiry value so the migration code can verify\n\t * against it.\n\t */\n\tcpu_base->expires_next = expires_next;\n\tcpu_base->in_hrtirq = 0;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\t/* Reprogramming necessary ? */\n\tif (!tick_program_event(expires_next, 0)) {\n\t\tcpu_base->hang_detected = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * The next timer was already expired due to:\n\t * - tracing\n\t * - long lasting callbacks\n\t * - being scheduled away when running in a VM\n\t *\n\t * We need to prevent that we loop forever in the hrtimer\n\t * interrupt routine. We give it 3 attempts to avoid\n\t * overreacting on some spurious event.\n\t *\n\t * Acquire base lock for updating the offsets and retrieving\n\t * the current time.\n\t */\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\tcpu_base->nr_retries++;\n\tif (++retries < 3)\n\t\tgoto retry;\n\t/*\n\t * Give the system a chance to do something else than looping\n\t * here. We stored the entry time, so we know exactly how long\n\t * we spent here. We schedule the next event this amount of\n\t * time away.\n\t */\n\tcpu_base->nr_hangs++;\n\tcpu_base->hang_detected = 1;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\tdelta = ktime_sub(now, entry_time);\n\tif ((unsigned int)delta > cpu_base->max_hang_time)\n\t\tcpu_base->max_hang_time = (unsigned int) delta;\n\t/*\n\t * Limit it to a sensible value as we enforce a longer\n\t * delay. Give the CPU at least 100ms to catch up.\n\t */\n\tif (delta > 100 * NSEC_PER_MSEC)\n\t\texpires_next = ktime_add_ns(now, 100 * NSEC_PER_MSEC);\n\telse\n\t\texpires_next = ktime_add(now, delta);\n\ttick_program_event(expires_next, 1);\n\tpr_warn_once(\"hrtimer: interrupt took %llu ns\\n\", ktime_to_ns(delta));\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_hres_active",
          "args": [],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_hres_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "650-653",
          "snippet": "static inline int hrtimer_hres_active(void)\n{\n\treturn __hrtimer_hres_active(this_cpu_ptr(&hrtimer_bases));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline int hrtimer_hres_active(void)\n{\n\treturn __hrtimer_hres_active(this_cpu_ptr(&hrtimer_bases));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void __hrtimer_peek_ahead_timers(void)\n{\n\tstruct tick_device *td;\n\n\tif (!hrtimer_hres_active())\n\t\treturn;\n\n\ttd = this_cpu_ptr(&tick_cpu_device);\n\tif (td && td->evtdev)\n\t\thrtimer_interrupt(td->evtdev);\n}"
  },
  {
    "function_name": "hrtimer_interrupt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1781-1870",
    "snippet": "void hrtimer_interrupt(struct clock_event_device *dev)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires_next, now, entry_time, delta;\n\tunsigned long flags;\n\tint retries = 0;\n\n\tBUG_ON(!cpu_base->hres_active);\n\tcpu_base->nr_events++;\n\tdev->next_event = KTIME_MAX;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tentry_time = now = hrtimer_update_base(cpu_base);\nretry:\n\tcpu_base->in_hrtirq = 1;\n\t/*\n\t * We set expires_next to KTIME_MAX here with cpu_base->lock\n\t * held to prevent that a timer is enqueued in our queue via\n\t * the migration code. This does not affect enqueueing of\n\t * timers which run their callback and need to be requeued on\n\t * this CPU.\n\t */\n\tcpu_base->expires_next = KTIME_MAX;\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\n\t/* Reevaluate the clock bases for the [soft] next expiry */\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\t/*\n\t * Store the new expiry value so the migration code can verify\n\t * against it.\n\t */\n\tcpu_base->expires_next = expires_next;\n\tcpu_base->in_hrtirq = 0;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\t/* Reprogramming necessary ? */\n\tif (!tick_program_event(expires_next, 0)) {\n\t\tcpu_base->hang_detected = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * The next timer was already expired due to:\n\t * - tracing\n\t * - long lasting callbacks\n\t * - being scheduled away when running in a VM\n\t *\n\t * We need to prevent that we loop forever in the hrtimer\n\t * interrupt routine. We give it 3 attempts to avoid\n\t * overreacting on some spurious event.\n\t *\n\t * Acquire base lock for updating the offsets and retrieving\n\t * the current time.\n\t */\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\tcpu_base->nr_retries++;\n\tif (++retries < 3)\n\t\tgoto retry;\n\t/*\n\t * Give the system a chance to do something else than looping\n\t * here. We stored the entry time, so we know exactly how long\n\t * we spent here. We schedule the next event this amount of\n\t * time away.\n\t */\n\tcpu_base->nr_hangs++;\n\tcpu_base->hang_detected = 1;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\tdelta = ktime_sub(now, entry_time);\n\tif ((unsigned int)delta > cpu_base->max_hang_time)\n\t\tcpu_base->max_hang_time = (unsigned int) delta;\n\t/*\n\t * Limit it to a sensible value as we enforce a longer\n\t * delay. Give the CPU at least 100ms to catch up.\n\t */\n\tif (delta > 100 * NSEC_PER_MSEC)\n\t\texpires_next = ktime_add_ns(now, 100 * NSEC_PER_MSEC);\n\telse\n\t\texpires_next = ktime_add(now, delta);\n\ttick_program_event(expires_next, 1);\n\tpr_warn_once(\"hrtimer: interrupt took %llu ns\\n\", ktime_to_ns(delta));\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"hrtimer: interrupt took %llu ns\\n\"",
            "ktime_to_ns(delta)"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "delta"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "expires_next",
            "1"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "23-45",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "now",
            "delta"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "now",
            "100 * NSEC_PER_MSEC"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "entry_time"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_base",
          "args": [
            "cpu_base"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "625-639",
          "snippet": "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_next_event",
          "args": [
            "cpu_base"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "594-623",
          "snippet": "static ktime_t hrtimer_update_next_event(struct hrtimer_cpu_base *cpu_base)\n{\n\tktime_t expires_next, soft = KTIME_MAX;\n\n\t/*\n\t * If the soft interrupt has already been activated, ignore the\n\t * soft bases. They will be handled in the already raised soft\n\t * interrupt.\n\t */\n\tif (!cpu_base->softirq_activated) {\n\t\tsoft = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\t\t/*\n\t\t * Update the soft expiry time. clock_settime() might have\n\t\t * affected it.\n\t\t */\n\t\tcpu_base->softirq_expires_next = soft;\n\t}\n\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_HARD);\n\t/*\n\t * If a softirq timer is expiring first, update cpu_base->next_timer\n\t * and program the hardware with the soft expiry time.\n\t */\n\tif (expires_next > soft) {\n\t\tcpu_base->next_timer = cpu_base->softirq_next_timer;\n\t\texpires_next = soft;\n\t}\n\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t hrtimer_update_next_event(struct hrtimer_cpu_base *cpu_base)\n{\n\tktime_t expires_next, soft = KTIME_MAX;\n\n\t/*\n\t * If the soft interrupt has already been activated, ignore the\n\t * soft bases. They will be handled in the already raised soft\n\t * interrupt.\n\t */\n\tif (!cpu_base->softirq_activated) {\n\t\tsoft = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\t\t/*\n\t\t * Update the soft expiry time. clock_settime() might have\n\t\t * affected it.\n\t\t */\n\t\tcpu_base->softirq_expires_next = soft;\n\t}\n\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_HARD);\n\t/*\n\t * If a softirq timer is expiring first, update cpu_base->next_timer\n\t * and program the hardware with the soft expiry time.\n\t */\n\tif (expires_next > soft) {\n\t\tcpu_base->next_timer = cpu_base->softirq_next_timer;\n\t\texpires_next = soft;\n\t}\n\n\treturn expires_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_run_queues",
          "args": [
            "cpu_base",
            "now",
            "flags",
            "HRTIMER_ACTIVE_HARD"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_run_queues",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1717-1754",
          "snippet": "static void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing query for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t\tif (active_mask == HRTIMER_ACTIVE_SOFT)\n\t\t\t\thrtimer_sync_wait_running(cpu_base, flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nstatic void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing query for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t\tif (active_mask == HRTIMER_ACTIVE_SOFT)\n\t\t\t\thrtimer_sync_wait_running(cpu_base, flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raise_softirq_irqoff",
          "args": [
            "HRTIMER_SOFTIRQ"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "696-701",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\tlockdep_assert_irqs_disabled();\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "now",
            "cpu_base->softirq_expires_next"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cpu_base->hres_active"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nvoid hrtimer_interrupt(struct clock_event_device *dev)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires_next, now, entry_time, delta;\n\tunsigned long flags;\n\tint retries = 0;\n\n\tBUG_ON(!cpu_base->hres_active);\n\tcpu_base->nr_events++;\n\tdev->next_event = KTIME_MAX;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tentry_time = now = hrtimer_update_base(cpu_base);\nretry:\n\tcpu_base->in_hrtirq = 1;\n\t/*\n\t * We set expires_next to KTIME_MAX here with cpu_base->lock\n\t * held to prevent that a timer is enqueued in our queue via\n\t * the migration code. This does not affect enqueueing of\n\t * timers which run their callback and need to be requeued on\n\t * this CPU.\n\t */\n\tcpu_base->expires_next = KTIME_MAX;\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\n\t/* Reevaluate the clock bases for the [soft] next expiry */\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\t/*\n\t * Store the new expiry value so the migration code can verify\n\t * against it.\n\t */\n\tcpu_base->expires_next = expires_next;\n\tcpu_base->in_hrtirq = 0;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\t/* Reprogramming necessary ? */\n\tif (!tick_program_event(expires_next, 0)) {\n\t\tcpu_base->hang_detected = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * The next timer was already expired due to:\n\t * - tracing\n\t * - long lasting callbacks\n\t * - being scheduled away when running in a VM\n\t *\n\t * We need to prevent that we loop forever in the hrtimer\n\t * interrupt routine. We give it 3 attempts to avoid\n\t * overreacting on some spurious event.\n\t *\n\t * Acquire base lock for updating the offsets and retrieving\n\t * the current time.\n\t */\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\tcpu_base->nr_retries++;\n\tif (++retries < 3)\n\t\tgoto retry;\n\t/*\n\t * Give the system a chance to do something else than looping\n\t * here. We stored the entry time, so we know exactly how long\n\t * we spent here. We schedule the next event this amount of\n\t * time away.\n\t */\n\tcpu_base->nr_hangs++;\n\tcpu_base->hang_detected = 1;\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\tdelta = ktime_sub(now, entry_time);\n\tif ((unsigned int)delta > cpu_base->max_hang_time)\n\t\tcpu_base->max_hang_time = (unsigned int) delta;\n\t/*\n\t * Limit it to a sensible value as we enforce a longer\n\t * delay. Give the CPU at least 100ms to catch up.\n\t */\n\tif (delta > 100 * NSEC_PER_MSEC)\n\t\texpires_next = ktime_add_ns(now, 100 * NSEC_PER_MSEC);\n\telse\n\t\texpires_next = ktime_add(now, delta);\n\ttick_program_event(expires_next, 1);\n\tpr_warn_once(\"hrtimer: interrupt took %llu ns\\n\", ktime_to_ns(delta));\n}"
  },
  {
    "function_name": "hrtimer_run_softirq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1756-1773",
    "snippet": "static __latent_entropy void hrtimer_run_softirq(struct softirq_action *h)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tunsigned long flags;\n\tktime_t now;\n\n\thrtimer_cpu_base_lock_expiry(cpu_base);\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tnow = hrtimer_update_base(cpu_base);\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_SOFT);\n\n\tcpu_base->softirq_activated = 0;\n\thrtimer_update_softirq_timer(cpu_base, true);\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\thrtimer_cpu_base_unlock_expiry(cpu_base);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_cpu_base_unlock_expiry",
          "args": [
            "cpu_base"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cpu_base_unlock_expiry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1424-1425",
          "snippet": "static inline void\nhrtimer_cpu_base_unlock_expiry(struct hrtimer_cpu_base *base) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void\nhrtimer_cpu_base_unlock_expiry(struct hrtimer_cpu_base *base) { }"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_softirq_timer",
          "args": [
            "cpu_base",
            "true"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_softirq_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1187-1210",
          "snippet": "static void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nstatic void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_run_queues",
          "args": [
            "cpu_base",
            "now",
            "flags",
            "HRTIMER_ACTIVE_SOFT"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_run_queues",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1717-1754",
          "snippet": "static void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing query for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t\tif (active_mask == HRTIMER_ACTIVE_SOFT)\n\t\t\t\thrtimer_sync_wait_running(cpu_base, flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nstatic void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing query for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t\tif (active_mask == HRTIMER_ACTIVE_SOFT)\n\t\t\t\thrtimer_sync_wait_running(cpu_base, flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_base",
          "args": [
            "cpu_base"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "625-639",
          "snippet": "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cpu_base_lock_expiry",
          "args": [
            "cpu_base"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cpu_base_lock_expiry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1422-1423",
          "snippet": "static inline void\nhrtimer_cpu_base_lock_expiry(struct hrtimer_cpu_base *base) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void\nhrtimer_cpu_base_lock_expiry(struct hrtimer_cpu_base *base) { }"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic __latent_entropy void hrtimer_run_softirq(struct softirq_action *h)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tunsigned long flags;\n\tktime_t now;\n\n\thrtimer_cpu_base_lock_expiry(cpu_base);\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tnow = hrtimer_update_base(cpu_base);\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_SOFT);\n\n\tcpu_base->softirq_activated = 0;\n\thrtimer_update_softirq_timer(cpu_base, true);\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\thrtimer_cpu_base_unlock_expiry(cpu_base);\n}"
  },
  {
    "function_name": "__hrtimer_run_queues",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1717-1754",
    "snippet": "static void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing query for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t\tif (active_mask == HRTIMER_ACTIVE_SOFT)\n\t\t\t\thrtimer_sync_wait_running(cpu_base, flags);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_sync_wait_running",
          "args": [
            "cpu_base",
            "flags"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_sync_wait_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1426-1427",
          "snippet": "static inline void hrtimer_sync_wait_running(struct hrtimer_cpu_base *base,\n\t\t\t\t\t     unsigned long flags) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void hrtimer_sync_wait_running(struct hrtimer_cpu_base *base,\n\t\t\t\t\t     unsigned long flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "__run_hrtimer",
          "args": [
            "cpu_base",
            "base",
            "timer",
            "&basenow",
            "flags"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "__run_hrtimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1642-1715",
          "snippet": "static void __run_hrtimer(struct hrtimer_cpu_base *cpu_base,\n\t\t\t  struct hrtimer_clock_base *base,\n\t\t\t  struct hrtimer *timer, ktime_t *now,\n\t\t\t  unsigned long flags) __must_hold(&cpu_base->lock)\n{\n\tenum hrtimer_restart (*fn)(struct hrtimer *);\n\tbool expires_in_hardirq;\n\tint restart;\n\n\tlockdep_assert_held(&cpu_base->lock);\n\n\tdebug_deactivate(timer);\n\tbase->running = timer;\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\t__remove_hrtimer(timer, base, HRTIMER_STATE_INACTIVE, 0);\n\tfn = timer->function;\n\n\t/*\n\t * Clear the 'is relative' flag for the TIME_LOW_RES case. If the\n\t * timer is restarted with a period then it becomes an absolute\n\t * timer. If its not restarted it does not matter.\n\t */\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES))\n\t\ttimer->is_rel = false;\n\n\t/*\n\t * The timer is marked as running in the CPU base, so it is\n\t * protected against migration to a different CPU even if the lock\n\t * is dropped.\n\t */\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\ttrace_hrtimer_expire_entry(timer, now);\n\texpires_in_hardirq = lockdep_hrtimer_enter(timer);\n\n\trestart = fn(timer);\n\n\tlockdep_hrtimer_exit(expires_in_hardirq);\n\ttrace_hrtimer_expire_exit(timer);\n\traw_spin_lock_irq(&cpu_base->lock);\n\n\t/*\n\t * Note: We clear the running state after enqueue_hrtimer and\n\t * we do not reprogram the event hardware. Happens either in\n\t * hrtimer_start_range_ns() or in hrtimer_interrupt()\n\t *\n\t * Note: Because we dropped the cpu_base->lock above,\n\t * hrtimer_start_range_ns() can have popped in and enqueued the timer\n\t * for us already.\n\t */\n\tif (restart != HRTIMER_NORESTART &&\n\t    !(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\tenqueue_hrtimer(timer, base, HRTIMER_MODE_ABS);\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running.timer == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\tWARN_ON_ONCE(base->running != timer);\n\tbase->running = NULL;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __run_hrtimer(struct hrtimer_cpu_base *cpu_base,\n\t\t\t  struct hrtimer_clock_base *base,\n\t\t\t  struct hrtimer *timer, ktime_t *now,\n\t\t\t  unsigned long flags) __must_hold(&cpu_base->lock)\n{\n\tenum hrtimer_restart (*fn)(struct hrtimer *);\n\tbool expires_in_hardirq;\n\tint restart;\n\n\tlockdep_assert_held(&cpu_base->lock);\n\n\tdebug_deactivate(timer);\n\tbase->running = timer;\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\t__remove_hrtimer(timer, base, HRTIMER_STATE_INACTIVE, 0);\n\tfn = timer->function;\n\n\t/*\n\t * Clear the 'is relative' flag for the TIME_LOW_RES case. If the\n\t * timer is restarted with a period then it becomes an absolute\n\t * timer. If its not restarted it does not matter.\n\t */\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES))\n\t\ttimer->is_rel = false;\n\n\t/*\n\t * The timer is marked as running in the CPU base, so it is\n\t * protected against migration to a different CPU even if the lock\n\t * is dropped.\n\t */\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\ttrace_hrtimer_expire_entry(timer, now);\n\texpires_in_hardirq = lockdep_hrtimer_enter(timer);\n\n\trestart = fn(timer);\n\n\tlockdep_hrtimer_exit(expires_in_hardirq);\n\ttrace_hrtimer_expire_exit(timer);\n\traw_spin_lock_irq(&cpu_base->lock);\n\n\t/*\n\t * Note: We clear the running state after enqueue_hrtimer and\n\t * we do not reprogram the event hardware. Happens either in\n\t * hrtimer_start_range_ns() or in hrtimer_interrupt()\n\t *\n\t * Note: Because we dropped the cpu_base->lock above,\n\t * hrtimer_start_range_ns() can have popped in and enqueued the timer\n\t * for us already.\n\t */\n\tif (restart != HRTIMER_NORESTART &&\n\t    !(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\tenqueue_hrtimer(timer, base, HRTIMER_MODE_ABS);\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running.timer == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\tWARN_ON_ONCE(base->running != timer);\n\tbase->running = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_get_softexpires_tv64",
          "args": [
            "timer"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structhrtimer",
            "node"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "&base->active"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "now",
            "base->offset"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_active_base",
          "args": [
            "base",
            "cpu_base",
            "active"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nstatic void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,\n\t\t\t\t unsigned long flags, unsigned int active_mask)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int active = cpu_base->active_bases & active_mask;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t/*\n\t\t\t * The immediate goal for using the softexpires is\n\t\t\t * minimizing wakeups, not running timers at the\n\t\t\t * earliest interrupt after their soft expiration.\n\t\t\t * This allows us to avoid using a Priority Search\n\t\t\t * Tree, which can answer a stabbing query for\n\t\t\t * overlapping intervals and instead use the simple\n\t\t\t * BST we already have.\n\t\t\t * We don't add extra wakeups by delaying timers that\n\t\t\t * are right-of a not yet expired timer, because that\n\t\t\t * timer will have to trigger a wakeup anyway.\n\t\t\t */\n\t\t\tif (basenow < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(cpu_base, base, timer, &basenow, flags);\n\t\t\tif (active_mask == HRTIMER_ACTIVE_SOFT)\n\t\t\t\thrtimer_sync_wait_running(cpu_base, flags);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__run_hrtimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1642-1715",
    "snippet": "static void __run_hrtimer(struct hrtimer_cpu_base *cpu_base,\n\t\t\t  struct hrtimer_clock_base *base,\n\t\t\t  struct hrtimer *timer, ktime_t *now,\n\t\t\t  unsigned long flags) __must_hold(&cpu_base->lock)\n{\n\tenum hrtimer_restart (*fn)(struct hrtimer *);\n\tbool expires_in_hardirq;\n\tint restart;\n\n\tlockdep_assert_held(&cpu_base->lock);\n\n\tdebug_deactivate(timer);\n\tbase->running = timer;\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\t__remove_hrtimer(timer, base, HRTIMER_STATE_INACTIVE, 0);\n\tfn = timer->function;\n\n\t/*\n\t * Clear the 'is relative' flag for the TIME_LOW_RES case. If the\n\t * timer is restarted with a period then it becomes an absolute\n\t * timer. If its not restarted it does not matter.\n\t */\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES))\n\t\ttimer->is_rel = false;\n\n\t/*\n\t * The timer is marked as running in the CPU base, so it is\n\t * protected against migration to a different CPU even if the lock\n\t * is dropped.\n\t */\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\ttrace_hrtimer_expire_entry(timer, now);\n\texpires_in_hardirq = lockdep_hrtimer_enter(timer);\n\n\trestart = fn(timer);\n\n\tlockdep_hrtimer_exit(expires_in_hardirq);\n\ttrace_hrtimer_expire_exit(timer);\n\traw_spin_lock_irq(&cpu_base->lock);\n\n\t/*\n\t * Note: We clear the running state after enqueue_hrtimer and\n\t * we do not reprogram the event hardware. Happens either in\n\t * hrtimer_start_range_ns() or in hrtimer_interrupt()\n\t *\n\t * Note: Because we dropped the cpu_base->lock above,\n\t * hrtimer_start_range_ns() can have popped in and enqueued the timer\n\t * for us already.\n\t */\n\tif (restart != HRTIMER_NORESTART &&\n\t    !(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\tenqueue_hrtimer(timer, base, HRTIMER_MODE_ABS);\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running.timer == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\tWARN_ON_ONCE(base->running != timer);\n\tbase->running = NULL;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "base->running != timer"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_barrier",
          "args": [
            "&base->seq"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enqueue_hrtimer",
          "args": [
            "timer",
            "base",
            "HRTIMER_MODE_ABS"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_hrtimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1080-1092",
          "snippet": "static int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, HRTIMER_STATE_ENQUEUED);\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, HRTIMER_STATE_ENQUEUED);\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&cpu_base->lock"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_hrtimer_expire_exit",
          "args": [
            "timer"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_hrtimer_exit",
          "args": [
            "expires_in_hardirq"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "timer"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "366-429",
          "snippet": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\t/*\n\t\t * signal was not sent because of sig_ignor\n\t\t * we will not get a call back to restart it AND\n\t\t * it should be restarted.\n\t\t */\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n\t\t\t/*\n\t\t\t * FIXME: What we really want, is to stop this\n\t\t\t * timer completely and restart it in case the\n\t\t\t * SIG_IGN is removed. This is a non trivial\n\t\t\t * change which involves sighand locking\n\t\t\t * (sigh !), which we don't want to do late in\n\t\t\t * the release cycle.\n\t\t\t *\n\t\t\t * For now we just let timers with an interval\n\t\t\t * less than a jiffie expire every jiffie to\n\t\t\t * avoid softirq starvation in case of SIG_IGN\n\t\t\t * and a very small interval, which would put\n\t\t\t * the timer right back on the softirq pending\n\t\t\t * list. By moving now ahead of time we trick\n\t\t\t * hrtimer_forward() to expire the timer\n\t\t\t * later, while we still maintain the overrun\n\t\t\t * accuracy, but have some inconsistency in\n\t\t\t * the timer_gettime() case. This is at least\n\t\t\t * better than a starved softirq. A more\n\t\t\t * complex fix which solves also another related\n\t\t\t * inconsistency is already in the pipeline.\n\t\t\t */\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += hrtimer_forward(timer, now,\n\t\t\t\t\t\t\t    timr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\t/*\n\t\t * signal was not sent because of sig_ignor\n\t\t * we will not get a call back to restart it AND\n\t\t * it should be restarted.\n\t\t */\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n\t\t\t/*\n\t\t\t * FIXME: What we really want, is to stop this\n\t\t\t * timer completely and restart it in case the\n\t\t\t * SIG_IGN is removed. This is a non trivial\n\t\t\t * change which involves sighand locking\n\t\t\t * (sigh !), which we don't want to do late in\n\t\t\t * the release cycle.\n\t\t\t *\n\t\t\t * For now we just let timers with an interval\n\t\t\t * less than a jiffie expire every jiffie to\n\t\t\t * avoid softirq starvation in case of SIG_IGN\n\t\t\t * and a very small interval, which would put\n\t\t\t * the timer right back on the softirq pending\n\t\t\t * list. By moving now ahead of time we trick\n\t\t\t * hrtimer_forward() to expire the timer\n\t\t\t * later, while we still maintain the overrun\n\t\t\t * accuracy, but have some inconsistency in\n\t\t\t * the timer_gettime() case. This is at least\n\t\t\t * better than a starved softirq. A more\n\t\t\t * complex fix which solves also another related\n\t\t\t * inconsistency is already in the pipeline.\n\t\t\t */\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += hrtimer_forward(timer, now,\n\t\t\t\t\t\t\t    timr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_hrtimer_enter",
          "args": [
            "timer"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hrtimer_expire_entry",
          "args": [
            "timer",
            "now"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TIME_LOW_RES"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_hrtimer",
          "args": [
            "timer",
            "base",
            "HRTIMER_STATE_INACTIVE",
            "0"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_hrtimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1104-1129",
          "snippet": "static void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, newstate);\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superfluous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, newstate);\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superfluous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_barrier",
          "args": [
            "&base->seq"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_deactivate",
          "args": [
            "timer"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "debug_deactivate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "479-483",
          "snippet": "static inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cpu_base->lock"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__must_hold",
          "args": [
            "&cpu_base->lock"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __run_hrtimer(struct hrtimer_cpu_base *cpu_base,\n\t\t\t  struct hrtimer_clock_base *base,\n\t\t\t  struct hrtimer *timer, ktime_t *now,\n\t\t\t  unsigned long flags) __must_hold(&cpu_base->lock)\n{\n\tenum hrtimer_restart (*fn)(struct hrtimer *);\n\tbool expires_in_hardirq;\n\tint restart;\n\n\tlockdep_assert_held(&cpu_base->lock);\n\n\tdebug_deactivate(timer);\n\tbase->running = timer;\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\t__remove_hrtimer(timer, base, HRTIMER_STATE_INACTIVE, 0);\n\tfn = timer->function;\n\n\t/*\n\t * Clear the 'is relative' flag for the TIME_LOW_RES case. If the\n\t * timer is restarted with a period then it becomes an absolute\n\t * timer. If its not restarted it does not matter.\n\t */\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES))\n\t\ttimer->is_rel = false;\n\n\t/*\n\t * The timer is marked as running in the CPU base, so it is\n\t * protected against migration to a different CPU even if the lock\n\t * is dropped.\n\t */\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\ttrace_hrtimer_expire_entry(timer, now);\n\texpires_in_hardirq = lockdep_hrtimer_enter(timer);\n\n\trestart = fn(timer);\n\n\tlockdep_hrtimer_exit(expires_in_hardirq);\n\ttrace_hrtimer_expire_exit(timer);\n\traw_spin_lock_irq(&cpu_base->lock);\n\n\t/*\n\t * Note: We clear the running state after enqueue_hrtimer and\n\t * we do not reprogram the event hardware. Happens either in\n\t * hrtimer_start_range_ns() or in hrtimer_interrupt()\n\t *\n\t * Note: Because we dropped the cpu_base->lock above,\n\t * hrtimer_start_range_ns() can have popped in and enqueued the timer\n\t * for us already.\n\t */\n\tif (restart != HRTIMER_NORESTART &&\n\t    !(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\tenqueue_hrtimer(timer, base, HRTIMER_MODE_ABS);\n\n\t/*\n\t * Separate the ->running assignment from the ->state assignment.\n\t *\n\t * As with a regular write barrier, this ensures the read side in\n\t * hrtimer_active() cannot observe base->running.timer == NULL &&\n\t * timer->state == INACTIVE.\n\t */\n\traw_write_seqcount_barrier(&base->seq);\n\n\tWARN_ON_ONCE(base->running != timer);\n\tbase->running = NULL;\n}"
  },
  {
    "function_name": "hrtimer_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1604-1621",
    "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "timer->base"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&base->seq",
            "seq"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_read_seqcount_begin",
          "args": [
            "&base->seq"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "timer->base"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
  },
  {
    "function_name": "hrtimer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1589-1594",
    "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_init",
          "args": [
            "timer",
            "clock_id",
            "mode"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1969-1999",
          "snippet": "static void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context either for latency reasons or because the\n\t * hrtimer callback takes regular spinlocks or invokes other\n\t * functions which are not suitable for hard interrupt context on\n\t * PREEMPT_RT.\n\t *\n\t * The hrtimer_sleeper callback is RT compatible in hard interrupt\n\t * context, but there is a latency concern: Untrusted userspace can\n\t * spawn many threads which arm timers for the same expiry time on\n\t * the same CPU. That causes a latency spike due to the wakeup of\n\t * a gazillion threads.\n\t *\n\t * OTOH, privileged real-time user space applications rely on the\n\t * low latency of hard interrupt wakeups. If the current task is in\n\t * a real-time scheduling class, mark the mode for hard interrupt\n\t * expiry.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tif (task_is_realtime(current) && !(mode & HRTIMER_MODE_SOFT))\n\t\t\tmode |= HRTIMER_MODE_HARD;\n\t}\n\n\t__hrtimer_init(&sl->timer, clock_id, mode);\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = current;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context either for latency reasons or because the\n\t * hrtimer callback takes regular spinlocks or invokes other\n\t * functions which are not suitable for hard interrupt context on\n\t * PREEMPT_RT.\n\t *\n\t * The hrtimer_sleeper callback is RT compatible in hard interrupt\n\t * context, but there is a latency concern: Untrusted userspace can\n\t * spawn many threads which arm timers for the same expiry time on\n\t * the same CPU. That causes a latency spike due to the wakeup of\n\t * a gazillion threads.\n\t *\n\t * OTOH, privileged real-time user space applications rely on the\n\t * low latency of hard interrupt wakeups. If the current task is in\n\t * a real-time scheduling class, mark the mode for hard interrupt\n\t * expiry.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tif (task_is_realtime(current) && !(mode & HRTIMER_MODE_SOFT))\n\t\t\tmode |= HRTIMER_MODE_HARD;\n\t}\n\n\t__hrtimer_init(&sl->timer, clock_id, mode);\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_init",
          "args": [
            "timer",
            "clock_id",
            "mode"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "debug_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "464-470",
          "snippet": "static inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
  },
  {
    "function_name": "__hrtimer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1541-1575",
    "snippet": "static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tbool softtimer = !!(mode & HRTIMER_MODE_SOFT);\n\tstruct hrtimer_cpu_base *cpu_base;\n\tint base;\n\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context for latency reasons and because the callbacks\n\t * can invoke functions which might sleep on RT, e.g. spin_lock().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(mode & HRTIMER_MODE_HARD))\n\t\tsofttimer = true;\n\n\tmemset(timer, 0, sizeof(struct hrtimer));\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * POSIX magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they needs to become CLOCK_MONOTONIC to\n\t * ensure POSIX compliance.\n\t */\n\tif (clock_id == CLOCK_REALTIME && mode & HRTIMER_MODE_REL)\n\t\tclock_id = CLOCK_MONOTONIC;\n\n\tbase = softtimer ? HRTIMER_MAX_CLOCK_BASES / 2 : 0;\n\tbase += hrtimer_clockid_to_base(clock_id);\n\ttimer->is_soft = softtimer;\n\ttimer->is_hard = !!(mode & HRTIMER_MODE_HARD);\n\ttimer->base = &cpu_base->clock_base[base];\n\ttimerqueue_init(&timer->node);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerqueue_init",
          "args": [
            "&timer->node"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_clockid_to_base",
          "args": [
            "clock_id"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_clockid_to_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1529-1539",
          "snippet": "static inline int hrtimer_clockid_to_base(clockid_t clock_id)\n{\n\tif (likely(clock_id < MAX_CLOCKS)) {\n\t\tint base = hrtimer_clock_to_base_table[clock_id];\n\n\t\tif (likely(base != HRTIMER_MAX_CLOCK_BASES))\n\t\t\treturn base;\n\t}\n\tWARN(1, \"Invalid clockid %d. Using MONOTONIC\\n\", clock_id);\n\treturn HRTIMER_BASE_MONOTONIC;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {\n\t/* Make sure we catch unsupported clockids */\n\t[0 ... MAX_CLOCKS - 1]\t= HRTIMER_MAX_CLOCK_BASES,\n\n\t[CLOCK_REALTIME]\t= HRTIMER_BASE_REALTIME,\n\t[CLOCK_MONOTONIC]\t= HRTIMER_BASE_MONOTONIC,\n\t[CLOCK_BOOTTIME]\t= HRTIMER_BASE_BOOTTIME,\n\t[CLOCK_TAI]\t\t= HRTIMER_BASE_TAI,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {\n\t/* Make sure we catch unsupported clockids */\n\t[0 ... MAX_CLOCKS - 1]\t= HRTIMER_MAX_CLOCK_BASES,\n\n\t[CLOCK_REALTIME]\t= HRTIMER_BASE_REALTIME,\n\t[CLOCK_MONOTONIC]\t= HRTIMER_BASE_MONOTONIC,\n\t[CLOCK_BOOTTIME]\t= HRTIMER_BASE_BOOTTIME,\n\t[CLOCK_TAI]\t\t= HRTIMER_BASE_TAI,\n};\n\nstatic inline int hrtimer_clockid_to_base(clockid_t clock_id)\n{\n\tif (likely(clock_id < MAX_CLOCKS)) {\n\t\tint base = hrtimer_clock_to_base_table[clock_id];\n\n\t\tif (likely(base != HRTIMER_MAX_CLOCK_BASES))\n\t\t\treturn base;\n\t}\n\tWARN(1, \"Invalid clockid %d. Using MONOTONIC\\n\", clock_id);\n\treturn HRTIMER_BASE_MONOTONIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "timer",
            "0",
            "sizeof(struct hrtimer)"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tbool softtimer = !!(mode & HRTIMER_MODE_SOFT);\n\tstruct hrtimer_cpu_base *cpu_base;\n\tint base;\n\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context for latency reasons and because the callbacks\n\t * can invoke functions which might sleep on RT, e.g. spin_lock().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(mode & HRTIMER_MODE_HARD))\n\t\tsofttimer = true;\n\n\tmemset(timer, 0, sizeof(struct hrtimer));\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * POSIX magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they needs to become CLOCK_MONOTONIC to\n\t * ensure POSIX compliance.\n\t */\n\tif (clock_id == CLOCK_REALTIME && mode & HRTIMER_MODE_REL)\n\t\tclock_id = CLOCK_MONOTONIC;\n\n\tbase = softtimer ? HRTIMER_MAX_CLOCK_BASES / 2 : 0;\n\tbase += hrtimer_clockid_to_base(clock_id);\n\ttimer->is_soft = softtimer;\n\ttimer->is_hard = !!(mode & HRTIMER_MODE_HARD);\n\ttimer->base = &cpu_base->clock_base[base];\n\ttimerqueue_init(&timer->node);\n}"
  },
  {
    "function_name": "hrtimer_clockid_to_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1529-1539",
    "snippet": "static inline int hrtimer_clockid_to_base(clockid_t clock_id)\n{\n\tif (likely(clock_id < MAX_CLOCKS)) {\n\t\tint base = hrtimer_clock_to_base_table[clock_id];\n\n\t\tif (likely(base != HRTIMER_MAX_CLOCK_BASES))\n\t\t\treturn base;\n\t}\n\tWARN(1, \"Invalid clockid %d. Using MONOTONIC\\n\", clock_id);\n\treturn HRTIMER_BASE_MONOTONIC;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {\n\t/* Make sure we catch unsupported clockids */\n\t[0 ... MAX_CLOCKS - 1]\t= HRTIMER_MAX_CLOCK_BASES,\n\n\t[CLOCK_REALTIME]\t= HRTIMER_BASE_REALTIME,\n\t[CLOCK_MONOTONIC]\t= HRTIMER_BASE_MONOTONIC,\n\t[CLOCK_BOOTTIME]\t= HRTIMER_BASE_BOOTTIME,\n\t[CLOCK_TAI]\t\t= HRTIMER_BASE_TAI,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Invalid clockid %d. Using MONOTONIC\\n\"",
            "clock_id"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "base != HRTIMER_MAX_CLOCK_BASES"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "clock_id < MAX_CLOCKS"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic const int hrtimer_clock_to_base_table[MAX_CLOCKS] = {\n\t/* Make sure we catch unsupported clockids */\n\t[0 ... MAX_CLOCKS - 1]\t= HRTIMER_MAX_CLOCK_BASES,\n\n\t[CLOCK_REALTIME]\t= HRTIMER_BASE_REALTIME,\n\t[CLOCK_MONOTONIC]\t= HRTIMER_BASE_MONOTONIC,\n\t[CLOCK_BOOTTIME]\t= HRTIMER_BASE_BOOTTIME,\n\t[CLOCK_TAI]\t\t= HRTIMER_BASE_TAI,\n};\n\nstatic inline int hrtimer_clockid_to_base(clockid_t clock_id)\n{\n\tif (likely(clock_id < MAX_CLOCKS)) {\n\t\tint base = hrtimer_clock_to_base_table[clock_id];\n\n\t\tif (likely(base != HRTIMER_MAX_CLOCK_BASES))\n\t\t\treturn base;\n\t}\n\tWARN(1, \"Invalid clockid %d. Using MONOTONIC\\n\", clock_id);\n\treturn HRTIMER_BASE_MONOTONIC;\n}"
  },
  {
    "function_name": "hrtimer_next_event_without",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1502-1526",
    "snippet": "u64 hrtimer_next_event_without(const struct hrtimer *exclude)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (__hrtimer_hres_active(cpu_base)) {\n\t\tunsigned int active;\n\n\t\tif (!cpu_base->softirq_activated) {\n\t\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\t\texpires = __hrtimer_next_event_base(cpu_base, exclude,\n\t\t\t\t\t\t\t    active, KTIME_MAX);\n\t\t}\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\texpires = __hrtimer_next_event_base(cpu_base, exclude, active,\n\t\t\t\t\t\t    expires);\n\t}\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
      "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_next_event_base",
          "args": [
            "cpu_base",
            "exclude",
            "active",
            "expires"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_next_event_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "502-546",
          "snippet": "static ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "cpu_base"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "644-648",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nu64 hrtimer_next_event_without(const struct hrtimer *exclude)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (__hrtimer_hres_active(cpu_base)) {\n\t\tunsigned int active;\n\n\t\tif (!cpu_base->softirq_activated) {\n\t\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\t\texpires = __hrtimer_next_event_base(cpu_base, exclude,\n\t\t\t\t\t\t\t    active, KTIME_MAX);\n\t\t}\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\texpires = __hrtimer_next_event_base(cpu_base, exclude, active,\n\t\t\t\t\t\t    expires);\n\t}\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}"
  },
  {
    "function_name": "hrtimer_get_next_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1479-1493",
    "snippet": "u64 hrtimer_get_next_event(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (!__hrtimer_hres_active(cpu_base))\n\t\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_get_next_event",
          "args": [
            "cpu_base",
            "HRTIMER_ACTIVE_ALL"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_get_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "568-592",
          "snippet": "static ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "cpu_base"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "644-648",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nu64 hrtimer_get_next_event(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (!__hrtimer_hres_active(cpu_base))\n\t\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}"
  },
  {
    "function_name": "__hrtimer_get_remaining",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1457-1470",
    "snippet": "ktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust)\n{\n\tunsigned long flags;\n\tktime_t rem;\n\n\tlock_hrtimer_base(timer, &flags);\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES) && adjust)\n\t\trem = hrtimer_expires_remaining_adjusted(timer);\n\telse\n\t\trem = hrtimer_expires_remaining(timer);\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn rem;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_hrtimer_base",
          "args": [
            "timer",
            "&flags"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_hrtimer_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1014-1018",
          "snippet": "static inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_expires_remaining",
          "args": [
            "timer"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_expires_remaining_adjusted",
          "args": [
            "timer"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TIME_LOW_RES"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust)\n{\n\tunsigned long flags;\n\tktime_t rem;\n\n\tlock_hrtimer_base(timer, &flags);\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES) && adjust)\n\t\trem = hrtimer_expires_remaining_adjusted(timer);\n\telse\n\t\trem = hrtimer_expires_remaining(timer);\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn rem;\n}"
  },
  {
    "function_name": "hrtimer_cancel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1438-1449",
    "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_cancel_wait_running",
          "args": [
            "timer"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel_wait_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1393-1418",
          "snippet": "void hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "timer"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1316-1340",
          "snippet": "int hrtimer_try_to_cancel(struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\t/*\n\t * Check lockless first. If the timer is not active (neither\n\t * enqueued nor running the callback, nothing to do here.  The\n\t * base lock does not serialize against a concurrent enqueue,\n\t * so we can avoid taking it.\n\t */\n\tif (!hrtimer_active(timer))\n\t\treturn 0;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (!hrtimer_callback_running(timer))\n\t\tret = remove_hrtimer(timer, base, false, false);\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_try_to_cancel(struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\t/*\n\t * Check lockless first. If the timer is not active (neither\n\t * enqueued nor running the callback, nothing to do here.  The\n\t * base lock does not serialize against a concurrent enqueue,\n\t * so we can avoid taking it.\n\t */\n\tif (!hrtimer_active(timer))\n\t\treturn 0;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (!hrtimer_callback_running(timer))\n\t\tret = remove_hrtimer(timer, base, false, false);\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "hrtimer_sync_wait_running",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1426-1427",
    "snippet": "static inline void hrtimer_sync_wait_running(struct hrtimer_cpu_base *base,\n\t\t\t\t\t     unsigned long flags) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void hrtimer_sync_wait_running(struct hrtimer_cpu_base *base,\n\t\t\t\t\t     unsigned long flags) { }"
  },
  {
    "function_name": "hrtimer_cpu_base_unlock_expiry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1424-1425",
    "snippet": "static inline void\nhrtimer_cpu_base_unlock_expiry(struct hrtimer_cpu_base *base) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void\nhrtimer_cpu_base_unlock_expiry(struct hrtimer_cpu_base *base) { }"
  },
  {
    "function_name": "hrtimer_cpu_base_lock_expiry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1422-1423",
    "snippet": "static inline void\nhrtimer_cpu_base_lock_expiry(struct hrtimer_cpu_base *base) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void\nhrtimer_cpu_base_lock_expiry(struct hrtimer_cpu_base *base) { }"
  },
  {
    "function_name": "hrtimer_cpu_base_init_expiry_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1420-1421",
    "snippet": "static inline void\nhrtimer_cpu_base_init_expiry_lock(struct hrtimer_cpu_base *base) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void\nhrtimer_cpu_base_init_expiry_lock(struct hrtimer_cpu_base *base) { }"
  },
  {
    "function_name": "hrtimer_cancel_wait_running",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1393-1418",
    "snippet": "void hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&base->cpu_base->softirq_expiry_lock"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&base->cpu_base->timer_waiters"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&base->cpu_base->softirq_expiry_lock"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&base->cpu_base->timer_waiters"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migration_base",
          "args": [
            "base"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "is_migration_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "276-279",
          "snippet": "static inline bool is_migration_base(struct hrtimer_clock_base *base)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline bool is_migration_base(struct hrtimer_clock_base *base)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "timer->base"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}"
  },
  {
    "function_name": "hrtimer_sync_wait_running",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1366-1375",
    "snippet": "static void hrtimer_sync_wait_running(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t      unsigned long flags)\n{\n\tif (atomic_read(&cpu_base->timer_waiters)) {\n\t\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\t\tspin_unlock(&cpu_base->softirq_expiry_lock);\n\t\tspin_lock(&cpu_base->softirq_expiry_lock);\n\t\traw_spin_lock_irq(&cpu_base->lock);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&cpu_base->lock"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cpu_base->softirq_expiry_lock"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cpu_base->softirq_expiry_lock"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cpu_base->timer_waiters"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void hrtimer_sync_wait_running(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t      unsigned long flags)\n{\n\tif (atomic_read(&cpu_base->timer_waiters)) {\n\t\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\t\tspin_unlock(&cpu_base->softirq_expiry_lock);\n\t\tspin_lock(&cpu_base->softirq_expiry_lock);\n\t\traw_spin_lock_irq(&cpu_base->lock);\n\t}\n}"
  },
  {
    "function_name": "hrtimer_cpu_base_unlock_expiry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1354-1357",
    "snippet": "static void hrtimer_cpu_base_unlock_expiry(struct hrtimer_cpu_base *base)\n{\n\tspin_unlock(&base->softirq_expiry_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&base->softirq_expiry_lock"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void hrtimer_cpu_base_unlock_expiry(struct hrtimer_cpu_base *base)\n{\n\tspin_unlock(&base->softirq_expiry_lock);\n}"
  },
  {
    "function_name": "hrtimer_cpu_base_lock_expiry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1349-1352",
    "snippet": "static void hrtimer_cpu_base_lock_expiry(struct hrtimer_cpu_base *base)\n{\n\tspin_lock(&base->softirq_expiry_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&base->softirq_expiry_lock"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void hrtimer_cpu_base_lock_expiry(struct hrtimer_cpu_base *base)\n{\n\tspin_lock(&base->softirq_expiry_lock);\n}"
  },
  {
    "function_name": "hrtimer_cpu_base_init_expiry_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1344-1347",
    "snippet": "static void hrtimer_cpu_base_init_expiry_lock(struct hrtimer_cpu_base *base)\n{\n\tspin_lock_init(&base->softirq_expiry_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&base->softirq_expiry_lock"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void hrtimer_cpu_base_init_expiry_lock(struct hrtimer_cpu_base *base)\n{\n\tspin_lock_init(&base->softirq_expiry_lock);\n}"
  },
  {
    "function_name": "hrtimer_try_to_cancel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1316-1340",
    "snippet": "int hrtimer_try_to_cancel(struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\t/*\n\t * Check lockless first. If the timer is not active (neither\n\t * enqueued nor running the callback, nothing to do here.  The\n\t * base lock does not serialize against a concurrent enqueue,\n\t * so we can avoid taking it.\n\t */\n\tif (!hrtimer_active(timer))\n\t\treturn 0;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (!hrtimer_callback_running(timer))\n\t\tret = remove_hrtimer(timer, base, false, false);\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_hrtimer_base",
          "args": [
            "timer",
            "&flags"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_hrtimer_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1014-1018",
          "snippet": "static inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hrtimer",
          "args": [
            "timer",
            "base",
            "false",
            "false"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hrtimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1134-1169",
          "snippet": "static inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t       bool restart, bool keep_local)\n{\n\tu8 state = timer->state;\n\n\tif (state & HRTIMER_STATE_ENQUEUED) {\n\t\tbool reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\t/*\n\t\t * If the timer is not restarted then reprogramming is\n\t\t * required if the timer is local. If it is local and about\n\t\t * to be restarted, avoid programming it twice (on removal\n\t\t * and a moment later when it's requeued).\n\t\t */\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\t\telse\n\t\t\treprogram &= !keep_local;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t       bool restart, bool keep_local)\n{\n\tu8 state = timer->state;\n\n\tif (state & HRTIMER_STATE_ENQUEUED) {\n\t\tbool reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\t/*\n\t\t * If the timer is not restarted then reprogramming is\n\t\t * required if the timer is local. If it is local and about\n\t\t * to be restarted, avoid programming it twice (on removal\n\t\t * and a moment later when it's requeued).\n\t\t */\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\t\telse\n\t\t\treprogram &= !keep_local;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_callback_running",
          "args": [
            "timer"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_active",
          "args": [
            "timer"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1604-1621",
          "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_try_to_cancel(struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\t/*\n\t * Check lockless first. If the timer is not active (neither\n\t * enqueued nor running the callback, nothing to do here.  The\n\t * base lock does not serialize against a concurrent enqueue,\n\t * so we can avoid taking it.\n\t */\n\tif (!hrtimer_active(timer))\n\t\treturn 0;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (!hrtimer_callback_running(timer))\n\t\tret = remove_hrtimer(timer, base, false, false);\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n\n}"
  },
  {
    "function_name": "hrtimer_start_range_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1280-1302",
    "snippet": "void hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t    u64 delta_ns, const enum hrtimer_mode mode)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\n\t/*\n\t * Check whether the HRTIMER_MODE_SOFT bit and hrtimer.is_soft\n\t * match on CONFIG_PREEMPT_RT = n. With PREEMPT_RT check the hard\n\t * expiry mode because unmarked timers are moved to softirq expiry.\n\t */\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tWARN_ON_ONCE(!(mode & HRTIMER_MODE_SOFT) ^ !timer->is_soft);\n\telse\n\t\tWARN_ON_ONCE(!(mode & HRTIMER_MODE_HARD) ^ !timer->is_hard);\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (__hrtimer_start_range_ns(timer, tim, delta_ns, mode, base))\n\t\thrtimer_reprogram(timer, true);\n\n\tunlock_hrtimer_base(timer, &flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_hrtimer_base",
          "args": [
            "timer",
            "&flags"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_hrtimer_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1014-1018",
          "snippet": "static inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_reprogram",
          "args": [
            "timer",
            "true"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_reprogram",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "808-867",
          "snippet": "static void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will reevaluate the\n\t * clock bases and reprogram the clock event device.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tcpu_base->next_timer = timer;\n\n\t__hrtimer_reprogram(cpu_base, timer, expires);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will reevaluate the\n\t * clock bases and reprogram the clock event device.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tcpu_base->next_timer = timer;\n\n\t__hrtimer_reprogram(cpu_base, timer, expires);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_start_range_ns",
          "args": [
            "timer",
            "tim",
            "delta_ns",
            "mode",
            "base"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_start_range_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1212-1269",
          "snippet": "static int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t    u64 delta_ns, const enum hrtimer_mode mode,\n\t\t\t\t    struct hrtimer_clock_base *base)\n{\n\tstruct hrtimer_clock_base *new_base;\n\tbool force_local, first;\n\n\t/*\n\t * If the timer is on the local cpu base and is the first expiring\n\t * timer then this might end up reprogramming the hardware twice\n\t * (on removal and on enqueue). To avoid that by prevent the\n\t * reprogram on removal, keep the timer local to the current CPU\n\t * and enforce reprogramming after it is queued no matter whether\n\t * it is the new first expiring timer again or not.\n\t */\n\tforce_local = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\tforce_local &= base->cpu_base->next_timer == timer;\n\n\t/*\n\t * Remove an active timer from the queue. In case it is not queued\n\t * on the current CPU, make sure that remove_hrtimer() updates the\n\t * remote data correctly.\n\t *\n\t * If it's on the current CPU and the first expiring timer, then\n\t * skip reprogramming, keep the timer local and enforce\n\t * reprogramming later if it was the first expiring timer.  This\n\t * avoids programming the underlying clock event twice (once at\n\t * removal and once after enqueue).\n\t */\n\tremove_hrtimer(timer, base, true, force_local);\n\n\tif (mode & HRTIMER_MODE_REL)\n\t\ttim = ktime_add_safe(tim, base->get_time());\n\n\ttim = hrtimer_update_lowres(timer, tim, mode);\n\n\thrtimer_set_expires_range_ns(timer, tim, delta_ns);\n\n\t/* Switch the timer base, if necessary: */\n\tif (!force_local) {\n\t\tnew_base = switch_hrtimer_base(timer, base,\n\t\t\t\t\t       mode & HRTIMER_MODE_PINNED);\n\t} else {\n\t\tnew_base = base;\n\t}\n\n\tfirst = enqueue_hrtimer(timer, new_base, mode);\n\tif (!force_local)\n\t\treturn first;\n\n\t/*\n\t * Timer was forced to stay on the current CPU to avoid\n\t * reprogramming on removal and enqueue. Force reprogram the\n\t * hardware by evaluating the new first expiring timer.\n\t */\n\thrtimer_force_reprogram(new_base->cpu_base, 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t    u64 delta_ns, const enum hrtimer_mode mode,\n\t\t\t\t    struct hrtimer_clock_base *base)\n{\n\tstruct hrtimer_clock_base *new_base;\n\tbool force_local, first;\n\n\t/*\n\t * If the timer is on the local cpu base and is the first expiring\n\t * timer then this might end up reprogramming the hardware twice\n\t * (on removal and on enqueue). To avoid that by prevent the\n\t * reprogram on removal, keep the timer local to the current CPU\n\t * and enforce reprogramming after it is queued no matter whether\n\t * it is the new first expiring timer again or not.\n\t */\n\tforce_local = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\tforce_local &= base->cpu_base->next_timer == timer;\n\n\t/*\n\t * Remove an active timer from the queue. In case it is not queued\n\t * on the current CPU, make sure that remove_hrtimer() updates the\n\t * remote data correctly.\n\t *\n\t * If it's on the current CPU and the first expiring timer, then\n\t * skip reprogramming, keep the timer local and enforce\n\t * reprogramming later if it was the first expiring timer.  This\n\t * avoids programming the underlying clock event twice (once at\n\t * removal and once after enqueue).\n\t */\n\tremove_hrtimer(timer, base, true, force_local);\n\n\tif (mode & HRTIMER_MODE_REL)\n\t\ttim = ktime_add_safe(tim, base->get_time());\n\n\ttim = hrtimer_update_lowres(timer, tim, mode);\n\n\thrtimer_set_expires_range_ns(timer, tim, delta_ns);\n\n\t/* Switch the timer base, if necessary: */\n\tif (!force_local) {\n\t\tnew_base = switch_hrtimer_base(timer, base,\n\t\t\t\t\t       mode & HRTIMER_MODE_PINNED);\n\t} else {\n\t\tnew_base = base;\n\t}\n\n\tfirst = enqueue_hrtimer(timer, new_base, mode);\n\tif (!force_local)\n\t\treturn first;\n\n\t/*\n\t * Timer was forced to stay on the current CPU to avoid\n\t * reprogramming on removal and enqueue. Force reprogram the\n\t * hardware by evaluating the new first expiring timer.\n\t */\n\thrtimer_force_reprogram(new_base->cpu_base, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(mode & HRTIMER_MODE_HARD) ^ !timer->is_hard"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(mode & HRTIMER_MODE_SOFT) ^ !timer->is_soft"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t    u64 delta_ns, const enum hrtimer_mode mode)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\n\t/*\n\t * Check whether the HRTIMER_MODE_SOFT bit and hrtimer.is_soft\n\t * match on CONFIG_PREEMPT_RT = n. With PREEMPT_RT check the hard\n\t * expiry mode because unmarked timers are moved to softirq expiry.\n\t */\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tWARN_ON_ONCE(!(mode & HRTIMER_MODE_SOFT) ^ !timer->is_soft);\n\telse\n\t\tWARN_ON_ONCE(!(mode & HRTIMER_MODE_HARD) ^ !timer->is_hard);\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (__hrtimer_start_range_ns(timer, tim, delta_ns, mode, base))\n\t\thrtimer_reprogram(timer, true);\n\n\tunlock_hrtimer_base(timer, &flags);\n}"
  },
  {
    "function_name": "__hrtimer_start_range_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1212-1269",
    "snippet": "static int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t    u64 delta_ns, const enum hrtimer_mode mode,\n\t\t\t\t    struct hrtimer_clock_base *base)\n{\n\tstruct hrtimer_clock_base *new_base;\n\tbool force_local, first;\n\n\t/*\n\t * If the timer is on the local cpu base and is the first expiring\n\t * timer then this might end up reprogramming the hardware twice\n\t * (on removal and on enqueue). To avoid that by prevent the\n\t * reprogram on removal, keep the timer local to the current CPU\n\t * and enforce reprogramming after it is queued no matter whether\n\t * it is the new first expiring timer again or not.\n\t */\n\tforce_local = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\tforce_local &= base->cpu_base->next_timer == timer;\n\n\t/*\n\t * Remove an active timer from the queue. In case it is not queued\n\t * on the current CPU, make sure that remove_hrtimer() updates the\n\t * remote data correctly.\n\t *\n\t * If it's on the current CPU and the first expiring timer, then\n\t * skip reprogramming, keep the timer local and enforce\n\t * reprogramming later if it was the first expiring timer.  This\n\t * avoids programming the underlying clock event twice (once at\n\t * removal and once after enqueue).\n\t */\n\tremove_hrtimer(timer, base, true, force_local);\n\n\tif (mode & HRTIMER_MODE_REL)\n\t\ttim = ktime_add_safe(tim, base->get_time());\n\n\ttim = hrtimer_update_lowres(timer, tim, mode);\n\n\thrtimer_set_expires_range_ns(timer, tim, delta_ns);\n\n\t/* Switch the timer base, if necessary: */\n\tif (!force_local) {\n\t\tnew_base = switch_hrtimer_base(timer, base,\n\t\t\t\t\t       mode & HRTIMER_MODE_PINNED);\n\t} else {\n\t\tnew_base = base;\n\t}\n\n\tfirst = enqueue_hrtimer(timer, new_base, mode);\n\tif (!force_local)\n\t\treturn first;\n\n\t/*\n\t * Timer was forced to stay on the current CPU to avoid\n\t * reprogramming on removal and enqueue. Force reprogram the\n\t * hardware by evaluating the new first expiring timer.\n\t */\n\thrtimer_force_reprogram(new_base->cpu_base, 1);\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_force_reprogram",
          "args": [
            "new_base->cpu_base",
            "1"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_force_reprogram",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "689-700",
          "snippet": "static void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\t__hrtimer_reprogram(cpu_base, cpu_base->next_timer, expires_next);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\t__hrtimer_reprogram(cpu_base, cpu_base->next_timer, expires_next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_hrtimer",
          "args": [
            "timer",
            "new_base",
            "mode"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_hrtimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1080-1092",
          "snippet": "static int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, HRTIMER_STATE_ENQUEUED);\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, HRTIMER_STATE_ENQUEUED);\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "switch_hrtimer_base",
          "args": [
            "timer",
            "base",
            "mode & HRTIMER_MODE_PINNED"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "switch_hrtimer_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "224-272",
          "snippet": "static inline struct hrtimer_clock_base *\nswitch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t\t    int pinned)\n{\n\tstruct hrtimer_cpu_base *new_cpu_base, *this_cpu_base;\n\tstruct hrtimer_clock_base *new_base;\n\tint basenum = base->index;\n\n\tthis_cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tnew_cpu_base = get_target_base(this_cpu_base, pinned);\nagain:\n\tnew_base = &new_cpu_base->clock_base[basenum];\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to move timer to new_base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * so we keep it on the same CPU. No hassle vs. reprogramming\n\t\t * the event source in the high resolution case. The softirq\n\t\t * code will take care of this when the timer function has\n\t\t * completed. There is no conflict as we hold the lock until\n\t\t * the timer is enqueued.\n\t\t */\n\t\tif (unlikely(hrtimer_callback_running(timer)))\n\t\t\treturn base;\n\n\t\t/* See the comment in lock_hrtimer_base() */\n\t\tWRITE_ONCE(timer->base, &migration_base);\n\t\traw_spin_unlock(&base->cpu_base->lock);\n\t\traw_spin_lock(&new_base->cpu_base->lock);\n\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traw_spin_lock(&base->cpu_base->lock);\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tWRITE_ONCE(timer->base, base);\n\t\t\tgoto again;\n\t\t}\n\t\tWRITE_ONCE(timer->base, new_base);\n\t} else {\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn new_base;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define migration_base\tmigration_cpu_base.clock_base[0]"
          ],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define migration_base\tmigration_cpu_base.clock_base[0]\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline struct hrtimer_clock_base *\nswitch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t\t    int pinned)\n{\n\tstruct hrtimer_cpu_base *new_cpu_base, *this_cpu_base;\n\tstruct hrtimer_clock_base *new_base;\n\tint basenum = base->index;\n\n\tthis_cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tnew_cpu_base = get_target_base(this_cpu_base, pinned);\nagain:\n\tnew_base = &new_cpu_base->clock_base[basenum];\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to move timer to new_base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * so we keep it on the same CPU. No hassle vs. reprogramming\n\t\t * the event source in the high resolution case. The softirq\n\t\t * code will take care of this when the timer function has\n\t\t * completed. There is no conflict as we hold the lock until\n\t\t * the timer is enqueued.\n\t\t */\n\t\tif (unlikely(hrtimer_callback_running(timer)))\n\t\t\treturn base;\n\n\t\t/* See the comment in lock_hrtimer_base() */\n\t\tWRITE_ONCE(timer->base, &migration_base);\n\t\traw_spin_unlock(&base->cpu_base->lock);\n\t\traw_spin_lock(&new_base->cpu_base->lock);\n\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traw_spin_lock(&base->cpu_base->lock);\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tWRITE_ONCE(timer->base, base);\n\t\t\tgoto again;\n\t\t}\n\t\tWRITE_ONCE(timer->base, new_base);\n\t} else {\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn new_base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires_range_ns",
          "args": [
            "timer",
            "tim",
            "delta_ns"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_update_lowres",
          "args": [
            "timer",
            "tim",
            "mode"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_lowres",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1171-1185",
          "snippet": "static inline ktime_t hrtimer_update_lowres(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t\t    const enum hrtimer_mode mode)\n{\n#ifdef CONFIG_TIME_LOW_RES\n\t/*\n\t * CONFIG_TIME_LOW_RES indicates that the system has no way to return\n\t * granular time values. For relative timers we add hrtimer_resolution\n\t * (i.e. one jiffie) to prevent short timeouts.\n\t */\n\ttimer->is_rel = mode & HRTIMER_MODE_REL;\n\tif (timer->is_rel)\n\t\ttim = ktime_add_safe(tim, hrtimer_resolution);\n#endif\n\treturn tim;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_lowres(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t\t    const enum hrtimer_mode mode)\n{\n#ifdef CONFIG_TIME_LOW_RES\n\t/*\n\t * CONFIG_TIME_LOW_RES indicates that the system has no way to return\n\t * granular time values. For relative timers we add hrtimer_resolution\n\t * (i.e. one jiffie) to prevent short timeouts.\n\t */\n\ttimer->is_rel = mode & HRTIMER_MODE_REL;\n\tif (timer->is_rel)\n\t\ttim = ktime_add_safe(tim, hrtimer_resolution);\n#endif\n\treturn tim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "tim",
            "base->get_time()"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "base->get_time",
          "args": [],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_hrtimer",
          "args": [
            "timer",
            "base",
            "true",
            "force_local"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hrtimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1134-1169",
          "snippet": "static inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t       bool restart, bool keep_local)\n{\n\tu8 state = timer->state;\n\n\tif (state & HRTIMER_STATE_ENQUEUED) {\n\t\tbool reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\t/*\n\t\t * If the timer is not restarted then reprogramming is\n\t\t * required if the timer is local. If it is local and about\n\t\t * to be restarted, avoid programming it twice (on removal\n\t\t * and a moment later when it's requeued).\n\t\t */\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\t\telse\n\t\t\treprogram &= !keep_local;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t       bool restart, bool keep_local)\n{\n\tu8 state = timer->state;\n\n\tif (state & HRTIMER_STATE_ENQUEUED) {\n\t\tbool reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\t/*\n\t\t * If the timer is not restarted then reprogramming is\n\t\t * required if the timer is local. If it is local and about\n\t\t * to be restarted, avoid programming it twice (on removal\n\t\t * and a moment later when it's requeued).\n\t\t */\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\t\telse\n\t\t\treprogram &= !keep_local;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t    u64 delta_ns, const enum hrtimer_mode mode,\n\t\t\t\t    struct hrtimer_clock_base *base)\n{\n\tstruct hrtimer_clock_base *new_base;\n\tbool force_local, first;\n\n\t/*\n\t * If the timer is on the local cpu base and is the first expiring\n\t * timer then this might end up reprogramming the hardware twice\n\t * (on removal and on enqueue). To avoid that by prevent the\n\t * reprogram on removal, keep the timer local to the current CPU\n\t * and enforce reprogramming after it is queued no matter whether\n\t * it is the new first expiring timer again or not.\n\t */\n\tforce_local = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\tforce_local &= base->cpu_base->next_timer == timer;\n\n\t/*\n\t * Remove an active timer from the queue. In case it is not queued\n\t * on the current CPU, make sure that remove_hrtimer() updates the\n\t * remote data correctly.\n\t *\n\t * If it's on the current CPU and the first expiring timer, then\n\t * skip reprogramming, keep the timer local and enforce\n\t * reprogramming later if it was the first expiring timer.  This\n\t * avoids programming the underlying clock event twice (once at\n\t * removal and once after enqueue).\n\t */\n\tremove_hrtimer(timer, base, true, force_local);\n\n\tif (mode & HRTIMER_MODE_REL)\n\t\ttim = ktime_add_safe(tim, base->get_time());\n\n\ttim = hrtimer_update_lowres(timer, tim, mode);\n\n\thrtimer_set_expires_range_ns(timer, tim, delta_ns);\n\n\t/* Switch the timer base, if necessary: */\n\tif (!force_local) {\n\t\tnew_base = switch_hrtimer_base(timer, base,\n\t\t\t\t\t       mode & HRTIMER_MODE_PINNED);\n\t} else {\n\t\tnew_base = base;\n\t}\n\n\tfirst = enqueue_hrtimer(timer, new_base, mode);\n\tif (!force_local)\n\t\treturn first;\n\n\t/*\n\t * Timer was forced to stay on the current CPU to avoid\n\t * reprogramming on removal and enqueue. Force reprogram the\n\t * hardware by evaluating the new first expiring timer.\n\t */\n\thrtimer_force_reprogram(new_base->cpu_base, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "hrtimer_update_softirq_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1187-1210",
    "snippet": "static void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_reprogram",
          "args": [
            "cpu_base->softirq_next_timer",
            "reprogram"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_reprogram",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "808-867",
          "snippet": "static void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will reevaluate the\n\t * clock bases and reprogram the clock event device.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tcpu_base->next_timer = timer;\n\n\t__hrtimer_reprogram(cpu_base, timer, expires);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will reevaluate the\n\t * clock bases and reprogram the clock event device.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tcpu_base->next_timer = timer;\n\n\t__hrtimer_reprogram(cpu_base, timer, expires);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_get_next_event",
          "args": [
            "cpu_base",
            "HRTIMER_ACTIVE_SOFT"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_get_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "568-592",
          "snippet": "static ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n\nstatic void\nhrtimer_update_softirq_timer(struct hrtimer_cpu_base *cpu_base, bool reprogram)\n{\n\tktime_t expires;\n\n\t/*\n\t * Find the next SOFT expiration.\n\t */\n\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\n\t/*\n\t * reprogramming needs to be triggered, even if the next soft\n\t * hrtimer expires at the same time than the next hard\n\t * hrtimer. cpu_base->softirq_expires_next needs to be updated!\n\t */\n\tif (expires == KTIME_MAX)\n\t\treturn;\n\n\t/*\n\t * cpu_base->*next_timer is recomputed by __hrtimer_get_next_event()\n\t * cpu_base->*expires_next is only set by hrtimer_reprogram()\n\t */\n\thrtimer_reprogram(cpu_base->softirq_next_timer, reprogram);\n}"
  },
  {
    "function_name": "hrtimer_update_lowres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1171-1185",
    "snippet": "static inline ktime_t hrtimer_update_lowres(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t\t    const enum hrtimer_mode mode)\n{\n#ifdef CONFIG_TIME_LOW_RES\n\t/*\n\t * CONFIG_TIME_LOW_RES indicates that the system has no way to return\n\t * granular time values. For relative timers we add hrtimer_resolution\n\t * (i.e. one jiffie) to prevent short timeouts.\n\t */\n\ttimer->is_rel = mode & HRTIMER_MODE_REL;\n\tif (timer->is_rel)\n\t\ttim = ktime_add_safe(tim, hrtimer_resolution);\n#endif\n\treturn tim;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "tim",
            "hrtimer_resolution"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_lowres(struct hrtimer *timer, ktime_t tim,\n\t\t\t\t\t    const enum hrtimer_mode mode)\n{\n#ifdef CONFIG_TIME_LOW_RES\n\t/*\n\t * CONFIG_TIME_LOW_RES indicates that the system has no way to return\n\t * granular time values. For relative timers we add hrtimer_resolution\n\t * (i.e. one jiffie) to prevent short timeouts.\n\t */\n\ttimer->is_rel = mode & HRTIMER_MODE_REL;\n\tif (timer->is_rel)\n\t\ttim = ktime_add_safe(tim, hrtimer_resolution);\n#endif\n\treturn tim;\n}"
  },
  {
    "function_name": "remove_hrtimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1134-1169",
    "snippet": "static inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t       bool restart, bool keep_local)\n{\n\tu8 state = timer->state;\n\n\tif (state & HRTIMER_STATE_ENQUEUED) {\n\t\tbool reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\t/*\n\t\t * If the timer is not restarted then reprogramming is\n\t\t * required if the timer is local. If it is local and about\n\t\t * to be restarted, avoid programming it twice (on removal\n\t\t * and a moment later when it's requeued).\n\t\t */\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\t\telse\n\t\t\treprogram &= !keep_local;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__remove_hrtimer",
          "args": [
            "timer",
            "base",
            "state",
            "reprogram"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_hrtimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1104-1129",
          "snippet": "static void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, newstate);\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superfluous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, newstate);\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superfluous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_deactivate",
          "args": [
            "timer"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "debug_deactivate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "479-483",
          "snippet": "static inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t       bool restart, bool keep_local)\n{\n\tu8 state = timer->state;\n\n\tif (state & HRTIMER_STATE_ENQUEUED) {\n\t\tbool reprogram;\n\n\t\t/*\n\t\t * Remove the timer and force reprogramming when high\n\t\t * resolution mode is active and the timer is on the current\n\t\t * CPU. If we remove a timer on another CPU, reprogramming is\n\t\t * skipped. The interrupt event on this CPU is fired and\n\t\t * reprogramming happens in the interrupt handler. This is a\n\t\t * rare case and less expensive than a smp call.\n\t\t */\n\t\tdebug_deactivate(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\t/*\n\t\t * If the timer is not restarted then reprogramming is\n\t\t * required if the timer is local. If it is local and about\n\t\t * to be restarted, avoid programming it twice (on removal\n\t\t * and a moment later when it's requeued).\n\t\t */\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\t\telse\n\t\t\treprogram &= !keep_local;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__remove_hrtimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1104-1129",
    "snippet": "static void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, newstate);\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superfluous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_force_reprogram",
          "args": [
            "cpu_base",
            "1"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_force_reprogram",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "689-700",
          "snippet": "static void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\t__hrtimer_reprogram(cpu_base, cpu_base->next_timer, expires_next);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\t__hrtimer_reprogram(cpu_base, cpu_base->next_timer, expires_next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timerqueue_del",
          "args": [
            "&base->active",
            "&timer->node"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "timer->state",
            "newstate"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     u8 newstate, int reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tu8 state = timer->state;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, newstate);\n\tif (!(state & HRTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\tif (!timerqueue_del(&base->active, &timer->node))\n\t\tcpu_base->active_bases &= ~(1 << base->index);\n\n\t/*\n\t * Note: If reprogram is false we do not update\n\t * cpu_base->next_timer. This happens when we remove the first\n\t * timer on a remote cpu. No harm as we never dereference\n\t * cpu_base->next_timer. So the worst thing what can happen is\n\t * an superfluous call to hrtimer_force_reprogram() on the\n\t * remote cpu later on if the same timer gets enqueued again.\n\t */\n\tif (reprogram && timer == cpu_base->next_timer)\n\t\thrtimer_force_reprogram(cpu_base, 1);\n}"
  },
  {
    "function_name": "enqueue_hrtimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1080-1092",
    "snippet": "static int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, HRTIMER_STATE_ENQUEUED);\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerqueue_add",
          "args": [
            "&base->active",
            "&timer->node"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "timer->state",
            "HRTIMER_STATE_ENQUEUED"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_activate",
          "args": [
            "timer",
            "mode"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "debug_activate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "472-477",
          "snippet": "static inline void debug_activate(struct hrtimer *timer,\n\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_activate(timer, mode);\n\ttrace_hrtimer_start(timer, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_activate(struct hrtimer *timer,\n\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_activate(timer, mode);\n\ttrace_hrtimer_start(timer, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_activate(timer, mode);\n\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\t/* Pairs with the lockless read in hrtimer_is_queued() */\n\tWRITE_ONCE(timer->state, HRTIMER_STATE_ENQUEUED);\n\n\treturn timerqueue_add(&base->active, &timer->node);\n}"
  },
  {
    "function_name": "hrtimer_forward",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1037-1069",
    "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_add_expires",
          "args": [
            "timer",
            "interval"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires_tv64",
          "args": [
            "timer"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_add_expires_ns",
          "args": [
            "timer",
            "incr * orun"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_divns",
          "args": [
            "delta",
            "incr"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_divns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "303-320",
          "snippet": "s64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (u32) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\ns64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (u32) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "interval"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta >= interval"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timer->state & HRTIMER_STATE_ENQUEUED"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "hrtimer_get_expires(timer)"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
  },
  {
    "function_name": "unlock_hrtimer_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1014-1018",
    "snippet": "static inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timer->base->cpu_base->lock",
            "*flags"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}"
  },
  {
    "function_name": "hrtimers_resume_local",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "1004-1009",
    "snippet": "void hrtimers_resume_local(void)\n{\n\tlockdep_assert_irqs_disabled();\n\t/* Retrigger on the local CPU */\n\tretrigger_next_event(NULL);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retrigger_next_event",
          "args": [
            "NULL"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "retrigger_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "771-799",
          "snippet": "static void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * When high resolution mode or nohz is active, then the offsets of\n\t * CLOCK_REALTIME/TAI/BOOTTIME have to be updated. Otherwise the\n\t * next tick will take care of that.\n\t *\n\t * If high resolution mode is active then the next expiring timer\n\t * must be reevaluated and the clock event device reprogrammed if\n\t * necessary.\n\t *\n\t * In the NOHZ case the update of the offset and the reevaluation\n\t * of the next expiring timer is enough. The return from the SMP\n\t * function call will take care of the reprogramming in case the\n\t * CPU was in a NOHZ idle sleep.\n\t */\n\tif (!__hrtimer_hres_active(base) && !tick_nohz_active)\n\t\treturn;\n\n\traw_spin_lock(&base->lock);\n\thrtimer_update_base(base);\n\tif (__hrtimer_hres_active(base))\n\t\thrtimer_force_reprogram(base, 0);\n\telse\n\t\thrtimer_update_next_event(base);\n\traw_spin_unlock(&base->lock);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * When high resolution mode or nohz is active, then the offsets of\n\t * CLOCK_REALTIME/TAI/BOOTTIME have to be updated. Otherwise the\n\t * next tick will take care of that.\n\t *\n\t * If high resolution mode is active then the next expiring timer\n\t * must be reevaluated and the clock event device reprogrammed if\n\t * necessary.\n\t *\n\t * In the NOHZ case the update of the offset and the reevaluation\n\t * of the next expiring timer is enough. The return from the SMP\n\t * function call will take care of the reprogramming in case the\n\t * CPU was in a NOHZ idle sleep.\n\t */\n\tif (!__hrtimer_hres_active(base) && !tick_nohz_active)\n\t\treturn;\n\n\traw_spin_lock(&base->lock);\n\thrtimer_update_base(base);\n\tif (__hrtimer_hres_active(base))\n\t\thrtimer_force_reprogram(base, 0);\n\telse\n\t\thrtimer_update_next_event(base);\n\traw_spin_unlock(&base->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimers_resume_local(void)\n{\n\tlockdep_assert_irqs_disabled();\n\t/* Retrigger on the local CPU */\n\tretrigger_next_event(NULL);\n}"
  },
  {
    "function_name": "clock_was_set_delayed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "994-997",
    "snippet": "void clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&hrtimer_work"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}"
  },
  {
    "function_name": "clock_was_set_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "983-986",
    "snippet": "static void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set(CLOCK_SET_WALL);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WORK(hrtimer_work, clock_was_set_work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock_was_set",
          "args": [
            "CLOCK_SET_WALL"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "983-986",
          "snippet": "static void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set(CLOCK_SET_WALL);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic DECLARE_WORK(hrtimer_work, clock_was_set_work);\n\nstatic void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set(CLOCK_SET_WALL);\n}"
  },
  {
    "function_name": "clock_was_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "945-981",
    "snippet": "void clock_was_set(unsigned int bases)\n{\n\tstruct hrtimer_cpu_base *cpu_base = raw_cpu_ptr(&hrtimer_bases);\n\tcpumask_var_t mask;\n\tint cpu;\n\n\tif (!__hrtimer_hres_active(cpu_base) && !tick_nohz_active)\n\t\tgoto out_timerfd;\n\n\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL)) {\n\t\ton_each_cpu(retrigger_next_event, NULL, 1);\n\t\tgoto out_timerfd;\n\t}\n\n\t/* Avoid interrupting CPUs if possible */\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tunsigned long flags;\n\n\t\tcpu_base = &per_cpu(hrtimer_bases, cpu);\n\t\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\t\tif (update_needs_ipi(cpu_base, bases))\n\t\t\tcpumask_set_cpu(cpu, mask);\n\n\t\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\t}\n\n\tpreempt_disable();\n\tsmp_call_function_many(mask, retrigger_next_event, NULL, 1);\n\tpreempt_enable();\n\tcpus_read_unlock();\n\tfree_cpumask_var(mask);\n\nout_timerfd:\n\ttimerfd_clock_was_set();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerfd_clock_was_set",
          "args": [],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "mask"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_many",
          "args": [
            "mask",
            "retrigger_next_event",
            "NULL",
            "1"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_many",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "990-994",
          "snippet": "void smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tsmp_call_function_many_cond(mask, func, info, wait * SCF_WAIT, NULL);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define SCF_WAIT\t(1U << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define SCF_WAIT\t(1U << 0)\n\nvoid smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tsmp_call_function_many_cond(mask, func, info, wait * SCF_WAIT, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_needs_ipi",
          "args": [
            "cpu_base",
            "bases"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "update_needs_ipi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "869-929",
          "snippet": "static bool update_needs_ipi(struct hrtimer_cpu_base *cpu_base,\n\t\t\t     unsigned int active)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\tktime_t expires;\n\n\t/*\n\t * Update the base offsets unconditionally so the following\n\t * checks whether the SMP function call is required works.\n\t *\n\t * The update is safe even when the remote CPU is in the hrtimer\n\t * interrupt or the hrtimer soft interrupt and expiring affected\n\t * bases. Either it will see the update before handling a base or\n\t * it will see it when it finishes the processing and reevaluates\n\t * the next expiring timer.\n\t */\n\tseq = cpu_base->clock_was_set_seq;\n\thrtimer_update_base(cpu_base);\n\n\t/*\n\t * If the sequence did not change over the update then the\n\t * remote CPU already handled it.\n\t */\n\tif (seq == cpu_base->clock_was_set_seq)\n\t\treturn false;\n\n\t/*\n\t * If the remote CPU is currently handling an hrtimer interrupt, it\n\t * will reevaluate the first expiring timer of all clock bases\n\t * before reprogramming. Nothing to do here.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn false;\n\n\t/*\n\t * Walk the affected clock bases and check whether the first expiring\n\t * timer in a clock base is moving ahead of the first expiring timer of\n\t * @cpu_base. If so, the IPI must be invoked because per CPU clock\n\t * event devices cannot be remotely reprogrammed.\n\t */\n\tactive &= cpu_base->active_bases;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\texpires = ktime_sub(next->expires, base->offset);\n\t\tif (expires < cpu_base->expires_next)\n\t\t\treturn true;\n\n\t\t/* Extra check for softirq clock bases */\n\t\tif (base->clockid < HRTIMER_BASE_MONOTONIC_SOFT)\n\t\t\tcontinue;\n\t\tif (cpu_base->softirq_activated)\n\t\t\tcontinue;\n\t\tif (expires < cpu_base->softirq_expires_next)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic bool update_needs_ipi(struct hrtimer_cpu_base *cpu_base,\n\t\t\t     unsigned int active)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\tktime_t expires;\n\n\t/*\n\t * Update the base offsets unconditionally so the following\n\t * checks whether the SMP function call is required works.\n\t *\n\t * The update is safe even when the remote CPU is in the hrtimer\n\t * interrupt or the hrtimer soft interrupt and expiring affected\n\t * bases. Either it will see the update before handling a base or\n\t * it will see it when it finishes the processing and reevaluates\n\t * the next expiring timer.\n\t */\n\tseq = cpu_base->clock_was_set_seq;\n\thrtimer_update_base(cpu_base);\n\n\t/*\n\t * If the sequence did not change over the update then the\n\t * remote CPU already handled it.\n\t */\n\tif (seq == cpu_base->clock_was_set_seq)\n\t\treturn false;\n\n\t/*\n\t * If the remote CPU is currently handling an hrtimer interrupt, it\n\t * will reevaluate the first expiring timer of all clock bases\n\t * before reprogramming. Nothing to do here.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn false;\n\n\t/*\n\t * Walk the affected clock bases and check whether the first expiring\n\t * timer in a clock base is moving ahead of the first expiring timer of\n\t * @cpu_base. If so, the IPI must be invoked because per CPU clock\n\t * event devices cannot be remotely reprogrammed.\n\t */\n\tactive &= cpu_base->active_bases;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\texpires = ktime_sub(next->expires, base->offset);\n\t\tif (expires < cpu_base->expires_next)\n\t\t\treturn true;\n\n\t\t/* Extra check for softirq clock bases */\n\t\tif (base->clockid < HRTIMER_BASE_MONOTONIC_SOFT)\n\t\t\tcontinue;\n\t\tif (cpu_base->softirq_activated)\n\t\t\tcontinue;\n\t\tif (expires < cpu_base->softirq_expires_next)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cpu_base->lock",
            "flags"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "hrtimer_bases",
            "cpu"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "retrigger_next_event",
            "NULL",
            "1"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&mask",
            "GFP_KERNEL"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "cpu_base"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "644-648",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nvoid clock_was_set(unsigned int bases)\n{\n\tstruct hrtimer_cpu_base *cpu_base = raw_cpu_ptr(&hrtimer_bases);\n\tcpumask_var_t mask;\n\tint cpu;\n\n\tif (!__hrtimer_hres_active(cpu_base) && !tick_nohz_active)\n\t\tgoto out_timerfd;\n\n\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL)) {\n\t\ton_each_cpu(retrigger_next_event, NULL, 1);\n\t\tgoto out_timerfd;\n\t}\n\n\t/* Avoid interrupting CPUs if possible */\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tunsigned long flags;\n\n\t\tcpu_base = &per_cpu(hrtimer_bases, cpu);\n\t\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\t\tif (update_needs_ipi(cpu_base, bases))\n\t\t\tcpumask_set_cpu(cpu, mask);\n\n\t\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\t}\n\n\tpreempt_disable();\n\tsmp_call_function_many(mask, retrigger_next_event, NULL, 1);\n\tpreempt_enable();\n\tcpus_read_unlock();\n\tfree_cpumask_var(mask);\n\nout_timerfd:\n\ttimerfd_clock_was_set();\n}"
  },
  {
    "function_name": "update_needs_ipi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "869-929",
    "snippet": "static bool update_needs_ipi(struct hrtimer_cpu_base *cpu_base,\n\t\t\t     unsigned int active)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\tktime_t expires;\n\n\t/*\n\t * Update the base offsets unconditionally so the following\n\t * checks whether the SMP function call is required works.\n\t *\n\t * The update is safe even when the remote CPU is in the hrtimer\n\t * interrupt or the hrtimer soft interrupt and expiring affected\n\t * bases. Either it will see the update before handling a base or\n\t * it will see it when it finishes the processing and reevaluates\n\t * the next expiring timer.\n\t */\n\tseq = cpu_base->clock_was_set_seq;\n\thrtimer_update_base(cpu_base);\n\n\t/*\n\t * If the sequence did not change over the update then the\n\t * remote CPU already handled it.\n\t */\n\tif (seq == cpu_base->clock_was_set_seq)\n\t\treturn false;\n\n\t/*\n\t * If the remote CPU is currently handling an hrtimer interrupt, it\n\t * will reevaluate the first expiring timer of all clock bases\n\t * before reprogramming. Nothing to do here.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn false;\n\n\t/*\n\t * Walk the affected clock bases and check whether the first expiring\n\t * timer in a clock base is moving ahead of the first expiring timer of\n\t * @cpu_base. If so, the IPI must be invoked because per CPU clock\n\t * event devices cannot be remotely reprogrammed.\n\t */\n\tactive &= cpu_base->active_bases;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\texpires = ktime_sub(next->expires, base->offset);\n\t\tif (expires < cpu_base->expires_next)\n\t\t\treturn true;\n\n\t\t/* Extra check for softirq clock bases */\n\t\tif (base->clockid < HRTIMER_BASE_MONOTONIC_SOFT)\n\t\t\tcontinue;\n\t\tif (cpu_base->softirq_activated)\n\t\t\tcontinue;\n\t\tif (expires < cpu_base->softirq_expires_next)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "next->expires",
            "base->offset"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "&base->active"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_active_base",
          "args": [
            "base",
            "cpu_base",
            "active"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_update_base",
          "args": [
            "cpu_base"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "625-639",
          "snippet": "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic bool update_needs_ipi(struct hrtimer_cpu_base *cpu_base,\n\t\t\t     unsigned int active)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\tktime_t expires;\n\n\t/*\n\t * Update the base offsets unconditionally so the following\n\t * checks whether the SMP function call is required works.\n\t *\n\t * The update is safe even when the remote CPU is in the hrtimer\n\t * interrupt or the hrtimer soft interrupt and expiring affected\n\t * bases. Either it will see the update before handling a base or\n\t * it will see it when it finishes the processing and reevaluates\n\t * the next expiring timer.\n\t */\n\tseq = cpu_base->clock_was_set_seq;\n\thrtimer_update_base(cpu_base);\n\n\t/*\n\t * If the sequence did not change over the update then the\n\t * remote CPU already handled it.\n\t */\n\tif (seq == cpu_base->clock_was_set_seq)\n\t\treturn false;\n\n\t/*\n\t * If the remote CPU is currently handling an hrtimer interrupt, it\n\t * will reevaluate the first expiring timer of all clock bases\n\t * before reprogramming. Nothing to do here.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn false;\n\n\t/*\n\t * Walk the affected clock bases and check whether the first expiring\n\t * timer in a clock base is moving ahead of the first expiring timer of\n\t * @cpu_base. If so, the IPI must be invoked because per CPU clock\n\t * event devices cannot be remotely reprogrammed.\n\t */\n\tactive &= cpu_base->active_bases;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\texpires = ktime_sub(next->expires, base->offset);\n\t\tif (expires < cpu_base->expires_next)\n\t\t\treturn true;\n\n\t\t/* Extra check for softirq clock bases */\n\t\tif (base->clockid < HRTIMER_BASE_MONOTONIC_SOFT)\n\t\t\tcontinue;\n\t\tif (cpu_base->softirq_activated)\n\t\t\tcontinue;\n\t\tif (expires < cpu_base->softirq_expires_next)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "hrtimer_reprogram",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "808-867",
    "snippet": "static void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will reevaluate the\n\t * clock bases and reprogram the clock event device.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tcpu_base->next_timer = timer;\n\n\t__hrtimer_reprogram(cpu_base, timer, expires);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_reprogram",
          "args": [
            "cpu_base",
            "timer",
            "expires"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_reprogram",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "655-682",
          "snippet": "static void __hrtimer_reprogram(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\tstruct hrtimer *next_timer,\n\t\t\t\tktime_t expires_next)\n{\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectively block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(expires_next, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_reprogram(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\tstruct hrtimer *next_timer,\n\t\t\t\tktime_t expires_next)\n{\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectively block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(expires_next, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "expires",
            "timer_cpu_base->expires_next"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "expires",
            "timer_cpu_base->softirq_expires_next"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "hrtimer_get_expires_tv64(timer) < 0"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires_tv64",
          "args": [
            "timer"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "hrtimer_get_expires(timer)",
            "base->offset"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base = timer->base;\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\n\tWARN_ON_ONCE(hrtimer_get_expires_tv64(timer) < 0);\n\n\t/*\n\t * CLOCK_REALTIME timer might be requested with an absolute\n\t * expiry time which is less than base->offset. Set it to 0.\n\t */\n\tif (expires < 0)\n\t\texpires = 0;\n\n\tif (timer->is_soft) {\n\t\t/*\n\t\t * soft hrtimer could be started on a remote CPU. In this\n\t\t * case softirq_expires_next needs to be updated on the\n\t\t * remote CPU. The soft hrtimer will not expire before the\n\t\t * first hard hrtimer on the remote CPU -\n\t\t * hrtimer_check_target() prevents this case.\n\t\t */\n\t\tstruct hrtimer_cpu_base *timer_cpu_base = base->cpu_base;\n\n\t\tif (timer_cpu_base->softirq_activated)\n\t\t\treturn;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->softirq_expires_next))\n\t\t\treturn;\n\n\t\ttimer_cpu_base->softirq_next_timer = timer;\n\t\ttimer_cpu_base->softirq_expires_next = expires;\n\n\t\tif (!ktime_before(expires, timer_cpu_base->expires_next) ||\n\t\t    !reprogram)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * If the timer is not on the current cpu, we cannot reprogram\n\t * the other cpus clock event device.\n\t */\n\tif (base->cpu_base != cpu_base)\n\t\treturn;\n\n\tif (expires >= cpu_base->expires_next)\n\t\treturn;\n\n\t/*\n\t * If the hrtimer interrupt is running, then it will reevaluate the\n\t * clock bases and reprogram the clock event device.\n\t */\n\tif (cpu_base->in_hrtirq)\n\t\treturn;\n\n\tcpu_base->next_timer = timer;\n\n\t__hrtimer_reprogram(cpu_base, timer, expires);\n}"
  },
  {
    "function_name": "retrigger_next_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "771-799",
    "snippet": "static void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * When high resolution mode or nohz is active, then the offsets of\n\t * CLOCK_REALTIME/TAI/BOOTTIME have to be updated. Otherwise the\n\t * next tick will take care of that.\n\t *\n\t * If high resolution mode is active then the next expiring timer\n\t * must be reevaluated and the clock event device reprogrammed if\n\t * necessary.\n\t *\n\t * In the NOHZ case the update of the offset and the reevaluation\n\t * of the next expiring timer is enough. The return from the SMP\n\t * function call will take care of the reprogramming in case the\n\t * CPU was in a NOHZ idle sleep.\n\t */\n\tif (!__hrtimer_hres_active(base) && !tick_nohz_active)\n\t\treturn;\n\n\traw_spin_lock(&base->lock);\n\thrtimer_update_base(base);\n\tif (__hrtimer_hres_active(base))\n\t\thrtimer_force_reprogram(base, 0);\n\telse\n\t\thrtimer_update_next_event(base);\n\traw_spin_unlock(&base->lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&base->lock"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_next_event",
          "args": [
            "base"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "594-623",
          "snippet": "static ktime_t hrtimer_update_next_event(struct hrtimer_cpu_base *cpu_base)\n{\n\tktime_t expires_next, soft = KTIME_MAX;\n\n\t/*\n\t * If the soft interrupt has already been activated, ignore the\n\t * soft bases. They will be handled in the already raised soft\n\t * interrupt.\n\t */\n\tif (!cpu_base->softirq_activated) {\n\t\tsoft = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\t\t/*\n\t\t * Update the soft expiry time. clock_settime() might have\n\t\t * affected it.\n\t\t */\n\t\tcpu_base->softirq_expires_next = soft;\n\t}\n\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_HARD);\n\t/*\n\t * If a softirq timer is expiring first, update cpu_base->next_timer\n\t * and program the hardware with the soft expiry time.\n\t */\n\tif (expires_next > soft) {\n\t\tcpu_base->next_timer = cpu_base->softirq_next_timer;\n\t\texpires_next = soft;\n\t}\n\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t hrtimer_update_next_event(struct hrtimer_cpu_base *cpu_base)\n{\n\tktime_t expires_next, soft = KTIME_MAX;\n\n\t/*\n\t * If the soft interrupt has already been activated, ignore the\n\t * soft bases. They will be handled in the already raised soft\n\t * interrupt.\n\t */\n\tif (!cpu_base->softirq_activated) {\n\t\tsoft = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\t\t/*\n\t\t * Update the soft expiry time. clock_settime() might have\n\t\t * affected it.\n\t\t */\n\t\tcpu_base->softirq_expires_next = soft;\n\t}\n\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_HARD);\n\t/*\n\t * If a softirq timer is expiring first, update cpu_base->next_timer\n\t * and program the hardware with the soft expiry time.\n\t */\n\tif (expires_next > soft) {\n\t\tcpu_base->next_timer = cpu_base->softirq_next_timer;\n\t\texpires_next = soft;\n\t}\n\n\treturn expires_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_force_reprogram",
          "args": [
            "base",
            "0"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_force_reprogram",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "689-700",
          "snippet": "static void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\t__hrtimer_reprogram(cpu_base, cpu_base->next_timer, expires_next);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\t__hrtimer_reprogram(cpu_base, cpu_base->next_timer, expires_next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "base"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "644-648",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_base",
          "args": [
            "base"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "625-639",
          "snippet": "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&base->lock"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * When high resolution mode or nohz is active, then the offsets of\n\t * CLOCK_REALTIME/TAI/BOOTTIME have to be updated. Otherwise the\n\t * next tick will take care of that.\n\t *\n\t * If high resolution mode is active then the next expiring timer\n\t * must be reevaluated and the clock event device reprogrammed if\n\t * necessary.\n\t *\n\t * In the NOHZ case the update of the offset and the reevaluation\n\t * of the next expiring timer is enough. The return from the SMP\n\t * function call will take care of the reprogramming in case the\n\t * CPU was in a NOHZ idle sleep.\n\t */\n\tif (!__hrtimer_hres_active(base) && !tick_nohz_active)\n\t\treturn;\n\n\traw_spin_lock(&base->lock);\n\thrtimer_update_base(base);\n\tif (__hrtimer_hres_active(base))\n\t\thrtimer_force_reprogram(base, 0);\n\telse\n\t\thrtimer_update_next_event(base);\n\traw_spin_unlock(&base->lock);\n}"
  },
  {
    "function_name": "hrtimer_switch_to_hres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "755-755",
    "snippet": "static inline void hrtimer_switch_to_hres(void) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void hrtimer_switch_to_hres(void) { }"
  },
  {
    "function_name": "hrtimer_is_hres_enabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "754-754",
    "snippet": "static inline int hrtimer_is_hres_enabled(void) { return 0; }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int hrtimer_is_hres_enabled(void) { return 0; }"
  },
  {
    "function_name": "hrtimer_switch_to_hres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "735-750",
    "snippet": "static void hrtimer_switch_to_hres(void)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\tif (tick_init_highres()) {\n\t\tpr_warn(\"Could not switch to high resolution mode on CPU %u\\n\",\n\t\t\tbase->cpu);\n\t\treturn;\n\t}\n\tbase->hres_active = 1;\n\thrtimer_resolution = HIGH_RES_NSEC;\n\n\ttick_setup_sched_timer();\n\t/* \"Retrigger\" the interrupt to get things going */\n\tretrigger_next_event(NULL);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "retrigger_next_event",
          "args": [
            "NULL"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "retrigger_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "771-799",
          "snippet": "static void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * When high resolution mode or nohz is active, then the offsets of\n\t * CLOCK_REALTIME/TAI/BOOTTIME have to be updated. Otherwise the\n\t * next tick will take care of that.\n\t *\n\t * If high resolution mode is active then the next expiring timer\n\t * must be reevaluated and the clock event device reprogrammed if\n\t * necessary.\n\t *\n\t * In the NOHZ case the update of the offset and the reevaluation\n\t * of the next expiring timer is enough. The return from the SMP\n\t * function call will take care of the reprogramming in case the\n\t * CPU was in a NOHZ idle sleep.\n\t */\n\tif (!__hrtimer_hres_active(base) && !tick_nohz_active)\n\t\treturn;\n\n\traw_spin_lock(&base->lock);\n\thrtimer_update_base(base);\n\tif (__hrtimer_hres_active(base))\n\t\thrtimer_force_reprogram(base, 0);\n\telse\n\t\thrtimer_update_next_event(base);\n\traw_spin_unlock(&base->lock);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\t/*\n\t * When high resolution mode or nohz is active, then the offsets of\n\t * CLOCK_REALTIME/TAI/BOOTTIME have to be updated. Otherwise the\n\t * next tick will take care of that.\n\t *\n\t * If high resolution mode is active then the next expiring timer\n\t * must be reevaluated and the clock event device reprogrammed if\n\t * necessary.\n\t *\n\t * In the NOHZ case the update of the offset and the reevaluation\n\t * of the next expiring timer is enough. The return from the SMP\n\t * function call will take care of the reprogramming in case the\n\t * CPU was in a NOHZ idle sleep.\n\t */\n\tif (!__hrtimer_hres_active(base) && !tick_nohz_active)\n\t\treturn;\n\n\traw_spin_lock(&base->lock);\n\thrtimer_update_base(base);\n\tif (__hrtimer_hres_active(base))\n\t\thrtimer_force_reprogram(base, 0);\n\telse\n\t\thrtimer_update_next_event(base);\n\traw_spin_unlock(&base->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_setup_sched_timer",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_sched_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1454-1479",
          "snippet": "void tick_setup_sched_timer(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now = ktime_get();\n\n\t/*\n\t * Emulate tick processing via per-CPU hrtimers:\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);\n\tts->sched_timer.function = tick_sched_timer;\n\n\t/* Get the next period (per-CPU) */\n\thrtimer_set_expires(&ts->sched_timer, tick_init_jiffy_update());\n\n\t/* Offset the tick to avert jiffies_lock contention. */\n\tif (sched_skew_tick) {\n\t\tu64 offset = TICK_NSEC >> 1;\n\t\tdo_div(offset, num_possible_cpus());\n\t\toffset *= smp_processor_id();\n\t\thrtimer_add_expires_ns(&ts->sched_timer, offset);\n\t}\n\n\thrtimer_forward(&ts->sched_timer, now, TICK_NSEC);\n\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED_HARD);\n\ttick_nohz_activate(ts, NOHZ_MODE_HIGHRES);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_setup_sched_timer(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now = ktime_get();\n\n\t/*\n\t * Emulate tick processing via per-CPU hrtimers:\n\t */\n\thrtimer_init(&ts->sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);\n\tts->sched_timer.function = tick_sched_timer;\n\n\t/* Get the next period (per-CPU) */\n\thrtimer_set_expires(&ts->sched_timer, tick_init_jiffy_update());\n\n\t/* Offset the tick to avert jiffies_lock contention. */\n\tif (sched_skew_tick) {\n\t\tu64 offset = TICK_NSEC >> 1;\n\t\tdo_div(offset, num_possible_cpus());\n\t\toffset *= smp_processor_id();\n\t\thrtimer_add_expires_ns(&ts->sched_timer, offset);\n\t}\n\n\thrtimer_forward(&ts->sched_timer, now, TICK_NSEC);\n\thrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED_HARD);\n\ttick_nohz_activate(ts, NOHZ_MODE_HIGHRES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not switch to high resolution mode on CPU %u\\n\"",
            "base->cpu"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_init_highres",
          "args": [],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "tick_init_highres",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "124-127",
          "snippet": "int tick_init_highres(void)\n{\n\treturn tick_switch_to_oneshot(hrtimer_interrupt);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_init_highres(void)\n{\n\treturn tick_switch_to_oneshot(hrtimer_interrupt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic void hrtimer_switch_to_hres(void)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\tif (tick_init_highres()) {\n\t\tpr_warn(\"Could not switch to high resolution mode on CPU %u\\n\",\n\t\t\tbase->cpu);\n\t\treturn;\n\t}\n\tbase->hres_active = 1;\n\thrtimer_resolution = HIGH_RES_NSEC;\n\n\ttick_setup_sched_timer();\n\t/* \"Retrigger\" the interrupt to get things going */\n\tretrigger_next_event(NULL);\n}"
  },
  {
    "function_name": "hrtimer_is_hres_enabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "725-728",
    "snippet": "static inline int hrtimer_is_hres_enabled(void)\n{\n\treturn hrtimer_hres_enabled;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int hrtimer_is_hres_enabled(void)\n{\n\treturn hrtimer_hres_enabled;\n}"
  },
  {
    "function_name": "setup_hrtimer_hres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "715-718",
    "snippet": "static int __init setup_hrtimer_hres(char *str)\n{\n\treturn (kstrtobool(str, &hrtimer_hres_enabled) == 0);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "str",
            "&hrtimer_hres_enabled"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int __init setup_hrtimer_hres(char *str)\n{\n\treturn (kstrtobool(str, &hrtimer_hres_enabled) == 0);\n}"
  },
  {
    "function_name": "hrtimer_force_reprogram",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "689-700",
    "snippet": "static void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\t__hrtimer_reprogram(cpu_base, cpu_base->next_timer, expires_next);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_reprogram",
          "args": [
            "cpu_base",
            "cpu_base->next_timer",
            "expires_next"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_reprogram",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "655-682",
          "snippet": "static void __hrtimer_reprogram(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\tstruct hrtimer *next_timer,\n\t\t\t\tktime_t expires_next)\n{\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectively block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(expires_next, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_reprogram(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\tstruct hrtimer *next_timer,\n\t\t\t\tktime_t expires_next)\n{\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectively block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(expires_next, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_update_next_event",
          "args": [
            "cpu_base"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_update_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "594-623",
          "snippet": "static ktime_t hrtimer_update_next_event(struct hrtimer_cpu_base *cpu_base)\n{\n\tktime_t expires_next, soft = KTIME_MAX;\n\n\t/*\n\t * If the soft interrupt has already been activated, ignore the\n\t * soft bases. They will be handled in the already raised soft\n\t * interrupt.\n\t */\n\tif (!cpu_base->softirq_activated) {\n\t\tsoft = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\t\t/*\n\t\t * Update the soft expiry time. clock_settime() might have\n\t\t * affected it.\n\t\t */\n\t\tcpu_base->softirq_expires_next = soft;\n\t}\n\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_HARD);\n\t/*\n\t * If a softirq timer is expiring first, update cpu_base->next_timer\n\t * and program the hardware with the soft expiry time.\n\t */\n\tif (expires_next > soft) {\n\t\tcpu_base->next_timer = cpu_base->softirq_next_timer;\n\t\texpires_next = soft;\n\t}\n\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t hrtimer_update_next_event(struct hrtimer_cpu_base *cpu_base)\n{\n\tktime_t expires_next, soft = KTIME_MAX;\n\n\t/*\n\t * If the soft interrupt has already been activated, ignore the\n\t * soft bases. They will be handled in the already raised soft\n\t * interrupt.\n\t */\n\tif (!cpu_base->softirq_activated) {\n\t\tsoft = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\t\t/*\n\t\t * Update the soft expiry time. clock_settime() might have\n\t\t * affected it.\n\t\t */\n\t\tcpu_base->softirq_expires_next = soft;\n\t}\n\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_HARD);\n\t/*\n\t * If a softirq timer is expiring first, update cpu_base->next_timer\n\t * and program the hardware with the soft expiry time.\n\t */\n\tif (expires_next > soft) {\n\t\tcpu_base->next_timer = cpu_base->softirq_next_timer;\n\t\texpires_next = soft;\n\t}\n\n\treturn expires_next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next;\n\n\texpires_next = hrtimer_update_next_event(cpu_base);\n\n\tif (skip_equal && expires_next == cpu_base->expires_next)\n\t\treturn;\n\n\t__hrtimer_reprogram(cpu_base, cpu_base->next_timer, expires_next);\n}"
  },
  {
    "function_name": "__hrtimer_reprogram",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "655-682",
    "snippet": "static void __hrtimer_reprogram(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\tstruct hrtimer *next_timer,\n\t\t\t\tktime_t expires_next)\n{\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectively block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(expires_next, 1);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "expires_next",
            "1"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "23-45",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "cpu_base"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "644-648",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_reprogram(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\tstruct hrtimer *next_timer,\n\t\t\t\tktime_t expires_next)\n{\n\tcpu_base->expires_next = expires_next;\n\n\t/*\n\t * If hres is not active, hardware does not have to be\n\t * reprogrammed yet.\n\t *\n\t * If a hang was detected in the last timer interrupt then we\n\t * leave the hang delay active in the hardware. We want the\n\t * system to make progress. That also prevents the following\n\t * scenario:\n\t * T1 expires 50ms from now\n\t * T2 expires 5s from now\n\t *\n\t * T1 is removed, so this code is called and would reprogram\n\t * the hardware to 5s from now. Any hrtimer_start after that\n\t * will not reprogram the hardware due to hang_detected being\n\t * set. So we'd effectively block all timers until the T2 event\n\t * fires.\n\t */\n\tif (!__hrtimer_hres_active(cpu_base) || cpu_base->hang_detected)\n\t\treturn;\n\n\ttick_program_event(expires_next, 1);\n}"
  },
  {
    "function_name": "hrtimer_hres_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "650-653",
    "snippet": "static inline int hrtimer_hres_active(void)\n{\n\treturn __hrtimer_hres_active(this_cpu_ptr(&hrtimer_bases));\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_hres_active",
          "args": [
            "this_cpu_ptr(&hrtimer_bases)"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_hres_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "644-648",
          "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline int hrtimer_hres_active(void)\n{\n\treturn __hrtimer_hres_active(this_cpu_ptr(&hrtimer_bases));\n}"
  },
  {
    "function_name": "__hrtimer_hres_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "644-648",
    "snippet": "static inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HIGH_RES_TIMERS"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline int __hrtimer_hres_active(struct hrtimer_cpu_base *cpu_base)\n{\n\treturn IS_ENABLED(CONFIG_HIGH_RES_TIMERS) ?\n\t\tcpu_base->hres_active : 0;\n}"
  },
  {
    "function_name": "hrtimer_update_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "625-639",
    "snippet": "static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_update_offsets_now",
          "args": [
            "&base->clock_was_set_seq",
            "offs_real",
            "offs_boot",
            "offs_tai"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_update_offsets_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2287-2316",
          "snippet": "ktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,\n\t\t\t\t     ktime_t *offs_boot, ktime_t *offs_tai)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\t\tbase = ktime_add_ns(base, nsecs);\n\n\t\tif (*cwsseq != tk->clock_was_set_seq) {\n\t\t\t*cwsseq = tk->clock_was_set_seq;\n\t\t\t*offs_real = tk->offs_real;\n\t\t\t*offs_boot = tk->offs_boot;\n\t\t\t*offs_tai = tk->offs_tai;\n\t\t}\n\n\t\t/* Handle leapsecond insertion adjustments */\n\t\tif (unlikely(base >= tk->next_leap_ktime))\n\t\t\t*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn base;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,\n\t\t\t\t     ktime_t *offs_boot, ktime_t *offs_tai)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\t\tbase = ktime_add_ns(base, nsecs);\n\n\t\tif (*cwsseq != tk->clock_was_set_seq) {\n\t\t\t*cwsseq = tk->clock_was_set_seq;\n\t\t\t*offs_real = tk->offs_real;\n\t\t\t*offs_boot = tk->offs_boot;\n\t\t\t*offs_tai = tk->offs_tai;\n\t\t}\n\n\t\t/* Handle leapsecond insertion adjustments */\n\t\tif (unlikely(base >= tk->next_leap_ktime))\n\t\t\t*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn base;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;\n\tktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;\n\tktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;\n\n\tktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,\n\t\t\t\t\t    offs_real, offs_boot, offs_tai);\n\n\tbase->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;\n\tbase->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;\n\tbase->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;\n\n\treturn now;\n}"
  },
  {
    "function_name": "hrtimer_update_next_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "594-623",
    "snippet": "static ktime_t hrtimer_update_next_event(struct hrtimer_cpu_base *cpu_base)\n{\n\tktime_t expires_next, soft = KTIME_MAX;\n\n\t/*\n\t * If the soft interrupt has already been activated, ignore the\n\t * soft bases. They will be handled in the already raised soft\n\t * interrupt.\n\t */\n\tif (!cpu_base->softirq_activated) {\n\t\tsoft = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\t\t/*\n\t\t * Update the soft expiry time. clock_settime() might have\n\t\t * affected it.\n\t\t */\n\t\tcpu_base->softirq_expires_next = soft;\n\t}\n\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_HARD);\n\t/*\n\t * If a softirq timer is expiring first, update cpu_base->next_timer\n\t * and program the hardware with the soft expiry time.\n\t */\n\tif (expires_next > soft) {\n\t\tcpu_base->next_timer = cpu_base->softirq_next_timer;\n\t\texpires_next = soft;\n\t}\n\n\treturn expires_next;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
      "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_get_next_event",
          "args": [
            "cpu_base",
            "HRTIMER_ACTIVE_HARD"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_get_next_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "568-592",
          "snippet": "static ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t hrtimer_update_next_event(struct hrtimer_cpu_base *cpu_base)\n{\n\tktime_t expires_next, soft = KTIME_MAX;\n\n\t/*\n\t * If the soft interrupt has already been activated, ignore the\n\t * soft bases. They will be handled in the already raised soft\n\t * interrupt.\n\t */\n\tif (!cpu_base->softirq_activated) {\n\t\tsoft = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_SOFT);\n\t\t/*\n\t\t * Update the soft expiry time. clock_settime() might have\n\t\t * affected it.\n\t\t */\n\t\tcpu_base->softirq_expires_next = soft;\n\t}\n\n\texpires_next = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_HARD);\n\t/*\n\t * If a softirq timer is expiring first, update cpu_base->next_timer\n\t * and program the hardware with the soft expiry time.\n\t */\n\tif (expires_next > soft) {\n\t\tcpu_base->next_timer = cpu_base->softirq_next_timer;\n\t\texpires_next = soft;\n\t}\n\n\treturn expires_next;\n}"
  },
  {
    "function_name": "__hrtimer_get_next_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "568-592",
    "snippet": "static ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)",
      "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_next_event_base",
          "args": [
            "cpu_base",
            "NULL",
            "active",
            "expires_next"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_next_event_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "502-546",
          "snippet": "static ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_SOFT\t(HRTIMER_ACTIVE_HARD << MASK_SHIFT)\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nstatic ktime_t\n__hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base, unsigned int active_mask)\n{\n\tunsigned int active;\n\tstruct hrtimer *next_timer = NULL;\n\tktime_t expires_next = KTIME_MAX;\n\n\tif (!cpu_base->softirq_activated && (active_mask & HRTIMER_ACTIVE_SOFT)) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_SOFT;\n\t\tcpu_base->softirq_next_timer = NULL;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL,\n\t\t\t\t\t\t\t active, KTIME_MAX);\n\n\t\tnext_timer = cpu_base->softirq_next_timer;\n\t}\n\n\tif (active_mask & HRTIMER_ACTIVE_HARD) {\n\t\tactive = cpu_base->active_bases & HRTIMER_ACTIVE_HARD;\n\t\tcpu_base->next_timer = next_timer;\n\t\texpires_next = __hrtimer_next_event_base(cpu_base, NULL, active,\n\t\t\t\t\t\t\t expires_next);\n\t}\n\n\treturn expires_next;\n}"
  },
  {
    "function_name": "__hrtimer_next_event_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "502-546",
    "snippet": "static ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "hrtimer_get_expires(timer)",
            "base->offset"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "next",
            "structhrtimer",
            "node"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_iterate_next",
          "args": [
            "next"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "next",
            "structhrtimer",
            "node"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "&base->active"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_active_base",
          "args": [
            "base",
            "cpu_base",
            "active"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic ktime_t __hrtimer_next_event_base(struct hrtimer_cpu_base *cpu_base,\n\t\t\t\t\t const struct hrtimer *exclude,\n\t\t\t\t\t unsigned int active,\n\t\t\t\t\t ktime_t expires_next)\n{\n\tstruct hrtimer_clock_base *base;\n\tktime_t expires;\n\n\tfor_each_active_base(base, cpu_base, active) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\tif (timer == exclude) {\n\t\t\t/* Get to the next timer in the queue. */\n\t\t\tnext = timerqueue_iterate_next(next);\n\t\t\tif (!next)\n\t\t\t\tcontinue;\n\n\t\t\ttimer = container_of(next, struct hrtimer, node);\n\t\t}\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires < expires_next) {\n\t\t\texpires_next = expires;\n\n\t\t\t/* Skip cpu_base update if a timer is being excluded. */\n\t\t\tif (exclude)\n\t\t\t\tcontinue;\n\n\t\t\tif (timer->is_soft)\n\t\t\t\tcpu_base->softirq_next_timer = timer;\n\t\t\telse\n\t\t\t\tcpu_base->next_timer = timer;\n\t\t}\n\t}\n\t/*\n\t * clock_was_set() might have changed base->offset of any of\n\t * the clock bases so the result might be negative. Fix it up\n\t * to prevent a false positive in clockevents_program_event().\n\t */\n\tif (expires_next < 0)\n\t\texpires_next = 0;\n\treturn expires_next;\n}"
  },
  {
    "function_name": "__next_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "485-497",
    "snippet": "static struct hrtimer_clock_base *\n__next_base(struct hrtimer_cpu_base *cpu_base, unsigned int *active)\n{\n\tunsigned int idx;\n\n\tif (!*active)\n\t\treturn NULL;\n\n\tidx = __ffs(*active);\n\t*active &= ~(1U << idx);\n\n\treturn &cpu_base->clock_base[idx];\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "*active"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic struct hrtimer_clock_base *\n__next_base(struct hrtimer_cpu_base *cpu_base, unsigned int *active)\n{\n\tunsigned int idx;\n\n\tif (!*active)\n\t\treturn NULL;\n\n\tidx = __ffs(*active);\n\t*active &= ~(1U << idx);\n\n\treturn &cpu_base->clock_base[idx];\n}"
  },
  {
    "function_name": "debug_deactivate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "479-483",
    "snippet": "static inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_hrtimer_cancel",
          "args": [
            "timer"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_hrtimer_deactivate",
          "args": [
            "timer"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "debug_hrtimer_deactivate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "461-461",
          "snippet": "static inline void debug_hrtimer_deactivate(struct hrtimer *timer) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_deactivate(struct hrtimer *timer) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}"
  },
  {
    "function_name": "debug_activate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "472-477",
    "snippet": "static inline void debug_activate(struct hrtimer *timer,\n\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_activate(timer, mode);\n\ttrace_hrtimer_start(timer, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_hrtimer_start",
          "args": [
            "timer",
            "mode"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_hrtimer_activate",
          "args": [
            "timer",
            "mode"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "debug_hrtimer_activate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "459-460",
          "snippet": "static inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_activate(struct hrtimer *timer,\n\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_activate(timer, mode);\n\ttrace_hrtimer_start(timer, mode);\n}"
  },
  {
    "function_name": "debug_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "464-470",
    "snippet": "static inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_hrtimer_init",
          "args": [
            "timer",
            "clockid",
            "mode"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_hrtimer_init",
          "args": [
            "timer"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "debug_hrtimer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "458-458",
          "snippet": "static inline void debug_hrtimer_init(struct hrtimer *timer) { }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_init(struct hrtimer *timer) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}"
  },
  {
    "function_name": "debug_hrtimer_deactivate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "461-461",
    "snippet": "static inline void debug_hrtimer_deactivate(struct hrtimer *timer) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_deactivate(struct hrtimer *timer) { }"
  },
  {
    "function_name": "debug_hrtimer_activate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "459-460",
    "snippet": "static inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode) { }"
  },
  {
    "function_name": "debug_hrtimer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "458-458",
    "snippet": "static inline void debug_hrtimer_init(struct hrtimer *timer) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_init(struct hrtimer *timer) { }"
  },
  {
    "function_name": "destroy_hrtimer_on_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "450-453",
    "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
  },
  {
    "function_name": "hrtimer_init_sleeper_on_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "442-447",
    "snippet": "void hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(&sl->timer, &hrtimer_debug_descr);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_init_sleeper",
          "args": [
            "sl",
            "clock_id",
            "mode"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1969-1999",
          "snippet": "static void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context either for latency reasons or because the\n\t * hrtimer callback takes regular spinlocks or invokes other\n\t * functions which are not suitable for hard interrupt context on\n\t * PREEMPT_RT.\n\t *\n\t * The hrtimer_sleeper callback is RT compatible in hard interrupt\n\t * context, but there is a latency concern: Untrusted userspace can\n\t * spawn many threads which arm timers for the same expiry time on\n\t * the same CPU. That causes a latency spike due to the wakeup of\n\t * a gazillion threads.\n\t *\n\t * OTOH, privileged real-time user space applications rely on the\n\t * low latency of hard interrupt wakeups. If the current task is in\n\t * a real-time scheduling class, mark the mode for hard interrupt\n\t * expiry.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tif (task_is_realtime(current) && !(mode & HRTIMER_MODE_SOFT))\n\t\t\tmode |= HRTIMER_MODE_HARD;\n\t}\n\n\t__hrtimer_init(&sl->timer, clock_id, mode);\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = current;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context either for latency reasons or because the\n\t * hrtimer callback takes regular spinlocks or invokes other\n\t * functions which are not suitable for hard interrupt context on\n\t * PREEMPT_RT.\n\t *\n\t * The hrtimer_sleeper callback is RT compatible in hard interrupt\n\t * context, but there is a latency concern: Untrusted userspace can\n\t * spawn many threads which arm timers for the same expiry time on\n\t * the same CPU. That causes a latency spike due to the wakeup of\n\t * a gazillion threads.\n\t *\n\t * OTOH, privileged real-time user space applications rely on the\n\t * low latency of hard interrupt wakeups. If the current task is in\n\t * a real-time scheduling class, mark the mode for hard interrupt\n\t * expiry.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tif (task_is_realtime(current) && !(mode & HRTIMER_MODE_SOFT))\n\t\t\tmode |= HRTIMER_MODE_HARD;\n\t}\n\n\t__hrtimer_init(&sl->timer, clock_id, mode);\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_object_init_on_stack",
          "args": [
            "&sl->timer",
            "&hrtimer_debug_descr"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper_on_stack(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(&sl->timer, &hrtimer_debug_descr);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n}"
  },
  {
    "function_name": "hrtimer_init_on_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "431-436",
    "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_init",
          "args": [
            "timer",
            "clock_id",
            "mode"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1969-1999",
          "snippet": "static void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context either for latency reasons or because the\n\t * hrtimer callback takes regular spinlocks or invokes other\n\t * functions which are not suitable for hard interrupt context on\n\t * PREEMPT_RT.\n\t *\n\t * The hrtimer_sleeper callback is RT compatible in hard interrupt\n\t * context, but there is a latency concern: Untrusted userspace can\n\t * spawn many threads which arm timers for the same expiry time on\n\t * the same CPU. That causes a latency spike due to the wakeup of\n\t * a gazillion threads.\n\t *\n\t * OTOH, privileged real-time user space applications rely on the\n\t * low latency of hard interrupt wakeups. If the current task is in\n\t * a real-time scheduling class, mark the mode for hard interrupt\n\t * expiry.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tif (task_is_realtime(current) && !(mode & HRTIMER_MODE_SOFT))\n\t\t\tmode |= HRTIMER_MODE_HARD;\n\t}\n\n\t__hrtimer_init(&sl->timer, clock_id, mode);\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = current;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,\n\t\t\t\t   clockid_t clock_id, enum hrtimer_mode mode)\n{\n\t/*\n\t * On PREEMPT_RT enabled kernels hrtimers which are not explicitly\n\t * marked for hard interrupt expiry mode are moved into soft\n\t * interrupt context either for latency reasons or because the\n\t * hrtimer callback takes regular spinlocks or invokes other\n\t * functions which are not suitable for hard interrupt context on\n\t * PREEMPT_RT.\n\t *\n\t * The hrtimer_sleeper callback is RT compatible in hard interrupt\n\t * context, but there is a latency concern: Untrusted userspace can\n\t * spawn many threads which arm timers for the same expiry time on\n\t * the same CPU. That causes a latency spike due to the wakeup of\n\t * a gazillion threads.\n\t *\n\t * OTOH, privileged real-time user space applications rely on the\n\t * low latency of hard interrupt wakeups. If the current task is in\n\t * a real-time scheduling class, mark the mode for hard interrupt\n\t * expiry.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tif (task_is_realtime(current) && !(mode & HRTIMER_MODE_SOFT))\n\t\t\tmode |= HRTIMER_MODE_HARD;\n\t}\n\n\t__hrtimer_init(&sl->timer, clock_id, mode);\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_object_init_on_stack",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
  },
  {
    "function_name": "debug_hrtimer_deactivate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "423-426",
    "snippet": "static inline void debug_hrtimer_deactivate(struct hrtimer *timer)\n{\n\tdebug_object_deactivate(timer, &hrtimer_debug_descr);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_deactivate",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_deactivate(struct hrtimer *timer)\n{\n\tdebug_object_deactivate(timer, &hrtimer_debug_descr);\n}"
  },
  {
    "function_name": "debug_hrtimer_activate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "417-421",
    "snippet": "static inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_object_activate(timer, &hrtimer_debug_descr);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_activate",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_activate(struct hrtimer *timer,\n\t\t\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_object_activate(timer, &hrtimer_debug_descr);\n}"
  },
  {
    "function_name": "debug_hrtimer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "412-415",
    "snippet": "static inline void debug_hrtimer_init(struct hrtimer *timer)\n{\n\tdebug_object_init(timer, &hrtimer_debug_descr);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_init",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline void debug_hrtimer_init(struct hrtimer *timer)\n{\n\tdebug_object_init(timer, &hrtimer_debug_descr);\n}"
  },
  {
    "function_name": "hrtimer_fixup_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "390-402",
    "snippet": "static bool hrtimer_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_free(timer, &hrtimer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "timer"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic bool hrtimer_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_free(timer, &hrtimer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "hrtimer_fixup_activate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "375-384",
    "snippet": "static bool hrtimer_fixup_activate(void *addr, enum debug_obj_state state)\n{\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic bool hrtimer_fixup_activate(void *addr, enum debug_obj_state state)\n{\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "hrtimer_fixup_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "356-368",
    "snippet": "static bool hrtimer_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_init(timer, &hrtimer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_init",
          "args": [
            "timer",
            "&hrtimer_debug_descr"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "timer"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic bool hrtimer_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_init(timer, &hrtimer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "hrtimer_debug_hint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "347-350",
    "snippet": "static void *hrtimer_debug_hint(void *addr)\n{\n\treturn ((struct hrtimer *) addr)->function;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic void *hrtimer_debug_hint(void *addr)\n{\n\treturn ((struct hrtimer *) addr)->function;\n}"
  },
  {
    "function_name": "ktime_add_safe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "327-339",
    "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "KTIME_SEC_MAX",
            "0"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_unsafe",
          "args": [
            "lhs",
            "rhs"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
  },
  {
    "function_name": "__ktime_divns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "303-320",
    "snippet": "s64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (u32) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "(u32) div"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "kt"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\ns64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (u32) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}"
  },
  {
    "function_name": "lock_hrtimer_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "281-289",
    "snippet": "static inline struct hrtimer_clock_base *\nlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base = timer->base;\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\n\treturn base;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&base->cpu_base->lock",
            "*flags"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline struct hrtimer_clock_base *\nlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base = timer->base;\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\n\treturn base;\n}"
  },
  {
    "function_name": "is_migration_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "276-279",
    "snippet": "static inline bool is_migration_base(struct hrtimer_clock_base *base)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic inline bool is_migration_base(struct hrtimer_clock_base *base)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "switch_hrtimer_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "224-272",
    "snippet": "static inline struct hrtimer_clock_base *\nswitch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t\t    int pinned)\n{\n\tstruct hrtimer_cpu_base *new_cpu_base, *this_cpu_base;\n\tstruct hrtimer_clock_base *new_base;\n\tint basenum = base->index;\n\n\tthis_cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tnew_cpu_base = get_target_base(this_cpu_base, pinned);\nagain:\n\tnew_base = &new_cpu_base->clock_base[basenum];\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to move timer to new_base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * so we keep it on the same CPU. No hassle vs. reprogramming\n\t\t * the event source in the high resolution case. The softirq\n\t\t * code will take care of this when the timer function has\n\t\t * completed. There is no conflict as we hold the lock until\n\t\t * the timer is enqueued.\n\t\t */\n\t\tif (unlikely(hrtimer_callback_running(timer)))\n\t\t\treturn base;\n\n\t\t/* See the comment in lock_hrtimer_base() */\n\t\tWRITE_ONCE(timer->base, &migration_base);\n\t\traw_spin_unlock(&base->cpu_base->lock);\n\t\traw_spin_lock(&new_base->cpu_base->lock);\n\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traw_spin_lock(&base->cpu_base->lock);\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tWRITE_ONCE(timer->base, base);\n\t\t\tgoto again;\n\t\t}\n\t\tWRITE_ONCE(timer->base, new_base);\n\t} else {\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn new_base;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define migration_base\tmigration_cpu_base.clock_base[0]"
    ],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_check_target",
          "args": [
            "timer",
            "new_base"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_check_target",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "192-199",
          "snippet": "static int\nhrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)\n{\n\tktime_t expires;\n\n\texpires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);\n\treturn expires < new_base->cpu_base->expires_next;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int\nhrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)\n{\n\tktime_t expires;\n\n\texpires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);\n\treturn expires < new_base->cpu_base->expires_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "timer->base",
            "new_base"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "timer->base",
            "base"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&base->cpu_base->lock"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&new_base->cpu_base->lock"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "timer->base",
            "&migration_base"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "hrtimer_callback_running(timer)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_callback_running",
          "args": [
            "timer"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_target_base",
          "args": [
            "this_cpu_base",
            "pinned"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "get_target_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "201-210",
          "snippet": "static inline\nstruct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base,\n\t\t\t\t\t int pinned)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) && !pinned)\n\t\treturn &per_cpu(hrtimer_bases, get_nohz_timer_target());\n#endif\n\treturn base;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline\nstruct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base,\n\t\t\t\t\t int pinned)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) && !pinned)\n\t\treturn &per_cpu(hrtimer_bases, get_nohz_timer_target());\n#endif\n\treturn base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&hrtimer_bases"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define migration_base\tmigration_cpu_base.clock_base[0]\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline struct hrtimer_clock_base *\nswitch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t\t    int pinned)\n{\n\tstruct hrtimer_cpu_base *new_cpu_base, *this_cpu_base;\n\tstruct hrtimer_clock_base *new_base;\n\tint basenum = base->index;\n\n\tthis_cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tnew_cpu_base = get_target_base(this_cpu_base, pinned);\nagain:\n\tnew_base = &new_cpu_base->clock_base[basenum];\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to move timer to new_base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * so we keep it on the same CPU. No hassle vs. reprogramming\n\t\t * the event source in the high resolution case. The softirq\n\t\t * code will take care of this when the timer function has\n\t\t * completed. There is no conflict as we hold the lock until\n\t\t * the timer is enqueued.\n\t\t */\n\t\tif (unlikely(hrtimer_callback_running(timer)))\n\t\t\treturn base;\n\n\t\t/* See the comment in lock_hrtimer_base() */\n\t\tWRITE_ONCE(timer->base, &migration_base);\n\t\traw_spin_unlock(&base->cpu_base->lock);\n\t\traw_spin_lock(&new_base->cpu_base->lock);\n\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traw_spin_lock(&base->cpu_base->lock);\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tWRITE_ONCE(timer->base, base);\n\t\t\tgoto again;\n\t\t}\n\t\tWRITE_ONCE(timer->base, new_base);\n\t} else {\n\t\tif (new_cpu_base != this_cpu_base &&\n\t\t    hrtimer_check_target(timer, new_base)) {\n\t\t\tnew_cpu_base = this_cpu_base;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn new_base;\n}"
  },
  {
    "function_name": "get_target_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "201-210",
    "snippet": "static inline\nstruct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base,\n\t\t\t\t\t int pinned)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) && !pinned)\n\t\treturn &per_cpu(hrtimer_bases, get_nohz_timer_target());\n#endif\n\treturn base;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "hrtimer_bases",
            "get_nohz_timer_target()"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nohz_timer_target",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "get_nohz_timer_target",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "1021-1054",
          "snippet": "int get_nohz_timer_target(void)\n{\n\tint i, cpu = smp_processor_id(), default_cpu = -1;\n\tstruct sched_domain *sd;\n\tconst struct cpumask *hk_mask;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TIMER)) {\n\t\tif (!idle_cpu(cpu))\n\t\t\treturn cpu;\n\t\tdefault_cpu = cpu;\n\t}\n\n\thk_mask = housekeeping_cpumask(HK_FLAG_TIMER);\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tfor_each_cpu_and(i, sched_domain_span(sd), hk_mask) {\n\t\t\tif (cpu == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (!idle_cpu(i)) {\n\t\t\t\tcpu = i;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (default_cpu == -1)\n\t\tdefault_cpu = housekeeping_any_cpu(HK_FLAG_TIMER);\n\tcpu = default_cpu;\nunlock:\n\trcu_read_unlock();\n\treturn cpu;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "int i;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\nint i;\n\nint get_nohz_timer_target(void)\n{\n\tint i, cpu = smp_processor_id(), default_cpu = -1;\n\tstruct sched_domain *sd;\n\tconst struct cpumask *hk_mask;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TIMER)) {\n\t\tif (!idle_cpu(cpu))\n\t\t\treturn cpu;\n\t\tdefault_cpu = cpu;\n\t}\n\n\thk_mask = housekeeping_cpumask(HK_FLAG_TIMER);\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tfor_each_cpu_and(i, sched_domain_span(sd), hk_mask) {\n\t\t\tif (cpu == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (!idle_cpu(i)) {\n\t\t\t\tcpu = i;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (default_cpu == -1)\n\t\tdefault_cpu = housekeeping_any_cpu(HK_FLAG_TIMER);\n\tcpu = default_cpu;\nunlock:\n\trcu_read_unlock();\n\treturn cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&timers_migration_enabled"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nstatic inline\nstruct hrtimer_cpu_base *get_target_base(struct hrtimer_cpu_base *base,\n\t\t\t\t\t int pinned)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) && !pinned)\n\t\treturn &per_cpu(hrtimer_bases, get_nohz_timer_target());\n#endif\n\treturn base;\n}"
  },
  {
    "function_name": "hrtimer_check_target",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "192-199",
    "snippet": "static int\nhrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)\n{\n\tktime_t expires;\n\n\texpires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);\n\treturn expires < new_base->cpu_base->expires_next;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "hrtimer_get_expires(timer)",
            "new_base->offset"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic int\nhrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)\n{\n\tktime_t expires;\n\n\texpires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);\n\treturn expires < new_base->cpu_base->expires_next;\n}"
  },
  {
    "function_name": "lock_hrtimer_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "164-181",
    "snippet": "static\nstruct hrtimer_clock_base *lock_hrtimer_base(const struct hrtimer *timer,\n\t\t\t\t\t     unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base;\n\n\tfor (;;) {\n\t\tbase = READ_ONCE(timer->base);\n\t\tif (likely(base != &migration_base)) {\n\t\t\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\t\t\tif (likely(base == timer->base))\n\t\t\t\treturn base;\n\t\t\t/* The timer has migrated to another CPU: */\n\t\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define migration_base\tmigration_cpu_base.clock_base[0]"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&base->cpu_base->lock",
            "*flags"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "base == timer->base"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&base->cpu_base->lock",
            "*flags"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "base != &migration_base"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "timer->base"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define migration_base\tmigration_cpu_base.clock_base[0]\n\nstatic\nstruct hrtimer_clock_base *lock_hrtimer_base(const struct hrtimer *timer,\n\t\t\t\t\t     unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base;\n\n\tfor (;;) {\n\t\tbase = READ_ONCE(timer->base);\n\t\tif (likely(base != &migration_base)) {\n\t\t\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\t\t\tif (likely(base == timer->base))\n\t\t\t\treturn base;\n\t\t\t/* The timer has migrated to another CPU: */\n\t\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}"
  },
  {
    "function_name": "is_migration_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "147-150",
    "snippet": "static inline bool is_migration_base(struct hrtimer_clock_base *base)\n{\n\treturn base == &migration_base;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define migration_base\tmigration_cpu_base.clock_base[0]"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define migration_base\tmigration_cpu_base.clock_base[0]\n\nstatic inline bool is_migration_base(struct hrtimer_clock_base *base)\n{\n\treturn base == &migration_base;\n}"
  },
  {
    "function_name": "nanosleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2118-2133",
    "snippet": "SYSCALL_DEFINE2(nanosleep, struct __kernel_timespec __user *, rqtp,\n\t\tstruct __kernel_timespec __user *, rmtp)\n{\n\tstruct timespec64 tu;\n\n\tif (get_timespec64(&tu, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&tu))\n\t\treturn -EINVAL;\n\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;\n\tcurrent->restart_block.nanosleep.rmtp = rmtp;\n\treturn hrtimer_nanosleep(timespec64_to_ktime(tu), HRTIMER_MODE_REL,\n\t\t\t\t CLOCK_MONOTONIC);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nSYSCALL_DEFINE2(nanosleep, struct __kernel_timespec __user *, rqtp,\n\t\tstruct __kernel_timespec __user *, rmtp)\n{\n\tstruct timespec64 tu;\n\n\tif (get_timespec64(&tu, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&tu))\n\t\treturn -EINVAL;\n\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;\n\tcurrent->restart_block.nanosleep.rmtp = rmtp;\n\treturn hrtimer_nanosleep(timespec64_to_ktime(tu), HRTIMER_MODE_REL,\n\t\t\t\t CLOCK_MONOTONIC);\n}"
  },
  {
    "function_name": "nanosleep_time32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
    "lines": "2139-2154",
    "snippet": "SYSCALL_DEFINE2(nanosleep_time32, struct old_timespec32 __user *, rqtp,\n\t\t       struct old_timespec32 __user *, rmtp)\n{\n\tstruct timespec64 tu;\n\n\tif (get_old_timespec32(&tu, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&tu))\n\t\treturn -EINVAL;\n\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;\n\tcurrent->restart_block.nanosleep.compat_rmtp = rmtp;\n\treturn hrtimer_nanosleep(timespec64_to_ktime(tu), HRTIMER_MODE_REL,\n\t\t\t\t CLOCK_MONOTONIC);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <trace/events/timer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/timer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/err.h>",
      "#include <linux/tick.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nSYSCALL_DEFINE2(nanosleep_time32, struct old_timespec32 __user *, rqtp,\n\t\t       struct old_timespec32 __user *, rmtp)\n{\n\tstruct timespec64 tu;\n\n\tif (get_old_timespec32(&tu, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&tu))\n\t\treturn -EINVAL;\n\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;\n\tcurrent->restart_block.nanosleep.compat_rmtp = rmtp;\n\treturn hrtimer_nanosleep(timespec64_to_ktime(tu), HRTIMER_MODE_REL,\n\t\t\t\t CLOCK_MONOTONIC);\n}"
  }
]