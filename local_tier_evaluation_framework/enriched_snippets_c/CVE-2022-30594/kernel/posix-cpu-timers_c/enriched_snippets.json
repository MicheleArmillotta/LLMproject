[
  {
    "function_name": "thread_cpu_timer_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1605-1609",
    "snippet": "static int thread_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = THREAD_CLOCK;\n\treturn posix_cpu_timer_create(timer);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_timer_create",
          "args": [
            "timer"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "381-409",
          "snippet": "static int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tstatic struct lock_class_key posix_cpu_timers_key;\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = pid_for_clock(new_timer->it_clock, false);\n\tif (!pid) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If posix timer expiry is handled in task work context then\n\t * timer::it_lock can be taken without disabling interrupts as all\n\t * other locking happens in task context. This requires a separate\n\t * lock class key otherwise regular posix timer expiry would record\n\t * the lock class being taken in interrupt context and generate a\n\t * false positive warning.\n\t */\n\tif (IS_ENABLED(CONFIG_POSIX_CPU_TIMERS_TASK_WORK))\n\t\tlockdep_set_class(&new_timer->it_lock, &posix_cpu_timers_key);\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\ttimerqueue_init(&new_timer->it.cpu.node);\n\tnew_timer->it.cpu.pid = get_pid(pid);\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "const struct k_clock clock_posix_cpu = {\n\t.clock_getres\t\t= posix_cpu_clock_getres,\n\t.clock_set\t\t= posix_cpu_clock_set,\n\t.clock_get_timespec\t= posix_cpu_clock_get,\n\t.timer_create\t\t= posix_cpu_timer_create,\n\t.nsleep\t\t\t= posix_cpu_nsleep,\n\t.timer_set\t\t= posix_cpu_timer_set,\n\t.timer_del\t\t= posix_cpu_timer_del,\n\t.timer_get\t\t= posix_cpu_timer_get,\n\t.timer_rearm\t\t= posix_cpu_timer_rearm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nconst struct k_clock clock_posix_cpu = {\n\t.clock_getres\t\t= posix_cpu_clock_getres,\n\t.clock_set\t\t= posix_cpu_clock_set,\n\t.clock_get_timespec\t= posix_cpu_clock_get,\n\t.timer_create\t\t= posix_cpu_timer_create,\n\t.nsleep\t\t\t= posix_cpu_nsleep,\n\t.timer_set\t\t= posix_cpu_timer_set,\n\t.timer_del\t\t= posix_cpu_timer_del,\n\t.timer_get\t\t= posix_cpu_timer_get,\n\t.timer_rearm\t\t= posix_cpu_timer_rearm,\n};\n\nstatic int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tstatic struct lock_class_key posix_cpu_timers_key;\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = pid_for_clock(new_timer->it_clock, false);\n\tif (!pid) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If posix timer expiry is handled in task work context then\n\t * timer::it_lock can be taken without disabling interrupts as all\n\t * other locking happens in task context. This requires a separate\n\t * lock class key otherwise regular posix timer expiry would record\n\t * the lock class being taken in interrupt context and generate a\n\t * false positive warning.\n\t */\n\tif (IS_ENABLED(CONFIG_POSIX_CPU_TIMERS_TASK_WORK))\n\t\tlockdep_set_class(&new_timer->it_lock, &posix_cpu_timers_key);\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\ttimerqueue_init(&new_timer->it.cpu.node);\n\tnew_timer->it.cpu.pid = get_pid(pid);\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int thread_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = THREAD_CLOCK;\n\treturn posix_cpu_timer_create(timer);\n}"
  },
  {
    "function_name": "thread_cpu_clock_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1600-1604",
    "snippet": "static int thread_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\tstruct timespec64 *tp)\n{\n\treturn posix_cpu_clock_get(THREAD_CLOCK, tp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_clock_get",
          "args": [
            "THREAD_CLOCK",
            "tp"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_clock_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "353-374",
          "snippet": "static int posix_cpu_clock_get(const clockid_t clock, struct timespec64 *tp)\n{\n\tconst clockid_t clkid = CPUCLOCK_WHICH(clock);\n\tstruct task_struct *tsk;\n\tu64 t;\n\n\trcu_read_lock();\n\ttsk = pid_task(pid_for_clock(clock, true), clock_pid_type(clock));\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (CPUCLOCK_PERTHREAD(clock))\n\t\tt = cpu_clock_sample(clkid, tsk);\n\telse\n\t\tt = cpu_clock_sample_group(clkid, tsk, false);\n\trcu_read_unlock();\n\n\t*tp = ns_to_timespec64(t);\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic int posix_cpu_clock_get(const clockid_t clock, struct timespec64 *tp)\n{\n\tconst clockid_t clkid = CPUCLOCK_WHICH(clock);\n\tstruct task_struct *tsk;\n\tu64 t;\n\n\trcu_read_lock();\n\ttsk = pid_task(pid_for_clock(clock, true), clock_pid_type(clock));\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (CPUCLOCK_PERTHREAD(clock))\n\t\tt = cpu_clock_sample(clkid, tsk);\n\telse\n\t\tt = cpu_clock_sample_group(clkid, tsk, false);\n\trcu_read_unlock();\n\n\t*tp = ns_to_timespec64(t);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic int thread_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\tstruct timespec64 *tp)\n{\n\treturn posix_cpu_clock_get(THREAD_CLOCK, tp);\n}"
  },
  {
    "function_name": "thread_cpu_clock_getres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1595-1599",
    "snippet": "static int thread_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t   struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_getres(THREAD_CLOCK, tp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_clock_getres",
          "args": [
            "THREAD_CLOCK",
            "tp"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_clock_getres",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "153-171",
          "snippet": "static int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = validate_clock_permissions(which_clock);\n\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = validate_clock_permissions(which_clock);\n\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define THREAD_CLOCK\tmake_thread_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic int thread_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t   struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_getres(THREAD_CLOCK, tp);\n}"
  },
  {
    "function_name": "process_cpu_nsleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1590-1594",
    "snippet": "static int process_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *rqtp)\n{\n\treturn posix_cpu_nsleep(PROCESS_CLOCK, flags, rqtp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_nsleep",
          "args": [
            "PROCESS_CLOCK",
            "flags",
            "rqtp"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_nsleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1535-1560",
          "snippet": "static int posix_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct restart_block *restart_block = &current->restart_block;\n\tint error;\n\n\t/*\n\t * Diagnose required errors first.\n\t */\n\tif (CPUCLOCK_PERTHREAD(which_clock) &&\n\t    (CPUCLOCK_PID(which_clock) == 0 ||\n\t     CPUCLOCK_PID(which_clock) == task_pid_vnr(current)))\n\t\treturn -EINVAL;\n\n\terror = do_cpu_nanosleep(which_clock, flags, rqtp);\n\n\tif (error == -ERESTART_RESTARTBLOCK) {\n\n\t\tif (flags & TIMER_ABSTIME)\n\t\t\treturn -ERESTARTNOHAND;\n\n\t\trestart_block->nanosleep.clockid = which_clock;\n\t\tset_restart_fn(restart_block, posix_cpu_nsleep_restart);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int posix_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct restart_block *restart_block = &current->restart_block;\n\tint error;\n\n\t/*\n\t * Diagnose required errors first.\n\t */\n\tif (CPUCLOCK_PERTHREAD(which_clock) &&\n\t    (CPUCLOCK_PID(which_clock) == 0 ||\n\t     CPUCLOCK_PID(which_clock) == task_pid_vnr(current)))\n\t\treturn -EINVAL;\n\n\terror = do_cpu_nanosleep(which_clock, flags, rqtp);\n\n\tif (error == -ERESTART_RESTARTBLOCK) {\n\n\t\tif (flags & TIMER_ABSTIME)\n\t\t\treturn -ERESTARTNOHAND;\n\n\t\trestart_block->nanosleep.clockid = which_clock;\n\t\tset_restart_fn(restart_block, posix_cpu_nsleep_restart);\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic int process_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *rqtp)\n{\n\treturn posix_cpu_nsleep(PROCESS_CLOCK, flags, rqtp);\n}"
  },
  {
    "function_name": "process_cpu_timer_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1585-1589",
    "snippet": "static int process_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = PROCESS_CLOCK;\n\treturn posix_cpu_timer_create(timer);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_timer_create",
          "args": [
            "timer"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "381-409",
          "snippet": "static int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tstatic struct lock_class_key posix_cpu_timers_key;\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = pid_for_clock(new_timer->it_clock, false);\n\tif (!pid) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If posix timer expiry is handled in task work context then\n\t * timer::it_lock can be taken without disabling interrupts as all\n\t * other locking happens in task context. This requires a separate\n\t * lock class key otherwise regular posix timer expiry would record\n\t * the lock class being taken in interrupt context and generate a\n\t * false positive warning.\n\t */\n\tif (IS_ENABLED(CONFIG_POSIX_CPU_TIMERS_TASK_WORK))\n\t\tlockdep_set_class(&new_timer->it_lock, &posix_cpu_timers_key);\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\ttimerqueue_init(&new_timer->it.cpu.node);\n\tnew_timer->it.cpu.pid = get_pid(pid);\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "const struct k_clock clock_posix_cpu = {\n\t.clock_getres\t\t= posix_cpu_clock_getres,\n\t.clock_set\t\t= posix_cpu_clock_set,\n\t.clock_get_timespec\t= posix_cpu_clock_get,\n\t.timer_create\t\t= posix_cpu_timer_create,\n\t.nsleep\t\t\t= posix_cpu_nsleep,\n\t.timer_set\t\t= posix_cpu_timer_set,\n\t.timer_del\t\t= posix_cpu_timer_del,\n\t.timer_get\t\t= posix_cpu_timer_get,\n\t.timer_rearm\t\t= posix_cpu_timer_rearm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nconst struct k_clock clock_posix_cpu = {\n\t.clock_getres\t\t= posix_cpu_clock_getres,\n\t.clock_set\t\t= posix_cpu_clock_set,\n\t.clock_get_timespec\t= posix_cpu_clock_get,\n\t.timer_create\t\t= posix_cpu_timer_create,\n\t.nsleep\t\t\t= posix_cpu_nsleep,\n\t.timer_set\t\t= posix_cpu_timer_set,\n\t.timer_del\t\t= posix_cpu_timer_del,\n\t.timer_get\t\t= posix_cpu_timer_get,\n\t.timer_rearm\t\t= posix_cpu_timer_rearm,\n};\n\nstatic int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tstatic struct lock_class_key posix_cpu_timers_key;\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = pid_for_clock(new_timer->it_clock, false);\n\tif (!pid) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If posix timer expiry is handled in task work context then\n\t * timer::it_lock can be taken without disabling interrupts as all\n\t * other locking happens in task context. This requires a separate\n\t * lock class key otherwise regular posix timer expiry would record\n\t * the lock class being taken in interrupt context and generate a\n\t * false positive warning.\n\t */\n\tif (IS_ENABLED(CONFIG_POSIX_CPU_TIMERS_TASK_WORK))\n\t\tlockdep_set_class(&new_timer->it_lock, &posix_cpu_timers_key);\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\ttimerqueue_init(&new_timer->it.cpu.node);\n\tnew_timer->it.cpu.pid = get_pid(pid);\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int process_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = PROCESS_CLOCK;\n\treturn posix_cpu_timer_create(timer);\n}"
  },
  {
    "function_name": "process_cpu_clock_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1580-1584",
    "snippet": "static int process_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\t struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_get(PROCESS_CLOCK, tp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_clock_get",
          "args": [
            "PROCESS_CLOCK",
            "tp"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_clock_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "353-374",
          "snippet": "static int posix_cpu_clock_get(const clockid_t clock, struct timespec64 *tp)\n{\n\tconst clockid_t clkid = CPUCLOCK_WHICH(clock);\n\tstruct task_struct *tsk;\n\tu64 t;\n\n\trcu_read_lock();\n\ttsk = pid_task(pid_for_clock(clock, true), clock_pid_type(clock));\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (CPUCLOCK_PERTHREAD(clock))\n\t\tt = cpu_clock_sample(clkid, tsk);\n\telse\n\t\tt = cpu_clock_sample_group(clkid, tsk, false);\n\trcu_read_unlock();\n\n\t*tp = ns_to_timespec64(t);\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic int posix_cpu_clock_get(const clockid_t clock, struct timespec64 *tp)\n{\n\tconst clockid_t clkid = CPUCLOCK_WHICH(clock);\n\tstruct task_struct *tsk;\n\tu64 t;\n\n\trcu_read_lock();\n\ttsk = pid_task(pid_for_clock(clock, true), clock_pid_type(clock));\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (CPUCLOCK_PERTHREAD(clock))\n\t\tt = cpu_clock_sample(clkid, tsk);\n\telse\n\t\tt = cpu_clock_sample_group(clkid, tsk, false);\n\trcu_read_unlock();\n\n\t*tp = ns_to_timespec64(t);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic int process_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\t struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_get(PROCESS_CLOCK, tp);\n}"
  },
  {
    "function_name": "process_cpu_clock_getres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1575-1579",
    "snippet": "static int process_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t    struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_getres(PROCESS_CLOCK, tp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_clock_getres",
          "args": [
            "PROCESS_CLOCK",
            "tp"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_clock_getres",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "153-171",
          "snippet": "static int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = validate_clock_permissions(which_clock);\n\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = validate_clock_permissions(which_clock);\n\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define PROCESS_CLOCK\tmake_process_cpuclock(0, CPUCLOCK_SCHED)\n\nstatic int process_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t    struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_getres(PROCESS_CLOCK, tp);\n}"
  },
  {
    "function_name": "posix_cpu_nsleep_restart",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1562-1570",
    "snippet": "static long posix_cpu_nsleep_restart(struct restart_block *restart_block)\n{\n\tclockid_t which_clock = restart_block->nanosleep.clockid;\n\tstruct timespec64 t;\n\n\tt = ns_to_timespec64(restart_block->nanosleep.expires);\n\n\treturn do_cpu_nanosleep(which_clock, TIMER_ABSTIME, &t);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_cpu_nanosleep",
          "args": [
            "which_clock",
            "TIMER_ABSTIME",
            "&t"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "do_cpu_nanosleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1437-1531",
          "snippet": "static int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (!cpu_timer_getexpires(&timer.it.cpu)) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = cpu_timer_getexpires(&timer.it.cpu);\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (!cpu_timer_getexpires(&timer.it.cpu)) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = cpu_timer_getexpires(&timer.it.cpu);\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "restart_block->nanosleep.expires"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "506-525",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block)\n{\n\tclockid_t which_clock = restart_block->nanosleep.clockid;\n\tstruct timespec64 t;\n\n\tt = ns_to_timespec64(restart_block->nanosleep.expires);\n\n\treturn do_cpu_nanosleep(which_clock, TIMER_ABSTIME, &t);\n}"
  },
  {
    "function_name": "posix_cpu_nsleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1535-1560",
    "snippet": "static int posix_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct restart_block *restart_block = &current->restart_block;\n\tint error;\n\n\t/*\n\t * Diagnose required errors first.\n\t */\n\tif (CPUCLOCK_PERTHREAD(which_clock) &&\n\t    (CPUCLOCK_PID(which_clock) == 0 ||\n\t     CPUCLOCK_PID(which_clock) == task_pid_vnr(current)))\n\t\treturn -EINVAL;\n\n\terror = do_cpu_nanosleep(which_clock, flags, rqtp);\n\n\tif (error == -ERESTART_RESTARTBLOCK) {\n\n\t\tif (flags & TIMER_ABSTIME)\n\t\t\treturn -ERESTARTNOHAND;\n\n\t\trestart_block->nanosleep.clockid = which_clock;\n\t\tset_restart_fn(restart_block, posix_cpu_nsleep_restart);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_restart_fn",
          "args": [
            "restart_block",
            "posix_cpu_nsleep_restart"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_cpu_nanosleep",
          "args": [
            "which_clock",
            "flags",
            "rqtp"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "do_cpu_nanosleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1437-1531",
          "snippet": "static int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (!cpu_timer_getexpires(&timer.it.cpu)) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = cpu_timer_getexpires(&timer.it.cpu);\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (!cpu_timer_getexpires(&timer.it.cpu)) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = cpu_timer_getexpires(&timer.it.cpu);\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PID",
          "args": [
            "which_clock"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PID",
          "args": [
            "which_clock"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "which_clock"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int posix_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct restart_block *restart_block = &current->restart_block;\n\tint error;\n\n\t/*\n\t * Diagnose required errors first.\n\t */\n\tif (CPUCLOCK_PERTHREAD(which_clock) &&\n\t    (CPUCLOCK_PID(which_clock) == 0 ||\n\t     CPUCLOCK_PID(which_clock) == task_pid_vnr(current)))\n\t\treturn -EINVAL;\n\n\terror = do_cpu_nanosleep(which_clock, flags, rqtp);\n\n\tif (error == -ERESTART_RESTARTBLOCK) {\n\n\t\tif (flags & TIMER_ABSTIME)\n\t\t\treturn -ERESTARTNOHAND;\n\n\t\trestart_block->nanosleep.clockid = which_clock;\n\t\tset_restart_fn(restart_block, posix_cpu_nsleep_restart);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "do_cpu_nanosleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1437-1531",
    "snippet": "static int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (!cpu_timer_getexpires(&timer.it.cpu)) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = cpu_timer_getexpires(&timer.it.cpu);\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "static long posix_cpu_nsleep_restart(struct restart_block *restart_block);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nanosleep_copyout",
          "args": [
            "restart",
            "&it.it_value"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "nanosleep_copyout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2016-2033",
          "snippet": "int nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&timer.it_lock"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_cpu_timer_del",
          "args": [
            "&timer"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_del",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "466-505",
          "snippet": "static int posix_cpu_timer_del(struct k_itimer *timer)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p)\n\t\tgoto out;\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and process/\n\t * thread timer list entry concurrent read/writes.\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL)) {\n\t\t/*\n\t\t * This raced with the reaping of the task. The exit cleanup\n\t\t * should have removed this timer from the timer queue.\n\t\t */\n\t\tWARN_ON_ONCE(ctmr->head || timerqueue_node_queued(&ctmr->node));\n\t} else {\n\t\tif (timer->it.cpu.firing)\n\t\t\tret = TIMER_RETRY;\n\t\telse\n\t\t\tdisarm_timer(timer, p);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\nout:\n\trcu_read_unlock();\n\tif (!ret)\n\t\tput_pid(ctmr->pid);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int posix_cpu_timer_del(struct k_itimer *timer)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p)\n\t\tgoto out;\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and process/\n\t * thread timer list entry concurrent read/writes.\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL)) {\n\t\t/*\n\t\t * This raced with the reaping of the task. The exit cleanup\n\t\t * should have removed this timer from the timer queue.\n\t\t */\n\t\tWARN_ON_ONCE(ctmr->head || timerqueue_node_queued(&ctmr->node));\n\t} else {\n\t\tif (timer->it.cpu.firing)\n\t\t\tret = TIMER_RETRY;\n\t\telse\n\t\t\tdisarm_timer(timer, p);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\nout:\n\trcu_read_unlock();\n\tif (!ret)\n\t\tput_pid(ctmr->pid);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&timer.it_lock"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_cpu_timer_set",
          "args": [
            "&timer",
            "0",
            "&zero_it",
            "&it"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "618-781",
          "snippet": "static int posix_cpu_timer_set(struct k_itimer *timer, int timer_flags,\n\t\t\t       struct itimerspec64 *new, struct itimerspec64 *old)\n{\n\tclockid_t clkid = CPUCLOCK_WHICH(timer->it_clock);\n\tu64 old_expires, new_expires, old_incr, val;\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p) {\n\t\t/*\n\t\t * If p has just been reaped, we can no\n\t\t * longer get any information about it at all.\n\t\t */\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnew_expires = ktime_to_ns(timespec64_to_ktime(new->it_value));\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and p->cpu_timers\n\t * and p->signal->cpu_timers read/write in arm_timer()\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\t/*\n\t * If p has just been reaped, we can no\n\t * longer get any information about it at all.\n\t */\n\tif (unlikely(sighand == NULL)) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Disarm any old timer after extracting its expiry time.\n\t */\n\told_incr = timer->it_interval;\n\told_expires = cpu_timer_getexpires(ctmr);\n\n\tif (unlikely(timer->it.cpu.firing)) {\n\t\ttimer->it.cpu.firing = -1;\n\t\tret = TIMER_RETRY;\n\t} else {\n\t\tcpu_timer_dequeue(ctmr);\n\t}\n\n\t/*\n\t * We need to sample the current value to convert the new\n\t * value from to relative and absolute, and to convert the\n\t * old value from absolute to relative.  To set a process\n\t * timer, we need a sample to balance the thread expiry\n\t * times (in arm_timer).  With an absolute time, we must\n\t * check if it's already passed.  In short, we need a sample.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\tval = cpu_clock_sample(clkid, p);\n\telse\n\t\tval = cpu_clock_sample_group(clkid, p, true);\n\n\tif (old) {\n\t\tif (old_expires == 0) {\n\t\t\told->it_value.tv_sec = 0;\n\t\t\told->it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Update the timer in case it has overrun already.\n\t\t\t * If it has, we'll report it as having overrun and\n\t\t\t * with the next reloaded timer already ticking,\n\t\t\t * though we are swallowing that pending\n\t\t\t * notification here to install the new setting.\n\t\t\t */\n\t\t\tu64 exp = bump_cpu_timer(timer, val);\n\n\t\t\tif (val < exp) {\n\t\t\t\told_expires = exp - val;\n\t\t\t\told->it_value = ns_to_timespec64(old_expires);\n\t\t\t} else {\n\t\t\t\told->it_value.tv_nsec = 1;\n\t\t\t\told->it_value.tv_sec = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * We are colliding with the timer actually firing.\n\t\t * Punt after filling in the timer's old value, and\n\t\t * disable this firing since we are already reporting\n\t\t * it as an overrun (thanks to bump_cpu_timer above).\n\t\t */\n\t\tunlock_task_sighand(p, &flags);\n\t\tgoto out;\n\t}\n\n\tif (new_expires != 0 && !(timer_flags & TIMER_ABSTIME)) {\n\t\tnew_expires += val;\n\t}\n\n\t/*\n\t * Install the new expiry time (or zero).\n\t * For a timer with no notification action, we don't actually\n\t * arm the timer (we'll just fake it for timer_gettime).\n\t */\n\tcpu_timer_setexpires(ctmr, new_expires);\n\tif (new_expires != 0 && val < new_expires) {\n\t\tarm_timer(timer, p);\n\t}\n\n\tunlock_task_sighand(p, &flags);\n\t/*\n\t * Install the new reload setting, and\n\t * set up the signal and overrun bookkeeping.\n\t */\n\ttimer->it_interval = timespec64_to_ktime(new->it_interval);\n\n\t/*\n\t * This acts as a modification timestamp for the timer,\n\t * so any automatic reload attempt will punt on seeing\n\t * that we have reset the timer manually.\n\t */\n\ttimer->it_requeue_pending = (timer->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimer->it_overrun_last = 0;\n\ttimer->it_overrun = -1;\n\n\tif (val >= new_expires) {\n\t\tif (new_expires != 0) {\n\t\t\t/*\n\t\t\t * The designated time already passed, so we notify\n\t\t\t * immediately, even if the thread never runs to\n\t\t\t * accumulate more time on this clock.\n\t\t\t */\n\t\t\tcpu_timer_fire(timer);\n\t\t}\n\n\t\t/*\n\t\t * Make sure we don't keep around the process wide cputime\n\t\t * counter or the tick dependency if they are not necessary.\n\t\t */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (!sighand)\n\t\t\tgoto out;\n\n\t\tif (!cpu_timer_queued(ctmr))\n\t\t\ttrigger_base_recalc_expires(timer, p);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n out:\n\trcu_read_unlock();\n\tif (old)\n\t\told->it_interval = ns_to_timespec64(old_incr);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int posix_cpu_timer_set(struct k_itimer *timer, int timer_flags,\n\t\t\t       struct itimerspec64 *new, struct itimerspec64 *old)\n{\n\tclockid_t clkid = CPUCLOCK_WHICH(timer->it_clock);\n\tu64 old_expires, new_expires, old_incr, val;\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p) {\n\t\t/*\n\t\t * If p has just been reaped, we can no\n\t\t * longer get any information about it at all.\n\t\t */\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnew_expires = ktime_to_ns(timespec64_to_ktime(new->it_value));\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and p->cpu_timers\n\t * and p->signal->cpu_timers read/write in arm_timer()\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\t/*\n\t * If p has just been reaped, we can no\n\t * longer get any information about it at all.\n\t */\n\tif (unlikely(sighand == NULL)) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Disarm any old timer after extracting its expiry time.\n\t */\n\told_incr = timer->it_interval;\n\told_expires = cpu_timer_getexpires(ctmr);\n\n\tif (unlikely(timer->it.cpu.firing)) {\n\t\ttimer->it.cpu.firing = -1;\n\t\tret = TIMER_RETRY;\n\t} else {\n\t\tcpu_timer_dequeue(ctmr);\n\t}\n\n\t/*\n\t * We need to sample the current value to convert the new\n\t * value from to relative and absolute, and to convert the\n\t * old value from absolute to relative.  To set a process\n\t * timer, we need a sample to balance the thread expiry\n\t * times (in arm_timer).  With an absolute time, we must\n\t * check if it's already passed.  In short, we need a sample.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\tval = cpu_clock_sample(clkid, p);\n\telse\n\t\tval = cpu_clock_sample_group(clkid, p, true);\n\n\tif (old) {\n\t\tif (old_expires == 0) {\n\t\t\told->it_value.tv_sec = 0;\n\t\t\told->it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Update the timer in case it has overrun already.\n\t\t\t * If it has, we'll report it as having overrun and\n\t\t\t * with the next reloaded timer already ticking,\n\t\t\t * though we are swallowing that pending\n\t\t\t * notification here to install the new setting.\n\t\t\t */\n\t\t\tu64 exp = bump_cpu_timer(timer, val);\n\n\t\t\tif (val < exp) {\n\t\t\t\told_expires = exp - val;\n\t\t\t\told->it_value = ns_to_timespec64(old_expires);\n\t\t\t} else {\n\t\t\t\told->it_value.tv_nsec = 1;\n\t\t\t\told->it_value.tv_sec = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * We are colliding with the timer actually firing.\n\t\t * Punt after filling in the timer's old value, and\n\t\t * disable this firing since we are already reporting\n\t\t * it as an overrun (thanks to bump_cpu_timer above).\n\t\t */\n\t\tunlock_task_sighand(p, &flags);\n\t\tgoto out;\n\t}\n\n\tif (new_expires != 0 && !(timer_flags & TIMER_ABSTIME)) {\n\t\tnew_expires += val;\n\t}\n\n\t/*\n\t * Install the new expiry time (or zero).\n\t * For a timer with no notification action, we don't actually\n\t * arm the timer (we'll just fake it for timer_gettime).\n\t */\n\tcpu_timer_setexpires(ctmr, new_expires);\n\tif (new_expires != 0 && val < new_expires) {\n\t\tarm_timer(timer, p);\n\t}\n\n\tunlock_task_sighand(p, &flags);\n\t/*\n\t * Install the new reload setting, and\n\t * set up the signal and overrun bookkeeping.\n\t */\n\ttimer->it_interval = timespec64_to_ktime(new->it_interval);\n\n\t/*\n\t * This acts as a modification timestamp for the timer,\n\t * so any automatic reload attempt will punt on seeing\n\t * that we have reset the timer manually.\n\t */\n\ttimer->it_requeue_pending = (timer->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimer->it_overrun_last = 0;\n\ttimer->it_overrun = -1;\n\n\tif (val >= new_expires) {\n\t\tif (new_expires != 0) {\n\t\t\t/*\n\t\t\t * The designated time already passed, so we notify\n\t\t\t * immediately, even if the thread never runs to\n\t\t\t * accumulate more time on this clock.\n\t\t\t */\n\t\t\tcpu_timer_fire(timer);\n\t\t}\n\n\t\t/*\n\t\t * Make sure we don't keep around the process wide cputime\n\t\t * counter or the tick dependency if they are not necessary.\n\t\t */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (!sighand)\n\t\t\tgoto out;\n\n\t\tif (!cpu_timer_queued(ctmr))\n\t\t\ttrigger_base_recalc_expires(timer, p);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n out:\n\trcu_read_unlock();\n\tif (old)\n\t\told->it_interval = ns_to_timespec64(old_incr);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_getexpires",
          "args": [
            "&timer.it.cpu"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_getexpires",
          "args": [
            "&timer.it.cpu"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&it",
            "0",
            "sizeof(it)"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_cpu_timer_create",
          "args": [
            "&timer"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "381-409",
          "snippet": "static int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tstatic struct lock_class_key posix_cpu_timers_key;\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = pid_for_clock(new_timer->it_clock, false);\n\tif (!pid) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If posix timer expiry is handled in task work context then\n\t * timer::it_lock can be taken without disabling interrupts as all\n\t * other locking happens in task context. This requires a separate\n\t * lock class key otherwise regular posix timer expiry would record\n\t * the lock class being taken in interrupt context and generate a\n\t * false positive warning.\n\t */\n\tif (IS_ENABLED(CONFIG_POSIX_CPU_TIMERS_TASK_WORK))\n\t\tlockdep_set_class(&new_timer->it_lock, &posix_cpu_timers_key);\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\ttimerqueue_init(&new_timer->it.cpu.node);\n\tnew_timer->it.cpu.pid = get_pid(pid);\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "const struct k_clock clock_posix_cpu = {\n\t.clock_getres\t\t= posix_cpu_clock_getres,\n\t.clock_set\t\t= posix_cpu_clock_set,\n\t.clock_get_timespec\t= posix_cpu_clock_get,\n\t.timer_create\t\t= posix_cpu_timer_create,\n\t.nsleep\t\t\t= posix_cpu_nsleep,\n\t.timer_set\t\t= posix_cpu_timer_set,\n\t.timer_del\t\t= posix_cpu_timer_del,\n\t.timer_get\t\t= posix_cpu_timer_get,\n\t.timer_rearm\t\t= posix_cpu_timer_rearm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nconst struct k_clock clock_posix_cpu = {\n\t.clock_getres\t\t= posix_cpu_clock_getres,\n\t.clock_set\t\t= posix_cpu_clock_set,\n\t.clock_get_timespec\t= posix_cpu_clock_get,\n\t.timer_create\t\t= posix_cpu_timer_create,\n\t.nsleep\t\t\t= posix_cpu_nsleep,\n\t.timer_set\t\t= posix_cpu_timer_set,\n\t.timer_del\t\t= posix_cpu_timer_del,\n\t.timer_get\t\t= posix_cpu_timer_get,\n\t.timer_rearm\t\t= posix_cpu_timer_rearm,\n};\n\nstatic int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tstatic struct lock_class_key posix_cpu_timers_key;\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = pid_for_clock(new_timer->it_clock, false);\n\tif (!pid) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If posix timer expiry is handled in task work context then\n\t * timer::it_lock can be taken without disabling interrupts as all\n\t * other locking happens in task context. This requires a separate\n\t * lock class key otherwise regular posix timer expiry would record\n\t * the lock class being taken in interrupt context and generate a\n\t * false positive warning.\n\t */\n\tif (IS_ENABLED(CONFIG_POSIX_CPU_TIMERS_TASK_WORK))\n\t\tlockdep_set_class(&new_timer->it_lock, &posix_cpu_timers_key);\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\ttimerqueue_init(&new_timer->it.cpu.node);\n\tnew_timer->it.cpu.pid = get_pid(pid);\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&timer.it_lock"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&timer",
            "0",
            "sizeof timer"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    const struct timespec64 *rqtp)\n{\n\tstruct itimerspec64 it;\n\tstruct k_itimer timer;\n\tu64 expires;\n\tint error;\n\n\t/*\n\t * Set up a temporary timer and then wait for it to go off.\n\t */\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\n\tif (!error) {\n\t\tstatic struct itimerspec64 zero_it;\n\t\tstruct restart_block *restart;\n\n\t\tmemset(&it, 0, sizeof(it));\n\t\tit.it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, &it, NULL);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (!cpu_timer_getexpires(&timer.it.cpu)) {\n\t\t\t\t/*\n\t\t\t\t * Our timer fired and was reset, below\n\t\t\t\t * deletion can not fail.\n\t\t\t\t */\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Block until cpu_timer_fire (or a signal) wakes us.\n\t\t\t */\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t/*\n\t\t * We were interrupted by a signal.\n\t\t */\n\t\texpires = cpu_timer_getexpires(&timer.it.cpu);\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, &it);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Timer is now unarmed, deletion can not fail.\n\t\t\t */\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == TIMER_RETRY) {\n\t\t\t/*\n\t\t\t * We need to handle case when timer was or is in the\n\t\t\t * middle of firing. In other cases we already freed\n\t\t\t * resources.\n\t\t\t */\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it.it_value.tv_sec | it.it_value.tv_nsec) == 0) {\n\t\t\t/*\n\t\t\t * It actually did fire already.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -ERESTART_RESTARTBLOCK;\n\t\t/*\n\t\t * Report back to the user the time still remaining.\n\t\t */\n\t\trestart = &current->restart_block;\n\t\trestart->nanosleep.expires = expires;\n\t\tif (restart->nanosleep.type != TT_NONE)\n\t\t\terror = nanosleep_copyout(restart, &it.it_value);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "set_process_cpu_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1397-1435",
    "snippet": "void set_process_cpu_timer(struct task_struct *tsk, unsigned int clkid,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now, *nextevt;\n\n\tif (WARN_ON_ONCE(clkid >= CPUCLOCK_SCHED))\n\t\treturn;\n\n\tnextevt = &tsk->signal->posix_cputimers.bases[clkid].nextevt;\n\tnow = cpu_clock_sample_group(clkid, tsk, true);\n\n\tif (oldval) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (*newval)\n\t\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if this is the earliest timer. CPUCLOCK_PROF\n\t * expiry cache is also used by RLIMIT_CPU!.\n\t */\n\tif (*newval < *nextevt)\n\t\t*nextevt = *newval;\n\n\ttick_dep_set_signal(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_set_signal",
          "args": [
            "tsk",
            "TICK_DEP_BIT_POSIX_TIMER"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample_group",
          "args": [
            "clkid",
            "tsk",
            "true"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "334-351",
          "snippet": "static u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "clkid >= CPUCLOCK_SCHED"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nvoid set_process_cpu_timer(struct task_struct *tsk, unsigned int clkid,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now, *nextevt;\n\n\tif (WARN_ON_ONCE(clkid >= CPUCLOCK_SCHED))\n\t\treturn;\n\n\tnextevt = &tsk->signal->posix_cputimers.bases[clkid].nextevt;\n\tnow = cpu_clock_sample_group(clkid, tsk, true);\n\n\tif (oldval) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (*newval)\n\t\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if this is the earliest timer. CPUCLOCK_PROF\n\t * expiry cache is also used by RLIMIT_CPU!.\n\t */\n\tif (*newval < *nextevt)\n\t\t*nextevt = *newval;\n\n\ttick_dep_set_signal(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}"
  },
  {
    "function_name": "run_posix_cpu_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1370-1391",
    "snippet": "void run_posix_cpu_timers(void)\n{\n\tstruct task_struct *tsk = current;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * If the actual expiry is deferred to task work context and the\n\t * work is already scheduled there is no point to do anything here.\n\t */\n\tif (posix_cpu_timers_work_scheduled(tsk))\n\t\treturn;\n\n\t/*\n\t * The fast path checks that there are no expired thread or thread\n\t * group timers.  If that's so, just return.\n\t */\n\tif (!fastpath_timer_check(tsk))\n\t\treturn;\n\n\t__run_posix_cpu_timers(tsk);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__run_posix_cpu_timers",
          "args": [
            "tsk"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "__run_posix_cpu_timers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1246-1251",
          "snippet": "static inline void __run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tlockdep_posixtimer_enter();\n\thandle_posix_cpu_timers(tsk);\n\tlockdep_posixtimer_exit();\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline void __run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tlockdep_posixtimer_enter();\n\thandle_posix_cpu_timers(tsk);\n\tlockdep_posixtimer_exit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fastpath_timer_check",
          "args": [
            "tsk"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "fastpath_timer_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1108-1152",
          "snippet": "static inline bool fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct posix_cputimers *pct = &tsk->posix_cputimers;\n\tstruct signal_struct *sig;\n\n\tif (!expiry_cache_is_inactive(pct)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\ttask_sample_cputime(tsk, samples);\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tsig = tsk->signal;\n\tpct = &sig->posix_cputimers;\n\t/*\n\t * Check if thread group timers expired when timers are active and\n\t * no other thread in the group is already handling expiry for\n\t * thread group cputimers. These fields are read without the\n\t * sighand lock. However, this is fine because this is meant to be\n\t * a fastpath heuristic to determine whether we should try to\n\t * acquire the sighand lock to handle timer expiry.\n\t *\n\t * In the worst case scenario, if concurrently timers_active is set\n\t * or expiry_active is cleared, but the current thread doesn't see\n\t * the change yet, the timer checks are delayed until the next\n\t * thread in the group gets a scheduler interrupt to handle the\n\t * timer. This isn't an issue in practice because these types of\n\t * delays with signals actually getting sent are expected.\n\t */\n\tif (READ_ONCE(pct->timers_active) && !READ_ONCE(pct->expiry_active)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\tproc_sample_cputime_atomic(&sig->cputimer.cputime_atomic,\n\t\t\t\t\t   samples);\n\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tif (dl_task(tsk) && tsk->dl.dl_overrun)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline bool fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct posix_cputimers *pct = &tsk->posix_cputimers;\n\tstruct signal_struct *sig;\n\n\tif (!expiry_cache_is_inactive(pct)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\ttask_sample_cputime(tsk, samples);\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tsig = tsk->signal;\n\tpct = &sig->posix_cputimers;\n\t/*\n\t * Check if thread group timers expired when timers are active and\n\t * no other thread in the group is already handling expiry for\n\t * thread group cputimers. These fields are read without the\n\t * sighand lock. However, this is fine because this is meant to be\n\t * a fastpath heuristic to determine whether we should try to\n\t * acquire the sighand lock to handle timer expiry.\n\t *\n\t * In the worst case scenario, if concurrently timers_active is set\n\t * or expiry_active is cleared, but the current thread doesn't see\n\t * the change yet, the timer checks are delayed until the next\n\t * thread in the group gets a scheduler interrupt to handle the\n\t * timer. This isn't an issue in practice because these types of\n\t * delays with signals actually getting sent are expected.\n\t */\n\tif (READ_ONCE(pct->timers_active) && !READ_ONCE(pct->expiry_active)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\tproc_sample_cputime_atomic(&sig->cputimer.cputime_atomic,\n\t\t\t\t\t   samples);\n\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tif (dl_task(tsk) && tsk->dl.dl_overrun)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_cpu_timers_work_scheduled",
          "args": [
            "tsk"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timers_work_scheduled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1253-1256",
          "snippet": "static inline bool posix_cpu_timers_work_scheduled(struct task_struct *tsk)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline bool posix_cpu_timers_work_scheduled(struct task_struct *tsk)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nvoid run_posix_cpu_timers(void)\n{\n\tstruct task_struct *tsk = current;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * If the actual expiry is deferred to task work context and the\n\t * work is already scheduled there is no point to do anything here.\n\t */\n\tif (posix_cpu_timers_work_scheduled(tsk))\n\t\treturn;\n\n\t/*\n\t * The fast path checks that there are no expired thread or thread\n\t * group timers.  If that's so, just return.\n\t */\n\tif (!fastpath_timer_check(tsk))\n\t\treturn;\n\n\t__run_posix_cpu_timers(tsk);\n}"
  },
  {
    "function_name": "handle_posix_cpu_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1265-1363",
    "snippet": "static void handle_posix_cpu_timers(struct task_struct *tsk)\n{\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags, start;\n\tLIST_HEAD(firing);\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\n\tdo {\n\t\t/*\n\t\t * On RT locking sighand lock does not disable interrupts,\n\t\t * so this needs to be careful vs. ticks. Store the current\n\t\t * jiffies value.\n\t\t */\n\t\tstart = READ_ONCE(jiffies);\n\t\tbarrier();\n\n\t\t/*\n\t\t * Here we take off tsk->signal->cpu_timers[N] and\n\t\t * tsk->cpu_timers[N] all the timers that are firing, and\n\t\t * put them on the firing list.\n\t\t */\n\t\tcheck_thread_timers(tsk, &firing);\n\n\t\tcheck_process_timers(tsk, &firing);\n\n\t\t/*\n\t\t * The above timer checks have updated the expiry cache and\n\t\t * because nothing can have queued or modified timers after\n\t\t * sighand lock was taken above it is guaranteed to be\n\t\t * consistent. So the next timer interrupt fastpath check\n\t\t * will find valid data.\n\t\t *\n\t\t * If timer expiry runs in the timer interrupt context then\n\t\t * the loop is not relevant as timers will be directly\n\t\t * expired in interrupt context. The stub function below\n\t\t * returns always true which allows the compiler to\n\t\t * optimize the loop out.\n\t\t *\n\t\t * If timer expiry is deferred to task work context then\n\t\t * the following rules apply:\n\t\t *\n\t\t * - On !RT kernels no tick can have happened on this CPU\n\t\t *   after sighand lock was acquired because interrupts are\n\t\t *   disabled. So reenabling task work before dropping\n\t\t *   sighand lock and reenabling interrupts is race free.\n\t\t *\n\t\t * - On RT kernels ticks might have happened but the tick\n\t\t *   work ignored posix CPU timer handling because the\n\t\t *   CPUTIMERS_WORK_SCHEDULED bit is set. Reenabling work\n\t\t *   must be done very carefully including a check whether\n\t\t *   ticks have happened since the start of the timer\n\t\t *   expiry checks. posix_cpu_timers_enable_work() takes\n\t\t *   care of that and eventually lets the expiry checks\n\t\t *   run again.\n\t\t */\n\t} while (!posix_cpu_timers_enable_work(tsk, start));\n\n\t/*\n\t * We must release sighand lock before taking any timer's lock.\n\t * There is a potential race with timer deletion here, as the\n\t * siglock now protects our private firing list.  We have set\n\t * the firing flag in each timer, so that a deletion attempt\n\t * that gets the timer lock before we do will give it up and\n\t * spin until we've taken care of that timer below.\n\t */\n\tunlock_task_sighand(tsk, &flags);\n\n\t/*\n\t * Now that all the timers on our list have the firing flag,\n\t * no one will touch their list entries but us.  We'll take\n\t * each timer's lock before clearing its firing flag, so no\n\t * timer call will interfere.\n\t */\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.elist) {\n\t\tint cpu_firing;\n\n\t\t/*\n\t\t * spin_lock() is sufficient here even independent of the\n\t\t * expiry context. If expiry happens in hard interrupt\n\t\t * context it's obvious. For task work context it's safe\n\t\t * because all other operations on timer::it_lock happen in\n\t\t * task context (syscall or exit).\n\t\t */\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.elist);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t/*\n\t\t * The firing flag is -1 if we collided with a reset\n\t\t * of the timer, which already reported this\n\t\t * almost-firing as an overrun.  So don't generate an event.\n\t\t */\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&timer->it_lock"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_fire",
          "args": [
            "timer"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_fire",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "578-610",
          "snippet": "static void cpu_timer_fire(struct k_itimer *timer)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (!timer->it_interval) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void cpu_timer_fire(struct k_itimer *timer)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (!timer->it_interval) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "cpu_firing >= 0"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&timer->it.cpu.elist"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&timer->it_lock"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "timer",
            "next",
            "&firing",
            "it.cpu.elist"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "tsk",
            "&flags"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_cpu_timers_enable_work",
          "args": [
            "tsk",
            "start"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timers_enable_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1258-1262",
          "snippet": "static inline bool posix_cpu_timers_enable_work(struct task_struct *tsk,\n\t\t\t\t\t\tunsigned long start)\n{\n\treturn true;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline bool posix_cpu_timers_enable_work(struct task_struct *tsk,\n\t\t\t\t\t\tunsigned long start)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_process_timers",
          "args": [
            "tsk",
            "&firing"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "check_process_timers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "967-1034",
          "snippet": "static void check_process_timers(struct task_struct *tsk,\n\t\t\t\t struct list_head *firing)\n{\n\tstruct signal_struct *const sig = tsk->signal;\n\tstruct posix_cputimers *pct = &sig->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\tunsigned long soft;\n\n\t/*\n\t * If there are no active process wide timers (POSIX 1.b, itimers,\n\t * RLIMIT_CPU) nothing to check. Also skip the process wide timer\n\t * processing when there is already another task handling them.\n\t */\n\tif (!READ_ONCE(pct->timers_active) || pct->expiry_active)\n\t\treturn;\n\n\t/*\n\t * Signify that a thread is checking for process timers.\n\t * Write access to this field is protected by the sighand lock.\n\t */\n\tpct->expiry_active = true;\n\n\t/*\n\t * Collect the current process totals. Group accounting is active\n\t * so the sample can be taken directly.\n\t */\n\tproc_sample_cputime_atomic(&sig->cputimer.cputime_atomic, samples);\n\tcollect_posix_cputimers(pct, samples, firing);\n\n\t/*\n\t * Check for the special case process timers.\n\t */\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_PROF],\n\t\t\t &pct->bases[CPUCLOCK_PROF].nextevt,\n\t\t\t samples[CPUCLOCK_PROF], SIGPROF);\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_VIRT],\n\t\t\t &pct->bases[CPUCLOCK_VIRT].nextevt,\n\t\t\t samples[CPUCLOCK_VIRT], SIGVTALRM);\n\n\tsoft = task_rlimit(tsk, RLIMIT_CPU);\n\tif (soft != RLIM_INFINITY) {\n\t\t/* RLIMIT_CPU is in seconds. Samples are nanoseconds */\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_CPU);\n\t\tu64 ptime = samples[CPUCLOCK_PROF];\n\t\tu64 softns = (u64)soft * NSEC_PER_SEC;\n\t\tu64 hardns = (u64)hard * NSEC_PER_SEC;\n\n\t\t/* At the hard limit, send SIGKILL. No further action. */\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    check_rlimit(ptime, hardns, SIGKILL, false, true))\n\t\t\treturn;\n\n\t\t/* At the soft limit, send a SIGXCPU every second */\n\t\tif (check_rlimit(ptime, softns, SIGXCPU, false, false)) {\n\t\t\tsig->rlim[RLIMIT_CPU].rlim_cur = soft + 1;\n\t\t\tsoftns += NSEC_PER_SEC;\n\t\t}\n\n\t\t/* Update the expiry cache */\n\t\tif (softns < pct->bases[CPUCLOCK_PROF].nextevt)\n\t\t\tpct->bases[CPUCLOCK_PROF].nextevt = softns;\n\t}\n\n\tif (expiry_cache_is_inactive(pct))\n\t\tstop_process_timers(sig);\n\n\tpct->expiry_active = false;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void check_process_timers(struct task_struct *tsk,\n\t\t\t\t struct list_head *firing)\n{\n\tstruct signal_struct *const sig = tsk->signal;\n\tstruct posix_cputimers *pct = &sig->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\tunsigned long soft;\n\n\t/*\n\t * If there are no active process wide timers (POSIX 1.b, itimers,\n\t * RLIMIT_CPU) nothing to check. Also skip the process wide timer\n\t * processing when there is already another task handling them.\n\t */\n\tif (!READ_ONCE(pct->timers_active) || pct->expiry_active)\n\t\treturn;\n\n\t/*\n\t * Signify that a thread is checking for process timers.\n\t * Write access to this field is protected by the sighand lock.\n\t */\n\tpct->expiry_active = true;\n\n\t/*\n\t * Collect the current process totals. Group accounting is active\n\t * so the sample can be taken directly.\n\t */\n\tproc_sample_cputime_atomic(&sig->cputimer.cputime_atomic, samples);\n\tcollect_posix_cputimers(pct, samples, firing);\n\n\t/*\n\t * Check for the special case process timers.\n\t */\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_PROF],\n\t\t\t &pct->bases[CPUCLOCK_PROF].nextevt,\n\t\t\t samples[CPUCLOCK_PROF], SIGPROF);\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_VIRT],\n\t\t\t &pct->bases[CPUCLOCK_VIRT].nextevt,\n\t\t\t samples[CPUCLOCK_VIRT], SIGVTALRM);\n\n\tsoft = task_rlimit(tsk, RLIMIT_CPU);\n\tif (soft != RLIM_INFINITY) {\n\t\t/* RLIMIT_CPU is in seconds. Samples are nanoseconds */\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_CPU);\n\t\tu64 ptime = samples[CPUCLOCK_PROF];\n\t\tu64 softns = (u64)soft * NSEC_PER_SEC;\n\t\tu64 hardns = (u64)hard * NSEC_PER_SEC;\n\n\t\t/* At the hard limit, send SIGKILL. No further action. */\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    check_rlimit(ptime, hardns, SIGKILL, false, true))\n\t\t\treturn;\n\n\t\t/* At the soft limit, send a SIGXCPU every second */\n\t\tif (check_rlimit(ptime, softns, SIGXCPU, false, false)) {\n\t\t\tsig->rlim[RLIMIT_CPU].rlim_cur = soft + 1;\n\t\t\tsoftns += NSEC_PER_SEC;\n\t\t}\n\n\t\t/* Update the expiry cache */\n\t\tif (softns < pct->bases[CPUCLOCK_PROF].nextevt)\n\t\t\tpct->bases[CPUCLOCK_PROF].nextevt = softns;\n\t}\n\n\tif (expiry_cache_is_inactive(pct))\n\t\tstop_process_timers(sig);\n\n\tpct->expiry_active = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_thread_timers",
          "args": [
            "tsk",
            "&firing"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "check_thread_timers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "890-929",
          "snippet": "static void check_thread_timers(struct task_struct *tsk,\n\t\t\t\tstruct list_head *firing)\n{\n\tstruct posix_cputimers *pct = &tsk->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\tif (expiry_cache_is_inactive(pct))\n\t\treturn;\n\n\ttask_sample_cputime(tsk, samples);\n\tcollect_posix_cputimers(pct, samples, firing);\n\n\t/*\n\t * Check for the special case thread timers.\n\t */\n\tsoft = task_rlimit(tsk, RLIMIT_RTTIME);\n\tif (soft != RLIM_INFINITY) {\n\t\t/* Task RT timeout is accounted in jiffies. RTTIME is usec */\n\t\tunsigned long rttime = tsk->rt.timeout * (USEC_PER_SEC / HZ);\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_RTTIME);\n\n\t\t/* At the hard limit, send SIGKILL. No further action. */\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    check_rlimit(rttime, hard, SIGKILL, true, true))\n\t\t\treturn;\n\n\t\t/* At the soft limit, send a SIGXCPU every second */\n\t\tif (check_rlimit(rttime, soft, SIGXCPU, true, false)) {\n\t\t\tsoft += USEC_PER_SEC;\n\t\t\ttsk->signal->rlim[RLIMIT_RTTIME].rlim_cur = soft;\n\t\t}\n\t}\n\n\tif (expiry_cache_is_inactive(pct))\n\t\ttick_dep_clear_task(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void check_thread_timers(struct task_struct *tsk,\n\t\t\t\tstruct list_head *firing)\n{\n\tstruct posix_cputimers *pct = &tsk->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\tif (expiry_cache_is_inactive(pct))\n\t\treturn;\n\n\ttask_sample_cputime(tsk, samples);\n\tcollect_posix_cputimers(pct, samples, firing);\n\n\t/*\n\t * Check for the special case thread timers.\n\t */\n\tsoft = task_rlimit(tsk, RLIMIT_RTTIME);\n\tif (soft != RLIM_INFINITY) {\n\t\t/* Task RT timeout is accounted in jiffies. RTTIME is usec */\n\t\tunsigned long rttime = tsk->rt.timeout * (USEC_PER_SEC / HZ);\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_RTTIME);\n\n\t\t/* At the hard limit, send SIGKILL. No further action. */\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    check_rlimit(rttime, hard, SIGKILL, true, true))\n\t\t\treturn;\n\n\t\t/* At the soft limit, send a SIGXCPU every second */\n\t\tif (check_rlimit(rttime, soft, SIGXCPU, true, false)) {\n\t\t\tsoft += USEC_PER_SEC;\n\t\t\ttsk->signal->rlim[RLIMIT_RTTIME].rlim_cur = soft;\n\t\t}\n\t}\n\n\tif (expiry_cache_is_inactive(pct))\n\t\ttick_dep_clear_task(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "tsk",
            "&flags"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1384-1414",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "firing"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk)\n{\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags, start;\n\tLIST_HEAD(firing);\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\n\tdo {\n\t\t/*\n\t\t * On RT locking sighand lock does not disable interrupts,\n\t\t * so this needs to be careful vs. ticks. Store the current\n\t\t * jiffies value.\n\t\t */\n\t\tstart = READ_ONCE(jiffies);\n\t\tbarrier();\n\n\t\t/*\n\t\t * Here we take off tsk->signal->cpu_timers[N] and\n\t\t * tsk->cpu_timers[N] all the timers that are firing, and\n\t\t * put them on the firing list.\n\t\t */\n\t\tcheck_thread_timers(tsk, &firing);\n\n\t\tcheck_process_timers(tsk, &firing);\n\n\t\t/*\n\t\t * The above timer checks have updated the expiry cache and\n\t\t * because nothing can have queued or modified timers after\n\t\t * sighand lock was taken above it is guaranteed to be\n\t\t * consistent. So the next timer interrupt fastpath check\n\t\t * will find valid data.\n\t\t *\n\t\t * If timer expiry runs in the timer interrupt context then\n\t\t * the loop is not relevant as timers will be directly\n\t\t * expired in interrupt context. The stub function below\n\t\t * returns always true which allows the compiler to\n\t\t * optimize the loop out.\n\t\t *\n\t\t * If timer expiry is deferred to task work context then\n\t\t * the following rules apply:\n\t\t *\n\t\t * - On !RT kernels no tick can have happened on this CPU\n\t\t *   after sighand lock was acquired because interrupts are\n\t\t *   disabled. So reenabling task work before dropping\n\t\t *   sighand lock and reenabling interrupts is race free.\n\t\t *\n\t\t * - On RT kernels ticks might have happened but the tick\n\t\t *   work ignored posix CPU timer handling because the\n\t\t *   CPUTIMERS_WORK_SCHEDULED bit is set. Reenabling work\n\t\t *   must be done very carefully including a check whether\n\t\t *   ticks have happened since the start of the timer\n\t\t *   expiry checks. posix_cpu_timers_enable_work() takes\n\t\t *   care of that and eventually lets the expiry checks\n\t\t *   run again.\n\t\t */\n\t} while (!posix_cpu_timers_enable_work(tsk, start));\n\n\t/*\n\t * We must release sighand lock before taking any timer's lock.\n\t * There is a potential race with timer deletion here, as the\n\t * siglock now protects our private firing list.  We have set\n\t * the firing flag in each timer, so that a deletion attempt\n\t * that gets the timer lock before we do will give it up and\n\t * spin until we've taken care of that timer below.\n\t */\n\tunlock_task_sighand(tsk, &flags);\n\n\t/*\n\t * Now that all the timers on our list have the firing flag,\n\t * no one will touch their list entries but us.  We'll take\n\t * each timer's lock before clearing its firing flag, so no\n\t * timer call will interfere.\n\t */\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.elist) {\n\t\tint cpu_firing;\n\n\t\t/*\n\t\t * spin_lock() is sufficient here even independent of the\n\t\t * expiry context. If expiry happens in hard interrupt\n\t\t * context it's obvious. For task work context it's safe\n\t\t * because all other operations on timer::it_lock happen in\n\t\t * task context (syscall or exit).\n\t\t */\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.elist);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t/*\n\t\t * The firing flag is -1 if we collided with a reset\n\t\t * of the timer, which already reported this\n\t\t * almost-firing as an overrun.  So don't generate an event.\n\t\t */\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}"
  },
  {
    "function_name": "posix_cpu_timers_enable_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1258-1262",
    "snippet": "static inline bool posix_cpu_timers_enable_work(struct task_struct *tsk,\n\t\t\t\t\t\tunsigned long start)\n{\n\treturn true;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline bool posix_cpu_timers_enable_work(struct task_struct *tsk,\n\t\t\t\t\t\tunsigned long start)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "posix_cpu_timers_work_scheduled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1253-1256",
    "snippet": "static inline bool posix_cpu_timers_work_scheduled(struct task_struct *tsk)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline bool posix_cpu_timers_work_scheduled(struct task_struct *tsk)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "__run_posix_cpu_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1246-1251",
    "snippet": "static inline void __run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tlockdep_posixtimer_enter();\n\thandle_posix_cpu_timers(tsk);\n\tlockdep_posixtimer_exit();\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_posixtimer_exit",
          "args": [],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_posix_cpu_timers",
          "args": [
            "tsk"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "handle_posix_cpu_timers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1265-1363",
          "snippet": "static void handle_posix_cpu_timers(struct task_struct *tsk)\n{\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags, start;\n\tLIST_HEAD(firing);\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\n\tdo {\n\t\t/*\n\t\t * On RT locking sighand lock does not disable interrupts,\n\t\t * so this needs to be careful vs. ticks. Store the current\n\t\t * jiffies value.\n\t\t */\n\t\tstart = READ_ONCE(jiffies);\n\t\tbarrier();\n\n\t\t/*\n\t\t * Here we take off tsk->signal->cpu_timers[N] and\n\t\t * tsk->cpu_timers[N] all the timers that are firing, and\n\t\t * put them on the firing list.\n\t\t */\n\t\tcheck_thread_timers(tsk, &firing);\n\n\t\tcheck_process_timers(tsk, &firing);\n\n\t\t/*\n\t\t * The above timer checks have updated the expiry cache and\n\t\t * because nothing can have queued or modified timers after\n\t\t * sighand lock was taken above it is guaranteed to be\n\t\t * consistent. So the next timer interrupt fastpath check\n\t\t * will find valid data.\n\t\t *\n\t\t * If timer expiry runs in the timer interrupt context then\n\t\t * the loop is not relevant as timers will be directly\n\t\t * expired in interrupt context. The stub function below\n\t\t * returns always true which allows the compiler to\n\t\t * optimize the loop out.\n\t\t *\n\t\t * If timer expiry is deferred to task work context then\n\t\t * the following rules apply:\n\t\t *\n\t\t * - On !RT kernels no tick can have happened on this CPU\n\t\t *   after sighand lock was acquired because interrupts are\n\t\t *   disabled. So reenabling task work before dropping\n\t\t *   sighand lock and reenabling interrupts is race free.\n\t\t *\n\t\t * - On RT kernels ticks might have happened but the tick\n\t\t *   work ignored posix CPU timer handling because the\n\t\t *   CPUTIMERS_WORK_SCHEDULED bit is set. Reenabling work\n\t\t *   must be done very carefully including a check whether\n\t\t *   ticks have happened since the start of the timer\n\t\t *   expiry checks. posix_cpu_timers_enable_work() takes\n\t\t *   care of that and eventually lets the expiry checks\n\t\t *   run again.\n\t\t */\n\t} while (!posix_cpu_timers_enable_work(tsk, start));\n\n\t/*\n\t * We must release sighand lock before taking any timer's lock.\n\t * There is a potential race with timer deletion here, as the\n\t * siglock now protects our private firing list.  We have set\n\t * the firing flag in each timer, so that a deletion attempt\n\t * that gets the timer lock before we do will give it up and\n\t * spin until we've taken care of that timer below.\n\t */\n\tunlock_task_sighand(tsk, &flags);\n\n\t/*\n\t * Now that all the timers on our list have the firing flag,\n\t * no one will touch their list entries but us.  We'll take\n\t * each timer's lock before clearing its firing flag, so no\n\t * timer call will interfere.\n\t */\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.elist) {\n\t\tint cpu_firing;\n\n\t\t/*\n\t\t * spin_lock() is sufficient here even independent of the\n\t\t * expiry context. If expiry happens in hard interrupt\n\t\t * context it's obvious. For task work context it's safe\n\t\t * because all other operations on timer::it_lock happen in\n\t\t * task context (syscall or exit).\n\t\t */\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.elist);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t/*\n\t\t * The firing flag is -1 if we collided with a reset\n\t\t * of the timer, which already reported this\n\t\t * almost-firing as an overrun.  So don't generate an event.\n\t\t */\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk)\n{\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags, start;\n\tLIST_HEAD(firing);\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\n\tdo {\n\t\t/*\n\t\t * On RT locking sighand lock does not disable interrupts,\n\t\t * so this needs to be careful vs. ticks. Store the current\n\t\t * jiffies value.\n\t\t */\n\t\tstart = READ_ONCE(jiffies);\n\t\tbarrier();\n\n\t\t/*\n\t\t * Here we take off tsk->signal->cpu_timers[N] and\n\t\t * tsk->cpu_timers[N] all the timers that are firing, and\n\t\t * put them on the firing list.\n\t\t */\n\t\tcheck_thread_timers(tsk, &firing);\n\n\t\tcheck_process_timers(tsk, &firing);\n\n\t\t/*\n\t\t * The above timer checks have updated the expiry cache and\n\t\t * because nothing can have queued or modified timers after\n\t\t * sighand lock was taken above it is guaranteed to be\n\t\t * consistent. So the next timer interrupt fastpath check\n\t\t * will find valid data.\n\t\t *\n\t\t * If timer expiry runs in the timer interrupt context then\n\t\t * the loop is not relevant as timers will be directly\n\t\t * expired in interrupt context. The stub function below\n\t\t * returns always true which allows the compiler to\n\t\t * optimize the loop out.\n\t\t *\n\t\t * If timer expiry is deferred to task work context then\n\t\t * the following rules apply:\n\t\t *\n\t\t * - On !RT kernels no tick can have happened on this CPU\n\t\t *   after sighand lock was acquired because interrupts are\n\t\t *   disabled. So reenabling task work before dropping\n\t\t *   sighand lock and reenabling interrupts is race free.\n\t\t *\n\t\t * - On RT kernels ticks might have happened but the tick\n\t\t *   work ignored posix CPU timer handling because the\n\t\t *   CPUTIMERS_WORK_SCHEDULED bit is set. Reenabling work\n\t\t *   must be done very carefully including a check whether\n\t\t *   ticks have happened since the start of the timer\n\t\t *   expiry checks. posix_cpu_timers_enable_work() takes\n\t\t *   care of that and eventually lets the expiry checks\n\t\t *   run again.\n\t\t */\n\t} while (!posix_cpu_timers_enable_work(tsk, start));\n\n\t/*\n\t * We must release sighand lock before taking any timer's lock.\n\t * There is a potential race with timer deletion here, as the\n\t * siglock now protects our private firing list.  We have set\n\t * the firing flag in each timer, so that a deletion attempt\n\t * that gets the timer lock before we do will give it up and\n\t * spin until we've taken care of that timer below.\n\t */\n\tunlock_task_sighand(tsk, &flags);\n\n\t/*\n\t * Now that all the timers on our list have the firing flag,\n\t * no one will touch their list entries but us.  We'll take\n\t * each timer's lock before clearing its firing flag, so no\n\t * timer call will interfere.\n\t */\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.elist) {\n\t\tint cpu_firing;\n\n\t\t/*\n\t\t * spin_lock() is sufficient here even independent of the\n\t\t * expiry context. If expiry happens in hard interrupt\n\t\t * context it's obvious. For task work context it's safe\n\t\t * because all other operations on timer::it_lock happen in\n\t\t * task context (syscall or exit).\n\t\t */\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.elist);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t/*\n\t\t * The firing flag is -1 if we collided with a reset\n\t\t * of the timer, which already reported this\n\t\t * almost-firing as an overrun.  So don't generate an event.\n\t\t */\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_posixtimer_enter",
          "args": [],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline void __run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tlockdep_posixtimer_enter();\n\thandle_posix_cpu_timers(tsk);\n\tlockdep_posixtimer_exit();\n}"
  },
  {
    "function_name": "posix_cpu_timers_enable_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1208-1244",
    "snippet": "static inline bool posix_cpu_timers_enable_work(struct task_struct *tsk,\n\t\t\t\t\t\tunsigned long start)\n{\n\tbool ret = true;\n\n\t/*\n\t * On !RT kernels interrupts are disabled while collecting expired\n\t * timers, so no tick can happen and the fast path check can be\n\t * reenabled without further checks.\n\t */\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\ttsk->posix_cputimers_work.scheduled = false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * On RT enabled kernels ticks can happen while the expired timers\n\t * are collected under sighand lock. But any tick which observes\n\t * the CPUTIMERS_WORK_SCHEDULED bit set, does not run the fastpath\n\t * checks. So reenabling the tick work has do be done carefully:\n\t *\n\t * Disable interrupts and run the fast path check if jiffies have\n\t * advanced since the collecting of expired timers started. If\n\t * jiffies have not advanced or the fast path check did not find\n\t * newly expired timers, reenable the fast path check in the timer\n\t * interrupt. If there are newly expired timers, return false and\n\t * let the collection loop repeat.\n\t */\n\tlocal_irq_disable();\n\tif (start != jiffies && fastpath_timer_check(tsk))\n\t\tret = false;\n\telse\n\t\ttsk->posix_cputimers_work.scheduled = false;\n\tlocal_irq_enable();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastpath_timer_check",
          "args": [
            "tsk"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "fastpath_timer_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1108-1152",
          "snippet": "static inline bool fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct posix_cputimers *pct = &tsk->posix_cputimers;\n\tstruct signal_struct *sig;\n\n\tif (!expiry_cache_is_inactive(pct)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\ttask_sample_cputime(tsk, samples);\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tsig = tsk->signal;\n\tpct = &sig->posix_cputimers;\n\t/*\n\t * Check if thread group timers expired when timers are active and\n\t * no other thread in the group is already handling expiry for\n\t * thread group cputimers. These fields are read without the\n\t * sighand lock. However, this is fine because this is meant to be\n\t * a fastpath heuristic to determine whether we should try to\n\t * acquire the sighand lock to handle timer expiry.\n\t *\n\t * In the worst case scenario, if concurrently timers_active is set\n\t * or expiry_active is cleared, but the current thread doesn't see\n\t * the change yet, the timer checks are delayed until the next\n\t * thread in the group gets a scheduler interrupt to handle the\n\t * timer. This isn't an issue in practice because these types of\n\t * delays with signals actually getting sent are expected.\n\t */\n\tif (READ_ONCE(pct->timers_active) && !READ_ONCE(pct->expiry_active)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\tproc_sample_cputime_atomic(&sig->cputimer.cputime_atomic,\n\t\t\t\t\t   samples);\n\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tif (dl_task(tsk) && tsk->dl.dl_overrun)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline bool fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct posix_cputimers *pct = &tsk->posix_cputimers;\n\tstruct signal_struct *sig;\n\n\tif (!expiry_cache_is_inactive(pct)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\ttask_sample_cputime(tsk, samples);\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tsig = tsk->signal;\n\tpct = &sig->posix_cputimers;\n\t/*\n\t * Check if thread group timers expired when timers are active and\n\t * no other thread in the group is already handling expiry for\n\t * thread group cputimers. These fields are read without the\n\t * sighand lock. However, this is fine because this is meant to be\n\t * a fastpath heuristic to determine whether we should try to\n\t * acquire the sighand lock to handle timer expiry.\n\t *\n\t * In the worst case scenario, if concurrently timers_active is set\n\t * or expiry_active is cleared, but the current thread doesn't see\n\t * the change yet, the timer checks are delayed until the next\n\t * thread in the group gets a scheduler interrupt to handle the\n\t * timer. This isn't an issue in practice because these types of\n\t * delays with signals actually getting sent are expected.\n\t */\n\tif (READ_ONCE(pct->timers_active) && !READ_ONCE(pct->expiry_active)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\tproc_sample_cputime_atomic(&sig->cputimer.cputime_atomic,\n\t\t\t\t\t   samples);\n\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tif (dl_task(tsk) && tsk->dl.dl_overrun)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline bool posix_cpu_timers_enable_work(struct task_struct *tsk,\n\t\t\t\t\t\tunsigned long start)\n{\n\tbool ret = true;\n\n\t/*\n\t * On !RT kernels interrupts are disabled while collecting expired\n\t * timers, so no tick can happen and the fast path check can be\n\t * reenabled without further checks.\n\t */\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\ttsk->posix_cputimers_work.scheduled = false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * On RT enabled kernels ticks can happen while the expired timers\n\t * are collected under sighand lock. But any tick which observes\n\t * the CPUTIMERS_WORK_SCHEDULED bit set, does not run the fastpath\n\t * checks. So reenabling the tick work has do be done carefully:\n\t *\n\t * Disable interrupts and run the fast path check if jiffies have\n\t * advanced since the collecting of expired timers started. If\n\t * jiffies have not advanced or the fast path check did not find\n\t * newly expired timers, reenable the fast path check in the timer\n\t * interrupt. If there are newly expired timers, return false and\n\t * let the collection loop repeat.\n\t */\n\tlocal_irq_disable();\n\tif (start != jiffies && fastpath_timer_check(tsk))\n\t\tret = false;\n\telse\n\t\ttsk->posix_cputimers_work.scheduled = false;\n\tlocal_irq_enable();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__run_posix_cpu_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1198-1206",
    "snippet": "static inline void __run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tif (WARN_ON_ONCE(tsk->posix_cputimers_work.scheduled))\n\t\treturn;\n\n\t/* Schedule task work to actually expire the timers */\n\ttsk->posix_cputimers_work.scheduled = true;\n\ttask_work_add(tsk, &tsk->posix_cputimers_work.work, TWA_RESUME);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_work_add",
          "args": [
            "tsk",
            "&tsk->posix_cputimers_work.work",
            "TWA_RESUME"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/task_work.c",
          "lines": "32-62",
          "snippet": "int task_work_add(struct task_struct *task, struct callback_head *work,\n\t\t  enum task_work_notify_mode notify)\n{\n\tstruct callback_head *head;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack(work);\n\n\tdo {\n\t\thead = READ_ONCE(task->task_works);\n\t\tif (unlikely(head == &work_exited))\n\t\t\treturn -ESRCH;\n\t\twork->next = head;\n\t} while (cmpxchg(&task->task_works, head, work) != head);\n\n\tswitch (notify) {\n\tcase TWA_NONE:\n\t\tbreak;\n\tcase TWA_RESUME:\n\t\tset_notify_resume(task);\n\t\tbreak;\n\tcase TWA_SIGNAL:\n\t\tset_notify_signal(task);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/resume_user_mode.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_head work_exited;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/resume_user_mode.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nint task_work_add(struct task_struct *task, struct callback_head *work,\n\t\t  enum task_work_notify_mode notify)\n{\n\tstruct callback_head *head;\n\n\t/* record the work call stack in order to print it in KASAN reports */\n\tkasan_record_aux_stack(work);\n\n\tdo {\n\t\thead = READ_ONCE(task->task_works);\n\t\tif (unlikely(head == &work_exited))\n\t\t\treturn -ESRCH;\n\t\twork->next = head;\n\t} while (cmpxchg(&task->task_works, head, work) != head);\n\n\tswitch (notify) {\n\tcase TWA_NONE:\n\t\tbreak;\n\tcase TWA_RESUME:\n\t\tset_notify_resume(task);\n\t\tbreak;\n\tcase TWA_SIGNAL:\n\t\tset_notify_signal(task);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tsk->posix_cputimers_work.scheduled"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline void __run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tif (WARN_ON_ONCE(tsk->posix_cputimers_work.scheduled))\n\t\treturn;\n\n\t/* Schedule task work to actually expire the timers */\n\ttsk->posix_cputimers_work.scheduled = true;\n\ttask_work_add(tsk, &tsk->posix_cputimers_work.work, TWA_RESUME);\n}"
  },
  {
    "function_name": "posix_cpu_timers_work_scheduled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1193-1196",
    "snippet": "static inline bool posix_cpu_timers_work_scheduled(struct task_struct *tsk)\n{\n\treturn tsk->posix_cputimers_work.scheduled;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline bool posix_cpu_timers_work_scheduled(struct task_struct *tsk)\n{\n\treturn tsk->posix_cputimers_work.scheduled;\n}"
  },
  {
    "function_name": "posix_cputimers_init_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1182-1185",
    "snippet": "void __init posix_cputimers_init_work(void)\n{\n\tclear_posix_cputimers_work(current);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_posix_cputimers_work",
          "args": [
            "current"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "clear_posix_cputimers_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1165-1176",
          "snippet": "void clear_posix_cputimers_work(struct task_struct *p)\n{\n\t/*\n\t * A copied work entry from the old task is not meaningful, clear it.\n\t * N.B. init_task_work will not do this.\n\t */\n\tmemset(&p->posix_cputimers_work.work, 0,\n\t       sizeof(p->posix_cputimers_work.work));\n\tinit_task_work(&p->posix_cputimers_work.work,\n\t\t       posix_cpu_timers_work);\n\tp->posix_cputimers_work.scheduled = false;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nvoid clear_posix_cputimers_work(struct task_struct *p)\n{\n\t/*\n\t * A copied work entry from the old task is not meaningful, clear it.\n\t * N.B. init_task_work will not do this.\n\t */\n\tmemset(&p->posix_cputimers_work.work, 0,\n\t       sizeof(p->posix_cputimers_work.work));\n\tinit_task_work(&p->posix_cputimers_work.work,\n\t\t       posix_cpu_timers_work);\n\tp->posix_cputimers_work.scheduled = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nvoid __init posix_cputimers_init_work(void)\n{\n\tclear_posix_cputimers_work(current);\n}"
  },
  {
    "function_name": "clear_posix_cputimers_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1165-1176",
    "snippet": "void clear_posix_cputimers_work(struct task_struct *p)\n{\n\t/*\n\t * A copied work entry from the old task is not meaningful, clear it.\n\t * N.B. init_task_work will not do this.\n\t */\n\tmemset(&p->posix_cputimers_work.work, 0,\n\t       sizeof(p->posix_cputimers_work.work));\n\tinit_task_work(&p->posix_cputimers_work.work,\n\t\t       posix_cpu_timers_work);\n\tp->posix_cputimers_work.scheduled = false;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_task_work",
          "args": [
            "&p->posix_cputimers_work.work",
            "posix_cpu_timers_work"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&p->posix_cputimers_work.work",
            "0",
            "sizeof(p->posix_cputimers_work.work)"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nvoid clear_posix_cputimers_work(struct task_struct *p)\n{\n\t/*\n\t * A copied work entry from the old task is not meaningful, clear it.\n\t * N.B. init_task_work will not do this.\n\t */\n\tmemset(&p->posix_cputimers_work.work, 0,\n\t       sizeof(p->posix_cputimers_work.work));\n\tinit_task_work(&p->posix_cputimers_work.work,\n\t\t       posix_cpu_timers_work);\n\tp->posix_cputimers_work.scheduled = false;\n}"
  },
  {
    "function_name": "posix_cpu_timers_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1157-1160",
    "snippet": "static void posix_cpu_timers_work(struct callback_head *work)\n{\n\thandle_posix_cpu_timers(current);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_posix_cpu_timers",
          "args": [
            "current"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "handle_posix_cpu_timers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1265-1363",
          "snippet": "static void handle_posix_cpu_timers(struct task_struct *tsk)\n{\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags, start;\n\tLIST_HEAD(firing);\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\n\tdo {\n\t\t/*\n\t\t * On RT locking sighand lock does not disable interrupts,\n\t\t * so this needs to be careful vs. ticks. Store the current\n\t\t * jiffies value.\n\t\t */\n\t\tstart = READ_ONCE(jiffies);\n\t\tbarrier();\n\n\t\t/*\n\t\t * Here we take off tsk->signal->cpu_timers[N] and\n\t\t * tsk->cpu_timers[N] all the timers that are firing, and\n\t\t * put them on the firing list.\n\t\t */\n\t\tcheck_thread_timers(tsk, &firing);\n\n\t\tcheck_process_timers(tsk, &firing);\n\n\t\t/*\n\t\t * The above timer checks have updated the expiry cache and\n\t\t * because nothing can have queued or modified timers after\n\t\t * sighand lock was taken above it is guaranteed to be\n\t\t * consistent. So the next timer interrupt fastpath check\n\t\t * will find valid data.\n\t\t *\n\t\t * If timer expiry runs in the timer interrupt context then\n\t\t * the loop is not relevant as timers will be directly\n\t\t * expired in interrupt context. The stub function below\n\t\t * returns always true which allows the compiler to\n\t\t * optimize the loop out.\n\t\t *\n\t\t * If timer expiry is deferred to task work context then\n\t\t * the following rules apply:\n\t\t *\n\t\t * - On !RT kernels no tick can have happened on this CPU\n\t\t *   after sighand lock was acquired because interrupts are\n\t\t *   disabled. So reenabling task work before dropping\n\t\t *   sighand lock and reenabling interrupts is race free.\n\t\t *\n\t\t * - On RT kernels ticks might have happened but the tick\n\t\t *   work ignored posix CPU timer handling because the\n\t\t *   CPUTIMERS_WORK_SCHEDULED bit is set. Reenabling work\n\t\t *   must be done very carefully including a check whether\n\t\t *   ticks have happened since the start of the timer\n\t\t *   expiry checks. posix_cpu_timers_enable_work() takes\n\t\t *   care of that and eventually lets the expiry checks\n\t\t *   run again.\n\t\t */\n\t} while (!posix_cpu_timers_enable_work(tsk, start));\n\n\t/*\n\t * We must release sighand lock before taking any timer's lock.\n\t * There is a potential race with timer deletion here, as the\n\t * siglock now protects our private firing list.  We have set\n\t * the firing flag in each timer, so that a deletion attempt\n\t * that gets the timer lock before we do will give it up and\n\t * spin until we've taken care of that timer below.\n\t */\n\tunlock_task_sighand(tsk, &flags);\n\n\t/*\n\t * Now that all the timers on our list have the firing flag,\n\t * no one will touch their list entries but us.  We'll take\n\t * each timer's lock before clearing its firing flag, so no\n\t * timer call will interfere.\n\t */\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.elist) {\n\t\tint cpu_firing;\n\n\t\t/*\n\t\t * spin_lock() is sufficient here even independent of the\n\t\t * expiry context. If expiry happens in hard interrupt\n\t\t * context it's obvious. For task work context it's safe\n\t\t * because all other operations on timer::it_lock happen in\n\t\t * task context (syscall or exit).\n\t\t */\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.elist);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t/*\n\t\t * The firing flag is -1 if we collided with a reset\n\t\t * of the timer, which already reported this\n\t\t * almost-firing as an overrun.  So don't generate an event.\n\t\t */\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk)\n{\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags, start;\n\tLIST_HEAD(firing);\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\n\tdo {\n\t\t/*\n\t\t * On RT locking sighand lock does not disable interrupts,\n\t\t * so this needs to be careful vs. ticks. Store the current\n\t\t * jiffies value.\n\t\t */\n\t\tstart = READ_ONCE(jiffies);\n\t\tbarrier();\n\n\t\t/*\n\t\t * Here we take off tsk->signal->cpu_timers[N] and\n\t\t * tsk->cpu_timers[N] all the timers that are firing, and\n\t\t * put them on the firing list.\n\t\t */\n\t\tcheck_thread_timers(tsk, &firing);\n\n\t\tcheck_process_timers(tsk, &firing);\n\n\t\t/*\n\t\t * The above timer checks have updated the expiry cache and\n\t\t * because nothing can have queued or modified timers after\n\t\t * sighand lock was taken above it is guaranteed to be\n\t\t * consistent. So the next timer interrupt fastpath check\n\t\t * will find valid data.\n\t\t *\n\t\t * If timer expiry runs in the timer interrupt context then\n\t\t * the loop is not relevant as timers will be directly\n\t\t * expired in interrupt context. The stub function below\n\t\t * returns always true which allows the compiler to\n\t\t * optimize the loop out.\n\t\t *\n\t\t * If timer expiry is deferred to task work context then\n\t\t * the following rules apply:\n\t\t *\n\t\t * - On !RT kernels no tick can have happened on this CPU\n\t\t *   after sighand lock was acquired because interrupts are\n\t\t *   disabled. So reenabling task work before dropping\n\t\t *   sighand lock and reenabling interrupts is race free.\n\t\t *\n\t\t * - On RT kernels ticks might have happened but the tick\n\t\t *   work ignored posix CPU timer handling because the\n\t\t *   CPUTIMERS_WORK_SCHEDULED bit is set. Reenabling work\n\t\t *   must be done very carefully including a check whether\n\t\t *   ticks have happened since the start of the timer\n\t\t *   expiry checks. posix_cpu_timers_enable_work() takes\n\t\t *   care of that and eventually lets the expiry checks\n\t\t *   run again.\n\t\t */\n\t} while (!posix_cpu_timers_enable_work(tsk, start));\n\n\t/*\n\t * We must release sighand lock before taking any timer's lock.\n\t * There is a potential race with timer deletion here, as the\n\t * siglock now protects our private firing list.  We have set\n\t * the firing flag in each timer, so that a deletion attempt\n\t * that gets the timer lock before we do will give it up and\n\t * spin until we've taken care of that timer below.\n\t */\n\tunlock_task_sighand(tsk, &flags);\n\n\t/*\n\t * Now that all the timers on our list have the firing flag,\n\t * no one will touch their list entries but us.  We'll take\n\t * each timer's lock before clearing its firing flag, so no\n\t * timer call will interfere.\n\t */\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.elist) {\n\t\tint cpu_firing;\n\n\t\t/*\n\t\t * spin_lock() is sufficient here even independent of the\n\t\t * expiry context. If expiry happens in hard interrupt\n\t\t * context it's obvious. For task work context it's safe\n\t\t * because all other operations on timer::it_lock happen in\n\t\t * task context (syscall or exit).\n\t\t */\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.elist);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t/*\n\t\t * The firing flag is -1 if we collided with a reset\n\t\t * of the timer, which already reported this\n\t\t * almost-firing as an overrun.  So don't generate an event.\n\t\t */\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timers_work(struct callback_head *work)\n{\n\thandle_posix_cpu_timers(current);\n}"
  },
  {
    "function_name": "fastpath_timer_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1108-1152",
    "snippet": "static inline bool fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct posix_cputimers *pct = &tsk->posix_cputimers;\n\tstruct signal_struct *sig;\n\n\tif (!expiry_cache_is_inactive(pct)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\ttask_sample_cputime(tsk, samples);\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tsig = tsk->signal;\n\tpct = &sig->posix_cputimers;\n\t/*\n\t * Check if thread group timers expired when timers are active and\n\t * no other thread in the group is already handling expiry for\n\t * thread group cputimers. These fields are read without the\n\t * sighand lock. However, this is fine because this is meant to be\n\t * a fastpath heuristic to determine whether we should try to\n\t * acquire the sighand lock to handle timer expiry.\n\t *\n\t * In the worst case scenario, if concurrently timers_active is set\n\t * or expiry_active is cleared, but the current thread doesn't see\n\t * the change yet, the timer checks are delayed until the next\n\t * thread in the group gets a scheduler interrupt to handle the\n\t * timer. This isn't an issue in practice because these types of\n\t * delays with signals actually getting sent are expected.\n\t */\n\tif (READ_ONCE(pct->timers_active) && !READ_ONCE(pct->expiry_active)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\tproc_sample_cputime_atomic(&sig->cputimer.cputime_atomic,\n\t\t\t\t\t   samples);\n\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tif (dl_task(tsk) && tsk->dl.dl_overrun)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "tsk"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputimers_expired",
          "args": [
            "samples",
            "pct"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputimers_expired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1086-1096",
          "snippet": "static inline bool\ntask_cputimers_expired(const u64 *samples, struct posix_cputimers *pct)\n{\n\tint i;\n\n\tfor (i = 0; i < CPUCLOCK_MAX; i++) {\n\t\tif (samples[i] >= pct->bases[i].nextevt)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline bool\ntask_cputimers_expired(const u64 *samples, struct posix_cputimers *pct)\n{\n\tint i;\n\n\tfor (i = 0; i < CPUCLOCK_MAX; i++) {\n\t\tif (samples[i] >= pct->bases[i].nextevt)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_sample_cputime_atomic",
          "args": [
            "&sig->cputimer.cputime_atomic",
            "samples"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sample_cputime_atomic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "223-232",
          "snippet": "static void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pct->expiry_active"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pct->timers_active"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_sample_cputime",
          "args": [
            "tsk",
            "samples"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "task_sample_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "215-221",
          "snippet": "static void task_sample_cputime(struct task_struct *p, u64 *samples)\n{\n\tu64 stime, utime;\n\n\ttask_cputime(p, &utime, &stime);\n\tstore_samples(samples, stime, utime, p->se.sum_exec_runtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void task_sample_cputime(struct task_struct *p, u64 *samples)\n{\n\tu64 stime, utime;\n\n\ttask_cputime(p, &utime, &stime);\n\tstore_samples(samples, stime, utime, p->se.sum_exec_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expiry_cache_is_inactive",
          "args": [
            "pct"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "expiry_cache_is_inactive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "146-151",
          "snippet": "static inline bool expiry_cache_is_inactive(const struct posix_cputimers *pct)\n{\n\treturn !(~pct->bases[CPUCLOCK_PROF].nextevt |\n\t\t ~pct->bases[CPUCLOCK_VIRT].nextevt |\n\t\t ~pct->bases[CPUCLOCK_SCHED].nextevt);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline bool expiry_cache_is_inactive(const struct posix_cputimers *pct)\n{\n\treturn !(~pct->bases[CPUCLOCK_PROF].nextevt |\n\t\t ~pct->bases[CPUCLOCK_VIRT].nextevt |\n\t\t ~pct->bases[CPUCLOCK_SCHED].nextevt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline bool fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct posix_cputimers *pct = &tsk->posix_cputimers;\n\tstruct signal_struct *sig;\n\n\tif (!expiry_cache_is_inactive(pct)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\ttask_sample_cputime(tsk, samples);\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tsig = tsk->signal;\n\tpct = &sig->posix_cputimers;\n\t/*\n\t * Check if thread group timers expired when timers are active and\n\t * no other thread in the group is already handling expiry for\n\t * thread group cputimers. These fields are read without the\n\t * sighand lock. However, this is fine because this is meant to be\n\t * a fastpath heuristic to determine whether we should try to\n\t * acquire the sighand lock to handle timer expiry.\n\t *\n\t * In the worst case scenario, if concurrently timers_active is set\n\t * or expiry_active is cleared, but the current thread doesn't see\n\t * the change yet, the timer checks are delayed until the next\n\t * thread in the group gets a scheduler interrupt to handle the\n\t * timer. This isn't an issue in practice because these types of\n\t * delays with signals actually getting sent are expected.\n\t */\n\tif (READ_ONCE(pct->timers_active) && !READ_ONCE(pct->expiry_active)) {\n\t\tu64 samples[CPUCLOCK_MAX];\n\n\t\tproc_sample_cputime_atomic(&sig->cputimer.cputime_atomic,\n\t\t\t\t\t   samples);\n\n\t\tif (task_cputimers_expired(samples, pct))\n\t\t\treturn true;\n\t}\n\n\tif (dl_task(tsk) && tsk->dl.dl_overrun)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "task_cputimers_expired",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1086-1096",
    "snippet": "static inline bool\ntask_cputimers_expired(const u64 *samples, struct posix_cputimers *pct)\n{\n\tint i;\n\n\tfor (i = 0; i < CPUCLOCK_MAX; i++) {\n\t\tif (samples[i] >= pct->bases[i].nextevt)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline bool\ntask_cputimers_expired(const u64 *samples, struct posix_cputimers *pct)\n{\n\tint i;\n\n\tfor (i = 0; i < CPUCLOCK_MAX; i++) {\n\t\tif (samples[i] >= pct->bases[i].nextevt)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "posix_cpu_timer_rearm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "1040-1075",
    "snippet": "static void posix_cpu_timer_rearm(struct k_itimer *timer)\n{\n\tclockid_t clkid = CPUCLOCK_WHICH(timer->it_clock);\n\tstruct task_struct *p;\n\tstruct sighand_struct *sighand;\n\tunsigned long flags;\n\tu64 now;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p)\n\t\tgoto out;\n\n\t/* Protect timer list r/w in arm_timer() */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL))\n\t\tgoto out;\n\n\t/*\n\t * Fetch the current sample and update the timer's expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\tnow = cpu_clock_sample(clkid, p);\n\telse\n\t\tnow = cpu_clock_sample_group(clkid, p, true);\n\n\tbump_cpu_timer(timer, now);\n\n\t/*\n\t * Now re-arm for the new expiry time.\n\t */\n\tarm_timer(timer, p);\n\tunlock_task_sighand(p, &flags);\nout:\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arm_timer",
          "args": [
            "timer",
            "p"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "arm_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "551-573",
          "snippet": "static void arm_timer(struct k_itimer *timer, struct task_struct *p)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, p);\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tu64 newexp = cpu_timer_getexpires(ctmr);\n\n\tif (!cpu_timer_enqueue(&base->tqhead, ctmr))\n\t\treturn;\n\n\t/*\n\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t * need to update expiration cache. Take into account that\n\t * for process timers we share expiration cache with itimers\n\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t */\n\tif (newexp < base->nextevt)\n\t\tbase->nextevt = newexp;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\telse\n\t\ttick_dep_set_signal(p, TICK_DEP_BIT_POSIX_TIMER);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void arm_timer(struct k_itimer *timer, struct task_struct *p)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, p);\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tu64 newexp = cpu_timer_getexpires(ctmr);\n\n\tif (!cpu_timer_enqueue(&base->tqhead, ctmr))\n\t\treturn;\n\n\t/*\n\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t * need to update expiration cache. Take into account that\n\t * for process timers we share expiration cache with itimers\n\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t */\n\tif (newexp < base->nextevt)\n\t\tbase->nextevt = newexp;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\telse\n\t\ttick_dep_set_signal(p, TICK_DEP_BIT_POSIX_TIMER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bump_cpu_timer",
          "args": [
            "timer",
            "now"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "bump_cpu_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "116-143",
          "snippet": "static u64 bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tu64 delta, incr, expires = timer->it.cpu.node.expires;\n\tint i;\n\n\tif (!timer->it_interval)\n\t\treturn expires;\n\n\tif (now < expires)\n\t\treturn expires;\n\n\tincr = timer->it_interval;\n\tdelta = now + incr - expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.node.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n\treturn timer->it.cpu.node.expires;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic u64 bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tu64 delta, incr, expires = timer->it.cpu.node.expires;\n\tint i;\n\n\tif (!timer->it_interval)\n\t\treturn expires;\n\n\tif (now < expires)\n\t\treturn expires;\n\n\tincr = timer->it_interval;\n\tdelta = now + incr - expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.node.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n\treturn timer->it.cpu.node.expires;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample_group",
          "args": [
            "clkid",
            "p",
            "true"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "334-351",
          "snippet": "static u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample",
          "args": [
            "clkid",
            "p"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "188-206",
          "snippet": "static u64 cpu_clock_sample(const clockid_t clkid, struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\tif (clkid == CPUCLOCK_SCHED)\n\t\treturn task_sched_runtime(p);\n\n\ttask_cputime(p, &utime, &stime);\n\n\tswitch (clkid) {\n\tcase CPUCLOCK_PROF:\n\t\treturn utime + stime;\n\tcase CPUCLOCK_VIRT:\n\t\treturn utime;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic u64 cpu_clock_sample(const clockid_t clkid, struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\tif (clkid == CPUCLOCK_SCHED)\n\t\treturn task_sched_runtime(p);\n\n\ttask_cputime(p, &utime, &stime);\n\n\tswitch (clkid) {\n\tcase CPUCLOCK_PROF:\n\t\treturn utime + stime;\n\tcase CPUCLOCK_VIRT:\n\t\treturn utime;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "timer->it_clock"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sighand == NULL"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1384-1414",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_task_rcu",
          "args": [
            "timer"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_task_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "107-110",
          "snippet": "static inline struct task_struct *cpu_timer_task_rcu(struct k_itimer *timer)\n{\n\treturn pid_task(timer->it.cpu.pid, clock_pid_type(timer->it_clock));\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic inline struct task_struct *cpu_timer_task_rcu(struct k_itimer *timer)\n{\n\treturn pid_task(timer->it.cpu.pid, clock_pid_type(timer->it_clock));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "timer->it_clock"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer)\n{\n\tclockid_t clkid = CPUCLOCK_WHICH(timer->it_clock);\n\tstruct task_struct *p;\n\tstruct sighand_struct *sighand;\n\tunsigned long flags;\n\tu64 now;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p)\n\t\tgoto out;\n\n\t/* Protect timer list r/w in arm_timer() */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL))\n\t\tgoto out;\n\n\t/*\n\t * Fetch the current sample and update the timer's expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\tnow = cpu_clock_sample(clkid, p);\n\telse\n\t\tnow = cpu_clock_sample_group(clkid, p, true);\n\n\tbump_cpu_timer(timer, now);\n\n\t/*\n\t * Now re-arm for the new expiry time.\n\t */\n\tarm_timer(timer, p);\n\tunlock_task_sighand(p, &flags);\nout:\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "check_process_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "967-1034",
    "snippet": "static void check_process_timers(struct task_struct *tsk,\n\t\t\t\t struct list_head *firing)\n{\n\tstruct signal_struct *const sig = tsk->signal;\n\tstruct posix_cputimers *pct = &sig->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\tunsigned long soft;\n\n\t/*\n\t * If there are no active process wide timers (POSIX 1.b, itimers,\n\t * RLIMIT_CPU) nothing to check. Also skip the process wide timer\n\t * processing when there is already another task handling them.\n\t */\n\tif (!READ_ONCE(pct->timers_active) || pct->expiry_active)\n\t\treturn;\n\n\t/*\n\t * Signify that a thread is checking for process timers.\n\t * Write access to this field is protected by the sighand lock.\n\t */\n\tpct->expiry_active = true;\n\n\t/*\n\t * Collect the current process totals. Group accounting is active\n\t * so the sample can be taken directly.\n\t */\n\tproc_sample_cputime_atomic(&sig->cputimer.cputime_atomic, samples);\n\tcollect_posix_cputimers(pct, samples, firing);\n\n\t/*\n\t * Check for the special case process timers.\n\t */\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_PROF],\n\t\t\t &pct->bases[CPUCLOCK_PROF].nextevt,\n\t\t\t samples[CPUCLOCK_PROF], SIGPROF);\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_VIRT],\n\t\t\t &pct->bases[CPUCLOCK_VIRT].nextevt,\n\t\t\t samples[CPUCLOCK_VIRT], SIGVTALRM);\n\n\tsoft = task_rlimit(tsk, RLIMIT_CPU);\n\tif (soft != RLIM_INFINITY) {\n\t\t/* RLIMIT_CPU is in seconds. Samples are nanoseconds */\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_CPU);\n\t\tu64 ptime = samples[CPUCLOCK_PROF];\n\t\tu64 softns = (u64)soft * NSEC_PER_SEC;\n\t\tu64 hardns = (u64)hard * NSEC_PER_SEC;\n\n\t\t/* At the hard limit, send SIGKILL. No further action. */\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    check_rlimit(ptime, hardns, SIGKILL, false, true))\n\t\t\treturn;\n\n\t\t/* At the soft limit, send a SIGXCPU every second */\n\t\tif (check_rlimit(ptime, softns, SIGXCPU, false, false)) {\n\t\t\tsig->rlim[RLIMIT_CPU].rlim_cur = soft + 1;\n\t\t\tsoftns += NSEC_PER_SEC;\n\t\t}\n\n\t\t/* Update the expiry cache */\n\t\tif (softns < pct->bases[CPUCLOCK_PROF].nextevt)\n\t\t\tpct->bases[CPUCLOCK_PROF].nextevt = softns;\n\t}\n\n\tif (expiry_cache_is_inactive(pct))\n\t\tstop_process_timers(sig);\n\n\tpct->expiry_active = false;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_process_timers",
          "args": [
            "sig"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "stop_process_timers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "931-938",
          "snippet": "static inline void stop_process_timers(struct signal_struct *sig)\n{\n\tstruct posix_cputimers *pct = &sig->posix_cputimers;\n\n\t/* Turn off the active flag. This is done without locking. */\n\tWRITE_ONCE(pct->timers_active, false);\n\ttick_dep_clear_signal(sig, TICK_DEP_BIT_POSIX_TIMER);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void stop_process_timers(struct signal_struct *sig)\n{\n\tstruct posix_cputimers *pct = &sig->posix_cputimers;\n\n\t/* Turn off the active flag. This is done without locking. */\n\tWRITE_ONCE(pct->timers_active, false);\n\ttick_dep_clear_signal(sig, TICK_DEP_BIT_POSIX_TIMER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expiry_cache_is_inactive",
          "args": [
            "pct"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "expiry_cache_is_inactive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "146-151",
          "snippet": "static inline bool expiry_cache_is_inactive(const struct posix_cputimers *pct)\n{\n\treturn !(~pct->bases[CPUCLOCK_PROF].nextevt |\n\t\t ~pct->bases[CPUCLOCK_VIRT].nextevt |\n\t\t ~pct->bases[CPUCLOCK_SCHED].nextevt);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline bool expiry_cache_is_inactive(const struct posix_cputimers *pct)\n{\n\treturn !(~pct->bases[CPUCLOCK_PROF].nextevt |\n\t\t ~pct->bases[CPUCLOCK_VIRT].nextevt |\n\t\t ~pct->bases[CPUCLOCK_SCHED].nextevt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_rlimit",
          "args": [
            "ptime",
            "softns",
            "SIGXCPU",
            "false",
            "false"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "check_rlimit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "871-883",
          "snippet": "static bool check_rlimit(u64 time, u64 limit, int signo, bool rt, bool hard)\n{\n\tif (time < limit)\n\t\treturn false;\n\n\tif (print_fatal_signals) {\n\t\tpr_info(\"%s Watchdog Timeout (%s): %s[%d]\\n\",\n\t\t\trt ? \"RT\" : \"CPU\", hard ? \"hard\" : \"soft\",\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t}\n\t__group_send_sig_info(signo, SEND_SIG_PRIV, current);\n\treturn true;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic bool check_rlimit(u64 time, u64 limit, int signo, bool rt, bool hard)\n{\n\tif (time < limit)\n\t\treturn false;\n\n\tif (print_fatal_signals) {\n\t\tpr_info(\"%s Watchdog Timeout (%s): %s[%d]\\n\",\n\t\t\trt ? \"RT\" : \"CPU\", hard ? \"hard\" : \"soft\",\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t}\n\t__group_send_sig_info(signo, SEND_SIG_PRIV, current);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rlimit_max",
          "args": [
            "tsk",
            "RLIMIT_CPU"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rlimit",
          "args": [
            "tsk",
            "RLIMIT_CPU"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_cpu_itimer",
          "args": [
            "tsk",
            "&sig->it[CPUCLOCK_VIRT]",
            "&pct->bases[CPUCLOCK_VIRT].nextevt",
            "samples[CPUCLOCK_VIRT]",
            "SIGVTALRM"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "check_cpu_itimer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "940-960",
          "snippet": "static void check_cpu_itimer(struct task_struct *tsk, struct cpu_itimer *it,\n\t\t\t     u64 *expires, u64 cur_time, int signo)\n{\n\tif (!it->expires)\n\t\treturn;\n\n\tif (cur_time >= it->expires) {\n\t\tif (it->incr)\n\t\t\tit->expires += it->incr;\n\t\telse\n\t\t\tit->expires = 0;\n\n\t\ttrace_itimer_expire(signo == SIGPROF ?\n\t\t\t\t    ITIMER_PROF : ITIMER_VIRTUAL,\n\t\t\t\t    task_tgid(tsk), cur_time);\n\t\t__group_send_sig_info(signo, SEND_SIG_PRIV, tsk);\n\t}\n\n\tif (it->expires && it->expires < *expires)\n\t\t*expires = it->expires;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void check_cpu_itimer(struct task_struct *tsk, struct cpu_itimer *it,\n\t\t\t     u64 *expires, u64 cur_time, int signo)\n{\n\tif (!it->expires)\n\t\treturn;\n\n\tif (cur_time >= it->expires) {\n\t\tif (it->incr)\n\t\t\tit->expires += it->incr;\n\t\telse\n\t\t\tit->expires = 0;\n\n\t\ttrace_itimer_expire(signo == SIGPROF ?\n\t\t\t\t    ITIMER_PROF : ITIMER_VIRTUAL,\n\t\t\t\t    task_tgid(tsk), cur_time);\n\t\t__group_send_sig_info(signo, SEND_SIG_PRIV, tsk);\n\t}\n\n\tif (it->expires && it->expires < *expires)\n\t\t*expires = it->expires;\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_posix_cputimers",
          "args": [
            "pct",
            "samples",
            "firing"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "collect_posix_cputimers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "851-861",
          "snippet": "static void collect_posix_cputimers(struct posix_cputimers *pct, u64 *samples,\n\t\t\t\t    struct list_head *firing)\n{\n\tstruct posix_cputimer_base *base = pct->bases;\n\tint i;\n\n\tfor (i = 0; i < CPUCLOCK_MAX; i++, base++) {\n\t\tbase->nextevt = collect_timerqueue(&base->tqhead, firing,\n\t\t\t\t\t\t    samples[i]);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void collect_posix_cputimers(struct posix_cputimers *pct, u64 *samples,\n\t\t\t\t    struct list_head *firing)\n{\n\tstruct posix_cputimer_base *base = pct->bases;\n\tint i;\n\n\tfor (i = 0; i < CPUCLOCK_MAX; i++, base++) {\n\t\tbase->nextevt = collect_timerqueue(&base->tqhead, firing,\n\t\t\t\t\t\t    samples[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_sample_cputime_atomic",
          "args": [
            "&sig->cputimer.cputime_atomic",
            "samples"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sample_cputime_atomic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "223-232",
          "snippet": "static void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pct->timers_active"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void check_process_timers(struct task_struct *tsk,\n\t\t\t\t struct list_head *firing)\n{\n\tstruct signal_struct *const sig = tsk->signal;\n\tstruct posix_cputimers *pct = &sig->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\tunsigned long soft;\n\n\t/*\n\t * If there are no active process wide timers (POSIX 1.b, itimers,\n\t * RLIMIT_CPU) nothing to check. Also skip the process wide timer\n\t * processing when there is already another task handling them.\n\t */\n\tif (!READ_ONCE(pct->timers_active) || pct->expiry_active)\n\t\treturn;\n\n\t/*\n\t * Signify that a thread is checking for process timers.\n\t * Write access to this field is protected by the sighand lock.\n\t */\n\tpct->expiry_active = true;\n\n\t/*\n\t * Collect the current process totals. Group accounting is active\n\t * so the sample can be taken directly.\n\t */\n\tproc_sample_cputime_atomic(&sig->cputimer.cputime_atomic, samples);\n\tcollect_posix_cputimers(pct, samples, firing);\n\n\t/*\n\t * Check for the special case process timers.\n\t */\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_PROF],\n\t\t\t &pct->bases[CPUCLOCK_PROF].nextevt,\n\t\t\t samples[CPUCLOCK_PROF], SIGPROF);\n\tcheck_cpu_itimer(tsk, &sig->it[CPUCLOCK_VIRT],\n\t\t\t &pct->bases[CPUCLOCK_VIRT].nextevt,\n\t\t\t samples[CPUCLOCK_VIRT], SIGVTALRM);\n\n\tsoft = task_rlimit(tsk, RLIMIT_CPU);\n\tif (soft != RLIM_INFINITY) {\n\t\t/* RLIMIT_CPU is in seconds. Samples are nanoseconds */\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_CPU);\n\t\tu64 ptime = samples[CPUCLOCK_PROF];\n\t\tu64 softns = (u64)soft * NSEC_PER_SEC;\n\t\tu64 hardns = (u64)hard * NSEC_PER_SEC;\n\n\t\t/* At the hard limit, send SIGKILL. No further action. */\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    check_rlimit(ptime, hardns, SIGKILL, false, true))\n\t\t\treturn;\n\n\t\t/* At the soft limit, send a SIGXCPU every second */\n\t\tif (check_rlimit(ptime, softns, SIGXCPU, false, false)) {\n\t\t\tsig->rlim[RLIMIT_CPU].rlim_cur = soft + 1;\n\t\t\tsoftns += NSEC_PER_SEC;\n\t\t}\n\n\t\t/* Update the expiry cache */\n\t\tif (softns < pct->bases[CPUCLOCK_PROF].nextevt)\n\t\t\tpct->bases[CPUCLOCK_PROF].nextevt = softns;\n\t}\n\n\tif (expiry_cache_is_inactive(pct))\n\t\tstop_process_timers(sig);\n\n\tpct->expiry_active = false;\n}"
  },
  {
    "function_name": "check_cpu_itimer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "940-960",
    "snippet": "static void check_cpu_itimer(struct task_struct *tsk, struct cpu_itimer *it,\n\t\t\t     u64 *expires, u64 cur_time, int signo)\n{\n\tif (!it->expires)\n\t\treturn;\n\n\tif (cur_time >= it->expires) {\n\t\tif (it->incr)\n\t\t\tit->expires += it->incr;\n\t\telse\n\t\t\tit->expires = 0;\n\n\t\ttrace_itimer_expire(signo == SIGPROF ?\n\t\t\t\t    ITIMER_PROF : ITIMER_VIRTUAL,\n\t\t\t\t    task_tgid(tsk), cur_time);\n\t\t__group_send_sig_info(signo, SEND_SIG_PRIV, tsk);\n\t}\n\n\tif (it->expires && it->expires < *expires)\n\t\t*expires = it->expires;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__group_send_sig_info",
          "args": [
            "signo",
            "SEND_SIG_PRIV",
            "tsk"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "__group_send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1284-1288",
          "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_itimer_expire",
          "args": [
            "signo == SIGPROF ?\n\t\t\t\t    ITIMER_PROF : ITIMER_VIRTUAL",
            "task_tgid(tsk)",
            "cur_time"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "tsk"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void check_cpu_itimer(struct task_struct *tsk, struct cpu_itimer *it,\n\t\t\t     u64 *expires, u64 cur_time, int signo)\n{\n\tif (!it->expires)\n\t\treturn;\n\n\tif (cur_time >= it->expires) {\n\t\tif (it->incr)\n\t\t\tit->expires += it->incr;\n\t\telse\n\t\t\tit->expires = 0;\n\n\t\ttrace_itimer_expire(signo == SIGPROF ?\n\t\t\t\t    ITIMER_PROF : ITIMER_VIRTUAL,\n\t\t\t\t    task_tgid(tsk), cur_time);\n\t\t__group_send_sig_info(signo, SEND_SIG_PRIV, tsk);\n\t}\n\n\tif (it->expires && it->expires < *expires)\n\t\t*expires = it->expires;\n}"
  },
  {
    "function_name": "stop_process_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "931-938",
    "snippet": "static inline void stop_process_timers(struct signal_struct *sig)\n{\n\tstruct posix_cputimers *pct = &sig->posix_cputimers;\n\n\t/* Turn off the active flag. This is done without locking. */\n\tWRITE_ONCE(pct->timers_active, false);\n\ttick_dep_clear_signal(sig, TICK_DEP_BIT_POSIX_TIMER);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_clear_signal",
          "args": [
            "sig",
            "TICK_DEP_BIT_POSIX_TIMER"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "pct->timers_active",
            "false"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void stop_process_timers(struct signal_struct *sig)\n{\n\tstruct posix_cputimers *pct = &sig->posix_cputimers;\n\n\t/* Turn off the active flag. This is done without locking. */\n\tWRITE_ONCE(pct->timers_active, false);\n\ttick_dep_clear_signal(sig, TICK_DEP_BIT_POSIX_TIMER);\n}"
  },
  {
    "function_name": "check_thread_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "890-929",
    "snippet": "static void check_thread_timers(struct task_struct *tsk,\n\t\t\t\tstruct list_head *firing)\n{\n\tstruct posix_cputimers *pct = &tsk->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\tif (expiry_cache_is_inactive(pct))\n\t\treturn;\n\n\ttask_sample_cputime(tsk, samples);\n\tcollect_posix_cputimers(pct, samples, firing);\n\n\t/*\n\t * Check for the special case thread timers.\n\t */\n\tsoft = task_rlimit(tsk, RLIMIT_RTTIME);\n\tif (soft != RLIM_INFINITY) {\n\t\t/* Task RT timeout is accounted in jiffies. RTTIME is usec */\n\t\tunsigned long rttime = tsk->rt.timeout * (USEC_PER_SEC / HZ);\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_RTTIME);\n\n\t\t/* At the hard limit, send SIGKILL. No further action. */\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    check_rlimit(rttime, hard, SIGKILL, true, true))\n\t\t\treturn;\n\n\t\t/* At the soft limit, send a SIGXCPU every second */\n\t\tif (check_rlimit(rttime, soft, SIGXCPU, true, false)) {\n\t\t\tsoft += USEC_PER_SEC;\n\t\t\ttsk->signal->rlim[RLIMIT_RTTIME].rlim_cur = soft;\n\t\t}\n\t}\n\n\tif (expiry_cache_is_inactive(pct))\n\t\ttick_dep_clear_task(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_clear_task",
          "args": [
            "tsk",
            "TICK_DEP_BIT_POSIX_TIMER"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expiry_cache_is_inactive",
          "args": [
            "pct"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "expiry_cache_is_inactive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "146-151",
          "snippet": "static inline bool expiry_cache_is_inactive(const struct posix_cputimers *pct)\n{\n\treturn !(~pct->bases[CPUCLOCK_PROF].nextevt |\n\t\t ~pct->bases[CPUCLOCK_VIRT].nextevt |\n\t\t ~pct->bases[CPUCLOCK_SCHED].nextevt);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline bool expiry_cache_is_inactive(const struct posix_cputimers *pct)\n{\n\treturn !(~pct->bases[CPUCLOCK_PROF].nextevt |\n\t\t ~pct->bases[CPUCLOCK_VIRT].nextevt |\n\t\t ~pct->bases[CPUCLOCK_SCHED].nextevt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_rlimit",
          "args": [
            "rttime",
            "soft",
            "SIGXCPU",
            "true",
            "false"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "check_rlimit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "871-883",
          "snippet": "static bool check_rlimit(u64 time, u64 limit, int signo, bool rt, bool hard)\n{\n\tif (time < limit)\n\t\treturn false;\n\n\tif (print_fatal_signals) {\n\t\tpr_info(\"%s Watchdog Timeout (%s): %s[%d]\\n\",\n\t\t\trt ? \"RT\" : \"CPU\", hard ? \"hard\" : \"soft\",\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t}\n\t__group_send_sig_info(signo, SEND_SIG_PRIV, current);\n\treturn true;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic bool check_rlimit(u64 time, u64 limit, int signo, bool rt, bool hard)\n{\n\tif (time < limit)\n\t\treturn false;\n\n\tif (print_fatal_signals) {\n\t\tpr_info(\"%s Watchdog Timeout (%s): %s[%d]\\n\",\n\t\t\trt ? \"RT\" : \"CPU\", hard ? \"hard\" : \"soft\",\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t}\n\t__group_send_sig_info(signo, SEND_SIG_PRIV, current);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rlimit_max",
          "args": [
            "tsk",
            "RLIMIT_RTTIME"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rlimit",
          "args": [
            "tsk",
            "RLIMIT_RTTIME"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_posix_cputimers",
          "args": [
            "pct",
            "samples",
            "firing"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "collect_posix_cputimers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "851-861",
          "snippet": "static void collect_posix_cputimers(struct posix_cputimers *pct, u64 *samples,\n\t\t\t\t    struct list_head *firing)\n{\n\tstruct posix_cputimer_base *base = pct->bases;\n\tint i;\n\n\tfor (i = 0; i < CPUCLOCK_MAX; i++, base++) {\n\t\tbase->nextevt = collect_timerqueue(&base->tqhead, firing,\n\t\t\t\t\t\t    samples[i]);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void collect_posix_cputimers(struct posix_cputimers *pct, u64 *samples,\n\t\t\t\t    struct list_head *firing)\n{\n\tstruct posix_cputimer_base *base = pct->bases;\n\tint i;\n\n\tfor (i = 0; i < CPUCLOCK_MAX; i++, base++) {\n\t\tbase->nextevt = collect_timerqueue(&base->tqhead, firing,\n\t\t\t\t\t\t    samples[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_sample_cputime",
          "args": [
            "tsk",
            "samples"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "task_sample_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "215-221",
          "snippet": "static void task_sample_cputime(struct task_struct *p, u64 *samples)\n{\n\tu64 stime, utime;\n\n\ttask_cputime(p, &utime, &stime);\n\tstore_samples(samples, stime, utime, p->se.sum_exec_runtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void task_sample_cputime(struct task_struct *p, u64 *samples)\n{\n\tu64 stime, utime;\n\n\ttask_cputime(p, &utime, &stime);\n\tstore_samples(samples, stime, utime, p->se.sum_exec_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_dl_overrun",
          "args": [
            "tsk"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "check_dl_overrun",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "863-869",
          "snippet": "static inline void check_dl_overrun(struct task_struct *tsk)\n{\n\tif (tsk->dl.dl_overrun) {\n\t\ttsk->dl.dl_overrun = 0;\n\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline void check_dl_overrun(struct task_struct *tsk)\n{\n\tif (tsk->dl.dl_overrun) {\n\t\ttsk->dl.dl_overrun = 0;\n\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "tsk"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void check_thread_timers(struct task_struct *tsk,\n\t\t\t\tstruct list_head *firing)\n{\n\tstruct posix_cputimers *pct = &tsk->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\tunsigned long soft;\n\n\tif (dl_task(tsk))\n\t\tcheck_dl_overrun(tsk);\n\n\tif (expiry_cache_is_inactive(pct))\n\t\treturn;\n\n\ttask_sample_cputime(tsk, samples);\n\tcollect_posix_cputimers(pct, samples, firing);\n\n\t/*\n\t * Check for the special case thread timers.\n\t */\n\tsoft = task_rlimit(tsk, RLIMIT_RTTIME);\n\tif (soft != RLIM_INFINITY) {\n\t\t/* Task RT timeout is accounted in jiffies. RTTIME is usec */\n\t\tunsigned long rttime = tsk->rt.timeout * (USEC_PER_SEC / HZ);\n\t\tunsigned long hard = task_rlimit_max(tsk, RLIMIT_RTTIME);\n\n\t\t/* At the hard limit, send SIGKILL. No further action. */\n\t\tif (hard != RLIM_INFINITY &&\n\t\t    check_rlimit(rttime, hard, SIGKILL, true, true))\n\t\t\treturn;\n\n\t\t/* At the soft limit, send a SIGXCPU every second */\n\t\tif (check_rlimit(rttime, soft, SIGXCPU, true, false)) {\n\t\t\tsoft += USEC_PER_SEC;\n\t\t\ttsk->signal->rlim[RLIMIT_RTTIME].rlim_cur = soft;\n\t\t}\n\t}\n\n\tif (expiry_cache_is_inactive(pct))\n\t\ttick_dep_clear_task(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}"
  },
  {
    "function_name": "check_rlimit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "871-883",
    "snippet": "static bool check_rlimit(u64 time, u64 limit, int signo, bool rt, bool hard)\n{\n\tif (time < limit)\n\t\treturn false;\n\n\tif (print_fatal_signals) {\n\t\tpr_info(\"%s Watchdog Timeout (%s): %s[%d]\\n\",\n\t\t\trt ? \"RT\" : \"CPU\", hard ? \"hard\" : \"soft\",\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t}\n\t__group_send_sig_info(signo, SEND_SIG_PRIV, current);\n\treturn true;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__group_send_sig_info",
          "args": [
            "signo",
            "SEND_SIG_PRIV",
            "current"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "__group_send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1284-1288",
          "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s Watchdog Timeout (%s): %s[%d]\\n\"",
            "rt ? \"RT\" : \"CPU\"",
            "hard ? \"hard\" : \"soft\"",
            "current->comm",
            "task_pid_nr(current)"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic bool check_rlimit(u64 time, u64 limit, int signo, bool rt, bool hard)\n{\n\tif (time < limit)\n\t\treturn false;\n\n\tif (print_fatal_signals) {\n\t\tpr_info(\"%s Watchdog Timeout (%s): %s[%d]\\n\",\n\t\t\trt ? \"RT\" : \"CPU\", hard ? \"hard\" : \"soft\",\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t}\n\t__group_send_sig_info(signo, SEND_SIG_PRIV, current);\n\treturn true;\n}"
  },
  {
    "function_name": "check_dl_overrun",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "863-869",
    "snippet": "static inline void check_dl_overrun(struct task_struct *tsk)\n{\n\tif (tsk->dl.dl_overrun) {\n\t\ttsk->dl.dl_overrun = 0;\n\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__group_send_sig_info",
          "args": [
            "SIGXCPU",
            "SEND_SIG_PRIV",
            "tsk"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "__group_send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1284-1288",
          "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic inline void check_dl_overrun(struct task_struct *tsk)\n{\n\tif (tsk->dl.dl_overrun) {\n\t\ttsk->dl.dl_overrun = 0;\n\t\t__group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);\n\t}\n}"
  },
  {
    "function_name": "collect_posix_cputimers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "851-861",
    "snippet": "static void collect_posix_cputimers(struct posix_cputimers *pct, u64 *samples,\n\t\t\t\t    struct list_head *firing)\n{\n\tstruct posix_cputimer_base *base = pct->bases;\n\tint i;\n\n\tfor (i = 0; i < CPUCLOCK_MAX; i++, base++) {\n\t\tbase->nextevt = collect_timerqueue(&base->tqhead, firing,\n\t\t\t\t\t\t    samples[i]);\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "collect_timerqueue",
          "args": [
            "&base->tqhead",
            "firing",
            "samples[i]"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "collect_timerqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "827-849",
          "snippet": "static u64 collect_timerqueue(struct timerqueue_head *head,\n\t\t\t      struct list_head *firing, u64 now)\n{\n\tstruct timerqueue_node *next;\n\tint i = 0;\n\n\twhile ((next = timerqueue_getnext(head))) {\n\t\tstruct cpu_timer *ctmr;\n\t\tu64 expires;\n\n\t\tctmr = container_of(next, struct cpu_timer, node);\n\t\texpires = cpu_timer_getexpires(ctmr);\n\t\t/* Limit the number of timers to expire at once */\n\t\tif (++i == MAX_COLLECTED || now < expires)\n\t\t\treturn expires;\n\n\t\tctmr->firing = 1;\n\t\tcpu_timer_dequeue(ctmr);\n\t\tlist_add_tail(&ctmr->elist, firing);\n\t}\n\n\treturn U64_MAX;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [
            "#define MAX_COLLECTED\t20"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define MAX_COLLECTED\t20\n\nstatic u64 collect_timerqueue(struct timerqueue_head *head,\n\t\t\t      struct list_head *firing, u64 now)\n{\n\tstruct timerqueue_node *next;\n\tint i = 0;\n\n\twhile ((next = timerqueue_getnext(head))) {\n\t\tstruct cpu_timer *ctmr;\n\t\tu64 expires;\n\n\t\tctmr = container_of(next, struct cpu_timer, node);\n\t\texpires = cpu_timer_getexpires(ctmr);\n\t\t/* Limit the number of timers to expire at once */\n\t\tif (++i == MAX_COLLECTED || now < expires)\n\t\t\treturn expires;\n\n\t\tctmr->firing = 1;\n\t\tcpu_timer_dequeue(ctmr);\n\t\tlist_add_tail(&ctmr->elist, firing);\n\t}\n\n\treturn U64_MAX;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void collect_posix_cputimers(struct posix_cputimers *pct, u64 *samples,\n\t\t\t\t    struct list_head *firing)\n{\n\tstruct posix_cputimer_base *base = pct->bases;\n\tint i;\n\n\tfor (i = 0; i < CPUCLOCK_MAX; i++, base++) {\n\t\tbase->nextevt = collect_timerqueue(&base->tqhead, firing,\n\t\t\t\t\t\t    samples[i]);\n\t}\n}"
  },
  {
    "function_name": "collect_timerqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "827-849",
    "snippet": "static u64 collect_timerqueue(struct timerqueue_head *head,\n\t\t\t      struct list_head *firing, u64 now)\n{\n\tstruct timerqueue_node *next;\n\tint i = 0;\n\n\twhile ((next = timerqueue_getnext(head))) {\n\t\tstruct cpu_timer *ctmr;\n\t\tu64 expires;\n\n\t\tctmr = container_of(next, struct cpu_timer, node);\n\t\texpires = cpu_timer_getexpires(ctmr);\n\t\t/* Limit the number of timers to expire at once */\n\t\tif (++i == MAX_COLLECTED || now < expires)\n\t\t\treturn expires;\n\n\t\tctmr->firing = 1;\n\t\tcpu_timer_dequeue(ctmr);\n\t\tlist_add_tail(&ctmr->elist, firing);\n\t}\n\n\treturn U64_MAX;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [
      "#define MAX_COLLECTED\t20"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ctmr->elist",
            "firing"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_dequeue",
          "args": [
            "ctmr"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_getexpires",
          "args": [
            "ctmr"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "next",
            "structcpu_timer",
            "node"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "head"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\n#define MAX_COLLECTED\t20\n\nstatic u64 collect_timerqueue(struct timerqueue_head *head,\n\t\t\t      struct list_head *firing, u64 now)\n{\n\tstruct timerqueue_node *next;\n\tint i = 0;\n\n\twhile ((next = timerqueue_getnext(head))) {\n\t\tstruct cpu_timer *ctmr;\n\t\tu64 expires;\n\n\t\tctmr = container_of(next, struct cpu_timer, node);\n\t\texpires = cpu_timer_getexpires(ctmr);\n\t\t/* Limit the number of timers to expire at once */\n\t\tif (++i == MAX_COLLECTED || now < expires)\n\t\t\treturn expires;\n\n\t\tctmr->firing = 1;\n\t\tcpu_timer_dequeue(ctmr);\n\t\tlist_add_tail(&ctmr->elist, firing);\n\t}\n\n\treturn U64_MAX;\n}"
  },
  {
    "function_name": "posix_cpu_timer_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "783-823",
    "snippet": "static void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec64 *itp)\n{\n\tclockid_t clkid = CPUCLOCK_WHICH(timer->it_clock);\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tu64 now, expires = cpu_timer_getexpires(ctmr);\n\tstruct task_struct *p;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p)\n\t\tgoto out;\n\n\t/*\n\t * Easy part: convert the reload time.\n\t */\n\titp->it_interval = ktime_to_timespec64(timer->it_interval);\n\n\tif (!expires)\n\t\tgoto out;\n\n\t/*\n\t * Sample the clock to take the difference with the expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\tnow = cpu_clock_sample(clkid, p);\n\telse\n\t\tnow = cpu_clock_sample_group(clkid, p, false);\n\n\tif (now < expires) {\n\t\titp->it_value = ns_to_timespec64(expires - now);\n\t} else {\n\t\t/*\n\t\t * The timer should have expired already, but the firing\n\t\t * hasn't taken place yet.  Say it's just about to expire.\n\t\t */\n\t\titp->it_value.tv_nsec = 1;\n\t\titp->it_value.tv_sec = 0;\n\t}\nout:\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "expires - now"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "506-525",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample_group",
          "args": [
            "clkid",
            "p",
            "false"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "334-351",
          "snippet": "static u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample",
          "args": [
            "clkid",
            "p"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "188-206",
          "snippet": "static u64 cpu_clock_sample(const clockid_t clkid, struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\tif (clkid == CPUCLOCK_SCHED)\n\t\treturn task_sched_runtime(p);\n\n\ttask_cputime(p, &utime, &stime);\n\n\tswitch (clkid) {\n\tcase CPUCLOCK_PROF:\n\t\treturn utime + stime;\n\tcase CPUCLOCK_VIRT:\n\t\treturn utime;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic u64 cpu_clock_sample(const clockid_t clkid, struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\tif (clkid == CPUCLOCK_SCHED)\n\t\treturn task_sched_runtime(p);\n\n\ttask_cputime(p, &utime, &stime);\n\n\tswitch (clkid) {\n\tcase CPUCLOCK_PROF:\n\t\treturn utime + stime;\n\tcase CPUCLOCK_VIRT:\n\t\treturn utime;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "timer->it_clock"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "timer->it_interval"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_task_rcu",
          "args": [
            "timer"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_task_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "107-110",
          "snippet": "static inline struct task_struct *cpu_timer_task_rcu(struct k_itimer *timer)\n{\n\treturn pid_task(timer->it.cpu.pid, clock_pid_type(timer->it_clock));\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic inline struct task_struct *cpu_timer_task_rcu(struct k_itimer *timer)\n{\n\treturn pid_task(timer->it.cpu.pid, clock_pid_type(timer->it_clock));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_getexpires",
          "args": [
            "ctmr"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "timer->it_clock"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec64 *itp)\n{\n\tclockid_t clkid = CPUCLOCK_WHICH(timer->it_clock);\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tu64 now, expires = cpu_timer_getexpires(ctmr);\n\tstruct task_struct *p;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p)\n\t\tgoto out;\n\n\t/*\n\t * Easy part: convert the reload time.\n\t */\n\titp->it_interval = ktime_to_timespec64(timer->it_interval);\n\n\tif (!expires)\n\t\tgoto out;\n\n\t/*\n\t * Sample the clock to take the difference with the expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\tnow = cpu_clock_sample(clkid, p);\n\telse\n\t\tnow = cpu_clock_sample_group(clkid, p, false);\n\n\tif (now < expires) {\n\t\titp->it_value = ns_to_timespec64(expires - now);\n\t} else {\n\t\t/*\n\t\t * The timer should have expired already, but the firing\n\t\t * hasn't taken place yet.  Say it's just about to expire.\n\t\t */\n\t\titp->it_value.tv_nsec = 1;\n\t\titp->it_value.tv_sec = 0;\n\t}\nout:\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "posix_cpu_timer_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "618-781",
    "snippet": "static int posix_cpu_timer_set(struct k_itimer *timer, int timer_flags,\n\t\t\t       struct itimerspec64 *new, struct itimerspec64 *old)\n{\n\tclockid_t clkid = CPUCLOCK_WHICH(timer->it_clock);\n\tu64 old_expires, new_expires, old_incr, val;\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p) {\n\t\t/*\n\t\t * If p has just been reaped, we can no\n\t\t * longer get any information about it at all.\n\t\t */\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnew_expires = ktime_to_ns(timespec64_to_ktime(new->it_value));\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and p->cpu_timers\n\t * and p->signal->cpu_timers read/write in arm_timer()\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\t/*\n\t * If p has just been reaped, we can no\n\t * longer get any information about it at all.\n\t */\n\tif (unlikely(sighand == NULL)) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Disarm any old timer after extracting its expiry time.\n\t */\n\told_incr = timer->it_interval;\n\told_expires = cpu_timer_getexpires(ctmr);\n\n\tif (unlikely(timer->it.cpu.firing)) {\n\t\ttimer->it.cpu.firing = -1;\n\t\tret = TIMER_RETRY;\n\t} else {\n\t\tcpu_timer_dequeue(ctmr);\n\t}\n\n\t/*\n\t * We need to sample the current value to convert the new\n\t * value from to relative and absolute, and to convert the\n\t * old value from absolute to relative.  To set a process\n\t * timer, we need a sample to balance the thread expiry\n\t * times (in arm_timer).  With an absolute time, we must\n\t * check if it's already passed.  In short, we need a sample.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\tval = cpu_clock_sample(clkid, p);\n\telse\n\t\tval = cpu_clock_sample_group(clkid, p, true);\n\n\tif (old) {\n\t\tif (old_expires == 0) {\n\t\t\told->it_value.tv_sec = 0;\n\t\t\told->it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Update the timer in case it has overrun already.\n\t\t\t * If it has, we'll report it as having overrun and\n\t\t\t * with the next reloaded timer already ticking,\n\t\t\t * though we are swallowing that pending\n\t\t\t * notification here to install the new setting.\n\t\t\t */\n\t\t\tu64 exp = bump_cpu_timer(timer, val);\n\n\t\t\tif (val < exp) {\n\t\t\t\told_expires = exp - val;\n\t\t\t\told->it_value = ns_to_timespec64(old_expires);\n\t\t\t} else {\n\t\t\t\told->it_value.tv_nsec = 1;\n\t\t\t\told->it_value.tv_sec = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * We are colliding with the timer actually firing.\n\t\t * Punt after filling in the timer's old value, and\n\t\t * disable this firing since we are already reporting\n\t\t * it as an overrun (thanks to bump_cpu_timer above).\n\t\t */\n\t\tunlock_task_sighand(p, &flags);\n\t\tgoto out;\n\t}\n\n\tif (new_expires != 0 && !(timer_flags & TIMER_ABSTIME)) {\n\t\tnew_expires += val;\n\t}\n\n\t/*\n\t * Install the new expiry time (or zero).\n\t * For a timer with no notification action, we don't actually\n\t * arm the timer (we'll just fake it for timer_gettime).\n\t */\n\tcpu_timer_setexpires(ctmr, new_expires);\n\tif (new_expires != 0 && val < new_expires) {\n\t\tarm_timer(timer, p);\n\t}\n\n\tunlock_task_sighand(p, &flags);\n\t/*\n\t * Install the new reload setting, and\n\t * set up the signal and overrun bookkeeping.\n\t */\n\ttimer->it_interval = timespec64_to_ktime(new->it_interval);\n\n\t/*\n\t * This acts as a modification timestamp for the timer,\n\t * so any automatic reload attempt will punt on seeing\n\t * that we have reset the timer manually.\n\t */\n\ttimer->it_requeue_pending = (timer->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimer->it_overrun_last = 0;\n\ttimer->it_overrun = -1;\n\n\tif (val >= new_expires) {\n\t\tif (new_expires != 0) {\n\t\t\t/*\n\t\t\t * The designated time already passed, so we notify\n\t\t\t * immediately, even if the thread never runs to\n\t\t\t * accumulate more time on this clock.\n\t\t\t */\n\t\t\tcpu_timer_fire(timer);\n\t\t}\n\n\t\t/*\n\t\t * Make sure we don't keep around the process wide cputime\n\t\t * counter or the tick dependency if they are not necessary.\n\t\t */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (!sighand)\n\t\t\tgoto out;\n\n\t\tif (!cpu_timer_queued(ctmr))\n\t\t\ttrigger_base_recalc_expires(timer, p);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n out:\n\trcu_read_unlock();\n\tif (old)\n\t\told->it_interval = ns_to_timespec64(old_incr);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "old_incr"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "506-525",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trigger_base_recalc_expires",
          "args": [
            "timer",
            "p"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_base_recalc_expires",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "428-434",
          "snippet": "static void trigger_base_recalc_expires(struct k_itimer *timer,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, tsk);\n\n\tbase->nextevt = 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void trigger_base_recalc_expires(struct k_itimer *timer,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, tsk);\n\n\tbase->nextevt = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_queued",
          "args": [
            "ctmr"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1384-1414",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_fire",
          "args": [
            "timer"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_fire",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "578-610",
          "snippet": "static void cpu_timer_fire(struct k_itimer *timer)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (!timer->it_interval) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void cpu_timer_fire(struct k_itimer *timer)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (!timer->it_interval) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "new->it_interval"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arm_timer",
          "args": [
            "timer",
            "p"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "arm_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "551-573",
          "snippet": "static void arm_timer(struct k_itimer *timer, struct task_struct *p)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, p);\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tu64 newexp = cpu_timer_getexpires(ctmr);\n\n\tif (!cpu_timer_enqueue(&base->tqhead, ctmr))\n\t\treturn;\n\n\t/*\n\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t * need to update expiration cache. Take into account that\n\t * for process timers we share expiration cache with itimers\n\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t */\n\tif (newexp < base->nextevt)\n\t\tbase->nextevt = newexp;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\telse\n\t\ttick_dep_set_signal(p, TICK_DEP_BIT_POSIX_TIMER);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void arm_timer(struct k_itimer *timer, struct task_struct *p)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, p);\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tu64 newexp = cpu_timer_getexpires(ctmr);\n\n\tif (!cpu_timer_enqueue(&base->tqhead, ctmr))\n\t\treturn;\n\n\t/*\n\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t * need to update expiration cache. Take into account that\n\t * for process timers we share expiration cache with itimers\n\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t */\n\tif (newexp < base->nextevt)\n\t\tbase->nextevt = newexp;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\telse\n\t\ttick_dep_set_signal(p, TICK_DEP_BIT_POSIX_TIMER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_setexpires",
          "args": [
            "ctmr",
            "new_expires"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bump_cpu_timer",
          "args": [
            "timer",
            "val"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "bump_cpu_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "116-143",
          "snippet": "static u64 bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tu64 delta, incr, expires = timer->it.cpu.node.expires;\n\tint i;\n\n\tif (!timer->it_interval)\n\t\treturn expires;\n\n\tif (now < expires)\n\t\treturn expires;\n\n\tincr = timer->it_interval;\n\tdelta = now + incr - expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.node.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n\treturn timer->it.cpu.node.expires;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic u64 bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tu64 delta, incr, expires = timer->it.cpu.node.expires;\n\tint i;\n\n\tif (!timer->it_interval)\n\t\treturn expires;\n\n\tif (now < expires)\n\t\treturn expires;\n\n\tincr = timer->it_interval;\n\tdelta = now + incr - expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.node.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n\treturn timer->it.cpu.node.expires;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample_group",
          "args": [
            "clkid",
            "p",
            "true"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "334-351",
          "snippet": "static u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample",
          "args": [
            "clkid",
            "p"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "188-206",
          "snippet": "static u64 cpu_clock_sample(const clockid_t clkid, struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\tif (clkid == CPUCLOCK_SCHED)\n\t\treturn task_sched_runtime(p);\n\n\ttask_cputime(p, &utime, &stime);\n\n\tswitch (clkid) {\n\tcase CPUCLOCK_PROF:\n\t\treturn utime + stime;\n\tcase CPUCLOCK_VIRT:\n\t\treturn utime;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic u64 cpu_clock_sample(const clockid_t clkid, struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\tif (clkid == CPUCLOCK_SCHED)\n\t\treturn task_sched_runtime(p);\n\n\ttask_cputime(p, &utime, &stime);\n\n\tswitch (clkid) {\n\tcase CPUCLOCK_PROF:\n\t\treturn utime + stime;\n\tcase CPUCLOCK_VIRT:\n\t\treturn utime;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "timer->it_clock"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_dequeue",
          "args": [
            "ctmr"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "timer->it.cpu.firing"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_getexpires",
          "args": [
            "ctmr"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sighand == NULL"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "timespec64_to_ktime(new->it_value)"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "new->it_value"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_task_rcu",
          "args": [
            "timer"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_task_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "107-110",
          "snippet": "static inline struct task_struct *cpu_timer_task_rcu(struct k_itimer *timer)\n{\n\treturn pid_task(timer->it.cpu.pid, clock_pid_type(timer->it_clock));\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic inline struct task_struct *cpu_timer_task_rcu(struct k_itimer *timer)\n{\n\treturn pid_task(timer->it.cpu.pid, clock_pid_type(timer->it_clock));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "timer->it_clock"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int posix_cpu_timer_set(struct k_itimer *timer, int timer_flags,\n\t\t\t       struct itimerspec64 *new, struct itimerspec64 *old)\n{\n\tclockid_t clkid = CPUCLOCK_WHICH(timer->it_clock);\n\tu64 old_expires, new_expires, old_incr, val;\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p) {\n\t\t/*\n\t\t * If p has just been reaped, we can no\n\t\t * longer get any information about it at all.\n\t\t */\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnew_expires = ktime_to_ns(timespec64_to_ktime(new->it_value));\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and p->cpu_timers\n\t * and p->signal->cpu_timers read/write in arm_timer()\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\t/*\n\t * If p has just been reaped, we can no\n\t * longer get any information about it at all.\n\t */\n\tif (unlikely(sighand == NULL)) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Disarm any old timer after extracting its expiry time.\n\t */\n\told_incr = timer->it_interval;\n\told_expires = cpu_timer_getexpires(ctmr);\n\n\tif (unlikely(timer->it.cpu.firing)) {\n\t\ttimer->it.cpu.firing = -1;\n\t\tret = TIMER_RETRY;\n\t} else {\n\t\tcpu_timer_dequeue(ctmr);\n\t}\n\n\t/*\n\t * We need to sample the current value to convert the new\n\t * value from to relative and absolute, and to convert the\n\t * old value from absolute to relative.  To set a process\n\t * timer, we need a sample to balance the thread expiry\n\t * times (in arm_timer).  With an absolute time, we must\n\t * check if it's already passed.  In short, we need a sample.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\tval = cpu_clock_sample(clkid, p);\n\telse\n\t\tval = cpu_clock_sample_group(clkid, p, true);\n\n\tif (old) {\n\t\tif (old_expires == 0) {\n\t\t\told->it_value.tv_sec = 0;\n\t\t\told->it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Update the timer in case it has overrun already.\n\t\t\t * If it has, we'll report it as having overrun and\n\t\t\t * with the next reloaded timer already ticking,\n\t\t\t * though we are swallowing that pending\n\t\t\t * notification here to install the new setting.\n\t\t\t */\n\t\t\tu64 exp = bump_cpu_timer(timer, val);\n\n\t\t\tif (val < exp) {\n\t\t\t\told_expires = exp - val;\n\t\t\t\told->it_value = ns_to_timespec64(old_expires);\n\t\t\t} else {\n\t\t\t\told->it_value.tv_nsec = 1;\n\t\t\t\told->it_value.tv_sec = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(ret)) {\n\t\t/*\n\t\t * We are colliding with the timer actually firing.\n\t\t * Punt after filling in the timer's old value, and\n\t\t * disable this firing since we are already reporting\n\t\t * it as an overrun (thanks to bump_cpu_timer above).\n\t\t */\n\t\tunlock_task_sighand(p, &flags);\n\t\tgoto out;\n\t}\n\n\tif (new_expires != 0 && !(timer_flags & TIMER_ABSTIME)) {\n\t\tnew_expires += val;\n\t}\n\n\t/*\n\t * Install the new expiry time (or zero).\n\t * For a timer with no notification action, we don't actually\n\t * arm the timer (we'll just fake it for timer_gettime).\n\t */\n\tcpu_timer_setexpires(ctmr, new_expires);\n\tif (new_expires != 0 && val < new_expires) {\n\t\tarm_timer(timer, p);\n\t}\n\n\tunlock_task_sighand(p, &flags);\n\t/*\n\t * Install the new reload setting, and\n\t * set up the signal and overrun bookkeeping.\n\t */\n\ttimer->it_interval = timespec64_to_ktime(new->it_interval);\n\n\t/*\n\t * This acts as a modification timestamp for the timer,\n\t * so any automatic reload attempt will punt on seeing\n\t * that we have reset the timer manually.\n\t */\n\ttimer->it_requeue_pending = (timer->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimer->it_overrun_last = 0;\n\ttimer->it_overrun = -1;\n\n\tif (val >= new_expires) {\n\t\tif (new_expires != 0) {\n\t\t\t/*\n\t\t\t * The designated time already passed, so we notify\n\t\t\t * immediately, even if the thread never runs to\n\t\t\t * accumulate more time on this clock.\n\t\t\t */\n\t\t\tcpu_timer_fire(timer);\n\t\t}\n\n\t\t/*\n\t\t * Make sure we don't keep around the process wide cputime\n\t\t * counter or the tick dependency if they are not necessary.\n\t\t */\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (!sighand)\n\t\t\tgoto out;\n\n\t\tif (!cpu_timer_queued(ctmr))\n\t\t\ttrigger_base_recalc_expires(timer, p);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n out:\n\trcu_read_unlock();\n\tif (old)\n\t\told->it_interval = ns_to_timespec64(old_incr);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cpu_timer_fire",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "578-610",
    "snippet": "static void cpu_timer_fire(struct k_itimer *timer)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (!timer->it_interval) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cpu_timer_rearm",
          "args": [
            "timer"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timer_rearm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1040-1075",
          "snippet": "static void posix_cpu_timer_rearm(struct k_itimer *timer)\n{\n\tclockid_t clkid = CPUCLOCK_WHICH(timer->it_clock);\n\tstruct task_struct *p;\n\tstruct sighand_struct *sighand;\n\tunsigned long flags;\n\tu64 now;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p)\n\t\tgoto out;\n\n\t/* Protect timer list r/w in arm_timer() */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL))\n\t\tgoto out;\n\n\t/*\n\t * Fetch the current sample and update the timer's expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\tnow = cpu_clock_sample(clkid, p);\n\telse\n\t\tnow = cpu_clock_sample_group(clkid, p, true);\n\n\tbump_cpu_timer(timer, now);\n\n\t/*\n\t * Now re-arm for the new expiry time.\n\t */\n\tarm_timer(timer, p);\n\tunlock_task_sighand(p, &flags);\nout:\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer)\n{\n\tclockid_t clkid = CPUCLOCK_WHICH(timer->it_clock);\n\tstruct task_struct *p;\n\tstruct sighand_struct *sighand;\n\tunsigned long flags;\n\tu64 now;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p)\n\t\tgoto out;\n\n\t/* Protect timer list r/w in arm_timer() */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL))\n\t\tgoto out;\n\n\t/*\n\t * Fetch the current sample and update the timer's expiry time.\n\t */\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\tnow = cpu_clock_sample(clkid, p);\n\telse\n\t\tnow = cpu_clock_sample_group(clkid, p, true);\n\n\tbump_cpu_timer(timer, now);\n\n\t/*\n\t * Now re-arm for the new expiry time.\n\t */\n\tarm_timer(timer, p);\n\tunlock_task_sighand(p, &flags);\nout:\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_timer_event",
          "args": [
            "timer",
            "++timer->it_requeue_pending"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "336-357",
          "snippet": "int posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_setexpires",
          "args": [
            "ctmr",
            "0"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_setexpires",
          "args": [
            "ctmr",
            "0"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "timer->it_process"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "timer->sigq == NULL"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_setexpires",
          "args": [
            "ctmr",
            "0"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void cpu_timer_fire(struct k_itimer *timer)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\t/*\n\t\t * User don't want any signal.\n\t\t */\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (unlikely(timer->sigq == NULL)) {\n\t\t/*\n\t\t * This a special case for clock_nanosleep,\n\t\t * not a normal timer from sys_timer_create.\n\t\t */\n\t\twake_up_process(timer->it_process);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (!timer->it_interval) {\n\t\t/*\n\t\t * One-shot timer.  Clear it as soon as it's fired.\n\t\t */\n\t\tposix_timer_event(timer, 0);\n\t\tcpu_timer_setexpires(ctmr, 0);\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t/*\n\t\t * The signal did not get queued because the signal\n\t\t * was ignored, so we won't get any callback to\n\t\t * reload the timer.  But we need to keep it\n\t\t * ticking in case the signal is deliverable next time.\n\t\t */\n\t\tposix_cpu_timer_rearm(timer);\n\t\t++timer->it_requeue_pending;\n\t}\n}"
  },
  {
    "function_name": "arm_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "551-573",
    "snippet": "static void arm_timer(struct k_itimer *timer, struct task_struct *p)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, p);\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tu64 newexp = cpu_timer_getexpires(ctmr);\n\n\tif (!cpu_timer_enqueue(&base->tqhead, ctmr))\n\t\treturn;\n\n\t/*\n\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t * need to update expiration cache. Take into account that\n\t * for process timers we share expiration cache with itimers\n\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t */\n\tif (newexp < base->nextevt)\n\t\tbase->nextevt = newexp;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\telse\n\t\ttick_dep_set_signal(p, TICK_DEP_BIT_POSIX_TIMER);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_set_signal",
          "args": [
            "p",
            "TICK_DEP_BIT_POSIX_TIMER"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_dep_set_task",
          "args": [
            "p",
            "TICK_DEP_BIT_POSIX_TIMER"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "timer->it_clock"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_enqueue",
          "args": [
            "&base->tqhead",
            "ctmr"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_timer_getexpires",
          "args": [
            "ctmr"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_base",
          "args": [
            "timer",
            "p"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "timer_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "411-420",
          "snippet": "static struct posix_cputimer_base *timer_base(struct k_itimer *timer,\n\t\t\t\t\t      struct task_struct *tsk)\n{\n\tint clkidx = CPUCLOCK_WHICH(timer->it_clock);\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\treturn tsk->posix_cputimers.bases + clkidx;\n\telse\n\t\treturn tsk->signal->posix_cputimers.bases + clkidx;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic struct posix_cputimer_base *timer_base(struct k_itimer *timer,\n\t\t\t\t\t      struct task_struct *tsk)\n{\n\tint clkidx = CPUCLOCK_WHICH(timer->it_clock);\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\treturn tsk->posix_cputimers.bases + clkidx;\n\telse\n\t\treturn tsk->signal->posix_cputimers.bases + clkidx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void arm_timer(struct k_itimer *timer, struct task_struct *p)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, p);\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tu64 newexp = cpu_timer_getexpires(ctmr);\n\n\tif (!cpu_timer_enqueue(&base->tqhead, ctmr))\n\t\treturn;\n\n\t/*\n\t * We are the new earliest-expiring POSIX 1.b timer, hence\n\t * need to update expiration cache. Take into account that\n\t * for process timers we share expiration cache with itimers\n\t * and RLIMIT_CPU and for thread timers with RLIMIT_RTTIME.\n\t */\n\tif (newexp < base->nextevt)\n\t\tbase->nextevt = newexp;\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\ttick_dep_set_task(p, TICK_DEP_BIT_POSIX_TIMER);\n\telse\n\t\ttick_dep_set_signal(p, TICK_DEP_BIT_POSIX_TIMER);\n}"
  },
  {
    "function_name": "posix_cpu_timers_exit_group",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "542-545",
    "snippet": "void posix_cpu_timers_exit_group(struct task_struct *tsk)\n{\n\tcleanup_timers(&tsk->signal->posix_cputimers);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_timers",
          "args": [
            "&tsk->signal->posix_cputimers"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_timers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "526-531",
          "snippet": "static void cleanup_timers(struct posix_cputimers *pct)\n{\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_PROF].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_VIRT].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_SCHED].tqhead);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void cleanup_timers(struct posix_cputimers *pct)\n{\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_PROF].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_VIRT].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_SCHED].tqhead);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nvoid posix_cpu_timers_exit_group(struct task_struct *tsk)\n{\n\tcleanup_timers(&tsk->signal->posix_cputimers);\n}"
  },
  {
    "function_name": "posix_cpu_timers_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "538-541",
    "snippet": "void posix_cpu_timers_exit(struct task_struct *tsk)\n{\n\tcleanup_timers(&tsk->posix_cputimers);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_timers",
          "args": [
            "&tsk->posix_cputimers"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_timers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "526-531",
          "snippet": "static void cleanup_timers(struct posix_cputimers *pct)\n{\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_PROF].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_VIRT].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_SCHED].tqhead);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void cleanup_timers(struct posix_cputimers *pct)\n{\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_PROF].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_VIRT].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_SCHED].tqhead);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nvoid posix_cpu_timers_exit(struct task_struct *tsk)\n{\n\tcleanup_timers(&tsk->posix_cputimers);\n}"
  },
  {
    "function_name": "cleanup_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "526-531",
    "snippet": "static void cleanup_timers(struct posix_cputimers *pct)\n{\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_PROF].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_VIRT].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_SCHED].tqhead);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_timerqueue",
          "args": [
            "&pct->bases[CPUCLOCK_SCHED].tqhead"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_timerqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "507-517",
          "snippet": "static void cleanup_timerqueue(struct timerqueue_head *head)\n{\n\tstruct timerqueue_node *node;\n\tstruct cpu_timer *ctmr;\n\n\twhile ((node = timerqueue_getnext(head))) {\n\t\ttimerqueue_del(head, node);\n\t\tctmr = container_of(node, struct cpu_timer, node);\n\t\tctmr->head = NULL;\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void cleanup_timerqueue(struct timerqueue_head *head)\n{\n\tstruct timerqueue_node *node;\n\tstruct cpu_timer *ctmr;\n\n\twhile ((node = timerqueue_getnext(head))) {\n\t\ttimerqueue_del(head, node);\n\t\tctmr = container_of(node, struct cpu_timer, node);\n\t\tctmr->head = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void cleanup_timers(struct posix_cputimers *pct)\n{\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_PROF].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_VIRT].tqhead);\n\tcleanup_timerqueue(&pct->bases[CPUCLOCK_SCHED].tqhead);\n}"
  },
  {
    "function_name": "cleanup_timerqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "507-517",
    "snippet": "static void cleanup_timerqueue(struct timerqueue_head *head)\n{\n\tstruct timerqueue_node *node;\n\tstruct cpu_timer *ctmr;\n\n\twhile ((node = timerqueue_getnext(head))) {\n\t\ttimerqueue_del(head, node);\n\t\tctmr = container_of(node, struct cpu_timer, node);\n\t\tctmr->head = NULL;\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structcpu_timer",
            "node"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_del",
          "args": [
            "head",
            "node"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "head"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void cleanup_timerqueue(struct timerqueue_head *head)\n{\n\tstruct timerqueue_node *node;\n\tstruct cpu_timer *ctmr;\n\n\twhile ((node = timerqueue_getnext(head))) {\n\t\ttimerqueue_del(head, node);\n\t\tctmr = container_of(node, struct cpu_timer, node);\n\t\tctmr->head = NULL;\n\t}\n}"
  },
  {
    "function_name": "posix_cpu_timer_del",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "466-505",
    "snippet": "static int posix_cpu_timer_del(struct k_itimer *timer)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p)\n\t\tgoto out;\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and process/\n\t * thread timer list entry concurrent read/writes.\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL)) {\n\t\t/*\n\t\t * This raced with the reaping of the task. The exit cleanup\n\t\t * should have removed this timer from the timer queue.\n\t\t */\n\t\tWARN_ON_ONCE(ctmr->head || timerqueue_node_queued(&ctmr->node));\n\t} else {\n\t\tif (timer->it.cpu.firing)\n\t\t\tret = TIMER_RETRY;\n\t\telse\n\t\t\tdisarm_timer(timer, p);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\nout:\n\trcu_read_unlock();\n\tif (!ret)\n\t\tput_pid(ctmr->pid);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "ctmr->pid"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "120-124",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disarm_timer",
          "args": [
            "timer",
            "p"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "446-457",
          "snippet": "static void disarm_timer(struct k_itimer *timer, struct task_struct *p)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct posix_cputimer_base *base;\n\n\tif (!cpu_timer_dequeue(ctmr))\n\t\treturn;\n\n\tbase = timer_base(timer, p);\n\tif (cpu_timer_getexpires(ctmr) == base->nextevt)\n\t\ttrigger_base_recalc_expires(timer, p);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void disarm_timer(struct k_itimer *timer, struct task_struct *p)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct posix_cputimer_base *base;\n\n\tif (!cpu_timer_dequeue(ctmr))\n\t\treturn;\n\n\tbase = timer_base(timer, p);\n\tif (cpu_timer_getexpires(ctmr) == base->nextevt)\n\t\ttrigger_base_recalc_expires(timer, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ctmr->head || timerqueue_node_queued(&ctmr->node)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_node_queued",
          "args": [
            "&ctmr->node"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sighand == NULL"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1384-1414",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_task_rcu",
          "args": [
            "timer"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_timer_task_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "107-110",
          "snippet": "static inline struct task_struct *cpu_timer_task_rcu(struct k_itimer *timer)\n{\n\treturn pid_task(timer->it.cpu.pid, clock_pid_type(timer->it_clock));\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic inline struct task_struct *cpu_timer_task_rcu(struct k_itimer *timer)\n{\n\treturn pid_task(timer->it.cpu.pid, clock_pid_type(timer->it_clock));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic int posix_cpu_timer_del(struct k_itimer *timer)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tp = cpu_timer_task_rcu(timer);\n\tif (!p)\n\t\tgoto out;\n\n\t/*\n\t * Protect against sighand release/switch in exit/exec and process/\n\t * thread timer list entry concurrent read/writes.\n\t */\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == NULL)) {\n\t\t/*\n\t\t * This raced with the reaping of the task. The exit cleanup\n\t\t * should have removed this timer from the timer queue.\n\t\t */\n\t\tWARN_ON_ONCE(ctmr->head || timerqueue_node_queued(&ctmr->node));\n\t} else {\n\t\tif (timer->it.cpu.firing)\n\t\t\tret = TIMER_RETRY;\n\t\telse\n\t\t\tdisarm_timer(timer, p);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\nout:\n\trcu_read_unlock();\n\tif (!ret)\n\t\tput_pid(ctmr->pid);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "disarm_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "446-457",
    "snippet": "static void disarm_timer(struct k_itimer *timer, struct task_struct *p)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct posix_cputimer_base *base;\n\n\tif (!cpu_timer_dequeue(ctmr))\n\t\treturn;\n\n\tbase = timer_base(timer, p);\n\tif (cpu_timer_getexpires(ctmr) == base->nextevt)\n\t\ttrigger_base_recalc_expires(timer, p);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trigger_base_recalc_expires",
          "args": [
            "timer",
            "p"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_base_recalc_expires",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "428-434",
          "snippet": "static void trigger_base_recalc_expires(struct k_itimer *timer,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, tsk);\n\n\tbase->nextevt = 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void trigger_base_recalc_expires(struct k_itimer *timer,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, tsk);\n\n\tbase->nextevt = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_getexpires",
          "args": [
            "ctmr"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_base",
          "args": [
            "timer",
            "p"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "timer_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "411-420",
          "snippet": "static struct posix_cputimer_base *timer_base(struct k_itimer *timer,\n\t\t\t\t\t      struct task_struct *tsk)\n{\n\tint clkidx = CPUCLOCK_WHICH(timer->it_clock);\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\treturn tsk->posix_cputimers.bases + clkidx;\n\telse\n\t\treturn tsk->signal->posix_cputimers.bases + clkidx;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic struct posix_cputimer_base *timer_base(struct k_itimer *timer,\n\t\t\t\t\t      struct task_struct *tsk)\n{\n\tint clkidx = CPUCLOCK_WHICH(timer->it_clock);\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\treturn tsk->posix_cputimers.bases + clkidx;\n\telse\n\t\treturn tsk->signal->posix_cputimers.bases + clkidx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_timer_dequeue",
          "args": [
            "ctmr"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic void disarm_timer(struct k_itimer *timer, struct task_struct *p)\n{\n\tstruct cpu_timer *ctmr = &timer->it.cpu;\n\tstruct posix_cputimer_base *base;\n\n\tif (!cpu_timer_dequeue(ctmr))\n\t\treturn;\n\n\tbase = timer_base(timer, p);\n\tif (cpu_timer_getexpires(ctmr) == base->nextevt)\n\t\ttrigger_base_recalc_expires(timer, p);\n}"
  },
  {
    "function_name": "trigger_base_recalc_expires",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "428-434",
    "snippet": "static void trigger_base_recalc_expires(struct k_itimer *timer,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, tsk);\n\n\tbase->nextevt = 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_base",
          "args": [
            "timer",
            "tsk"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "timer_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "411-420",
          "snippet": "static struct posix_cputimer_base *timer_base(struct k_itimer *timer,\n\t\t\t\t\t      struct task_struct *tsk)\n{\n\tint clkidx = CPUCLOCK_WHICH(timer->it_clock);\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\treturn tsk->posix_cputimers.bases + clkidx;\n\telse\n\t\treturn tsk->signal->posix_cputimers.bases + clkidx;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic struct posix_cputimer_base *timer_base(struct k_itimer *timer,\n\t\t\t\t\t      struct task_struct *tsk)\n{\n\tint clkidx = CPUCLOCK_WHICH(timer->it_clock);\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\treturn tsk->posix_cputimers.bases + clkidx;\n\telse\n\t\treturn tsk->signal->posix_cputimers.bases + clkidx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void trigger_base_recalc_expires(struct k_itimer *timer,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tstruct posix_cputimer_base *base = timer_base(timer, tsk);\n\n\tbase->nextevt = 0;\n}"
  },
  {
    "function_name": "timer_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "411-420",
    "snippet": "static struct posix_cputimer_base *timer_base(struct k_itimer *timer,\n\t\t\t\t\t      struct task_struct *tsk)\n{\n\tint clkidx = CPUCLOCK_WHICH(timer->it_clock);\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\treturn tsk->posix_cputimers.bases + clkidx;\n\telse\n\t\treturn tsk->signal->posix_cputimers.bases + clkidx;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "timer->it_clock"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "timer->it_clock"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic struct posix_cputimer_base *timer_base(struct k_itimer *timer,\n\t\t\t\t\t      struct task_struct *tsk)\n{\n\tint clkidx = CPUCLOCK_WHICH(timer->it_clock);\n\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock))\n\t\treturn tsk->posix_cputimers.bases + clkidx;\n\telse\n\t\treturn tsk->signal->posix_cputimers.bases + clkidx;\n}"
  },
  {
    "function_name": "posix_cpu_timer_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "381-409",
    "snippet": "static int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tstatic struct lock_class_key posix_cpu_timers_key;\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = pid_for_clock(new_timer->it_clock, false);\n\tif (!pid) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If posix timer expiry is handled in task work context then\n\t * timer::it_lock can be taken without disabling interrupts as all\n\t * other locking happens in task context. This requires a separate\n\t * lock class key otherwise regular posix timer expiry would record\n\t * the lock class being taken in interrupt context and generate a\n\t * false positive warning.\n\t */\n\tif (IS_ENABLED(CONFIG_POSIX_CPU_TIMERS_TASK_WORK))\n\t\tlockdep_set_class(&new_timer->it_lock, &posix_cpu_timers_key);\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\ttimerqueue_init(&new_timer->it.cpu.node);\n\tnew_timer->it.cpu.pid = get_pid(pid);\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "const struct k_clock clock_posix_cpu = {\n\t.clock_getres\t\t= posix_cpu_clock_getres,\n\t.clock_set\t\t= posix_cpu_clock_set,\n\t.clock_get_timespec\t= posix_cpu_clock_get,\n\t.timer_create\t\t= posix_cpu_timer_create,\n\t.nsleep\t\t\t= posix_cpu_nsleep,\n\t.timer_set\t\t= posix_cpu_timer_set,\n\t.timer_del\t\t= posix_cpu_timer_del,\n\t.timer_get\t\t= posix_cpu_timer_get,\n\t.timer_rearm\t\t= posix_cpu_timer_rearm,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "pid"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "460-469",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timerqueue_init",
          "args": [
            "&new_timer->it.cpu.node"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&new_timer->it_lock",
            "&posix_cpu_timers_key"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_POSIX_CPU_TIMERS_TASK_WORK"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_for_clock",
          "args": [
            "new_timer->it_clock",
            "false"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "pid_for_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "51-89",
          "snippet": "static struct pid *pid_for_clock(const clockid_t clock, bool gettime)\n{\n\tconst bool thread = !!CPUCLOCK_PERTHREAD(clock);\n\tconst pid_t upid = CPUCLOCK_PID(clock);\n\tstruct pid *pid;\n\n\tif (CPUCLOCK_WHICH(clock) >= CPUCLOCK_MAX)\n\t\treturn NULL;\n\n\t/*\n\t * If the encoded PID is 0, then the timer is targeted at current\n\t * or the process to which current belongs.\n\t */\n\tif (upid == 0)\n\t\treturn thread ? task_pid(current) : task_tgid(current);\n\n\tpid = find_vpid(upid);\n\tif (!pid)\n\t\treturn NULL;\n\n\tif (thread) {\n\t\tstruct task_struct *tsk = pid_task(pid, PIDTYPE_PID);\n\t\treturn (tsk && same_thread_group(tsk, current)) ? pid : NULL;\n\t}\n\n\t/*\n\t * For clock_gettime(PROCESS) allow finding the process by\n\t * with the pid of the current task.  The code needs the tgid\n\t * of the process so that pid_task(pid, PIDTYPE_TGID) can be\n\t * used to find the process.\n\t */\n\tif (gettime && (pid == task_pid(current)))\n\t\treturn task_tgid(current);\n\n\t/*\n\t * For processes require that pid identifies a process.\n\t */\n\treturn pid_has_task(pid, PIDTYPE_TGID) ? pid : NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic struct pid *pid_for_clock(const clockid_t clock, bool gettime)\n{\n\tconst bool thread = !!CPUCLOCK_PERTHREAD(clock);\n\tconst pid_t upid = CPUCLOCK_PID(clock);\n\tstruct pid *pid;\n\n\tif (CPUCLOCK_WHICH(clock) >= CPUCLOCK_MAX)\n\t\treturn NULL;\n\n\t/*\n\t * If the encoded PID is 0, then the timer is targeted at current\n\t * or the process to which current belongs.\n\t */\n\tif (upid == 0)\n\t\treturn thread ? task_pid(current) : task_tgid(current);\n\n\tpid = find_vpid(upid);\n\tif (!pid)\n\t\treturn NULL;\n\n\tif (thread) {\n\t\tstruct task_struct *tsk = pid_task(pid, PIDTYPE_PID);\n\t\treturn (tsk && same_thread_group(tsk, current)) ? pid : NULL;\n\t}\n\n\t/*\n\t * For clock_gettime(PROCESS) allow finding the process by\n\t * with the pid of the current task.  The code needs the tgid\n\t * of the process so that pid_task(pid, PIDTYPE_TGID) can be\n\t * used to find the process.\n\t */\n\tif (gettime && (pid == task_pid(current)))\n\t\treturn task_tgid(current);\n\n\t/*\n\t * For processes require that pid identifies a process.\n\t */\n\treturn pid_has_task(pid, PIDTYPE_TGID) ? pid : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nconst struct k_clock clock_posix_cpu = {\n\t.clock_getres\t\t= posix_cpu_clock_getres,\n\t.clock_set\t\t= posix_cpu_clock_set,\n\t.clock_get_timespec\t= posix_cpu_clock_get,\n\t.timer_create\t\t= posix_cpu_timer_create,\n\t.nsleep\t\t\t= posix_cpu_nsleep,\n\t.timer_set\t\t= posix_cpu_timer_set,\n\t.timer_del\t\t= posix_cpu_timer_del,\n\t.timer_get\t\t= posix_cpu_timer_get,\n\t.timer_rearm\t\t= posix_cpu_timer_rearm,\n};\n\nstatic int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tstatic struct lock_class_key posix_cpu_timers_key;\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = pid_for_clock(new_timer->it_clock, false);\n\tif (!pid) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If posix timer expiry is handled in task work context then\n\t * timer::it_lock can be taken without disabling interrupts as all\n\t * other locking happens in task context. This requires a separate\n\t * lock class key otherwise regular posix timer expiry would record\n\t * the lock class being taken in interrupt context and generate a\n\t * false positive warning.\n\t */\n\tif (IS_ENABLED(CONFIG_POSIX_CPU_TIMERS_TASK_WORK))\n\t\tlockdep_set_class(&new_timer->it_lock, &posix_cpu_timers_key);\n\n\tnew_timer->kclock = &clock_posix_cpu;\n\ttimerqueue_init(&new_timer->it.cpu.node);\n\tnew_timer->it.cpu.pid = get_pid(pid);\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_cpu_clock_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "353-374",
    "snippet": "static int posix_cpu_clock_get(const clockid_t clock, struct timespec64 *tp)\n{\n\tconst clockid_t clkid = CPUCLOCK_WHICH(clock);\n\tstruct task_struct *tsk;\n\tu64 t;\n\n\trcu_read_lock();\n\ttsk = pid_task(pid_for_clock(clock, true), clock_pid_type(clock));\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (CPUCLOCK_PERTHREAD(clock))\n\t\tt = cpu_clock_sample(clkid, tsk);\n\telse\n\t\tt = cpu_clock_sample_group(clkid, tsk, false);\n\trcu_read_unlock();\n\n\t*tp = ns_to_timespec64(t);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "t"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "506-525",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample_group",
          "args": [
            "clkid",
            "tsk",
            "false"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "334-351",
          "snippet": "static u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_clock_sample",
          "args": [
            "clkid",
            "tsk"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_clock_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "188-206",
          "snippet": "static u64 cpu_clock_sample(const clockid_t clkid, struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\tif (clkid == CPUCLOCK_SCHED)\n\t\treturn task_sched_runtime(p);\n\n\ttask_cputime(p, &utime, &stime);\n\n\tswitch (clkid) {\n\tcase CPUCLOCK_PROF:\n\t\treturn utime + stime;\n\tcase CPUCLOCK_VIRT:\n\t\treturn utime;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic u64 cpu_clock_sample(const clockid_t clkid, struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\tif (clkid == CPUCLOCK_SCHED)\n\t\treturn task_sched_runtime(p);\n\n\ttask_cputime(p, &utime, &stime);\n\n\tswitch (clkid) {\n\tcase CPUCLOCK_PROF:\n\t\treturn utime + stime;\n\tcase CPUCLOCK_VIRT:\n\t\treturn utime;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "clock"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid_for_clock(clock, true)",
            "clock_pid_type(clock)"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock_pid_type",
          "args": [
            "clock"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "clock_pid_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "102-105",
          "snippet": "static inline enum pid_type clock_pid_type(const clockid_t clock)\n{\n\treturn CPUCLOCK_PERTHREAD(clock) ? PIDTYPE_PID : PIDTYPE_TGID;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline enum pid_type clock_pid_type(const clockid_t clock)\n{\n\treturn CPUCLOCK_PERTHREAD(clock) ? PIDTYPE_PID : PIDTYPE_TGID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_for_clock",
          "args": [
            "clock",
            "true"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "pid_for_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "51-89",
          "snippet": "static struct pid *pid_for_clock(const clockid_t clock, bool gettime)\n{\n\tconst bool thread = !!CPUCLOCK_PERTHREAD(clock);\n\tconst pid_t upid = CPUCLOCK_PID(clock);\n\tstruct pid *pid;\n\n\tif (CPUCLOCK_WHICH(clock) >= CPUCLOCK_MAX)\n\t\treturn NULL;\n\n\t/*\n\t * If the encoded PID is 0, then the timer is targeted at current\n\t * or the process to which current belongs.\n\t */\n\tif (upid == 0)\n\t\treturn thread ? task_pid(current) : task_tgid(current);\n\n\tpid = find_vpid(upid);\n\tif (!pid)\n\t\treturn NULL;\n\n\tif (thread) {\n\t\tstruct task_struct *tsk = pid_task(pid, PIDTYPE_PID);\n\t\treturn (tsk && same_thread_group(tsk, current)) ? pid : NULL;\n\t}\n\n\t/*\n\t * For clock_gettime(PROCESS) allow finding the process by\n\t * with the pid of the current task.  The code needs the tgid\n\t * of the process so that pid_task(pid, PIDTYPE_TGID) can be\n\t * used to find the process.\n\t */\n\tif (gettime && (pid == task_pid(current)))\n\t\treturn task_tgid(current);\n\n\t/*\n\t * For processes require that pid identifies a process.\n\t */\n\treturn pid_has_task(pid, PIDTYPE_TGID) ? pid : NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic struct pid *pid_for_clock(const clockid_t clock, bool gettime)\n{\n\tconst bool thread = !!CPUCLOCK_PERTHREAD(clock);\n\tconst pid_t upid = CPUCLOCK_PID(clock);\n\tstruct pid *pid;\n\n\tif (CPUCLOCK_WHICH(clock) >= CPUCLOCK_MAX)\n\t\treturn NULL;\n\n\t/*\n\t * If the encoded PID is 0, then the timer is targeted at current\n\t * or the process to which current belongs.\n\t */\n\tif (upid == 0)\n\t\treturn thread ? task_pid(current) : task_tgid(current);\n\n\tpid = find_vpid(upid);\n\tif (!pid)\n\t\treturn NULL;\n\n\tif (thread) {\n\t\tstruct task_struct *tsk = pid_task(pid, PIDTYPE_PID);\n\t\treturn (tsk && same_thread_group(tsk, current)) ? pid : NULL;\n\t}\n\n\t/*\n\t * For clock_gettime(PROCESS) allow finding the process by\n\t * with the pid of the current task.  The code needs the tgid\n\t * of the process so that pid_task(pid, PIDTYPE_TGID) can be\n\t * used to find the process.\n\t */\n\tif (gettime && (pid == task_pid(current)))\n\t\treturn task_tgid(current);\n\n\t/*\n\t * For processes require that pid identifies a process.\n\t */\n\treturn pid_has_task(pid, PIDTYPE_TGID) ? pid : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "clock"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic int posix_cpu_clock_get(const clockid_t clock, struct timespec64 *tp)\n{\n\tconst clockid_t clkid = CPUCLOCK_WHICH(clock);\n\tstruct task_struct *tsk;\n\tu64 t;\n\n\trcu_read_lock();\n\ttsk = pid_task(pid_for_clock(clock, true), clock_pid_type(clock));\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (CPUCLOCK_PERTHREAD(clock))\n\t\tt = cpu_clock_sample(clkid, tsk);\n\telse\n\t\tt = cpu_clock_sample_group(clkid, tsk, false);\n\trcu_read_unlock();\n\n\t*tp = ns_to_timespec64(t);\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_clock_sample_group",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "334-351",
    "snippet": "static u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sample_cputime_atomic",
          "args": [
            "&cputimer->cputime_atomic",
            "samples"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sample_cputime_atomic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "223-232",
          "snippet": "static void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__thread_group_cputime",
          "args": [
            "p",
            "samples"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "__thread_group_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "321-327",
          "snippet": "static void __thread_group_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct task_cputime ct;\n\n\tthread_group_cputime(tsk, &ct);\n\tstore_samples(samples, ct.stime, ct.utime, ct.sum_exec_runtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void __thread_group_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct task_cputime ct;\n\n\tthread_group_cputime(tsk, &ct);\n\tstore_samples(samples, ct.stime, ct.utime, ct.sum_exec_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_start_cputime",
          "args": [
            "p",
            "samples"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_start_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "290-319",
          "snippet": "static void thread_group_start_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct posix_cputimers *pct = &tsk->signal->posix_cputimers;\n\n\tlockdep_assert_task_sighand_held(tsk);\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tstruct task_cputime sum;\n\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting timers_active without a lock. Ensure this\n\t\t * only gets written to in one operation. We set it after\n\t\t * update_gt_cputime() as a small optimization, but\n\t\t * barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(pct->timers_active, true);\n\t}\n\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void thread_group_start_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct posix_cputimers *pct = &tsk->signal->posix_cputimers;\n\n\tlockdep_assert_task_sighand_held(tsk);\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tstruct task_cputime sum;\n\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting timers_active without a lock. Ensure this\n\t\t * only gets written to in one operation. We set it after\n\t\t * update_gt_cputime() as a small optimization, but\n\t\t * barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(pct->timers_active, true);\n\t}\n\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pct->timers_active"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic u64 cpu_clock_sample_group(const clockid_t clkid, struct task_struct *p,\n\t\t\t\t  bool start)\n{\n\tstruct thread_group_cputimer *cputimer = &p->signal->cputimer;\n\tstruct posix_cputimers *pct = &p->signal->posix_cputimers;\n\tu64 samples[CPUCLOCK_MAX];\n\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tif (start)\n\t\t\tthread_group_start_cputime(p, samples);\n\t\telse\n\t\t\t__thread_group_cputime(p, samples);\n\t} else {\n\t\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n\t}\n\n\treturn samples[clkid];\n}"
  },
  {
    "function_name": "__thread_group_cputime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "321-327",
    "snippet": "static void __thread_group_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct task_cputime ct;\n\n\tthread_group_cputime(tsk, &ct);\n\tstore_samples(samples, ct.stime, ct.utime, ct.sum_exec_runtime);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "store_samples",
          "args": [
            "samples",
            "ct.stime",
            "ct.utime",
            "ct.sum_exec_runtime"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "store_samples",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "208-213",
          "snippet": "static inline void store_samples(u64 *samples, u64 stime, u64 utime, u64 rtime)\n{\n\tsamples[CPUCLOCK_PROF] = stime + utime;\n\tsamples[CPUCLOCK_VIRT] = utime;\n\tsamples[CPUCLOCK_SCHED] = rtime;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void store_samples(u64 *samples, u64 stime, u64 utime, u64 rtime)\n{\n\tsamples[CPUCLOCK_PROF] = stime + utime;\n\tsamples[CPUCLOCK_VIRT] = utime;\n\tsamples[CPUCLOCK_SCHED] = rtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_cputime",
          "args": [
            "tsk",
            "&ct"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "__thread_group_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "321-327",
          "snippet": "static void __thread_group_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct task_cputime ct;\n\n\tthread_group_cputime(tsk, &ct);\n\tstore_samples(samples, ct.stime, ct.utime, ct.sum_exec_runtime);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void __thread_group_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct task_cputime ct;\n\n\tthread_group_cputime(tsk, &ct);\n\tstore_samples(samples, ct.stime, ct.utime, ct.sum_exec_runtime);\n}"
  },
  {
    "function_name": "thread_group_start_cputime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "290-319",
    "snippet": "static void thread_group_start_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct posix_cputimers *pct = &tsk->signal->posix_cputimers;\n\n\tlockdep_assert_task_sighand_held(tsk);\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tstruct task_cputime sum;\n\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting timers_active without a lock. Ensure this\n\t\t * only gets written to in one operation. We set it after\n\t\t * update_gt_cputime() as a small optimization, but\n\t\t * barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(pct->timers_active, true);\n\t}\n\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sample_cputime_atomic",
          "args": [
            "&cputimer->cputime_atomic",
            "samples"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sample_cputime_atomic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "223-232",
          "snippet": "static void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "pct->timers_active",
            "true"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_gt_cputime",
          "args": [
            "&cputimer->cputime_atomic",
            "&sum"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "update_gt_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "249-255",
          "snippet": "static void update_gt_cputime(struct task_cputime_atomic *cputime_atomic,\n\t\t\t      struct task_cputime *sum)\n{\n\t__update_gt_cputime(&cputime_atomic->utime, sum->utime);\n\t__update_gt_cputime(&cputime_atomic->stime, sum->stime);\n\t__update_gt_cputime(&cputime_atomic->sum_exec_runtime, sum->sum_exec_runtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void update_gt_cputime(struct task_cputime_atomic *cputime_atomic,\n\t\t\t      struct task_cputime *sum)\n{\n\t__update_gt_cputime(&cputime_atomic->utime, sum->utime);\n\t__update_gt_cputime(&cputime_atomic->stime, sum->stime);\n\t__update_gt_cputime(&cputime_atomic->sum_exec_runtime, sum->sum_exec_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_cputime",
          "args": [
            "tsk",
            "&sum"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "__thread_group_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "321-327",
          "snippet": "static void __thread_group_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct task_cputime ct;\n\n\tthread_group_cputime(tsk, &ct);\n\tstore_samples(samples, ct.stime, ct.utime, ct.sum_exec_runtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void __thread_group_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct task_cputime ct;\n\n\tthread_group_cputime(tsk, &ct);\n\tstore_samples(samples, ct.stime, ct.utime, ct.sum_exec_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pct->timers_active"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_task_sighand_held",
          "args": [
            "tsk"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_task_sighand_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1417-1428",
          "snippet": "void lockdep_assert_task_sighand_held(struct task_struct *task)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tsighand = rcu_dereference(task->sighand);\n\tif (sighand)\n\t\tlockdep_assert_held(&sighand->siglock);\n\telse\n\t\tWARN_ON_ONCE(1);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid lockdep_assert_task_sighand_held(struct task_struct *task)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tsighand = rcu_dereference(task->sighand);\n\tif (sighand)\n\t\tlockdep_assert_held(&sighand->siglock);\n\telse\n\t\tWARN_ON_ONCE(1);\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic void thread_group_start_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct posix_cputimers *pct = &tsk->signal->posix_cputimers;\n\n\tlockdep_assert_task_sighand_held(tsk);\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(pct->timers_active)) {\n\t\tstruct task_cputime sum;\n\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting timers_active without a lock. Ensure this\n\t\t * only gets written to in one operation. We set it after\n\t\t * update_gt_cputime() as a small optimization, but\n\t\t * barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(pct->timers_active, true);\n\t}\n\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n}"
  },
  {
    "function_name": "thread_group_sample_cputime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "268-276",
    "snippet": "void thread_group_sample_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct posix_cputimers *pct = &tsk->signal->posix_cputimers;\n\n\tWARN_ON_ONCE(!pct->timers_active);\n\n\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sample_cputime_atomic",
          "args": [
            "&cputimer->cputime_atomic",
            "samples"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sample_cputime_atomic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "223-232",
          "snippet": "static void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pct->timers_active"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nvoid thread_group_sample_cputime(struct task_struct *tsk, u64 *samples)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct posix_cputimers *pct = &tsk->signal->posix_cputimers;\n\n\tWARN_ON_ONCE(!pct->timers_active);\n\n\tproc_sample_cputime_atomic(&cputimer->cputime_atomic, samples);\n}"
  },
  {
    "function_name": "update_gt_cputime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "249-255",
    "snippet": "static void update_gt_cputime(struct task_cputime_atomic *cputime_atomic,\n\t\t\t      struct task_cputime *sum)\n{\n\t__update_gt_cputime(&cputime_atomic->utime, sum->utime);\n\t__update_gt_cputime(&cputime_atomic->stime, sum->stime);\n\t__update_gt_cputime(&cputime_atomic->sum_exec_runtime, sum->sum_exec_runtime);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__update_gt_cputime",
          "args": [
            "&cputime_atomic->sum_exec_runtime",
            "sum->sum_exec_runtime"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__update_gt_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "238-247",
          "snippet": "static inline void __update_gt_cputime(atomic64_t *cputime, u64 sum_cputime)\n{\n\tu64 curr_cputime;\nretry:\n\tcurr_cputime = atomic64_read(cputime);\n\tif (sum_cputime > curr_cputime) {\n\t\tif (atomic64_cmpxchg(cputime, curr_cputime, sum_cputime) != curr_cputime)\n\t\t\tgoto retry;\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void __update_gt_cputime(atomic64_t *cputime, u64 sum_cputime)\n{\n\tu64 curr_cputime;\nretry:\n\tcurr_cputime = atomic64_read(cputime);\n\tif (sum_cputime > curr_cputime) {\n\t\tif (atomic64_cmpxchg(cputime, curr_cputime, sum_cputime) != curr_cputime)\n\t\t\tgoto retry;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void update_gt_cputime(struct task_cputime_atomic *cputime_atomic,\n\t\t\t      struct task_cputime *sum)\n{\n\t__update_gt_cputime(&cputime_atomic->utime, sum->utime);\n\t__update_gt_cputime(&cputime_atomic->stime, sum->stime);\n\t__update_gt_cputime(&cputime_atomic->sum_exec_runtime, sum->sum_exec_runtime);\n}"
  },
  {
    "function_name": "__update_gt_cputime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "238-247",
    "snippet": "static inline void __update_gt_cputime(atomic64_t *cputime, u64 sum_cputime)\n{\n\tu64 curr_cputime;\nretry:\n\tcurr_cputime = atomic64_read(cputime);\n\tif (sum_cputime > curr_cputime) {\n\t\tif (atomic64_cmpxchg(cputime, curr_cputime, sum_cputime) != curr_cputime)\n\t\t\tgoto retry;\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_cmpxchg",
          "args": [
            "cputime",
            "curr_cputime",
            "sum_cputime"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "cputime"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void __update_gt_cputime(atomic64_t *cputime, u64 sum_cputime)\n{\n\tu64 curr_cputime;\nretry:\n\tcurr_cputime = atomic64_read(cputime);\n\tif (sum_cputime > curr_cputime) {\n\t\tif (atomic64_cmpxchg(cputime, curr_cputime, sum_cputime) != curr_cputime)\n\t\t\tgoto retry;\n\t}\n}"
  },
  {
    "function_name": "proc_sample_cputime_atomic",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "223-232",
    "snippet": "static void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "store_samples",
          "args": [
            "samples",
            "stime",
            "utime",
            "rtime"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "store_samples",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "208-213",
          "snippet": "static inline void store_samples(u64 *samples, u64 stime, u64 utime, u64 rtime)\n{\n\tsamples[CPUCLOCK_PROF] = stime + utime;\n\tsamples[CPUCLOCK_VIRT] = utime;\n\tsamples[CPUCLOCK_SCHED] = rtime;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void store_samples(u64 *samples, u64 stime, u64 utime, u64 rtime)\n{\n\tsamples[CPUCLOCK_PROF] = stime + utime;\n\tsamples[CPUCLOCK_VIRT] = utime;\n\tsamples[CPUCLOCK_SCHED] = rtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&at->sum_exec_runtime"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&at->stime"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&at->utime"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void proc_sample_cputime_atomic(struct task_cputime_atomic *at,\n\t\t\t\t       u64 *samples)\n{\n\tu64 stime, utime, rtime;\n\n\tutime = atomic64_read(&at->utime);\n\tstime = atomic64_read(&at->stime);\n\trtime = atomic64_read(&at->sum_exec_runtime);\n\tstore_samples(samples, stime, utime, rtime);\n}"
  },
  {
    "function_name": "task_sample_cputime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "215-221",
    "snippet": "static void task_sample_cputime(struct task_struct *p, u64 *samples)\n{\n\tu64 stime, utime;\n\n\ttask_cputime(p, &utime, &stime);\n\tstore_samples(samples, stime, utime, p->se.sum_exec_runtime);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "store_samples",
          "args": [
            "samples",
            "stime",
            "utime",
            "p->se.sum_exec_runtime"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "store_samples",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "208-213",
          "snippet": "static inline void store_samples(u64 *samples, u64 stime, u64 utime, u64 rtime)\n{\n\tsamples[CPUCLOCK_PROF] = stime + utime;\n\tsamples[CPUCLOCK_VIRT] = utime;\n\tsamples[CPUCLOCK_SCHED] = rtime;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void store_samples(u64 *samples, u64 stime, u64 utime, u64 rtime)\n{\n\tsamples[CPUCLOCK_PROF] = stime + utime;\n\tsamples[CPUCLOCK_VIRT] = utime;\n\tsamples[CPUCLOCK_SCHED] = rtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "p",
            "&utime",
            "&stime"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "832-870",
          "snippet": "bool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void task_sample_cputime(struct task_struct *p, u64 *samples)\n{\n\tu64 stime, utime;\n\n\ttask_cputime(p, &utime, &stime);\n\tstore_samples(samples, stime, utime, p->se.sum_exec_runtime);\n}"
  },
  {
    "function_name": "store_samples",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "208-213",
    "snippet": "static inline void store_samples(u64 *samples, u64 stime, u64 utime, u64 rtime)\n{\n\tsamples[CPUCLOCK_PROF] = stime + utime;\n\tsamples[CPUCLOCK_VIRT] = utime;\n\tsamples[CPUCLOCK_SCHED] = rtime;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline void store_samples(u64 *samples, u64 stime, u64 utime, u64 rtime)\n{\n\tsamples[CPUCLOCK_PROF] = stime + utime;\n\tsamples[CPUCLOCK_VIRT] = utime;\n\tsamples[CPUCLOCK_SCHED] = rtime;\n}"
  },
  {
    "function_name": "cpu_clock_sample",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "188-206",
    "snippet": "static u64 cpu_clock_sample(const clockid_t clkid, struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\tif (clkid == CPUCLOCK_SCHED)\n\t\treturn task_sched_runtime(p);\n\n\ttask_cputime(p, &utime, &stime);\n\n\tswitch (clkid) {\n\tcase CPUCLOCK_PROF:\n\t\treturn utime + stime;\n\tcase CPUCLOCK_VIRT:\n\t\treturn utime;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "p",
            "&utime",
            "&stime"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "832-870",
          "snippet": "bool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_sched_runtime",
          "args": [
            "p"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "task_sched_runtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5148-5185",
          "snippet": "unsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tu64 ns;\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)\n\t/*\n\t * 64-bit doesn't need locks to atomically read a 64-bit value.\n\t * So we have a optimization chance when the task's delta_exec is 0.\n\t * Reading ->on_cpu is racy, but this is ok.\n\t *\n\t * If we race with it leaving CPU, we'll take a lock. So we're correct.\n\t * If we race with it entering CPU, unaccounted time is 0. This is\n\t * indistinguishable from the read occurring a few cycles earlier.\n\t * If we see ->on_cpu without ->on_rq, the task is leaving, and has\n\t * been accounted, so we're correct here as well.\n\t */\n\tif (!p->on_cpu || !task_on_rq_queued(p))\n\t\treturn p->se.sum_exec_runtime;\n#endif\n\n\trq = task_rq_lock(p, &rf);\n\t/*\n\t * Must be ->curr _and_ ->on_rq.  If dequeued, we would\n\t * project cycles that may never be accounted to this\n\t * thread, breaking clock_gettime().\n\t */\n\tif (task_current(rq, p) && task_on_rq_queued(p)) {\n\t\tprefetch_curr_exec_start(p);\n\t\tupdate_rq_clock(rq);\n\t\tp->sched_class->update_curr(rq);\n\t}\n\tns = p->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ns;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nunsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tu64 ns;\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)\n\t/*\n\t * 64-bit doesn't need locks to atomically read a 64-bit value.\n\t * So we have a optimization chance when the task's delta_exec is 0.\n\t * Reading ->on_cpu is racy, but this is ok.\n\t *\n\t * If we race with it leaving CPU, we'll take a lock. So we're correct.\n\t * If we race with it entering CPU, unaccounted time is 0. This is\n\t * indistinguishable from the read occurring a few cycles earlier.\n\t * If we see ->on_cpu without ->on_rq, the task is leaving, and has\n\t * been accounted, so we're correct here as well.\n\t */\n\tif (!p->on_cpu || !task_on_rq_queued(p))\n\t\treturn p->se.sum_exec_runtime;\n#endif\n\n\trq = task_rq_lock(p, &rf);\n\t/*\n\t * Must be ->curr _and_ ->on_rq.  If dequeued, we would\n\t * project cycles that may never be accounted to this\n\t * thread, breaking clock_gettime().\n\t */\n\tif (task_current(rq, p) && task_on_rq_queued(p)) {\n\t\tprefetch_curr_exec_start(p);\n\t\tupdate_rq_clock(rq);\n\t\tp->sched_class->update_curr(rq);\n\t}\n\tns = p->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic u64 cpu_clock_sample(const clockid_t clkid, struct task_struct *p)\n{\n\tu64 utime, stime;\n\n\tif (clkid == CPUCLOCK_SCHED)\n\t\treturn task_sched_runtime(p);\n\n\ttask_cputime(p, &utime, &stime);\n\n\tswitch (clkid) {\n\tcase CPUCLOCK_PROF:\n\t\treturn utime + stime;\n\tcase CPUCLOCK_VIRT:\n\t\treturn utime;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_cpu_clock_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "173-183",
    "snippet": "static int\nposix_cpu_clock_set(const clockid_t clock, const struct timespec64 *tp)\n{\n\tint error = validate_clock_permissions(clock);\n\n\t/*\n\t * You can never reset a CPU clock, but we check for other errors\n\t * in the call before failing with EPERM.\n\t */\n\treturn error ? : -EPERM;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_clock_permissions",
          "args": [
            "clock"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "validate_clock_permissions",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "91-100",
          "snippet": "static inline int validate_clock_permissions(const clockid_t clock)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = pid_for_clock(clock, false) ? 0 : -EINVAL;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int validate_clock_permissions(const clockid_t clock)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = pid_for_clock(clock, false) ? 0 : -EINVAL;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int\nposix_cpu_clock_set(const clockid_t clock, const struct timespec64 *tp)\n{\n\tint error = validate_clock_permissions(clock);\n\n\t/*\n\t * You can never reset a CPU clock, but we check for other errors\n\t * in the call before failing with EPERM.\n\t */\n\treturn error ? : -EPERM;\n}"
  },
  {
    "function_name": "posix_cpu_clock_getres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "153-171",
    "snippet": "static int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = validate_clock_permissions(which_clock);\n\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "which_clock"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_clock_permissions",
          "args": [
            "which_clock"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "validate_clock_permissions",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "91-100",
          "snippet": "static inline int validate_clock_permissions(const clockid_t clock)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = pid_for_clock(clock, false) ? 0 : -EINVAL;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int validate_clock_permissions(const clockid_t clock)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = pid_for_clock(clock, false) ? 0 : -EINVAL;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tint error = validate_clock_permissions(which_clock);\n\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);\n\t\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\t\t/*\n\t\t\t * If sched_clock is using a cycle counter, we\n\t\t\t * don't have any idea of its true resolution\n\t\t\t * exported, but it is much more than 1s/HZ.\n\t\t\t */\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "expiry_cache_is_inactive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "146-151",
    "snippet": "static inline bool expiry_cache_is_inactive(const struct posix_cputimers *pct)\n{\n\treturn !(~pct->bases[CPUCLOCK_PROF].nextevt |\n\t\t ~pct->bases[CPUCLOCK_VIRT].nextevt |\n\t\t ~pct->bases[CPUCLOCK_SCHED].nextevt);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline bool expiry_cache_is_inactive(const struct posix_cputimers *pct)\n{\n\treturn !(~pct->bases[CPUCLOCK_PROF].nextevt |\n\t\t ~pct->bases[CPUCLOCK_VIRT].nextevt |\n\t\t ~pct->bases[CPUCLOCK_SCHED].nextevt);\n}"
  },
  {
    "function_name": "bump_cpu_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "116-143",
    "snippet": "static u64 bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tu64 delta, incr, expires = timer->it.cpu.node.expires;\n\tint i;\n\n\tif (!timer->it_interval)\n\t\treturn expires;\n\n\tif (now < expires)\n\t\treturn expires;\n\n\tincr = timer->it_interval;\n\tdelta = now + incr - expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.node.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n\treturn timer->it.cpu.node.expires;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic u64 bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tu64 delta, incr, expires = timer->it.cpu.node.expires;\n\tint i;\n\n\tif (!timer->it_interval)\n\t\treturn expires;\n\n\tif (now < expires)\n\t\treturn expires;\n\n\tincr = timer->it_interval;\n\tdelta = now + incr - expires;\n\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.node.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n\treturn timer->it.cpu.node.expires;\n}"
  },
  {
    "function_name": "cpu_timer_task_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "107-110",
    "snippet": "static inline struct task_struct *cpu_timer_task_rcu(struct k_itimer *timer)\n{\n\treturn pid_task(timer->it.cpu.pid, clock_pid_type(timer->it_clock));\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "timer->it.cpu.pid",
            "clock_pid_type(timer->it_clock)"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock_pid_type",
          "args": [
            "timer->it_clock"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "clock_pid_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "102-105",
          "snippet": "static inline enum pid_type clock_pid_type(const clockid_t clock)\n{\n\treturn CPUCLOCK_PERTHREAD(clock) ? PIDTYPE_PID : PIDTYPE_TGID;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline enum pid_type clock_pid_type(const clockid_t clock)\n{\n\treturn CPUCLOCK_PERTHREAD(clock) ? PIDTYPE_PID : PIDTYPE_TGID;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nstatic inline struct task_struct *cpu_timer_task_rcu(struct k_itimer *timer)\n{\n\treturn pid_task(timer->it.cpu.pid, clock_pid_type(timer->it_clock));\n}"
  },
  {
    "function_name": "clock_pid_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "102-105",
    "snippet": "static inline enum pid_type clock_pid_type(const clockid_t clock)\n{\n\treturn CPUCLOCK_PERTHREAD(clock) ? PIDTYPE_PID : PIDTYPE_TGID;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "clock"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline enum pid_type clock_pid_type(const clockid_t clock)\n{\n\treturn CPUCLOCK_PERTHREAD(clock) ? PIDTYPE_PID : PIDTYPE_TGID;\n}"
  },
  {
    "function_name": "validate_clock_permissions",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "91-100",
    "snippet": "static inline int validate_clock_permissions(const clockid_t clock)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = pid_for_clock(clock, false) ? 0 : -EINVAL;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_for_clock",
          "args": [
            "clock",
            "false"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "pid_for_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "51-89",
          "snippet": "static struct pid *pid_for_clock(const clockid_t clock, bool gettime)\n{\n\tconst bool thread = !!CPUCLOCK_PERTHREAD(clock);\n\tconst pid_t upid = CPUCLOCK_PID(clock);\n\tstruct pid *pid;\n\n\tif (CPUCLOCK_WHICH(clock) >= CPUCLOCK_MAX)\n\t\treturn NULL;\n\n\t/*\n\t * If the encoded PID is 0, then the timer is targeted at current\n\t * or the process to which current belongs.\n\t */\n\tif (upid == 0)\n\t\treturn thread ? task_pid(current) : task_tgid(current);\n\n\tpid = find_vpid(upid);\n\tif (!pid)\n\t\treturn NULL;\n\n\tif (thread) {\n\t\tstruct task_struct *tsk = pid_task(pid, PIDTYPE_PID);\n\t\treturn (tsk && same_thread_group(tsk, current)) ? pid : NULL;\n\t}\n\n\t/*\n\t * For clock_gettime(PROCESS) allow finding the process by\n\t * with the pid of the current task.  The code needs the tgid\n\t * of the process so that pid_task(pid, PIDTYPE_TGID) can be\n\t * used to find the process.\n\t */\n\tif (gettime && (pid == task_pid(current)))\n\t\treturn task_tgid(current);\n\n\t/*\n\t * For processes require that pid identifies a process.\n\t */\n\treturn pid_has_task(pid, PIDTYPE_TGID) ? pid : NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic struct pid *pid_for_clock(const clockid_t clock, bool gettime)\n{\n\tconst bool thread = !!CPUCLOCK_PERTHREAD(clock);\n\tconst pid_t upid = CPUCLOCK_PID(clock);\n\tstruct pid *pid;\n\n\tif (CPUCLOCK_WHICH(clock) >= CPUCLOCK_MAX)\n\t\treturn NULL;\n\n\t/*\n\t * If the encoded PID is 0, then the timer is targeted at current\n\t * or the process to which current belongs.\n\t */\n\tif (upid == 0)\n\t\treturn thread ? task_pid(current) : task_tgid(current);\n\n\tpid = find_vpid(upid);\n\tif (!pid)\n\t\treturn NULL;\n\n\tif (thread) {\n\t\tstruct task_struct *tsk = pid_task(pid, PIDTYPE_PID);\n\t\treturn (tsk && same_thread_group(tsk, current)) ? pid : NULL;\n\t}\n\n\t/*\n\t * For clock_gettime(PROCESS) allow finding the process by\n\t * with the pid of the current task.  The code needs the tgid\n\t * of the process so that pid_task(pid, PIDTYPE_TGID) can be\n\t * used to find the process.\n\t */\n\tif (gettime && (pid == task_pid(current)))\n\t\treturn task_tgid(current);\n\n\t/*\n\t * For processes require that pid identifies a process.\n\t */\n\treturn pid_has_task(pid, PIDTYPE_TGID) ? pid : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic inline int validate_clock_permissions(const clockid_t clock)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = pid_for_clock(clock, false) ? 0 : -EINVAL;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pid_for_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "51-89",
    "snippet": "static struct pid *pid_for_clock(const clockid_t clock, bool gettime)\n{\n\tconst bool thread = !!CPUCLOCK_PERTHREAD(clock);\n\tconst pid_t upid = CPUCLOCK_PID(clock);\n\tstruct pid *pid;\n\n\tif (CPUCLOCK_WHICH(clock) >= CPUCLOCK_MAX)\n\t\treturn NULL;\n\n\t/*\n\t * If the encoded PID is 0, then the timer is targeted at current\n\t * or the process to which current belongs.\n\t */\n\tif (upid == 0)\n\t\treturn thread ? task_pid(current) : task_tgid(current);\n\n\tpid = find_vpid(upid);\n\tif (!pid)\n\t\treturn NULL;\n\n\tif (thread) {\n\t\tstruct task_struct *tsk = pid_task(pid, PIDTYPE_PID);\n\t\treturn (tsk && same_thread_group(tsk, current)) ? pid : NULL;\n\t}\n\n\t/*\n\t * For clock_gettime(PROCESS) allow finding the process by\n\t * with the pid of the current task.  The code needs the tgid\n\t * of the process so that pid_task(pid, PIDTYPE_TGID) can be\n\t * used to find the process.\n\t */\n\tif (gettime && (pid == task_pid(current)))\n\t\treturn task_tgid(current);\n\n\t/*\n\t * For processes require that pid identifies a process.\n\t */\n\treturn pid_has_task(pid, PIDTYPE_TGID) ? pid : NULL;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
      "static void handle_posix_cpu_timers(struct task_struct *tsk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_has_task",
          "args": [
            "pid",
            "PIDTYPE_TGID"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid",
          "args": [
            "current"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "init_task_pid_links",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1710-1716",
          "snippet": "static inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "tsk",
            "current"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vpid",
          "args": [
            "upid"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "find_vpid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "315-318",
          "snippet": "struct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_WHICH",
          "args": [
            "clock"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PID",
          "args": [
            "clock"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPUCLOCK_PERTHREAD",
          "args": [
            "clock"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nstatic struct pid *pid_for_clock(const clockid_t clock, bool gettime)\n{\n\tconst bool thread = !!CPUCLOCK_PERTHREAD(clock);\n\tconst pid_t upid = CPUCLOCK_PID(clock);\n\tstruct pid *pid;\n\n\tif (CPUCLOCK_WHICH(clock) >= CPUCLOCK_MAX)\n\t\treturn NULL;\n\n\t/*\n\t * If the encoded PID is 0, then the timer is targeted at current\n\t * or the process to which current belongs.\n\t */\n\tif (upid == 0)\n\t\treturn thread ? task_pid(current) : task_tgid(current);\n\n\tpid = find_vpid(upid);\n\tif (!pid)\n\t\treturn NULL;\n\n\tif (thread) {\n\t\tstruct task_struct *tsk = pid_task(pid, PIDTYPE_PID);\n\t\treturn (tsk && same_thread_group(tsk, current)) ? pid : NULL;\n\t}\n\n\t/*\n\t * For clock_gettime(PROCESS) allow finding the process by\n\t * with the pid of the current task.  The code needs the tgid\n\t * of the process so that pid_task(pid, PIDTYPE_TGID) can be\n\t * used to find the process.\n\t */\n\tif (gettime && (pid == task_pid(current)))\n\t\treturn task_tgid(current);\n\n\t/*\n\t * For processes require that pid identifies a process.\n\t */\n\treturn pid_has_task(pid, PIDTYPE_TGID) ? pid : NULL;\n}"
  },
  {
    "function_name": "update_rlimit_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "39-46",
    "snippet": "void update_rlimit_cpu(struct task_struct *task, unsigned long rlim_new)\n{\n\tu64 nsecs = rlim_new * NSEC_PER_SEC;\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tset_process_cpu_timer(task, CPUCLOCK_PROF, &nsecs, NULL);\n\tspin_unlock_irq(&task->sighand->siglock);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_process_cpu_timer",
          "args": [
            "task",
            "CPUCLOCK_PROF",
            "&nsecs",
            "NULL"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "set_process_cpu_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1397-1435",
          "snippet": "void set_process_cpu_timer(struct task_struct *tsk, unsigned int clkid,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now, *nextevt;\n\n\tif (WARN_ON_ONCE(clkid >= CPUCLOCK_SCHED))\n\t\treturn;\n\n\tnextevt = &tsk->signal->posix_cputimers.bases[clkid].nextevt;\n\tnow = cpu_clock_sample_group(clkid, tsk, true);\n\n\tif (oldval) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (*newval)\n\t\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if this is the earliest timer. CPUCLOCK_PROF\n\t * expiry cache is also used by RLIMIT_CPU!.\n\t */\n\tif (*newval < *nextevt)\n\t\t*nextevt = *newval;\n\n\ttick_dep_set_signal(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);",
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nvoid set_process_cpu_timer(struct task_struct *tsk, unsigned int clkid,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now, *nextevt;\n\n\tif (WARN_ON_ONCE(clkid >= CPUCLOCK_SCHED))\n\t\treturn;\n\n\tnextevt = &tsk->signal->posix_cputimers.bases[clkid].nextevt;\n\tnow = cpu_clock_sample_group(clkid, tsk, true);\n\n\tif (oldval) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (*newval)\n\t\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if this is the earliest timer. CPUCLOCK_PROF\n\t * expiry cache is also used by RLIMIT_CPU!.\n\t */\n\tif (*newval < *nextevt)\n\t\t*nextevt = *newval;\n\n\ttick_dep_set_signal(tsk, TICK_DEP_BIT_POSIX_TIMER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&task->sighand->siglock"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nvoid update_rlimit_cpu(struct task_struct *task, unsigned long rlim_new)\n{\n\tu64 nsecs = rlim_new * NSEC_PER_SEC;\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tset_process_cpu_timer(task, CPUCLOCK_PROF, &nsecs, NULL);\n\tspin_unlock_irq(&task->sighand->siglock);\n}"
  },
  {
    "function_name": "posix_cputimers_group_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
    "lines": "24-31",
    "snippet": "void posix_cputimers_group_init(struct posix_cputimers *pct, u64 cpu_limit)\n{\n\tposix_cputimers_init(pct);\n\tif (cpu_limit != RLIM_INFINITY) {\n\t\tpct->bases[CPUCLOCK_PROF].nextevt = cpu_limit * NSEC_PER_SEC;\n\t\tpct->timers_active = true;\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/task_work.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/compat.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/tick.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/math64.h>",
      "#include <linux/errno.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_cputimers_init",
          "args": [
            "pct"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nvoid posix_cputimers_group_init(struct posix_cputimers *pct, u64 cpu_limit)\n{\n\tposix_cputimers_init(pct);\n\tif (cpu_limit != RLIM_INFINITY) {\n\t\tpct->bases[CPUCLOCK_PROF].nextevt = cpu_limit * NSEC_PER_SEC;\n\t\tpct->timers_active = true;\n\t}\n}"
  }
]